<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Phoenix</title>
    <link href="/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Phoenix/Phoenix/"/>
    <url>/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Phoenix/Phoenix/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Phoenix概述"><a href="#一、Phoenix概述" class="headerlink" title="一、Phoenix概述"></a>一、Phoenix概述</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>phoenix的名称直译为凤凰。</p><p>phoenix是构建的Hbase之上的，是使用Java语言编写的一个HBase框架，<strong>使用标准的SQL操作Hbase</strong>，可以做联机事务处理，拥有低延迟的特性。</p><p>phoenix会把SQL编译成一系列的Hbase的scan操作，然后把scan结果生成标准的JDBC结果集，</p><p>其底层由于使用了Hbase的API，协处理器，过滤器，处理千万级行的数据也只用毫秒或秒级就搞定。</p><p>支持有：SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY等操作。</p><p>但phoenix目前不支持Intersect, Minus操作，Oracle是支持此操作的。</p><p>可以通过类似Mysql方式连接phoenix:</p><p>Connection conn = DriverManager.getConnection(“jdbc:phoenix:server1,server2:3333”,props);</p><p>Phoenix支持通过DDL命令进行表格创建和版本化增量更改，相应元数据存储在Hbase表中。</p><p>元数据用于描述phoenix表与hbase之间的关系与映射。</p><h2 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><p>Apache Phoenix在Hadoop中为低延迟应用程序启用OLTP和运营分析：</p><ul><li>具有完整ACID事务功能的标准SQL和JDBC API的强大功能</li><li>通过利用HBase作为其后备存储，使用NoSQL的后期绑定模式以增强查找功能的灵活性</li><li>Apache Phoenix与其他Hadoop产品完全集成，如Spark，Hive，Pig，Flume和Map Reduce。</li></ul><ul><li><p>如果需要对HBase进行复杂的操作，那么应该使用Phoenix，其会将SQL语句转换成HBase相应的API。</p></li><li><p>Phoenix只能用在HBase上，其查询性能要远高于Hive。</p></li></ul><p><strong>注意，phoenix没有insert，其insert与update合起来叫做：upsert</strong></p><h2 id="1-3-Phoenix与HBase的关系"><a href="#1-3-Phoenix与HBase的关系" class="headerlink" title="1.3 Phoenix与HBase的关系"></a>1.3 Phoenix与HBase的关系</h2><p>Phoenix与HBase中的表是独立的，两者之间没有必然的关系。</p><p>Phoenix与HBase集成后会创建六张系统表：SYSTEM.CATALOG、SYSTEM.FUNCTION、SYSTEM.LOG、SYSTEM.SEQUENCE、SYSTEM.STATS，其中SYSTEM.CATALOG表用于存放Phoenix创建表时的元数据。</p><p>Phoenix创建表时会自动调用HBase客户端创建相应的表，并且在SYSTEM.CATALOG系统表中记录Phoenix创建表时的元数据，其主键的值对应HBase的RowKey，非主键的列对应HBase的Column（列族不指定时为0，且列会进行编码）</p><p>如果是通过Phoenix创建的表，那么必须通过Phoenix客户端来对表进行操作，因为通过Phoenix创建的表其非主键的列会进行编码。</p><hr><h1 id="二、Phoenix安装"><a href="#二、Phoenix安装" class="headerlink" title="二、Phoenix安装"></a>二、Phoenix安装</h1><p><strong>注意HBase版本需要与Phoenix匹配</strong></p><p><img src="/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Phoenix/Phoenix/image-20211222213126594.png" alt="image-20211222213126594"></p><h2 id="2-1-相关环境"><a href="#2-1-相关环境" class="headerlink" title="2.1 相关环境"></a>2.1 相关环境</h2><p>确保JDK、Zookeeper、Hadoop、HBASE已安装，且版本适配。</p><p>本人采用的版本为JDK1.8，Zookeeper3.4.9，Hadoop2.10，HBase1.6，Phoenix4.16，分布式环境。</p><p><img src="/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Phoenix/Phoenix/image-20211222162321025.png" alt="image-20211222162321025"></p><p><img src="/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Phoenix/Phoenix/image-20211222162355531.png" alt="image-20211222162355531"></p><h2 id="2-1-关闭Hbase"><a href="#2-1-关闭Hbase" class="headerlink" title="2.1 关闭Hbase"></a>2.1 关闭Hbase</h2><p>在主节点上执行</p><p><code>/export/servers/hbase-1.6.0/bin/stop-hbase.sh</code></p><h2 id="2-2-上传文件并解压"><a href="#2-2-上传文件并解压" class="headerlink" title="2.2 上传文件并解压"></a>2.2 上传文件并解压</h2><p><code>tar -zxvf /export/servers/phoenix-hbase-1.6-4.16.0-bin.tar.gz -C /export/servers/</code></p><h2 id="2-3-将phoenix-4-16-0-HBase-1-6-server-jar复制到所有节点的hbase-lib目录下"><a href="#2-3-将phoenix-4-16-0-HBase-1-6-server-jar复制到所有节点的hbase-lib目录下" class="headerlink" title="2.3 将phoenix-4.16.0-HBase-1.6-server.jar复制到所有节点的hbase lib目录下"></a>2.3 将phoenix-4.16.0-HBase-1.6-server.jar复制到所有节点的hbase lib目录下</h2><p><strong>注意只复制server包，不复制client包</strong>，如果都复制可能会出现问题</p><p><img src="/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Phoenix/Phoenix/image-20211222163000685.png" alt="image-20211222163000685"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp /export/servers/phoenix-hbase-1.6-4.16.0-bin/phoenix-server-hbase-1.6-4.16.0.jar norNode01:/export/servers/hbase-1.6.0/lib/<br><br>scp /export/servers/phoenix-hbase-1.6-4.16.0-bin/phoenix-server-hbase-1.6-4.16.0.jar norNode02:/export/servers/hbase-1.6.0/lib/<br><br>scp /export/servers/phoenix-hbase-1.6-4.16.0-bin/phoenix-server-hbase-1.6-4.16.0.jar norNode03:/export/servers/hbase-1.6.0/lib/<br><br>scp /export/servers/phoenix-hbase-1.6-4.16.0-bin/phoenix-server-hbase-1.6-4.16.0.jar norNode04:/export/servers/hbase-1.6.0/lib/<br><br>scp /export/servers/phoenix-hbase-1.6-4.16.0-bin/phoenix-server-hbase-1.6-4.16.0.jar norNode05:/export/servers/hbase-1.6.0/lib/<br></code></pre></td></tr></table></figure><h2 id="2-4-启动Hbase"><a href="#2-4-启动Hbase" class="headerlink" title="2.4 启动Hbase"></a>2.4 启动Hbase</h2><p>在主节点上执行</p><p><code>/export/servers/hbase-1.6.0/bin/start-hbase.sh</code></p><h2 id="2-5-配置环境变量（可省略）"><a href="#2-5-配置环境变量（可省略）" class="headerlink" title="2.5 配置环境变量（可省略）"></a>2.5 配置环境变量（可省略）</h2><p><code>vim /etc/profile</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PHOENIX_HOME=/export/servers/phoenix-hbase-1.6-4.16.0-bin<br>export PATH=$PATH:$PHOENIX_HOME/bin<br></code></pre></td></tr></table></figure><p><code>source /etc/profile</code></p><h2 id="2-6-启动Phoenix"><a href="#2-6-启动Phoenix" class="headerlink" title="2.6 启动Phoenix"></a>2.6 启动Phoenix</h2><p>Phoenix提供了sqlline.py脚本用于启动Phoenix客户端并进行连接，启动时只需要指定HBase连接的Zookeeper集群地址即可。（默认为 localhost:2181），如果有多个节点，中间使用逗号分开。</p><p>进入bin目录，通过sqlline.py操作phoenix</p><p><img src="/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Phoenix/Phoenix/image-20211222171221665.png" alt="image-20211222171221665"></p><h2 id="2-7-退出Phoenix"><a href="#2-7-退出Phoenix" class="headerlink" title="2.7 退出Phoenix"></a>2.7 退出Phoenix</h2><p><code>!exit</code></p><hr><h1 id="三、基本操作"><a href="#三、基本操作" class="headerlink" title="三、基本操作"></a>三、基本操作</h1><p><strong>Phoenix的SQL中如果表名、字段名不使用双引号标注那么默认转换成大写。</strong></p><p>**Phoenix中的字符串使用单引号进行标注。 **</p><h2 id="3-1-表操作"><a href="#3-1-表操作" class="headerlink" title="3.1 表操作"></a>3.1 表操作</h2><h3 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h3><p>查询通过Phoenix创建的表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">!tables<br></code></pre></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> us_population (<br>      state <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>      city <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>      population <span class="hljs-type">BIGINT</span><br>      <span class="hljs-keyword">CONSTRAINT</span> my_pk <span class="hljs-keyword">PRIMARY</span> KEY (state, city)<br>);<br></code></pre></td></tr></table></figure><p><strong>主键的值对应HBase中的RowKey，列族不指定时默认是0，非主键的列对应HBase的列。</strong></p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> us_population;<br></code></pre></td></tr></table></figure><h2 id="3-2-数据操作"><a href="#3-2-数据操作" class="headerlink" title="3.2 数据操作"></a>3.2 数据操作</h2><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> us_population <span class="hljs-keyword">WHERE</span> state <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;NA&#x27;</span> <span class="hljs-keyword">AND</span> population <span class="hljs-operator">&gt;</span> <span class="hljs-number">10000</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> population <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p>在进行查询时，支持ORDER BY、GROUP BY、LIMIT、JOIN等操作，同时Phoenix提供了一系列的函数，其中包括COUNT()、MAX()、MIN()、SUM()等，具体的函数列表可以查看：<a href="http://phoenix.apache.org/language/functions.html">http://phoenix.apache.org/language/functions.html</a></p><p>不管条件中的列是否是联合主键中的，Phoenix一样可以支持。</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> us_population <span class="hljs-keyword">WHERE</span> state <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;NA&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="插入或更新数据"><a href="#插入或更新数据" class="headerlink" title="插入或更新数据"></a>插入或更新数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">UPSERT <span class="hljs-keyword">INTO</span> us_population <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;CA&#x27;</span>,<span class="hljs-string">&#x27;GZ&#x27;</span>,<span class="hljs-number">850000</span>);<br>UPSERT <span class="hljs-keyword">INTO</span> us_population(state,city) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;CA&#x27;</span>,<span class="hljs-string">&#x27;GZ&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>如果主键的值重复，那么进行更新操作，否则插入一条新的记录（在进行更新时，没有更新的列保持原值，在进行插入时，没有插入的列为null）</strong></p><p><strong>在使用UPSERT时，主键的列不能为空（包括联合主键）</strong></p><hr><h2 id="3-3-二级索引"><a href="#3-3-二级索引" class="headerlink" title="3.3 二级索引"></a>3.3 二级索引</h2><p>对于Hbase，如果想精确定位到某行记录，唯一的办法就是通过rowkey查询。如果不通过rowkey查找数据，就必须逐行比较每一行的值，对于较大的表，全表扫描的代价是不可接受的</p><p><a href="https://blog.csdn.net/qq_43278189/article/details/120773924">https://blog.csdn.net/qq_43278189/article/details/120773924</a></p><hr><h1 id="四、映射HBase中已存在的表"><a href="#四、映射HBase中已存在的表" class="headerlink" title="四、映射HBase中已存在的表"></a>四、映射HBase中已存在的表</h1><p>若想用Phoenix来进行操作通过HBase客户端创建的表，那么必须要进行表的映射，因为SYSTEM.CATALOG表中并没有维护Phoenix创建表的元数据。</p><p><strong>映射方式分为表映射和视图映射</strong></p><h2 id="4-1-创建表来进行表的映射"><a href="#4-1-创建表来进行表的映射" class="headerlink" title="4.1 创建表来进行表的映射"></a>4.1 创建表来进行表的映射</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> 表名(<br>  列名 类型 主键,<br>  列簇.列名,<br>  列簇.列名<br>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> &quot;VideoTable&quot; (<br>    &quot;ROW&quot; <span class="hljs-type">varchar</span> <span class="hljs-keyword">primary</span> key ,<br>    &quot;videoInfo&quot;.&quot;deviceID&quot; <span class="hljs-type">varchar</span> ,<br>    &quot;videoInfo&quot;.&quot;videoName&quot; <span class="hljs-type">varchar</span>,<br>    &quot;videoInfo&quot;.&quot;videoWidth&quot; <span class="hljs-type">varchar</span>,<br>    &quot;videoInfo&quot;.&quot;videoHeight&quot; <span class="hljs-type">varchar</span>,<br>    &quot;videoInfo&quot;.&quot;videoSize&quot;  <span class="hljs-type">varchar</span>,<br>    &quot;videoInfo&quot;.&quot;videoLength&quot; <span class="hljs-type">varchar</span>,<br>    &quot;videoInfo&quot;.&quot;videoStartTime&quot; <span class="hljs-type">varchar</span>,<br>    &quot;saveInfo&quot;.&quot;videoPath&quot; <span class="hljs-type">varchar</span><br>) column_encoded_bytes<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><blockquote><p>HBase中的RowKey映射Phoenix的主键，HBase中的Column映射Phoenix的列，且使用列簇名.列名进行映射。</p><p>相当于在SYSTEM.CATALOG表中录入相关的元数据，使Phoenix能够进行操作它。</p></blockquote><p><strong>对表的操作会影响Hbase中的表，如果只用来查询，推荐使用视图进行映射</strong></p><h3 id="Phoenix-映射已存在-HBase-表，出现查询不到数据的问题"><a href="#Phoenix-映射已存在-HBase-表，出现查询不到数据的问题" class="headerlink" title="Phoenix 映射已存在 HBase 表，出现查询不到数据的问题"></a>Phoenix 映射已存在 HBase 表，出现查询不到数据的问题</h3><p>使用网上数据如下</p><p>1、hbase shell 插入数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">create &#x27;test1&#x27;,&#x27;i&#x27;<br>put &#x27;test1&#x27;,&#x27;1&#x27;,&#x27;i:name&#x27;,&#x27;zhangsan&#x27;<br>put &#x27;test1&#x27;,&#x27;2&#x27;,&#x27;i:name&#x27;,&#x27;lisi&#x27;<br>put &#x27;test1&#x27;,&#x27;1&#x27;,&#x27;i:age&#x27;,&#x27;15&#x27;<br>put &#x27;test1&#x27;,&#x27;2&#x27;,&#x27;i:age&#x27;,&#x27;2&#x27;<br></code></pre></td></tr></table></figure><p><code>scan &#39;test1&#39;</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ROW                       COLUMN+CELL<br> 1                        <span class="hljs-attribute">column</span>=i:age, <span class="hljs-attribute">timestamp</span>=1523416240312, <span class="hljs-attribute">value</span>=15<br> 1                        <span class="hljs-attribute">column</span>=i:name, <span class="hljs-attribute">timestamp</span>=1523416227940, <span class="hljs-attribute">value</span>=zhangsan<br> 2                        <span class="hljs-attribute">column</span>=i:age, <span class="hljs-attribute">timestamp</span>=1523416249281, <span class="hljs-attribute">value</span>=2<br> 2                        <span class="hljs-attribute">column</span>=i:name, <span class="hljs-attribute">timestamp</span>=1523416234516, <span class="hljs-attribute">value</span>=lisi<br></code></pre></td></tr></table></figure><p>2、phoenix 创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> &quot;test1&quot;(<br>    pk <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">PRIMARY</span> KEY<br>    ,&quot;i&quot;.&quot;name&quot; <span class="hljs-type">VARCHAR</span><br>    ,&quot;i&quot;.&quot;age&quot; <span class="hljs-type">VARCHAR</span>);<br><br></code></pre></td></tr></table></figure><p>3、phoenix 查询，查询不到数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">0: jdbc:phoenix:&gt; select * from &quot;test1&quot;;<br>+-----+-------+------+<br>| PK  | name  | age  |<br>+-----+-------+------+<br>+-----+-------+------+<br>No rows selected (0.238 seconds)<br></code></pre></td></tr></table></figure><p><strong>问题原因</strong>：<br>经过阅读官方文档发现，phoenix 4.10 版本后，对列映射做了优化，采用一套新的机制，不在基于列名方式映射到 hbase。</p><p><strong>解决办法</strong>：<br>1、如果只做查询，强烈建议使用 phoenix 视图方式映射，删除视图不影响 hbase 源数据，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> &quot;test1&quot;(<br>    pk <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">PRIMARY</span> KEY<br>    ,&quot;i&quot;.&quot;name&quot; <span class="hljs-type">VARCHAR</span><br>    ,&quot;i&quot;.&quot;age&quot; <span class="hljs-type">VARCHAR</span>);<br></code></pre></td></tr></table></figure><p>2、必须要表映射，需要禁用列映射规则（会降低查询性能），如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> &quot;test1&quot;(<br>    pk <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">PRIMARY</span> KEY<br>    ,&quot;i&quot;.&quot;name&quot; <span class="hljs-type">VARCHAR</span><br>    ,&quot;i&quot;.&quot;age&quot; <span class="hljs-type">VARCHAR</span>)<br> column_encoded_bytes<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>参考：<br><a href="http://phoenix.apache.org/columnencoding.html">http://phoenix.apache.org/columnencoding.html</a></p><hr><h2 id="4-2-创建视图来进行表的映射"><a href="#4-2-创建视图来进行表的映射" class="headerlink" title="4.2 创建视图来进行表的映射"></a>4.2 创建视图来进行表的映射</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 视图名(<br>  列名 类型 主键,<br>  列簇.列名,<br>  列簇.列名<br>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> &quot;VideoTable&quot; (<br>    &quot;ROW&quot; <span class="hljs-type">varchar</span> <span class="hljs-keyword">primary</span> key ,<br>    &quot;videoInfo&quot;.&quot;deviceID&quot; <span class="hljs-type">varchar</span> ,<br>    &quot;videoInfo&quot;.&quot;videoName&quot; <span class="hljs-type">varchar</span>,<br>    &quot;videoInfo&quot;.&quot;videoWidth&quot; <span class="hljs-type">varchar</span>,<br>    &quot;videoInfo&quot;.&quot;videoHeight&quot; <span class="hljs-type">varchar</span>,<br>    &quot;videoInfo&quot;.&quot;videoSize&quot;  <span class="hljs-type">varchar</span>,<br>    &quot;videoInfo&quot;.&quot;videoLength&quot; <span class="hljs-type">varchar</span>,<br>    &quot;videoInfo&quot;.&quot;videoStartTime&quot; <span class="hljs-type">varchar</span>,<br>    &quot;saveInfo&quot;.&quot;videoPath&quot; <span class="hljs-type">varchar</span><br>) <br></code></pre></td></tr></table></figure><p><strong>Phoenix中的视图只能进行查询，不能进行添加、更新、删除操作。</strong></p><hr><h2 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h2><ul><li><p>视图只读，不支持新增和修改</p></li><li><p>如果删除视图，源数据不会发生改变</p></li><li><p>视图的查询效率较低（原因是：表映射会在表中创建一些空的键值对，这些空键值对的存在可以用来提高查询效率，而视图映射没有）</p></li><li><p>使用create table创建的<strong>关联表</strong>，如果对表进行了修改，源数据也会改变，同时如果关联表被删除，源表也会被删除。</p></li></ul><hr><h1 id="五、Phoenix操作方式"><a href="#五、Phoenix操作方式" class="headerlink" title="五、Phoenix操作方式"></a>五、Phoenix操作方式</h1><h2 id="5-1-使用sqlline-py操作Phoenix"><a href="#5-1-使用sqlline-py操作Phoenix" class="headerlink" title="5.1 使用sqlline.py操作Phoenix"></a>5.1 使用sqlline.py操作Phoenix</h2><p>Phoenix提供了sqlline.py脚本用于启动Phoenix客户端并进行连接，启动时只需要指定HBase连接的Zookeeper集群地址即可。（默认为 localhost:2181）</p><h2 id="5-2-使用Java操作Phoenix"><a href="#5-2-使用Java操作Phoenix" class="headerlink" title="5.2 使用Java操作Phoenix"></a>5.2 使用Java操作Phoenix</h2><ul><li>导入依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.phoenix&lt;/groupId&gt;<br>    &lt;artifactId&gt;phoenix-core&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">4.15</span><span class="hljs-number">.0</span>-HBase-<span class="hljs-number">1.5</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>使用标准的JDBC来操作HBase</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">phoenixTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Class.forName(<span class="hljs-string">&quot;org.apache.phoenix.jdbc.PhoenixDriver&quot;</span>);<br>        Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:phoenix:192.168.127.201,192.168.127.202,192.168.127.203,192.168.127.204,192.168.127.205:2181&quot;</span>);<br><br>        PreparedStatement statement = connection.prepareStatement(<span class="hljs-string">&quot;select * from \&quot; VideoTable\&quot; &quot;</span>);<br><br>        ResultSet resultSet = statement.executeQuery();<br><br>        <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>            System.out.println(resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>        &#125;<br><br>        statement.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-3-Spring-boot整合多数据源支持Phoenix"><a href="#5-3-Spring-boot整合多数据源支持Phoenix" class="headerlink" title="5.3 Spring-boot整合多数据源支持Phoenix"></a>5.3 Spring-boot整合多数据源支持Phoenix</h2><ul><li>使用的多数据源方式，非动态数据源</li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># phoenix 数据源自定义配置</span><br><span class="hljs-attr">phoenix</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">enable</span>: <span class="hljs-string">true</span><br>  <span class="hljs-attr">url</span>: <span class="hljs-string">jdbc:phoenix:192.168.127.201:2181</span><br>  <span class="hljs-attr">type</span>: <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>  <span class="hljs-meta">driver-class-name</span>: <span class="hljs-string">org.apache.phoenix.jdbc.PhoenixDriver</span><br>  <span class="hljs-attr">username</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">password</span>:<span class="hljs-string"></span><br>  <span class="hljs-meta">default-auto-commit</span>: <span class="hljs-string">true</span><br>  <span class="hljs-attr">schema</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">isNamespaceMappingEnabled</span>: <span class="hljs-string">false</span><br></code></pre></td></tr></table></figure><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoenixConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Environment env;<br><br>    <span class="hljs-comment">//mysql设置为默认数据库</span><br>    <span class="hljs-meta">@Primary</span><br>    <span class="hljs-meta">@Bean(&quot;mysqlDataSource&quot;)</span><br>    <span class="hljs-meta">@Qualifier(&quot;mysqlDataSource&quot;)</span><br>    <span class="hljs-comment">//@ConfigurationProperties(&quot;spring.datasource.druid.mysql&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">mysqlDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Bean(name = &quot;phoenixJdbcDataSource&quot;)</span><br>    <span class="hljs-meta">@Qualifier(&quot;phoenixJdbcDataSource&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>        dataSource.setUrl(env.getProperty(<span class="hljs-string">&quot;phoenix.url&quot;</span>));<br>        dataSource.setDriverClassName(env.getProperty(<span class="hljs-string">&quot;phoenix.driver-class-name&quot;</span>));<br>        dataSource.setUsername(env.getProperty(<span class="hljs-string">&quot;phoenix.username&quot;</span>));<span class="hljs-comment">//phoenix的用户名默认为空</span><br>        dataSource.setPassword(env.getProperty(<span class="hljs-string">&quot;phoenix.password&quot;</span>));<span class="hljs-comment">//phoenix的密码默认为空</span><br>        dataSource.setDefaultAutoCommit(Boolean.valueOf(env.getProperty(<span class="hljs-string">&quot;phoenix.default-auto-commit&quot;</span>)));<br>        dataSource.setConnectionProperties(<span class="hljs-string">&quot;phoenix.schema.isNamespaceMappingEnabled=&quot;</span>+env.getProperty(<span class="hljs-string">&quot;phoenix.schema.isNamespaceMappingEnabled&quot;</span>));<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(name = &quot;phoenixJdbcTemplate&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">phoenixJdbcTemplate</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;phoenixJdbcDataSource&quot;)</span> DataSource dataSource)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="具体操作示例"><a href="#具体操作示例" class="headerlink" title="具体操作示例"></a>具体操作示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoenixServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PhoenixService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;phoenixJdbcTemplate&quot;)</span><br>    JdbcTemplate phoenixJdbcTemplate;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PhoenixResult <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br><br>        phoenixJdbcTemplate.update(<span class="hljs-string">&quot;upsert into mytry.company(id,name,address) values(&#x27;20&#x27;,&#x27;xuxiao&#x27;,&#x27;德国柏林&#x27;)&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PhoenixResult(<span class="hljs-keyword">true</span>,<span class="hljs-string">&quot;数据添加成功&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PhoenixResult <span class="hljs-title">update</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> res = phoenixJdbcTemplate.update(<span class="hljs-string">&quot;upsert into mytry.company(id,name) values(&#x27;20&#x27;,&#x27;yyggg&#x27;)&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PhoenixResult(<span class="hljs-keyword">true</span>,<span class="hljs-string">&quot;数据更新成功&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PhoenixResult <span class="hljs-title">delete</span><span class="hljs-params">()</span></span>&#123;<br>        phoenixJdbcTemplate.update(<span class="hljs-string">&quot;delete from mytry.company where id =&#x27;20&#x27;&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PhoenixResult(<span class="hljs-keyword">true</span>,<span class="hljs-string">&quot;数据删除成功&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; query()&#123;<br>        <span class="hljs-keyword">return</span> phoenixJdbcTemplate.queryForList(<span class="hljs-string">&quot;select * from person&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="六、Phoenix优化"><a href="#六、Phoenix优化" class="headerlink" title="六、Phoenix优化"></a>六、Phoenix优化</h1><h2 id="6-1-服务端配置优化"><a href="#6-1-服务端配置优化" class="headerlink" title="6.1 服务端配置优化"></a>6.1 服务端配置优化</h2><p><img src="/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Phoenix/Phoenix/1337502-20190111163807055-545771228.png" alt="img"></p><blockquote><p>往HBase安装目录下的conf目录下的hbase-site.xml文件中添加配置。</p></blockquote><hr><h2 id="6-2-对表中的数据进行分区"><a href="#6-2-对表中的数据进行分区" class="headerlink" title="6.2 对表中的数据进行分区"></a>6.2 对表中的数据进行分区</h2><h3 id="哈希取模"><a href="#哈希取模" class="headerlink" title="哈希取模"></a>哈希取模</h3><p>通过在创建表时指定SALE_BUCKETS来实现将表中的数据预分割到多个Region中，有利于提高读取数据的性能。</p><p>其原理是将RowKey进行散列，把得到的余数的byte值插入到RowKey的第一个字节中，并通过预定义每个Region的Start Key和End Key，将数据分散存储到不同的Region中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> us_population (<br>      state <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>      city <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>      population <span class="hljs-type">BIGINT</span><br>      <span class="hljs-keyword">CONSTRAINT</span> my_pk <span class="hljs-keyword">PRIMARY</span> KEY (state, city)<br>)SALT_BUCKETS<span class="hljs-operator">=</span><span class="hljs-number">16</span>;<br></code></pre></td></tr></table></figure><p>通过SALE_BUCKETS设置哈希函数的除数P（除留余数法）</p><h3 id="根据值来进行预分区"><a href="#根据值来进行预分区" class="headerlink" title="根据值来进行预分区"></a>根据值来进行预分区</h3><p>在创建表时，可以精确的指定RowKey根据什么值来进行预分区，不同的值存储在独立的Region中，有利于提高读取数据的性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> us_population (<br>      state <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>      city <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>      population <span class="hljs-type">BIGINT</span><br>      <span class="hljs-keyword">CONSTRAINT</span> my_pk <span class="hljs-keyword">PRIMARY</span> KEY (state, city)<br>)SPLIT <span class="hljs-keyword">ON</span>(<span class="hljs-string">&#x27;CS&#x27;</span>,<span class="hljs-string">&#x27;EU&#x27;</span>,<span class="hljs-string">&#x27;NA&#x27;</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="6-3-创建表时指定列簇"><a href="#6-3-创建表时指定列簇" class="headerlink" title="6.3 创建表时指定列簇"></a>6.3 创建表时指定列簇</h2><p>在HBase中每个列簇对应一个文件，如果要查询的列其列簇下只有它自己，那么将极大的提高读取数据的性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> us_population (<br>      state <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>      city <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>      C1.population <span class="hljs-type">BIGINT</span><br>      <span class="hljs-keyword">CONSTRAINT</span> my_pk <span class="hljs-keyword">PRIMARY</span> KEY (state, city)<br>);<br></code></pre></td></tr></table></figure><p>列族只能在非主键列中进行指定。</p><hr><h2 id="6-4-对表进行压缩"><a href="#6-4-对表进行压缩" class="headerlink" title="6.4 对表进行压缩"></a>6.4 对表进行压缩</h2><p>在创建表时可以指定表的压缩方式，能极大的提高数据的读写效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> us_population (<br>      state <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>      city <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>      population <span class="hljs-type">BIGINT</span><br>      <span class="hljs-keyword">CONSTRAINT</span> my_pk <span class="hljs-keyword">PRIMARY</span> KEY (state, city)<br>)COMPRESSION<span class="hljs-operator">=</span><span class="hljs-string">&#x27;GZ&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>可选的压缩方式包括GZip、Snappy、Lzo等。</p></blockquote><h2 id="6-5-使用二级索引"><a href="#6-5-使用二级索引" class="headerlink" title="6.5 使用二级索引"></a>6.5 使用二级索引</h2><p>在HBase中会自动为RowKey添加索引，因此在通过RowKey查询数据时效率会很高，但是如果要根据其他列来进行组合查询，那么查询的性能就很低下，此时可以使用Phoenix提供的二级索引，能够极大的提高查询数据的性能。</p><ul><li>创建普通索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX 索引名称 <span class="hljs-keyword">ON</span> 表名(列名)<br></code></pre></td></tr></table></figure><ul><li>创建二级索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX 索引名称 <span class="hljs-keyword">ON</span> 表名(列名) INCLUDE(列名)<br></code></pre></td></tr></table></figure><hr><h1 id="七、可能遇到的问题"><a href="#七、可能遇到的问题" class="headerlink" title="七、可能遇到的问题"></a>七、可能遇到的问题</h1><h2 id="7-1-Phoenix-映射已存在-HBase-表，出现查询不到数据的问题"><a href="#7-1-Phoenix-映射已存在-HBase-表，出现查询不到数据的问题" class="headerlink" title="7.1 Phoenix 映射已存在 HBase 表，出现查询不到数据的问题"></a>7.1 Phoenix 映射已存在 HBase 表，出现查询不到数据的问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用网上数据如下</p><p>1、hbase shell 插入数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">create &#x27;test1&#x27;,&#x27;i&#x27;<br>put &#x27;test1&#x27;,&#x27;1&#x27;,&#x27;i:name&#x27;,&#x27;zhangsan&#x27;<br>put &#x27;test1&#x27;,&#x27;2&#x27;,&#x27;i:name&#x27;,&#x27;lisi&#x27;<br>put &#x27;test1&#x27;,&#x27;1&#x27;,&#x27;i:age&#x27;,&#x27;15&#x27;<br>put &#x27;test1&#x27;,&#x27;2&#x27;,&#x27;i:age&#x27;,&#x27;2&#x27;<br></code></pre></td></tr></table></figure><p><code>scan &#39;test1&#39;</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ROW                       COLUMN+CELL<br> 1                        <span class="hljs-attribute">column</span>=i:age, <span class="hljs-attribute">timestamp</span>=1523416240312, <span class="hljs-attribute">value</span>=15<br> 1                        <span class="hljs-attribute">column</span>=i:name, <span class="hljs-attribute">timestamp</span>=1523416227940, <span class="hljs-attribute">value</span>=zhangsan<br> 2                        <span class="hljs-attribute">column</span>=i:age, <span class="hljs-attribute">timestamp</span>=1523416249281, <span class="hljs-attribute">value</span>=2<br> 2                        <span class="hljs-attribute">column</span>=i:name, <span class="hljs-attribute">timestamp</span>=1523416234516, <span class="hljs-attribute">value</span>=lisi<br></code></pre></td></tr></table></figure><p>2、phoenix 创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> &quot;test1&quot;(<br>    pk <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">PRIMARY</span> KEY<br>    ,&quot;i&quot;.&quot;name&quot; <span class="hljs-type">VARCHAR</span><br>    ,&quot;i&quot;.&quot;age&quot; <span class="hljs-type">VARCHAR</span>);<br><br></code></pre></td></tr></table></figure><p>3、phoenix 查询，查询不到数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">0: jdbc:phoenix:&gt; select * from &quot;test1&quot;;<br>+-----+-------+------+<br>| PK  | name  | age  |<br>+-----+-------+------+<br>+-----+-------+------+<br>No rows selected (0.238 seconds)<br></code></pre></td></tr></table></figure><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>经过阅读官方文档发现，phoenix 4.10 版本后，对列映射做了优化，采用一套新的机制，不在基于列名方式映射到 hbase。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>1、如果只做查询，强烈建议使用 phoenix 视图方式映射，删除视图不影响 hbase 源数据，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> &quot;test1&quot;(<br>    pk <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">PRIMARY</span> KEY<br>    ,&quot;i&quot;.&quot;name&quot; <span class="hljs-type">VARCHAR</span><br>    ,&quot;i&quot;.&quot;age&quot; <span class="hljs-type">VARCHAR</span>);<br></code></pre></td></tr></table></figure><p>2、必须要表映射，需要禁用列映射规则（会降低查询性能），如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> &quot;test1&quot;(<br>    pk <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">PRIMARY</span> KEY<br>    ,&quot;i&quot;.&quot;name&quot; <span class="hljs-type">VARCHAR</span><br>    ,&quot;i&quot;.&quot;age&quot; <span class="hljs-type">VARCHAR</span>)<br> column_encoded_bytes<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>参考：<br><a href="http://phoenix.apache.org/columnencoding.html">http://phoenix.apache.org/columnencoding.html</a></p><hr><h2 id="7-2-Java项目中同时连接Hbase和phoenix"><a href="#7-2-Java项目中同时连接Hbase和phoenix" class="headerlink" title="7.2 Java项目中同时连接Hbase和phoenix"></a>7.2 Java项目中同时连接Hbase和phoenix</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>Java项目同时在pom文件中，同时引入了hbase-shaded-client 和phoenix-core依赖，在创建phoenix连接时可能会出现<strong>Can’t find method newStub in org.apache.phoenix.coprocessor.generated.MetaDataProtos$MetaDataService</strong>异常。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hbase<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hbase-shaded-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>&lt;/dependency<br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.phoenix<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>phoenix-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.15.0-HBase-1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell">Exception in thread &quot;main&quot; java.sql.SQLException: ERROR 2006 (INT08): Incompatible jars detected between client and server. Ensure that phoenix-[version]-server.jar is put on the classpath of HBase in every region server: Can&#x27;t find method newStub in org.apache.phoenix.coprocessor.generated.MetaDataProtos$MetaDataService!<br>at org.apache.phoenix.exception.SQLExceptionCode$Factory$1.newException(SQLExceptionCode.java:498)<br>at org.apache.phoenix.exception.SQLExceptionInfo.buildException(SQLExceptionInfo.java:150)<br>at org.apache.phoenix.query.ConnectionQueryServicesImpl.checkClientServerCompatibility(ConnectionQueryServicesImpl.java:1318)<br>at org.apache.phoenix.query.ConnectionQueryServicesImpl.ensureTableCreated(ConnectionQueryServicesImpl.java:1154)<br>at org.apache.phoenix.query.ConnectionQueryServicesImpl.createTable(ConnectionQueryServicesImpl.java:1491)<br>at org.apache.phoenix.schema.MetaDataClient.createTableInternal(MetaDataClient.java:2731)<br>at org.apache.phoenix.schema.MetaDataClient.createTable(MetaDataClient.java:1115)<br>at org.apache.phoenix.compile.CreateTableCompiler$1.execute(CreateTableCompiler.java:192)<br>at org.apache.phoenix.jdbc.PhoenixStatement$2.call(PhoenixStatement.java:408)<br>at org.apache.phoenix.jdbc.PhoenixStatement$2.call(PhoenixStatement.java:391)<br>at org.apache.phoenix.call.CallRunner.run(CallRunner.java:53)<br>at org.apache.phoenix.jdbc.PhoenixStatement.executeMutation(PhoenixStatement.java:390)<br>at org.apache.phoenix.jdbc.PhoenixStatement.executeMutation(PhoenixStatement.java:378)<br>at org.apache.phoenix.jdbc.PhoenixStatement.executeUpdate(PhoenixStatement.java:1806)<br>at org.apache.phoenix.query.ConnectionQueryServicesImpl$12.call(ConnectionQueryServicesImpl.java:2536)<br>at org.apache.phoenix.query.ConnectionQueryServicesImpl$12.call(ConnectionQueryServicesImpl.java:2499)<br>at org.apache.phoenix.util.PhoenixContextExecutor.call(PhoenixContextExecutor.java:76)<br>at org.apache.phoenix.query.ConnectionQueryServicesImpl.init(ConnectionQueryServicesImpl.java:2499)<br>at org.apache.phoenix.jdbc.PhoenixDriver.getConnectionQueryServices(PhoenixDriver.java:255)<br>at org.apache.phoenix.jdbc.PhoenixEmbeddedDriver.createConnection(PhoenixEmbeddedDriver.java:147)<br>at org.apache.phoenix.jdbc.PhoenixDriver.connect(PhoenixDriver.java:221)<br>at java.sql.DriverManager.getConnection(DriverManager.java:664)<br>at java.sql.DriverManager.getConnection(DriverManager.java:270)<br>at com.lew.test.Test.main(Test.java:18)<br>Caused by: java.lang.IllegalArgumentException: Can&#x27;t find method newStub in org.apache.phoenix.coprocessor.generated.MetaDataProtos$MetaDataService!<br>at org.apache.hadoop.hbase.util.Methods.call(Methods.java:45)<br>at org.apache.hadoop.hbase.protobuf.ProtobufUtil.newServiceStub(ProtobufUtil.java:1882)<br>at org.apache.hadoop.hbase.client.HTable$15.call(HTable.java:1774)<br>at java.util.concurrent.FutureTask.run(FutureTask.java:266)<br>at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)<br>at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)<br>at java.lang.Thread.run(Thread.java:748)<br>Caused by: java.lang.NoSuchMethodException: org.apache.phoenix.coprocessor.generated.MetaDataProtos$MetaDataService.newStub(org.apache.hadoop.hbase.shaded.com.google.protobuf.RpcChannel)<br>at java.lang.Class.getMethod(Class.java:1786)<br>at org.apache.hadoop.hbase.util.Methods.call(Methods.java:38)<br>... 6 more<br><br></code></pre></td></tr></table></figure><h3 id="问题原因-1"><a href="#问题原因-1" class="headerlink" title="问题原因"></a>问题原因</h3><p>包冲突，maven会按照pom中顺序加载jar包，即在前的优先级高</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>1，2都可以解决，实际项目里使用的1方式</p><ol><li>改变依赖顺序phoenix-core在前</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.phoenix<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>phoenix-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.15.0-HBase-1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hbase<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hbase-shaded-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <br></code></pre></td></tr></table></figure><ol start="2"><li>修改hbase client</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hbase<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hbase-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>&lt;/dependency<br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.phoenix<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>phoenix-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.15.0-HBase-1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br></code></pre></td></tr></table></figure><hr><h2 id="7-3-HBase集群正常运行，Phoenix一启动，HBase的Region节点就全部崩溃"><a href="#7-3-HBase集群正常运行，Phoenix一启动，HBase的Region节点就全部崩溃" class="headerlink" title="7.3 HBase集群正常运行，Phoenix一启动，HBase的Region节点就全部崩溃"></a>7.3 HBase集群正常运行，Phoenix一启动，HBase的Region节点就全部崩溃</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>刚搭完HBase集群，Phoenix一启动，HBase的Region节点就全崩溃了<br>报错如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.sql</span><span class="hljs-selector-class">.SQLException</span>: ERROR <span class="hljs-number">2006</span> (INT08): Incompatible jars detected between client and server. Ensure that phoenix<span class="hljs-selector-class">.jar</span> is put on the classpath of HBase <span class="hljs-keyword">in</span> every region server: org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.exceptions</span><span class="hljs-selector-class">.UnknownProtocolException</span>: No registered coprocessor service found <span class="hljs-keyword">for</span> name MetaDataService <span class="hljs-keyword">in</span> region SYSTEM<span class="hljs-selector-class">.CATALOG</span>,,<span class="hljs-number">1421861120199.56856673</span>d5cff02b55b9ff5955485dba.<br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.regionserver</span><span class="hljs-selector-class">.HRegion</span><span class="hljs-selector-class">.execService</span>(HRegion<span class="hljs-selector-class">.java</span>:<span class="hljs-number">5579</span>)<br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.regionserver</span><span class="hljs-selector-class">.HRegionServer</span><span class="hljs-selector-class">.execServiceOnRegion</span>(HRegionServer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">3416</span>)<br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.regionserver</span><span class="hljs-selector-class">.HRegionServer</span><span class="hljs-selector-class">.execService</span>(HRegionServer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">3398</span>)<br>    ... more<br>Caused by: org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.exceptions</span><span class="hljs-selector-class">.UnknownProtocolException</span>: org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.exceptions</span><span class="hljs-selector-class">.UnknownProtocolException</span>: No registered coprocessor service found <span class="hljs-keyword">for</span> name MetaDataService <span class="hljs-keyword">in</span> region SYSTEM<span class="hljs-selector-class">.CATALOG</span>,,<span class="hljs-number">1421861120199.56856673</span>d5cff02b55b9ff5955485dba.<br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.regionserver</span><span class="hljs-selector-class">.HRegion</span><span class="hljs-selector-class">.execService</span>(HRegion<span class="hljs-selector-class">.java</span>:<span class="hljs-number">5579</span>)<br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.regionserver</span><span class="hljs-selector-class">.HRegionServer</span><span class="hljs-selector-class">.execServiceOnRegion</span>(HRegionServer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">3416</span>)<br>    ... more<br>Caused by: org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.ipc</span><span class="hljs-selector-class">.RemoteWithExtrasException</span>(org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.exceptions</span>.UnknownProtocolException): org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.exceptions</span><span class="hljs-selector-class">.UnknownProtocolException</span>: No registered coprocessor service found <span class="hljs-keyword">for</span> name MetaDataService <span class="hljs-keyword">in</span> region SYSTEM<span class="hljs-selector-class">.CATALOG</span>,,<span class="hljs-number">1421861120199.56856673</span>d5cff02b55b9ff5955485dba.<br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.regionserver</span><span class="hljs-selector-class">.HRegion</span><span class="hljs-selector-class">.execService</span>(HRegion<span class="hljs-selector-class">.java</span>:<span class="hljs-number">5579</span>)<br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.hbase</span><span class="hljs-selector-class">.regionserver</span><span class="hljs-selector-class">.HRegionServer</span><span class="hljs-selector-class">.execServiceOnRegion</span>(HRegionServer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">3416</span>)<br>    ... <span class="hljs-number">14</span> more<br></code></pre></td></tr></table></figure><h3 id="问题原因-2"><a href="#问题原因-2" class="headerlink" title="问题原因"></a>问题原因</h3><p>Phoenix启动HBase就挂，而Phoenix基于HBase协处理器做了很多工作，很明显HBase单独启动没问题，走到协处理器这一步就报错，一定不是HBase端的问题，也一定是没有设定下面的参数为False。</p><p><code>hbase-site.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.coprocessor.abortonerror<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一般我们应用HBase协处理器技术，首先要将其设为False。这个是什么意思呢？意思就是当加载于HBase之上的协处理器异常时要不要abort Hbase。那肯定是不要，总不能加载了一个协处理器将整个集群搞挂了，毕竟手写协处理器代码难免有bug。</p><p>我们设置该参数后，重启HBase再启动Phoenix，这回HBase没事了，但是Phoenix依然报上面的错误。</p><p><strong>因为将Phoenix压缩包下几乎所有的jar包都拷贝到了HBase/lib目录下，造成了包冲突。而官网只是要求将Phoenix-version-server.jar拷贝到HBase/lib目录下。</strong></p><p><img src="/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Phoenix/Phoenix/image-20211223103803619.png" alt="image-20211223103803619"></p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li>按问题原因中设置hbase协处理器参数</li><li>只复制Phoenix-version-server.jar包，不复制Phoenix-version-client.jar等其他包</li><li>重启Hbase</li></ul><hr><h2 id="7-3-首次连接Phoenix时，会打印一些内容"><a href="#7-3-首次连接Phoenix时，会打印一些内容" class="headerlink" title="7.3 首次连接Phoenix时，会打印一些内容"></a>7.3 首次连接Phoenix时，会打印一些内容</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>SpringBoot项目首次连接phoenix时，会打印如下内容</p><p><img src="/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Phoenix/Phoenix/image-20211223105342644.png" alt="image-20211223105342644"></p><h3 id="问题原因-3"><a href="#问题原因-3" class="headerlink" title="问题原因"></a>问题原因</h3><p>这个不是异常或错误，是自动打印的日志</p><p><img src="/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Phoenix/Phoenix/image-20211223105606321.png" alt="image-20211223105606321"></p><h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><p>不是问题，无需处理</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Phoenix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Phoenix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase</title>
    <link href="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/"/>
    <url>/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/</url>
    
    <content type="html"><![CDATA[<h1 id="一、HBase概述"><a href="#一、HBase概述" class="headerlink" title="一、HBase概述"></a>一、HBase概述</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>HBase的原型是Google的BigTable论文，受到了该论文思想的启发，目前作为Hadoop的子项目来开发维护，用于支持结构化的数据存储。</p><p>HBase是一个高可靠性、高性能、面向列、可伸缩的<strong>分布式存储系统</strong>，利用HBASE技术可在廉价PC Server上搭建起大规模结构化存储集群。</p><p>HBase的目标是存储并处理大型的数据，更具体来说是仅需使用普通的硬件配置，就能够处理由成千上万的行和列所组成的大型数据。</p><p>HBase是Google Bigtable的开源实现，但是也有很多不同之处。比如：Google Bigtable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MAPREDUCE来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据；Google Bigtable利用Chubby作为协同服务，HBase利用Zookeeper作为对应。</p><h2 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><h3 id="海量存储"><a href="#海量存储" class="headerlink" title="海量存储"></a>海量存储</h3><p>Hbase适合存储PB级别的海量数据，在PB级别的数据以及采用廉价PC存储的情况下，能在几十到百毫秒内返回数据。这与Hbase的极易扩展性息息相关。正式因为Hbase良好的扩展性，才为海量数据的存储提供了便利。</p><h3 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h3><p>这里的列式存储其实说的是列族存储，Hbase是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定。</p><h3 id="极易扩展"><a href="#极易扩展" class="headerlink" title="极易扩展"></a>极易扩展</h3><p>Hbase的扩展性主要体现在两个方面，一个是基于上层处理能力（RegionServer）的扩展，一个是基于存储的扩展（HDFS）。<br> 通过横向添加RegionSever的机器，进行水平扩展，提升Hbase上层的处理能力，提升Hbsae服务更多Region的能力。</p><p>备注：RegionServer的作用是管理region、承接业务的访问，这个后面会详细的介绍通过横向添加Datanode的机器，进行存储层扩容，提升Hbase的数据存储能力和提升后端存储的读写能力。</p><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>由于目前大部分使用Hbase的架构，都是采用的廉价PC，因此单个IO的延迟其实并不小，一般在几十到上百ms之间。这里说的高并发，主要是在并发的情况下，Hbase的单个IO延迟下降并不多。能获得高并发、低延迟的服务。</p><h3 id="稀疏"><a href="#稀疏" class="headerlink" title="稀疏"></a>稀疏</h3><p>稀疏主要是针对Hbase列的灵活性，在列族中，你可以指定任意多的列，在列数据为空的情况下，是不会占用存储空间的。</p><hr><h2 id="1-3架构"><a href="#1-3架构" class="headerlink" title="1.3架构"></a>1.3架构</h2><p>Hbase架构如下图所示：</p><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/image-20211001205635471.png" alt="image-20211001205635471"></p><p>从图中可以看出Hbase是由Client、Zookeeper、Master、HRegionServer、HDFS等几个组件组成，下面来介绍一下几个组件的相关功能：</p><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>Client包含了访问Hbase的接口，另外Client还维护了对应的cache来加速Hbase的访问，比如cache的.META.元数据的信息。</p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>HBase通过Zookeeper来做master的高可用、RegionServer的监控、元数据的入口以及集群配置的维护等工作。具体工作如下：</p><ul><li>通过Zoopkeeper来保证集群中只有1个master在运行，如果master异常，会通过竞争机制产生新的master提供服</li><li>通过Zoopkeeper来监控RegionServer的状态，当RegionSevrer有异常的时候，通过回调的形式通知Master RegionServer上下线的信息</li><li>通过Zoopkeeper存储元数据的统一入口地址</li></ul><h3 id="Hmaster"><a href="#Hmaster" class="headerlink" title="Hmaster"></a>Hmaster</h3><p>master节点的主要职责如下：</p><ul><li>为RegionServer分配Region</li><li>维护整个集群的负载均衡</li><li>维护集群的元数据信息</li><li>发现失效的Region，并将失效的Region分配到正常的RegionServer上</li><li>当RegionSever失效的时候，协调对应Hlog的拆分</li></ul><h3 id="HregionServer"><a href="#HregionServer" class="headerlink" title="HregionServer"></a>HregionServer</h3><p>HregionServer直接对接用户的读写请求，是真正的“干活”的节点。它的功能概括如下：</p><ul><li>管理master为其分配的Region</li><li>处理来自客户端的读写请求</li><li>负责和底层HDFS的交互，存储数据到HDFS</li><li>负责Region变大以后的拆分</li><li>负责Storefile的合并工作</li></ul><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><p>HDFS为Hbase提供最终的底层数据存储服务，同时为HBase提供高可用（Hlog存储在HDFS）的支持，具体功能概括如下：</p><ul><li>提供元数据和表数据的底层分布式存储服务</li><li>数据多副本，保证的高可靠和高可用性</li></ul><h3 id="Write-Ahead-logs"><a href="#Write-Ahead-logs" class="headerlink" title="Write-Ahead logs"></a>Write-Ahead logs</h3><p>HBase的修改记录，当对HBase读写数据的时候，数据不是直接写进磁盘，它会在内存中保留一段时间（时间以及数据量阈值可以设定）。但把数据保存在内存中可能有更高的概率引起数据丢失，为了解决这个问题，数据会先写在一个叫做Write-Ahead logfile的文件中，然后再写入内存中。所以在系统出现故障的时候，数据可以通过这个日志文件重建。</p><blockquote><p>influxdb中也有类似设计</p><p>相当于MySQL的binlog</p></blockquote><h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><p>Hbase表的分片，HBase表会根据RowKey值被切分成不同的region存储在RegionServer中，在一个RegionServer中可以有多个不同的region。</p><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>HFile存储在Store中，一个Store对应HBase表中的一个列族。</p><h3 id="MemStore"><a href="#MemStore" class="headerlink" title="MemStore"></a>MemStore</h3><p>顾名思义，就是内存存储，位于内存中，用来保存当前的数据操作，所以当数据保存在WAL中之后，RegsionServer会在内存中存储键值对。</p><h3 id="HFile"><a href="#HFile" class="headerlink" title="HFile"></a>HFile</h3><p>这是在磁盘上保存原始数据的实际的物理文件，是实际的存储文件。StoreFile是以Hfile的形式存储在HDFS的。</p><hr><h1 id="二、HBase安装"><a href="#二、HBase安装" class="headerlink" title="二、HBase安装"></a>二、HBase安装</h1><p><strong>注意HBase版本需要与Hadoop匹配</strong></p><p>如果之后需要安装<code>Phoenix</code>等软件也需要提前规划好版本</p><p>对应版本如下图所示</p><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/image-20211216163736392.png" alt="image-20211216163736392"></p><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/1114671-20180725232327857-603686478.png" alt="img"></p><h2 id="2-1-Zookeeper正常部署"><a href="#2-1-Zookeeper正常部署" class="headerlink" title="2.1 Zookeeper正常部署"></a>2.1 Zookeeper正常部署</h2><p>首先保证Zookeeper集群的正常部署，并启动：</p><p><code>bin/zkServer.sh start</code></p><h2 id="2-2-Hadoop正常部署"><a href="#2-2-Hadoop正常部署" class="headerlink" title="2.2 Hadoop正常部署"></a>2.2 Hadoop正常部署</h2><p>保证Hadoop集群的正常部署并启动：</p><p><code>sbin/start-dfs.sh</code></p><p><code>sbin/start-yarn.sh</code></p><h2 id="2-3-HBase的解压"><a href="#2-3-HBase的解压" class="headerlink" title="2.3 HBase的解压"></a>2.3 HBase的解压</h2><p>解压HBase到指定目录：</p><p><code>tar -zxvf hbase-2.2.7-bin.tar.gz -C /export/servers/hbase-2.2.7</code></p><h2 id="2-4-HBase的配置文件"><a href="#2-4-HBase的配置文件" class="headerlink" title="2.4 HBase的配置文件"></a>2.4 HBase的配置文件</h2><p>修改HBase对应的配置文件。</p><p>1）hbase-env.sh修改内容：</p><p><code>export JAVA_HOME=/usr/java/jdk1.8.0/</code></p><p><code>export HBASE_MANAGES_ZK=false</code></p><p>2）hbase-site.xml修改内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.cluster.distributed<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>./tmp<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.rootdir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- hbase存放数据目录 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://node01:8020/hbase/hbase_db<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 端口要和Hadoop的fs.defaultFS端口一致--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.cluster.distributed<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- 是否分布式部署 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-comment">&lt;!-- zookooper 服务启动的节点，只能为奇数个 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01,node02,node03<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!--zookooper配置、日志等的存储位置，必须唯一存在 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/data/hbase/zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!--hbase web 端口 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.master.info.port<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>16610<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>3）regionservers：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-symbol">node01</span><br><span class="hljs-symbol">node02</span><br><span class="hljs-symbol">node03</span><br></code></pre></td></tr></table></figure><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/image-20211001221134151.png" alt="image-20211001221134151"></p><h2 id="2-5-HBase远程发送到其他集群"><a href="#2-5-HBase远程发送到其他集群" class="headerlink" title="2.5 HBase远程发送到其他集群"></a>2.5 HBase远程发送到其他集群</h2><p><code>xsync hbase/ </code></p><blockquote><p>我没有执行这一步也是可以的</p></blockquote><h2 id="2-6-HBase服务的启动"><a href="#2-6-HBase服务的启动" class="headerlink" title="2.6 HBase服务的启动"></a>2.6 HBase服务的启动</h2><ul><li>启动方式1</li></ul><p><code>bin/hbase-daemon.sh start master</code></p><p><code>bin/hbase-daemon.sh start regionserver</code></p><blockquote><p>如果集群之间的节点时间不同步，会导致regionserver无法启动，抛出ClockOutOfSyncException异常。</p><p>需要进行各节点时间同步，或设置属性：hbase.master.maxclockskew设置更大的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.master.maxclockskew<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>180000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Time  difference of regionserver from master<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br></code></pre></td></tr></table></figure></blockquote><ul><li>启动方式2</li></ul><p><code>bin/start-hbase.sh</code></p><p>对应的停止服务：</p><p><code>bin/stop-hbase.sh</code></p><h2 id="2-7-查看HBase页面"><a href="#2-7-查看HBase页面" class="headerlink" title="2.7 查看HBase页面"></a>2.7 查看HBase页面</h2><p>启动成功后，可以通过“host:port”的方式来访问HBase管理页面，例如：</p><p><a href="http://192.168.127.110:16610/">http://192.168.127.110:16610/</a> </p><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/image-20211001222014215.png" alt="image-20211001222014215"></p><hr><h1 id="三、HBase-Shell操作"><a href="#三、HBase-Shell操作" class="headerlink" title="三、HBase Shell操作"></a>三、HBase Shell操作</h1><h2 id="3-1-基本操作"><a href="#3-1-基本操作" class="headerlink" title="3.1 基本操作"></a>3.1 基本操作</h2><ul><li>进入HBase客户端命令行</li></ul><p><code>bin/hbase shell</code></p><ul><li>查看帮助命令</li></ul><p><code>help</code></p><ul><li>查看当前数据库中有哪些表</li></ul><p><code>list</code></p><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/image-20211001222250487.png" alt="image-20211001222250487"></p><h2 id="3-2-表的操作"><a href="#3-2-表的操作" class="headerlink" title="3.2 表的操作"></a>3.2 表的操作</h2><p>1．创建表</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">002</span>:<span class="hljs-number">0</span>&gt; create <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;info&#x27;</span><br></code></pre></td></tr></table></figure><p>2．插入数据到表</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">003</span>:<span class="hljs-number">0</span>&gt; put <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;1001&#x27;</span>,<span class="hljs-string">&#x27;info:sex&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span><br><br><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">004</span>:<span class="hljs-number">0</span>&gt; put <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;1001&#x27;</span>,<span class="hljs-string">&#x27;info:age&#x27;</span>,<span class="hljs-string">&#x27;18&#x27;</span><br><br><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">005</span>:<span class="hljs-number">0</span>&gt; put <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;1002&#x27;</span>,<span class="hljs-string">&#x27;info:name&#x27;</span>,<span class="hljs-string">&#x27;Janna&#x27;</span><br><br><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">006</span>:<span class="hljs-number">0</span>&gt; put <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;1002&#x27;</span>,<span class="hljs-string">&#x27;info:sex&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span><br><br><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">007</span>:<span class="hljs-number">0</span>&gt; put <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;1002&#x27;</span>,<span class="hljs-string">&#x27;info:age&#x27;</span>,<span class="hljs-string">&#x27;20&#x27;</span><br></code></pre></td></tr></table></figure><p>3．扫描查看表数据</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">008</span>:<span class="hljs-number">0</span>&gt; scan <span class="hljs-string">&#x27;student&#x27;</span><br><br><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">009</span>:<span class="hljs-number">0</span>&gt; scan <span class="hljs-string">&#x27;student&#x27;</span>,&#123;STARTROW =&gt; <span class="hljs-string">&#x27;1001&#x27;</span>, STOPROW =&gt; <span class="hljs-string">&#x27;1001&#x27;</span>&#125;<br><br><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">010</span>:<span class="hljs-number">0</span>&gt; scan <span class="hljs-string">&#x27;student&#x27;</span>,&#123;STARTROW =&gt; <span class="hljs-string">&#x27;1001&#x27;</span>&#125;<br><br></code></pre></td></tr></table></figure><p>4．查看表结构</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">011</span>:<span class="hljs-number">0</span>&gt; describe ‘student’<br></code></pre></td></tr></table></figure><p>5．更新指定字段的数据</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">012</span>:<span class="hljs-number">0</span>&gt; put <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;1001&#x27;</span>,<span class="hljs-string">&#x27;info:name&#x27;</span>,<span class="hljs-string">&#x27;Nick&#x27;</span><br><br><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">013</span>:<span class="hljs-number">0</span>&gt; put <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;1001&#x27;</span>,<span class="hljs-string">&#x27;info:age&#x27;</span>,<span class="hljs-string">&#x27;100&#x27;</span><br></code></pre></td></tr></table></figure><p>6．查看“指定行”或“指定列族:列”的数据</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">014</span>:<span class="hljs-number">0</span>&gt; get <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;1001&#x27;</span><br><br><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">015</span>:<span class="hljs-number">0</span>&gt; get <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;1001&#x27;</span>,<span class="hljs-string">&#x27;info:name&#x27;</span><br></code></pre></td></tr></table></figure><p>7．统计表数据行数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">021</span>:<span class="hljs-number">0</span>&gt; count <span class="hljs-string">&#x27;student&#x27;</span><br></code></pre></td></tr></table></figure><p>8．删除数据</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">删除某rowkey的全部数据：<br><br><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">016</span>:<span class="hljs-number">0</span>&gt; deleteall <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;1001&#x27;</span><br><br>删除某rowkey的某一列数据：<br><br><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">017</span>:<span class="hljs-number">0</span>&gt; delete <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;1002&#x27;</span>,<span class="hljs-string">&#x27;info:sex&#x27;</span><br></code></pre></td></tr></table></figure><p>9．清空表数据</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">hbase(main):<span class="hljs-number">018</span>:<span class="hljs-number">0</span>&gt; <span class="hljs-keyword">truncate</span> <span class="hljs-string">&#x27;student&#x27;</span><br><br>提示：清空表的操作顺序为先<span class="hljs-keyword">disable</span>，然后再<span class="hljs-keyword">truncate</span>。<br></code></pre></td></tr></table></figure><p>10．删除表</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">首先需要先让该表为<span class="hljs-keyword">disable</span>状态：<br><br>hbase(main):<span class="hljs-number">019</span>:<span class="hljs-number">0</span>&gt; <span class="hljs-keyword">disable</span> <span class="hljs-string">&#x27;student&#x27;</span><br><br>然后才能<span class="hljs-keyword">drop</span>这个表：<br><br>hbase(main):<span class="hljs-number">020</span>:<span class="hljs-number">0</span>&gt; <span class="hljs-keyword">drop</span> <span class="hljs-string">&#x27;student&#x27;</span><br><br>提示：如果直接<span class="hljs-keyword">drop</span>表，会报错：ERROR: <span class="hljs-keyword">Table</span> student <span class="hljs-keyword">is</span> enabled. <span class="hljs-keyword">Disable</span> it first.<br></code></pre></td></tr></table></figure><p>11．变更表信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">将info列族中的数据存放<span class="hljs-number">3</span>个版本：<br><br><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">022</span>:<span class="hljs-number">0</span>&gt; alter <span class="hljs-string">&#x27;student&#x27;</span>,&#123;NAME=&gt;<span class="hljs-string">&#x27;info&#x27;</span>,VERSIONS=&gt;<span class="hljs-number">3</span>&#125;<br><br><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">022</span>:<span class="hljs-number">0</span>&gt; get <span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;1001&#x27;</span>,&#123;COLUMN=&gt;<span class="hljs-string">&#x27;info:name&#x27;</span>,VERSIONS=&gt;<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="四、HBase数据结构"><a href="#四、HBase数据结构" class="headerlink" title="四、HBase数据结构"></a>四、HBase数据结构</h1><h2 id="4-1-RowKey"><a href="#4-1-RowKey" class="headerlink" title="4.1 RowKey"></a>4.1 RowKey</h2><p>与nosql数据库们一样,RowKey是用来检索记录的主键。访问HBASE table中的行，只有三种方式：</p><ol><li><p>通过单个RowKey访问</p></li><li><p>通过RowKey的range（正则）</p></li><li><p>全表扫描</p></li></ol><p>RowKey行键 (RowKey)可以是任意字符串(最大长度是64KB，实际应用中长度一般为 10-100bytes)，在HBASE内部，RowKey保存为字节数组。存储时，数据按照RowKey的字典序(byte order)排序存储。设计RowKey时，要充分排序存储这个特性，将经常一起读取的行存储放到一起。(位置相关性)</p><h2 id="4-2-Column-Family"><a href="#4-2-Column-Family" class="headerlink" title="4.2 Column Family"></a>4.2 Column Family</h2><p>列族：HBASE表中的每个列，都归属于某个列族。列族是表的schema的一部 分(而列不是)，必须在使用表之前定义。列名都以列族作为前缀。例如 courses:history，courses:math都属于courses 这个列族。</p><h2 id="4-3-Cell"><a href="#4-3-Cell" class="headerlink" title="4.3 Cell"></a>4.3 Cell</h2><p>由{rowkey, column Family:columu, version} 唯一确定的单元。cell中的数据是没有类型的，全部是字节码形式存贮。</p><p>关键字：无类型、字节码</p><h2 id="4-4-Time-Stamp"><a href="#4-4-Time-Stamp" class="headerlink" title="4.4 Time Stamp"></a>4.4 Time Stamp</h2><p>HBASE 中通过rowkey和columns确定的为一个存贮单元称为cell。每个 cell都保存 着同一份数据的多个版本。版本通过时间戳来索引。时间戳的类型是 64位整型。时间戳可以由HBASE(在数据写入时自动 )赋值，此时时间戳是精确到毫秒 的当前系统时间。时间戳也可以由客户显式赋值。如果应用程序要避免数据版 本冲突，就必须自己生成具有唯一性的时间戳。每个 cell中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。</p><p>为了避免数据存在过多版本造成的的管理 (包括存贮和索引)负担，HBASE提供 了两种数据版本回收方式。一是保存数据的最后n个版本，二是保存最近一段 时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。</p><h2 id="4-5-命名空间"><a href="#4-5-命名空间" class="headerlink" title="4.5 命名空间"></a>4.5 命名空间</h2><p>命名空间的结构:</p><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/image-20211002170548761.png" alt="image-20211002170548761"></p><p><strong>1) Table</strong>：表，所有的表都是命名空间的成员，即表必属于某个命名空间，如果没有指定，则在default默认的命名空间中。</p><p><strong>2) RegionServer group</strong>：一个命名空间包含了默认的RegionServer Group。</p><p><strong>3) Permission</strong>：权限，命名空间能够让我们来定义访问控制列表ACL（Access Control List）。例如，创建表，读取表，删除，更新等等操作。</p><p><strong>4) Quota</strong>：限额，可以强制一个命名空间可包含的region的数量。</p><hr><h1 id="五、HBase原理"><a href="#五、HBase原理" class="headerlink" title="五、HBase原理"></a>五、HBase原理</h1><h2 id="5-1-读流程"><a href="#5-1-读流程" class="headerlink" title="5.1 读流程"></a>5.1 读流程</h2><p>HBase读数据流程如下图所示</p><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/image-20211002170856670.png" alt="image-20211002170856670"></p><p>1）Client先访问zookeeper，从meta表读取region的位置，然后读取meta表中的数据。meta中又存储了用户表的region信息；</p><p>2）根据namespace、表名和rowkey在meta表中找到对应的region信息；</p><p>3）找到这个region对应的regionserver；</p><p>4）查找对应的region；</p><p>5）先从MemStore找数据，如果没有，再到BlockCache里面读；</p><p>6）BlockCache还没有，再到StoreFile上读(为了读取的效率)；</p><p>7）<strong>如果是从StoreFile里面读取的数据，不是直接返回给客户端，而是先写入BlockCache，再返回给客户端。</strong></p><h2 id="5-2-写流程"><a href="#5-2-写流程" class="headerlink" title="5.2 写流程"></a>5.2 写流程</h2><p>Hbase写流程如下图所示</p><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/image-20211002171014008.png" alt="image-20211002171014008"></p><p>1）Client向HregionServer发送写请求；</p><p>2）HregionServer将数据写到HLog（write ahead log）。为了数据的持久化和恢复；</p><p>3）HregionServer将数据写到内存（MemStore）；</p><p>4）反馈Client写成功。</p><h2 id="5-3-数据Flush过程"><a href="#5-3-数据Flush过程" class="headerlink" title="5.3 数据Flush过程"></a>5.3 数据Flush过程</h2><p>1）当MemStore数据达到阈值（默认是128M，老版本是64M），将数据刷到硬盘，将内存中的数据删除，同时删除HLog中的历史数据；</p><p>2）并将数据存储到HDFS中；</p><p>3）在HLog中做标记点。</p><h2 id="5-4-数据合并过程"><a href="#5-4-数据合并过程" class="headerlink" title="5.4 数据合并过程"></a>5.4 数据合并过程</h2><p>1）当数据块达到4块，Hmaster触发合并操作，Region将数据块加载到本地，进行合并；</p><p>2）当合并的数据超过256M，进行拆分，将拆分后的Region分配给不同的HregionServer管理；</p><p>3）当HregionServer宕机后，将HregionServer上的hlog拆分，然后分配给不同的HregionServer加载，修改.META.；</p><p>4）注意：HLog会同步到HDFS。</p><hr><h1 id="六、协处理器"><a href="#六、协处理器" class="headerlink" title="六、协处理器"></a>六、协处理器</h1><p><a href="https://www.cnblogs.com/yinzhengjie/p/9163304.html">https://www.cnblogs.com/yinzhengjie/p/9163304.html</a></p><h2 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1 简介"></a>6.1 简介</h2><p>协处理器可以使用客户端API，配合筛选机制。</p><p>例如，使用过滤器或限制列族的范围，都可以控制被返回到客户端的数据量。如果可以更进一步优化会更好，例如，数据的处理流程直接存放到服务器端执行，然后仅返回一个小的处理结果集。这类似于一个小型的MapReduce框架，该框架将工作分发到整个集群。</p><p>协处理器运行用户在region服务器上运行自己的代码，更准确的说是允许用户执行region级的操作，并且可以使用RDBMS中触发器（trigger）类似的功能。</p><p>在客户端，用户不用关心操作具体在哪里执行，HBase的分布式框架会帮助用户把这些工作变得透明。这里用户可以监听一些隐式的事件，并利用其来完成一些辅助任务。如果这还不够，用户还可以自己扩展现有的RPC协议引用自己的调用，这些调用由客户端触发，并在服务器端执行。</p><h2 id="6-2-分类"><a href="#6-2-分类" class="headerlink" title="6.2 分类"></a>6.2 分类</h2><p>协处理器框架已经提供了一些类，用户可以通过继承这些类来扩展自己的功能。这些类主要分为两大类，即observer和endpoint。以下是各个功能的简要介绍。</p><h3 id="observer"><a href="#observer" class="headerlink" title="observer"></a>observer</h3><p>这一类协处理器与触发器（trigger）类似：回调函数（也被称作钩子函数，hook）在一些特定时间发生时被执行。这些时间包括一些用户产生的事件，也包括服务器内部自动产生的事件，也包括服务器端内部自动产生的事件。协处理器框架提供的接口如下所示：</p><ul><li><p>RegionObserver：用户可以用这种的处理器处理数据修改时间，他们与表的region联系紧密；</p></li><li><p>MasterObserve：可以被用作管理或DDL类型的操作，这些是集群级事件；</p></li><li><p>WALObserver：提供控制WAL的钩子函数；</p></li></ul><p>observer提供了一些设计好的回调函数，每个操作在集群服务器端都可以被调用。</p><h3 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h3><p>除了事件处理之外还需要将用户自定义操作添加到服务器端。用户代码可以被部署到管理数据的服务器端，例如，做一些服务器端计算的工作。endpoint通过添加一些远程过程调用来动态扩展RPC协议。可以把他们理解为与RDBMS中类似的存储过程，endpoint可以与observer的实现组合起来直接作用于服务器端的状态。</p><h2 id="6-3-RegionObserver类"><a href="#6-3-RegionObserver类" class="headerlink" title="6.3 RegionObserver类"></a>6.3 RegionObserver类</h2><p>在region级别中介绍的Coprocessor第一个子类是RegionObserver类。从名字中可以看出它属于observer协处理器：当一个特定的region级别的操作发生时，他们的钩子函数会被触发。</p><p>BaseRegionObserver类可以作为所有用户实现监听类型协处理器的基类。它实现了所有RegionObserver接口的空方法，所有在默认情况下基础这个类的协处理器没有任何功能。用户需要重载他们方法实现自己的功能。</p><p>示例如下</p><p>此部分引用自<a href="https://www.cnblogs.com/yinzhengjie/p/9163304.html">https://www.cnblogs.com/yinzhengjie/p/9163304.html</a></p><h3 id="1-编写代码"><a href="#1-编写代码" class="headerlink" title="1.编写代码"></a>1.编写代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.Cell;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.CoprocessorEnvironment;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.client.Delete;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.client.Durability;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.client.Get;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.client.Put;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.coprocessor.BaseRegionObserver;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.coprocessor.ObserverContext;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.regionserver.wal.WALEdit;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRegionObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRegionObserver</span> </span>&#123;<br>    File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/home/yinzhengjie/coprocessor.log&quot;</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(CoprocessorEnvironment e)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.start(e);<br><br>        <span class="hljs-keyword">if</span>(!f.exists())&#123;<br>            f.createNewFile();<br>        &#125;<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream( f, <span class="hljs-keyword">true</span>);<br>        fos.write(<span class="hljs-string">&quot;this is a start function\n&quot;</span>.getBytes());<br>        fos.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">(CoprocessorEnvironment e)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.stop(e);<br>        <span class="hljs-keyword">if</span>(!f.exists())&#123;<br>            f.createNewFile();<br>        &#125;<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(f, <span class="hljs-keyword">true</span>);<br>        fos.write(<span class="hljs-string">&quot;this is a stop function\n&quot;</span>.getBytes());<br>        fos.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postFlush</span><span class="hljs-params">(ObserverContext&lt;RegionCoprocessorEnvironment&gt; e)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.postFlush(e);<br>        <span class="hljs-keyword">if</span>(!f.exists())&#123;<br>            f.createNewFile();<br>        &#125;<br><br>        <span class="hljs-comment">//</span><br>        String table = e.getEnvironment().getRegionInfo().getTable().getNameAsString();<br><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(f, <span class="hljs-keyword">true</span>);<br>        fos.write((<span class="hljs-string">&quot;this is a flush function, table: &quot;</span> + table +  <span class="hljs-string">&quot;被刷新了\n &quot;</span>).getBytes());<br>        fos.close();<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postGetOp</span><span class="hljs-params">(ObserverContext&lt;RegionCoprocessorEnvironment&gt; e, Get get, List&lt;Cell&gt; results)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.postGetOp(e, get, results);<br>        <span class="hljs-keyword">if</span>(!f.exists())&#123;<br>            f.createNewFile();<br>        &#125;<br>        <span class="hljs-comment">//通过put得到操作行</span><br>        String row = <span class="hljs-keyword">new</span> String(get.getRow());<br><br>        <span class="hljs-comment">//</span><br>        String table = e.getEnvironment().getRegionInfo().getTable().getNameAsString();<br><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(f, <span class="hljs-keyword">true</span>);<br>        fos.write((<span class="hljs-string">&quot;this is a get function, table: &quot;</span> + table + <span class="hljs-string">&quot;,row: &quot;</span> + row + <span class="hljs-string">&quot;发生了修改\n &quot;</span>).getBytes());<br>        fos.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postPut</span><span class="hljs-params">(ObserverContext&lt;RegionCoprocessorEnvironment&gt; e, Put put, WALEdit edit, Durability durability)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.postPut(e, put, edit, durability);<br><br>        <span class="hljs-keyword">if</span>(!f.exists())&#123;<br>            f.createNewFile();<br>        &#125;<br><br>        <span class="hljs-comment">//通过put得到操作行</span><br>        String row = <span class="hljs-keyword">new</span> String(put.getRow());<br><br>        <span class="hljs-comment">//</span><br>        String table = e.getEnvironment().getRegionInfo().getTable().getNameAsString();<br><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(f, <span class="hljs-keyword">true</span>);<br>        fos.write((<span class="hljs-string">&quot;this is a put function, table: &quot;</span> + table + <span class="hljs-string">&quot;,row: &quot;</span> + row + <span class="hljs-string">&quot;发生了修改\n &quot;</span>).getBytes());<br>        fos.close();<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postDelete</span><span class="hljs-params">(ObserverContext&lt;RegionCoprocessorEnvironment&gt; e, Delete delete, WALEdit edit, Durability durability)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.postDelete(e, delete, edit, durability);<br><br>        <span class="hljs-keyword">if</span>(!f.exists())&#123;<br>            f.createNewFile();<br>        &#125;<br>        <span class="hljs-comment">//通过put得到操作行</span><br>        String row = <span class="hljs-keyword">new</span> String(delete.getRow());<br><br>        <span class="hljs-comment">//</span><br>        String table = e.getEnvironment().getRegionInfo().getTable().getNameAsString();<br><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(f, <span class="hljs-keyword">true</span>);<br>        fos.write((<span class="hljs-string">&quot;this is a delete function, table: &quot;</span> + table + <span class="hljs-string">&quot;,row: &quot;</span> + row + <span class="hljs-string">&quot;发生了修改\n &quot;</span>).getBytes());<br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-将以上代码进行打包"><a href="#2-将以上代码进行打包" class="headerlink" title="2. 将以上代码进行打包"></a>2. 将以上代码进行打包</h3><p>将以上代码进行打包并将其放置/export/servers/hbase/lib下。并关闭hbase</p><h3 id="3-注册（hbase-conf-hbase-site-xml）"><a href="#3-注册（hbase-conf-hbase-site-xml）" class="headerlink" title="3.注册（hbase/conf/hbase-site.xml）"></a>3.注册（hbase/conf/hbase-site.xml）</h3><p>目的是使用写的jar包</p><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/795254-20180610151513855-1835807263.png" alt="img"></p><h3 id="4-同步文件"><a href="#4-同步文件" class="headerlink" title="4. 同步文件"></a>4. 同步文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs shell">[yinzhengjie@s101 ~]$ more `which xrsync.sh`<br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">判断用户是否传参</span><br>if [ $# -lt 1 ];then<br>    echo &quot;请输入参数&quot;;<br>    exit<br>fi<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取文件路径</span><br>file=$@<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取子路径</span><br>filename=`basename $file`<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取父路径</span><br>dirpath=`dirname $file`<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取完整路径</span><br>cd $dirpath<br>fullpath=`pwd -P`<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">同步文件到DataNode</span><br>for (( i=102;i&lt;=105;i++ ))<br>do<br>    #使终端变绿色 <br>    tput setaf 2<br>    echo =========== s$i %file ===========<br>    #使终端变回原来的颜色，即白灰色<br>    tput setaf 7<br>    #远程执行命令<br>    rsync -lr $filename `whoami`@s$i:$fullpath<br>    #判断命令是否执行成功<br>    if [ $? == 0 ];then<br>        echo &quot;命令执行成功&quot;<br>    fi<br>done<br>[yinzhengjie@s101 ~]$ <br><br>[yinzhengjie@s101 ~]$ more `which xrsync.sh`<br></code></pre></td></tr></table></figure><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/795254-20180610151644309-244242035.png" alt="img"></p><h3 id="5-启动Hbase"><a href="#5-启动Hbase" class="headerlink" title="5. 启动Hbase"></a>5. 启动Hbase</h3><p><a href="https://www.cnblogs.com/yinzhengjie/p/9163304.html">https://www.cnblogs.com/yinzhengjie/p/9163304.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[yinzhengjie@s101 ~]$ start-hbase.sh <br>starting master, logging to /soft/hbase/bin/../logs/hbase-yinzhengjie-master-s101.out<br>Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=128m; support was removed in 8.0<br>Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=128m; support was removed in 8.0<br>s104: starting regionserver, logging to /soft/hbase/bin/../logs/hbase-yinzhengjie-regionserver-s104.out<br>s103: starting regionserver, logging to /soft/hbase/bin/../logs/hbase-yinzhengjie-regionserver-s103.out<br>s102: starting regionserver, logging to /soft/hbase/bin/../logs/hbase-yinzhengjie-regionserver-s102.out<br>s104: Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=128m; support was removed in 8.0<br>s104: Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=128m; support was removed in 8.0<br>s103: Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=128m; support was removed in 8.0<br>s103: Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=128m; support was removed in 8.0<br>s102: Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=128m; support was removed in 8.0<br>s102: Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=128m; support was removed in 8.0<br>[yinzhengjie@s101 ~]$<br></code></pre></td></tr></table></figure><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/795254-20180610151927320-311518054.png" alt="img"></p><h3 id="6-验证"><a href="#6-验证" class="headerlink" title="6.验证"></a>6.验证</h3><p>验证（get，put，还有delete等操作都会在“/home/yinzhengjie/coprocessor.log”文件中记录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">[yinzhengjie@s101 ~]$ hbase shell<br>SLF4J: Class path contains multiple SLF4J bindings.<br>SLF4J: Found binding in [jar:file:/soft/hbase-1.2.6/lib/slf4j-log4j12-1.7.5.jar!/org/slf4j/impl/StaticLoggerBinder.class]<br>SLF4J: Found binding in [jar:file:/soft/hadoop-2.7.3/share/hadoop/common/lib/slf4j-log4j12-1.7.10.jar!/org/slf4j/impl/StaticLoggerBinder.class]<br>SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.<br>SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]<br>HBase Shell; enter &#x27;help&lt;RETURN&gt;&#x27; for list of supported commands.<br>Type &quot;exit&lt;RETURN&gt;&quot; to leave the HBase Shell<br>Version 1.2.6, rUnknown, Mon May 29 02:25:32 CDT 2017<br><br>hbase(main):001:0&gt; list<br>TABLE                                                                                                                              <br>ns1:t1                                                                                                                             <br>yinzhengjie:t1                                                                                                                     <br>2 row(s) in 0.2120 seconds<br><br>=&gt; [&quot;ns1:t1&quot;, &quot;yinzhengjie:t1&quot;]<br>hbase(main):002:0&gt; create &#x27;yinzhengjie:test&#x27;,&#x27;f1&#x27;<br>0 row(s) in 1.3300 seconds<br><br>=&gt; Hbase::Table - yinzhengjie:test<br>hbase(main):003:0&gt; list<br>TABLE                                                                                                                              <br>ns1:t1                                                                                                                             <br>yinzhengjie:t1                                                                                                                     <br>yinzhengjie:test                                                                                                                   <br>3 row(s) in 0.0080 seconds<br><br>=&gt; [&quot;ns1:t1&quot;, &quot;yinzhengjie:t1&quot;, &quot;yinzhengjie:test&quot;]<br>hbase(main):004:0&gt; put &#x27;yinzhengjie:test&#x27;,&#x27;row1&#x27;,&#x27;f1:name&#x27;,&#x27;yinzhengjie&#x27;<br>0 row(s) in 0.1720 seconds<br><br>hbase(main):005:0&gt;<br></code></pre></td></tr></table></figure><p><img src="/2021/10/01/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase/795254-20180610152635758-1275241242.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>HBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL配置遇到的一些问题</title>
    <link href="/2021/09/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/Mysql%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2021/09/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/Mysql%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="ERROR-1055，聚合函数问题"><a href="#ERROR-1055，聚合函数问题" class="headerlink" title="ERROR 1055，聚合函数问题"></a>ERROR 1055，聚合函数问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ERROR <span class="hljs-number">1055</span> (<span class="hljs-number">42000</span>): Expression #<span class="hljs-number">7</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">SELECT</span> list <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> clause <span class="hljs-keyword">and</span> contains nonaggregated <span class="hljs-keyword">column</span> <span class="hljs-string">&#x27;XXX&#x27;</span> which <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> functionally dependent <span class="hljs-keyword">on</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> clause; this <span class="hljs-keyword">is</span> incompatible withsql_mode=only_full_group_by<br></code></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在mysql默认设置中，对于 group by 的这种聚合操作，如果在select 中的列，没有在group by 中出现，那么这个SQL是不合法的，因为列不在group by的从句中，所以对于设置了这个mode的数据库，在使用group by 的时候，就要用MAX()，SUM()，AVG()的这种聚合函数，才能完成GROUP BY 的聚合操作。</p><p>主要由<strong>sql_mode</strong>设置决定</p><p>sql_mode是个很容易被忽视的变量，默认值是空值，在这种设置下是可以允许一些非法操作的，比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式，所以开发、测试环境的数据库也必须要设置，这样在开发测试阶段就可以发现问题 </p><p><strong>sql_mode常用值如下:</strong> </p><ul><li>ONLY_FULL_GROUP_BY：</li></ul><p>对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中 </p><ul><li>NO_AUTO_VALUE_ON_ZERO：</li></ul><p>该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。</p><ul><li>STRICT_TRANS_TABLES：</li></ul><p>在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制</p><ul><li>NO_ZERO_IN_DATE：</li></ul><p>在严格模式下，不允许日期和月份为零 </p><ul><li>NO_ZERO_DATE：</li></ul><p>设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</p><ul><li>ERROR_FOR_DIVISION_BY_ZERO：</li></ul><p>在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL </p><ul><li>NO_AUTO_CREATE_USER：</li></ul><p>禁止GRANT创建密码为空的用户</p><ul><li>NO_ENGINE_SUBSTITUTION：</li></ul><p>如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</p><ul><li>PIPES_AS_CONCAT：</li></ul><p>将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似</p><ul><li>ANSI_QUOTES：</li></ul><p>启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法主要分为三种：在当前会话有效、到MySQL重启前有效、永久有效</p><h3 id="在当前会话有效"><a href="#在当前会话有效" class="headerlink" title="在当前会话有效"></a>在当前会话有效</h3><ul><li>进入命令行界面</li></ul><p>输入：<code>SELECT @@sql_mode; </code></p><p>注意：这边缺省了session,完整的是：<code>SELECT @@SESSION.sql_mode;</code></p><p>结果：ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</p><ul><li>然后修改sql_mode</li></ul><p>输入：<code>set SESSION sql_mode =&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION &#39;;</code></p><p>以后再新建查询（包含group by）语句也不用再加set sql_mode 直到你关闭这次连接为止</p><blockquote><p>SESSION是当前会话的意思—-&gt;这句话就解释了直到你关闭这次连接为止</p><p>在新建查询中输入<code>SELECT @@sql_mode;</code>你会发现你在命令行中的设置并没有生效，因为是新建的查询是新的会话</p></blockquote><h3 id="到MySQL重启前有效"><a href="#到MySQL重启前有效" class="headerlink" title="到MySQL重启前有效"></a>到MySQL重启前有效</h3><ul><li>进入命令行界面</li></ul><p>输入：<code>SELECT @@GLOBAL.sql_mode;</code></p><p>结果：ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</p><ul><li>然后修改sql_mode</li></ul><p><code>set GLOBAL sql_mode = &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION &#39;;</code></p><p>改完了要在新打开的查寻窗口才有用，原来的没有效果的。</p><p>再运行sql，group by就可以使用了，但是这个方法不治本 ，当重启mysql后，依然使用不了group by</p><h3 id="永久有效"><a href="#永久有效" class="headerlink" title="永久有效"></a>永久有效</h3><p>mysql的配置文件扩展名在不同版本下后缀名不同：</p><ul><li><p>mac下：my.cnf </p></li><li><p>windows下：my.ini</p></li></ul><h4 id="1-MAC下默认没有配置文件，需要自己创建"><a href="#1-MAC下默认没有配置文件，需要自己创建" class="headerlink" title="1. MAC下默认没有配置文件，需要自己创建"></a>1. MAC下默认没有配置文件，需要自己创建</h4><p>首先，进入到 /etc文件夹下，输入</p><blockquote><p>cd /etc</p></blockquote><p>然后在 /etc 新建 my.cnf 文件</p><blockquote><p>sudo vim my.cnf</p></blockquote><h4 id="2-将如下配置内容写入到文件中"><a href="#2-将如下配置内容写入到文件中" class="headerlink" title="2. 将如下配置内容写入到文件中"></a>2. 将如下配置内容写入到文件中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Example MySQL config file <span class="hljs-keyword">for</span> medium systems.</span>  <br><span class="hljs-meta">  #</span><span class="bash"> </span> <br><span class="hljs-meta">  #</span><span class="bash"> This is <span class="hljs-keyword">for</span> a system with little memory (32M - 64M) <span class="hljs-built_in">where</span> MySQL plays</span>  <br><span class="hljs-meta">  #</span><span class="bash"> an important part, or systems up to 128M <span class="hljs-built_in">where</span> MySQL is used together with</span>  <br><span class="hljs-meta">  #</span><span class="bash"> other programs (such as a web server)</span>  <br><span class="hljs-meta">  #</span><span class="bash"> </span> <br><span class="hljs-meta">  #</span><span class="bash"> MySQL programs look <span class="hljs-keyword">for</span> option files <span class="hljs-keyword">in</span> a <span class="hljs-built_in">set</span> of</span>  <br><span class="hljs-meta">  #</span><span class="bash"> locations <span class="hljs-built_in">which</span> depend on the deployment platform.</span>  <br><span class="hljs-meta">  #</span><span class="bash"> You can copy this option file to one of those</span>  <br><span class="hljs-meta">  #</span><span class="bash"> locations. For information about these locations, see:</span>  <br><span class="hljs-meta">  #</span><span class="bash"> http://dev.mysql.com/doc/mysql/en/option-files.html</span>  <br><span class="hljs-meta">  #</span><span class="bash"> </span> <br><span class="hljs-meta">  #</span><span class="bash"> In this file, you can use all long options that a program supports.</span>  <br><span class="hljs-meta">  #</span><span class="bash"> If you want to know <span class="hljs-built_in">which</span> options a program supports, run the program</span>  <br><span class="hljs-meta">  #</span><span class="bash"> with the <span class="hljs-string">&quot;--help&quot;</span> option.</span>  <br><span class="hljs-meta">  #</span><span class="bash"> The following options will be passed to all MySQL clients</span>  <br>  [client]<br>  default-character-set=utf8<br><span class="hljs-meta">  #</span><span class="bash">password   = your_password</span>  <br>  port        = 3306  <br>  socket      = /tmp/mysql.sock   <br><span class="hljs-meta">  #</span><span class="bash"> Here follows entries <span class="hljs-keyword">for</span> some specific programs</span>  <br><span class="hljs-meta">  #</span><span class="bash"> The MySQL server</span>  <br>  [mysqld]<br>  character-set-server=utf8<br>  init_connect=&#x27;SET NAMES utf8<br>  port        = 3306  <br>  socket      = /tmp/mysql.sock  <br>  skip-external-locking  <br>  key_buffer_size = 16M  <br>  max_allowed_packet = 1M  <br>  table_open_cache = 64  <br>  sort_buffer_size = 512K  <br>  net_buffer_length = 8K  <br>  read_buffer_size = 256K  <br>  read_rnd_buffer_size = 512K  <br>  myisam_sort_buffer_size = 8M  <br>  character-set-server=utf8  <br>  init_connect=&#x27;SET NAMES utf8&#x27;<br>  sql_mode=&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#x27;<br><span class="hljs-meta"> </span><br><span class="hljs-meta">#</span><span class="bash"> Don<span class="hljs-string">&#x27;t listen on a TCP/IP port at all. This can be a security enhancement,</span></span>  <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-string"> if all processes that need to connect to mysqld run on the same host.</span></span>  <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-string"> All interaction with mysqld must be made via Unix sockets or named pipes.</span></span>  <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-string"> Note that using this option without enabling named pipes on Windows</span></span>  <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-string"> (via the &quot;enable-named-pipe&quot; option) will render mysqld useless!</span></span>  <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-string"> </span></span>  <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-string">skip-networking</span></span>  <br><span class="hljs-meta">  #</span><span class="bash"><span class="hljs-string"> Replication Master Server (default)</span></span>  <br><span class="hljs-meta">  #</span><span class="bash"><span class="hljs-string"> binary logging is required for replication</span></span>  <br>  log-bin=mysql-bin  <br>    # binary logging format - mixed recommended  <br>    binlog_format=mixed  <br>      # required unique id between 1 and 2^32 - 1  <br>      # defaults to 1 if master-host is not set  <br>      # but will not function as a master if omitted  <br>      server-id   = 1  <br>    # Replication Slave (comment out master section to use this)  <br>    #  <br>    # To configure this host as a replication slave, you can choose between  <br>    # two methods :  <br>    #  <br>    # 1) Use the CHANGE MASTER TO command (fully described in our manual) -  <br>    #    the syntax is:  <br>    #  <br>    #    CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;,  <br>    #    MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ;  <br>    #  <br>    #    where you replace &lt;host&gt;, &lt;user&gt;, &lt;password&gt; by quoted strings and  <br>    #    &lt;port&gt; by the master&#x27;s port number (3306 by default).  <br>    #  <br>    #    Example:  <br>    #  <br>    #    CHANGE MASTER TO MASTER_HOST=&#x27;125.564.12.1&#x27;, MASTER_PORT=3306,  <br>    #    MASTER_USER=&#x27;joe&#x27;, MASTER_PASSWORD=&#x27;secret&#x27;;  <br>    #  <br>    # OR  <br>    #  <br>    # 2) Set the variables below. However, in case you choose this method, then  <br>    #    start replication for the first time (even unsuccessfully, for example  <br>    #    if you mistyped the password in master-password and the slave fails to  <br>    #    connect), the slave will create a master.info file, and any later  <br>    #    change in this file to the variables&#x27; values below will be ignored and  <br>    #    overridden by the content of the master.info file, unless you shutdown  <br>    #    the slave server, delete master.info and restart the slaver server.  <br>    #    For that reason, you may want to leave the lines below untouched  <br>    #    (commented) and instead use CHANGE MASTER TO (see above)  <br>    #  <br>    # required unique id between 2 and 2^32 - 1  <br>    # (and different from the master)  <br>    # defaults to 2 if master-host is set  <br>    # but will not function as a slave if omitted  <br>    #server-id       = 2  <br>    #  <br>    # The replication master for this slave - required  <br>    #master-host     =   &lt;hostname&gt;  <br>    #  <br>    # The username the slave will use for authentication when connecting  <br>    # to the master - required  <br>    #master-user     =   &lt;username&gt;  <br>    #  <br>    # The password the slave will authenticate with when connecting to  <br>    # the master - required  <br>    #master-password =   &lt;password&gt;  <br>    #  <br>    # The port the master is listening on.  <br>    # optional - defaults to 3306  <br>    #master-port     =  &lt;port&gt;  <br>    #  <br>    # binary logging - not required for slaves, but recommended  <br>    #log-bin=mysql-bin  <br>      # Uncomment the following if you are using InnoDB tables  <br>      #innodb_data_home_dir = /usr/local/mysql/data  <br>      #innodb_data_file_path = ibdata1:10M:autoextend  <br>      #innodb_log_group_home_dir = /usr/local/mysql/data  <br>      # You can set .._buffer_pool_size up to 50 - 80 %  <br>      # of RAM but beware of setting memory usage too high  <br>      #innodb_buffer_pool_size = 16M  <br>      #innodb_additional_mem_pool_size = 2M  <br>      # Set .._log_file_size to 25 % of buffer pool size  <br>      #innodb_log_file_size = 5M  <br>      #innodb_log_buffer_size = 8M  <br>      #innodb_flush_log_at_trx_commit = 1  <br>      #innodb_lock_wait_timeout = 50  <br> <br>        [mysqldump]  <br>        quick  <br>        max_allowed_packet = 16M  <br> <br>          [mysql]  <br>          no-auto-rehash  <br>          # Remove the next comment character if you are not familiar with SQL  <br>          #safe-updates  <br>          default-character-set=utf8   <br> <br>        [myisamchk]  <br>        key_buffer_size = 20M  <br>        sort_buffer_size = 20M  <br>        read_buffer = 2M  <br>        write_buffer = 2M  <br> <br>          [mysqlhotcopy]  <br>          interactive-timeout<br><br><br></code></pre></td></tr></table></figure><h4 id="3-保存my-cnf文件"><a href="#3-保存my-cnf文件" class="headerlink" title="3. 保存my.cnf文件"></a>3. 保存my.cnf文件</h4><blockquote><p>:wq!</p></blockquote><h4 id="4-修改my-cnf的文件权限"><a href="#4-修改my-cnf的文件权限" class="headerlink" title="4. 修改my.cnf的文件权限"></a>4. 修改my.cnf的文件权限</h4><blockquote><p>sudo chmod 664 /etc/my.cnf</p></blockquote><h4 id="5-填写路径"><a href="#5-填写路径" class="headerlink" title="5. 填写路径"></a>5. 填写路径</h4><p><img src="/2021/09/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/Mysql%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/image-20210923143307830.png" alt="image-20210923143307830"></p><h4 id="6-重启mysql后，配置文件就可以生效了"><a href="#6-重启mysql后，配置文件就可以生效了" class="headerlink" title="6. 重启mysql后，配置文件就可以生效了"></a>6. 重启mysql后，配置文件就可以生效了</h4><hr><p><strong>注意</strong></p><blockquote><p>mysql 8 已经取消了”NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION”</p><p>两个参数，因此在mysql8 中不能加入这两个参数属性。</p></blockquote><h1 id="mysql自动将datetime类型的毫秒数四舍五入问题"><a href="#mysql自动将datetime类型的毫秒数四舍五入问题" class="headerlink" title="mysql自动将datetime类型的毫秒数四舍五入问题"></a>mysql自动将datetime类型的毫秒数四舍五入问题</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近在写项目时，遇到一个问题。持久层框架使用的是mybatis-plus，数据库中参数类型是datetime，自动生成的实体类中Java的类型是Date，当写入时，产生如下SQL</p><p><img src="/2021/09/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/Mysql%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/image-20211215162712241.png" alt="image-20211215162712241"></p><p>如图所示，修改日期的时间后三位为毫秒值，存到数据库中就变成了2021-12-15 16:21:07(<strong>四舍五入，此处是舍</strong>)</p><h2 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h2><p>查看MySQL 5.6 manual发现，5.6.4及以上版本的mysql server端确实支持fractional second part(fsp)，但如果client提交过来的小数位数超过server端建表时指定的小数位数，mysql server会自动进行四舍五入的截断，没有任何警告或异常。</p><p><img src="/2021/09/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/Mysql%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbGNvbWVfemhhbmc=,size_16,color_FFFFFF,t_70.png" alt="img"></p><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><p>因此如果需要精确到具体秒，需要在Java中提前进行处理，如将Date类型先转换成<code>yyyy-MM-dd HH:mm:ss</code>去掉毫秒值后，再转回Date类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">method</span><span class="hljs-params">(Date date)</span> </span>&#123;<br>    SimpleDateFormat simpleDateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    String formatDate = simpleDateFormat.format(date)<br>    Date parseDate = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        parseDate = simpleDateFormat.parse(formatDate);<br>    &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> parseDate;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
      <category>MySql配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、网络层次划分"><a href="#一、网络层次划分" class="headerlink" title="一、网络层次划分"></a>一、网络层次划分</h1><p>计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。因为不同用户的数据终端可能采取的字符集是不同的，两者需要进行通信，必须要在一定的标准上进行。</p><h2 id="1-1-OSI七层网络模型"><a href="#1-1-OSI七层网络模型" class="headerlink" title="1.1 OSI七层网络模型"></a>1.1 OSI七层网络模型</h2><p>为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了”开放系统互联参考模型”，即著名的<strong>OSI/RM模型</strong>（Open System Interconnection/Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：<strong>物理层</strong>（Physics Layer）、<strong>数据链路层</strong>（Data Link Layer）、<strong>网络层</strong>（Network Layer）、<strong>传输层</strong>（Transport Layer）、<strong>会话层</strong>（Session Layer）、<strong>表示层</strong>（Presentation Layer）、<strong>应用层</strong>（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。</p><p>除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示：</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210906204949954.png" alt="image-20210906204949954"></p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210906205034400.png" alt="image-20210906205034400"></p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210906205627924.png" alt="image-20210906205627924"></p><hr><h1 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><strong>物理层（Physical Layer）</strong>：激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。<strong>该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。</strong></p><ul><li><p>物理层的任务：<strong>透明地传输比特流</strong>。</p></li><li><p>物理层的功能：<strong>为数据段设备提供传送数据通路</strong></p></li><li><p>物理层传输单位：<strong>比特</strong></p></li><li><p>物理层实现的硬件：<strong>集线器</strong>，<strong>中继器</strong>（Repeater，也叫放大器）</p></li></ul><hr><h1 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p><strong>数据链路层（Data Link Layer）</strong>：在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到<strong>相邻节点的目标机网络层</strong>。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），<strong>帧是数据链路层的传送单位</strong>；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。</p><ul><li><p>数据链路层的任务：<strong>将网络层传输下来的IP数据报组装成帧</strong>、<strong>物理地址寻址、流量控制、数据的检错、重发</strong>等</p></li><li><p>数据链路层的功能：</p><ul><li><strong>链路连接的建立、拆除和分离</strong></li><li><strong>帧定界和帧同步</strong></li><li><strong>差错检测</strong></li></ul></li><li><p>物理层传输单位：<strong>帧</strong></p></li><li><p>数据链路层实现的硬件：<strong>交换机</strong>、<strong>网桥</strong></p></li><li><p>协议：PPP,HDLC、SDLC、STP、ARQ</p></li></ul><hr><h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p><strong>网络层（Network Layer）</strong>：目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果想用尽量少的词来记住网络层，那就是**”路径选择、路由及逻辑寻址”**。</p><p>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。</p><ul><li>网络层的任务：<ul><li>将传输层传下来的报文段<strong>封装成分组</strong></li><li><strong>选择合适的路由</strong>，使得传输层传下来的分组能够交付到目的主机</li></ul></li><li>网络层的功能：<ul><li>为传输层提供服务</li><li>组包和拆包</li><li>路由选择</li><li>拥塞控制</li></ul></li><li>网络层传输单位：<strong>数据段</strong></li><li>网络层实现的硬件：<strong>路由器</strong></li><li>协议：ICMP、ARP、RARP、IP、IGMP、OSPF</li></ul><h2 id="4-2-IP协议"><a href="#4-2-IP协议" class="headerlink" title="4.2 IP协议"></a>4.2 IP协议</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><p>每个IP地址都包含两部分：<strong>网络ID</strong>和<strong>主机ID</strong>，网络ID标识在同一个物理网络上的所有宿主机，主机ID标识网络上的每一个宿主机，运行TCP/IP的每个计算机都需要唯一的IP地址。</p><p><strong>IPV4</strong></p><p>IPV4有一个<strong>32</strong>位的连接地址，由4个8位字段组成，8位字段称为8位位组，每个8位位组之间用点号隔开，用于标识TCP/IP宿主机。</p><p><strong>IPV6</strong></p><p>IPv6的地址长度为<strong>128位</strong>，是IPv4地址长度的4倍，采用十六进制表示。IPv6有3种表示方法。</p><p>主要使用<strong>冒分十六进制</strong>表示法</p><p>格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示，例如：</p><p>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</p><h4 id="IPV4和IPV6的区别"><a href="#IPV4和IPV6的区别" class="headerlink" title="IPV4和IPV6的区别"></a>IPV4和IPV6的区别</h4><p> IPv4和IPv6是是目前使用的两种Internet协议版本，IPv4和IPv6协议之间存在各种差异，包括它们的功能，但关键的一点是它生成的地址（地址空间）的数量的区别。</p><ol><li><p>协议地址的区别</p><p>（1）地址长度</p><p> IPv4协议具有32位（4字节）地址长度；IPv6协议具有128位（16字节）地址长度。</p><p>（2）地址的表示方法</p><p> IPv4地址是以小数表示的二进制数。 IPv6地址是以十六进制表示的二进制数。</p><p>（3）地址配置</p><p> IPv4协议的地址可以通过手动或DHCP配置的。</p><p> IPv4协议需要使用Internet控制消息协议版本6（ICMPv6）或DHCPv6的无状态地址自动配置（SLAAC）。</p></li><li><p>数据包的区别</p><p>（1）包的大小</p><p> IPv4协议的数据包需要576个字节，碎片可选 ；IPv6协议的数据包需要1280个字节，不会碎片。</p><p>（2）包头</p><p> IPv4协议的包头的长度为20个字节，不识别用于QoS处理的数据包流，包含checksum，包含最多40个字节的选项字段。</p><p> IPv6协议的包头的长度为40个字节，包含指定QoS处理的数据包流的Flow Label字段，不包含checksum；IPv6协议没有字段，但IPv6扩展标头可用。</p><p>（3）数据包碎片</p><p>IPv4协议的数据包碎片会由转发路由器和发送主机完成。IPv6协议的数据包碎片仅由发送主机完成。</p></li><li><p>DNS记录</p><p>IPv4协议的地址（A）记录，映射主机名；指针（PTR）记录，IN-ADDR.ARPA DNS域。</p><p>IPv6协议的地址（AAAA）记录，映射主机名；指针（PTR）记录，IP6.ARPA DNS域</p></li><li><p>IPSec支持</p><p>IPv4协议的IPSec支持只是可选的；IPv6协议有内置的IPSec支持。</p></li><li><p>地址解析协议</p><p>IPv4协议：地址解析协议（ARP）可用于将IPv4地址映射到MAC地址。</p><p>IPv6协议：地址解析协议（ARP）被邻居发现协议（NDP）的功能所取代。</p></li><li><p>身份验证和加密</p><p>Pv6提供身份验证和加密；但IPv4不提供。</p></li></ol><h4 id="IP分类"><a href="#IP分类" class="headerlink" title="IP分类"></a>IP分类</h4><p>Intenet委员会定义了五种地址类型以适应不同尺寸的网络。地址类型定义网络ID使用哪些位,它也定义了网络的可能数目和每个网络可能的宿主机数目．</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210906221555685.png" alt="image-20210906221555685"></p><p> IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。 全0和全1的都保留不用。</p><ul><li><p>A类：(0.0.0.0-127.255.255.255)（默认子网掩码：255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。</p></li><li><p>B类：(128.0.0.0-191.255.255.255)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。</p></li><li><p>C类：(192.0.0.0-223.255.255.255)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。</p></li><li><p>D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户 。</p></li><li><p>E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。</p></li></ul><p>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><blockquote><p>255.255.255.255</p><p>该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p><p>注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p></blockquote><blockquote><p>0.0.0.0</p><p>常用于寻找自己的IP地址，例如在RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p></blockquote><blockquote><p>回环地址</p><p>127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p></blockquote><blockquote><p>A、B、C类私有地址</p><p>私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><p>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</p><p>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p><p>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p></blockquote><h4 id="IP为什么要分类"><a href="#IP为什么要分类" class="headerlink" title="IP为什么要分类"></a>IP为什么要分类</h4><p>根据IP地址访问终端是通过路由器，路由设备当中有一张路由表，该路由表记录了所有IP地址的位置，这样就可以进行包的转发了，如果我们不区分网络地址，那么这张路由表当中就要保存有所有IP地址的方向，这张路由表就会很大，就像下面说的那样：如果不分网络位和主机位，路由器的路由表就是都是32位的地址，那所有的路由器维护的路由表会很大，转发速度会变慢（因为查询变慢）。而且所有的路由器都要有全Internet的地址，所有人的路由器都要有足够的性能来存下全网地址。估计建造这样的Internet成本是现在的几万倍，甚至更高。</p><p> <strong>有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护这个网络地址的方向，就可以找到相应的终端了。</strong></p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。</p><p>这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p><p>使用子网可以把单个大网分成多个物理网络，并用路由器把它们连接起来。</p><p>子网掩码(Subnet Mask)用于<strong>屏蔽IP地址的一部分，使得TCP/IP能够区别网络ID和宿主机ID</strong>。当TCP/IP宿主机要通信时,子网掩码用于判断一个宿主机是在本地网络还是在远程网络。</p><p>缺省的子网掩码用于不分成子网的TCP/IP网络，对应于网络ID的所有位都置为1，每个8位位组的十进制数是255，对应于宿主机ID的所有位都置为0。</p><p>用于子网掩码的位数决定可能的子网数目和每个子网的宿主机数目，子网掩码的位数越多，则子网越多，但是宿主机也较少。</p><p>例：假设A类地址子网数是14，则所需位数至少为4，用于子网的位为：11111111, 11110000, 00000000, 00000000, 子网掩码为255.240.0.0,每个子网的宿主机数目为2^20-2=1,048, 574个。</p><h4 id="有关子网掩码和网络划分常见的面试考题"><a href="#有关子网掩码和网络划分常见的面试考题" class="headerlink" title="有关子网掩码和网络划分常见的面试考题"></a>有关子网掩码和网络划分常见的面试考题</h4><h5 id="利用子网数来计算"><a href="#利用子网数来计算" class="headerlink" title="利用子网数来计算"></a>利用子网数来计算</h5><p>在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。</p><p>(1) 将子网数目转化为二进制来表示;</p><p>如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；</p><p>(2) 取得该二进制的位数，为N；</p><p>该二进制为五位数，N = 5</p><p>(3) 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码。</p><p>将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0</p><h5 id="利用主机数来计算"><a href="#利用主机数来计算" class="headerlink" title="利用主机数来计算"></a>利用主机数来计算</h5><p>如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：</p><p>(1) 将主机数目转化为二进制来表示<code>700=1010111100</code>；</p><p>(2) 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位；该二进制为十位数，N=10；</p><p>(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。</p><p>将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。</p><h5 id="根据每个网络的主机数量进行子网地址的规划计算子网掩码"><a href="#根据每个网络的主机数量进行子网地址的规划计算子网掩码" class="headerlink" title="根据每个网络的主机数量进行子网地址的规划计算子网掩码"></a>根据每个网络的主机数量进行子网地址的规划计算子网掩码</h5><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：<code>10＋1＋1＋1＝13</code></p><p><strong>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。</strong></p><p>因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。</p><p>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p><h2 id="4-3-ARP-RARP协议"><a href="#4-3-ARP-RARP协议" class="headerlink" title="4.3 ARP/RARP协议"></a><span id="arp">4.3 ARP/RARP协议</span></h2><p><strong>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。</strong>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。<strong>ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</strong></p><p>ARP工作流程举例：</p><p>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；</p><p>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p><p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><p>（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</p><p>（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</p><p>（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p><p>（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</p><p>（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p><p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong></p><p>比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p><p>RARP协议工作流程：</p><p>（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</p><p>（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</p><p>（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</p><p>（4）如果不存在，RARP服务器对此不做任何的响应；</p><h2 id="4-4-路由选择协议"><a href="#4-4-路由选择协议" class="headerlink" title="4.4 路由选择协议"></a>4.4 路由选择协议</h2><p>常见的路由选择协议有：RIP协议、OSPF协议。</p><p><strong>RIP协议</strong> ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p><p><strong>OSPF协议</strong> ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p><hr><h1 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><strong>传输层（Transport Layer）</strong>：负责将上层数据分段并提供<strong>端到端</strong>的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或<strong>报文</strong>。 <strong>网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。</strong></p><p>传输层的作用包括：<strong>将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题</strong>等。</p><p>传输层重要的设备名称：<strong>网关</strong></p><ul><li>传输层的任务：<strong>负责主机中两个进程（端到端）之间的通信</strong></li><li>传输层的功能：<ul><li>为端到端连接提供可靠的服务</li><li>为端到端连接提供流量控制、差错控制、服务质量等管理服务</li></ul></li><li>传输层传输单位：<strong>报文段</strong>（TCP）或<strong>用户数据报</strong>（UDP）</li><li>传输层实现的硬件：<strong>网关</strong></li><li>协议：TCP、UDP</li></ul><h2 id="5-2-TCP协议"><a href="#5-2-TCP协议" class="headerlink" title="5.2 TCP协议"></a><span id="tcp">5.2 TCP协议</span></h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>TCP协议全称: <strong>传输控制协议</strong></p><p>TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于<strong>端到端</strong>的通讯。TCP提供的是一种可靠的数据流服务，采用”带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为”滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p><p>报头如下，首部大小固定20字节</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210907161940230.png" alt="image-20210907161940230"></p><ul><li>源端口号/目的端口号: 表示数据从哪个进程来, 到哪个进程去.</li><li>32位序号:</li><li>4位首部长度: 标识该TCP头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。</li><li>6位保留: 顾名思义, 先保留着, 以防万一</li><li>6位标志位</li><li>URG: 标识紧急指针是否有效<ul><li>ACK: 标识确认序号是否有效，我们称携带ACK标识的TCP报文段为<strong>确认报文</strong>段。</li><li>PSH: 用来提示接收端应用程序立刻将数据从tcp缓冲区读走，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中</li><li>RST: 要求重新建立连接。我们把含有RST标识的报文称为<strong>复位报文</strong>段</li><li>SYN: 请求建立连接。我们把含有SYN标识的报文称为<strong>同步报文</strong>段</li><li>FIN: 通知对端，本端即将关闭.。我们把含有FIN标识的报文称为<strong>结束报文</strong>段</li></ul></li><li>16位窗口大小：是TCP<strong>流量控制</strong>的一个手段。这里说的窗口，指的是<strong>接收通道窗口</strong>（Receiver Window，RWND）。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li><li>16位检验和: 由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。</li><li>16位紧急指针:是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。</li><li>选项和数据暂时忽略</li></ul><h3 id="TCP如何保证传输可靠性"><a href="#TCP如何保证传输可靠性" class="headerlink" title="TCP如何保证传输可靠性"></a>TCP如何保证传输可靠性</h3><h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><pre><code>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </code></pre><p>计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。 </p><ul><li><p>发送方：在发送数据之前计算检验和，并进行校验和的填充。 </p></li><li><p>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p></li></ul><p> 注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210907162918376.png" alt="image-20210907162918376"></p><h4 id="确认应答-序列号"><a href="#确认应答-序列号" class="headerlink" title="确认应答+序列号"></a>确认应答+序列号</h4><pre><code>应用数据被分割成 TCP 认为最适合发送的数据块。TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。TCP 的接收端会丢弃重复的数据。</code></pre><ul><li><p>序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。 </p></li><li><p>确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p></li></ul><p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210907165231469.png" alt="image-20210907165231469"></p><h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><pre><code>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </code></pre><p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？而没有收到ACK报文的原因可能是什么呢？</p><p>首先，发送方没有接收到响应的ACK报文原因可能有两点：</p><ul><li><p>数据在传输过程中由于网络原因等直接全体丢包，接收方没有接收到。</p></li><li><p>接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。</p></li></ul><p>TCP在解决这个问题的时候引入了一个新的机制，叫做<strong>超时重传机制</strong>。简单理解就是发送方在发送完数据后等待一个时间（里面有一个超时计数器），时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。</p><h5 id="一般报文超时是怎么确定的？"><a href="#一般报文超时是怎么确定的？" class="headerlink" title="一般报文超时是怎么确定的？"></a>一般报文超时是怎么确定的？</h5><p>一刀切的办法就是，我<strong>直接把超时时间设成一个固定值</strong>，比如说 200ms，但这样肯定是有问题的，我们的电脑和很多服务器都有交互，这些服务器位于天南海北，国内国外，延迟差异巨大，所以设置固定值是很不可靠的，<strong>我们要根据网络延迟，动态调整超时时间</strong>，延迟越大，超时时间越长。</p><p>在这里先引入两个概念：</p><ul><li>RTT（Round Trip Time）：往返时延，也就是<strong>数据包从发出去到收到对应 ACK 的时间。</strong>RTT 是针对连接的，每一个连接都有各自独立的 RTT。</li><li>RTO（Retransmission Time Out）：重传超时，也就是前面说的超时时间。</li></ul><p>jacobson算法：</p><p>工作原理是：</p><ol><li><p>将每条连接TCP都保持一个变量RTT。</p></li><li><p>当发送一个数据段时，同时启动连接的定时器。</p></li><li><p>如果定时器超时前确认到达，则记录所需的时间。</p></li><li><p>修正RTT的值。</p></li><li><p>如果定时器超时前没有收到确认，则将RTT的值增加一倍。</p></li></ol><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410175136539.png" alt="image-20210410175136539"></p><p>发送一个报文段，设定的重传时间到了，还没有收到确认。于是重传报文段，经过一段时间后：收到了确认报文段。</p><p>现在的问题是：如何判定此报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认？由于重传的报文段和原来的报文段完全一样，所以源主机在接受到确认后，无法做出正确的判断，而正确的判断对确定加权平均RTTs的值关系很大。因此产生了Karn算法，只要报文段重传了，就不采用其往返时间样本</p><p>Karn算法：</p><ol><li><p>报文段每重传一次，就将重传时间增大一些：</p></li><li><p>新的重传时间 = γ×(旧的重传时间)</p></li><li><p>系数 γ 的典型值是2 。</p></li><li><p>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和重传时间的数值。</p></li></ol><p>实践证明，这种策略较为合理。</p><h5 id="SYN报文重传间隔时间"><a href="#SYN报文重传间隔时间" class="headerlink" title="SYN报文重传间隔时间"></a>SYN报文重传间隔时间</h5><p>在实际情况下，由于SYN报文是TCP连接的第一个报文，如果该报文在传输的过程中丢弃了，那么发送方则无法测量RTT，也就无法根据RTT来计算RTO。因此，SYN重传的算法就要简单一些，SYN重传时间间隔一般根据系统实现的不同稍有差别，windows系统一般将第一次重传超时设为3秒，以后每次超时重传时间为上一次的2倍</p><h5 id="重传次数"><a href="#重传次数" class="headerlink" title="重传次数"></a>重传次数</h5><p>在三次握手时，重传次数时可以确定的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">net.ipv4.tcp_syn_retries = 6        //for client, 用于在syn发送阶段<br>net.ipv4.tcp_synack_retries = 5     //for server, 用于在yn-ack发送阶段<br></code></pre></td></tr></table></figure><h5 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h5><p>当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层的错误纠正协议之一。它包括停止等待ARQ协议和连续ARQ协议，错误侦测（Error Detection）、正面确认（Positive Acknowledgment）、逾时重传（Retransmission after Timeout）与负面确认继以重传（Negative Acknowledgment and Retransmission）等机制。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><pre><code>TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP利用滑动窗口实现流量控制）</code></pre><p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传什么的。而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。</p><p>在TCP协议的报头信息当中，有一个16位字段的窗口大小。在介绍这个窗口大小时我们知道，<strong>窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小</strong>。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。 </p><p> 注：16位的窗口大小最大能表示65535个字节（64K），但是TCP的窗口大小最大并不是64K。在TCP首部中40个字节的选项中还包含了一个窗口扩大因子M，实际的窗口大小就是16为窗口字段的值左移M位。每移一位，扩大两倍。</p><p> <img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210406215601482.png" alt="image-20210406215601482"></p><h5 id="可变滑动窗口"><a href="#可变滑动窗口" class="headerlink" title="可变滑动窗口"></a>可变滑动窗口</h5><p><a href="https://blog.csdn.net/yao5hed/article/details/81046945">https://blog.csdn.net/yao5hed/article/details/81046945</a></p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410181120147.png" alt="image-20210410181120147"></p><h5 id="流量控制引发的死锁？怎么避免死锁的发生？"><a href="#流量控制引发的死锁？怎么避免死锁的发生？" class="headerlink" title="流量控制引发的死锁？怎么避免死锁的发生？"></a>流量控制引发的死锁？怎么避免死锁的发生？</h5><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。</p><p>为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><pre><code>当网络拥塞时，减少数据的发送。发送方有拥塞窗口，发送数据前比对接收方发过来的接收窗口，取小慢启动、拥塞避免、拥塞发送、快速恢复应用数据被分割成TCP认为最适合发送的数据块。TCP的接收端会丢弃重复的数据。 </code></pre><p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p><pre><code>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</code></pre><h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>所以TCP引入了<strong>慢启动</strong>的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，<strong>首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。</strong></p><ul><li>算法流程<ul><li>连接建好的开始先初始化cwnd = 1(窗口)，表明可以传一个<strong>MSS</strong>（最大报文段长度）大小的数据</li><li>每当收到一个<strong>ACK</strong>，cwnd++，线性上升</li><li>每当过了一个<strong>RTT</strong>，cwnd = cwnd*2， 呈指数上升。</li><li>ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”</li></ul></li></ul><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410194920966.png" alt="image-20210410194920966"></p><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设<strong>置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长</strong>。</p><ul><li>一般来说ssthresh的值是65535字节(2的16次方)，当cwnd达到这个值时后</li><li>算法流程<ul><li>收到一个ACK时，cwnd = cwnd + 1/cwnd</li><li>每过一个RTT时，cwnd = cwnd + 1</li></ul></li></ul><h5 id="阻塞发生"><a href="#阻塞发生" class="headerlink" title="阻塞发生"></a>阻塞发生</h5><p>一旦出现网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。 </p><p>当丢包的时候，有两种情况</p><ul><li>等到RTO超时，重传数据包，TCP认为该情况太糟糕了<ul><li>sshthreash = swnd / 2</li><li>cwnd 重置为1</li><li>进入<strong>慢启动算法</strong></li></ul></li></ul><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210406221637813.png" alt="image-20210406221637813"></p><ul><li>快速重传算法，即收到3个重复的ACK就开始重传，无需等待RTO超时<ul><li>TCP Tahoe（代表版本）的实现和RTO超时一样。</li><li>TCP Reno的实现：<ul><li>cwnd = cwnd / 2</li><li>sshthresh = cwnd</li><li>进入<strong>快速恢复算法</strong>——Fast Recovery</li></ul></li></ul></li></ul><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410200127345.png" alt="image-20210410200127345"></p><p>拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。</p><h5 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h5><p><strong>快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认</strong>。</p><p>接收方成功的接受了发送方发送来的M1、M2并且分别给发送了ACK，现在接收方没有收到M3，而接收到了M4，显然接收方不能确认M4，因为M4是失序的报文段。如果根据可靠性传输原理接收方什么都不做，但是按照快速重传算法，在收到M4、M5等报文段的时候，不断重复的向发送方发送M2的ACK，如果接收方一连收到三个重复的ACK，那么发送方不必等待重传计时器到期，由发送方尽早重传未被确认的报文段。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410201904592.png" alt="image-20210410201904592"></p><p>与快重传配合使用的还有<strong>快恢复</strong>算法，其过程有以下两个要点：</p><ul><li><p>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p></li><li><p>由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p></li></ul><blockquote><p>也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p></blockquote><blockquote><h2 id="流量控制和阻塞控制的区别"><a href="#流量控制和阻塞控制的区别" class="headerlink" title="流量控制和阻塞控制的区别"></a>流量控制和阻塞控制的区别</h2><ul><li>流量控制：流量控制是控制<strong>端到端的速率</strong>，作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</li><li>拥塞控制：拥塞控制是控制<strong>全局网络的速率</strong>，作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。</li></ul><p>流量，而拥塞控制。<br>举个例子，<br>1.宽带速率1Gb/s，网络只有两台机器，从一台主机传送数据到另一台，这需要流量控制，以保证接收方能正常接收数据。<br>2.宽带速率1Gb/s，网络中有成千上万台机器，几万台主机发送到另外几万台，这需要拥塞控制，不然网络会瘫痪。<br>所以折中一下，在连接数较少的情况下可能需要流量控制，配合拥塞控制。</p><h2 id="阻塞控制题目"><a href="#阻塞控制题目" class="headerlink" title="阻塞控制题目"></a>阻塞控制题目</h2><p>设  TCP  的  ssthresh  （慢开始门限）的初始值为  8  （单位为报文段）。当拥塞窗口上升到  12  时网络发生了超时，  TCP  使用慢开始和拥塞避免。试分别求出第  1  次到第  15  次传输的各拥塞窗口大小。</p><table><thead><tr><th>次数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>拥塞窗口大小</td><td>1</td><td>2</td><td>4</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>1</td><td>2</td><td>4</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></blockquote><h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><ul><li><p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</p></li><li><p>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</p></li><li><p>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</p></li><li><p>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</p></li><li><p>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。<br><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210330145507987.png" alt="image-20210330145507987"></p></li></ul><h5 id="为什么不能两次握手"><a href="#为什么不能两次握手" class="headerlink" title="为什么不能两次握手"></a>为什么不能两次握手</h5><p>主要是<strong>为了防止已经失效的连接请求报文突然又传送到了服务器</strong>，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的费。<br>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><ul><li><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 <strong>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号</strong>。</p></li><li><p>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p></li><li><p>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p></li><li><p>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p></li><li><p>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p></li><li><p><strong>服务器只要收到了客户端发出的确认，立即进入CLOSED状态</strong>。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210330145711359.png" alt="image-20210330145711359"></p></li></ul><h5 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h5><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p><p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h3 id="TCP提高性能的机制"><a href="#TCP提高性能的机制" class="headerlink" title="TCP提高性能的机制"></a>TCP提高性能的机制</h3><ul><li><p>滑动窗口（上面写了）</p></li><li><p>快速重传（上面写了）</p></li><li><p>延迟应答</p><ul><li><p>如果接收数据的主机立刻返回ACK应答, 这时候返回的窗口可能比较小。<br>假设接收端缓冲区为1M. 一次收到了500K的数据，如果立刻应答, 返回的窗口大小就是500K。但实际上可能处理端处理的速度很快, 10ms之内就把500K数据从缓冲区消费掉了。在这种情况下, 接收端处理还远没有达到自己的极限, 即使窗口再放大一些, 也能处理过来，如果接收端稍微等一会儿再应答，比如等待200ms再应答, 那么这个时候返回的窗口大小就是1M。</p></li><li><p>不是所有的数据包都可以延迟应答，有两个限制</p><ul><li>数量限制: 每隔N个包就应答一次</li><li>时间限制: 超过最大延迟时间就应答一次</li></ul><blockquote><p>一般 N 取2, 最大延迟时间取200ms</p></blockquote></li></ul></li><li><p>捎带应答</p><ul><li>客户端和服务器在应用层也是 “一发一收” 的，意味着客户端给服务器说了 “How are you”，服务器也会给客户端回一个 “Fine, thank you”。那么这个时候ACK就可以搭顺风车, 和服务器回应的 “Fine, thank you” 一起发送给客户端</li></ul></li></ul><h3 id="TCP-粘包-拆包的原因及解决方法"><a href="#TCP-粘包-拆包的原因及解决方法" class="headerlink" title="TCP 粘包/拆包的原因及解决方法"></a>TCP 粘包/拆包的原因及解决方法</h3><p>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</p><p>首先要明确，粘包问题中的 “包”，是指应用层的数据包。在TCP的协议头中,，没有如同UDP一样的 “报文长度” 字段，但是有一个序号字段。<br>站在传输层的角度，TCP是一个一个报文传过来的，按照序号排好序放在缓冲区中。<br>站在应用层的角度，看到的只是一串连续的字节数据。<br>那么应用程序看到了这一连串的字节数据，就不知道从哪个部分开始到哪个部分是一个完整的应用层数据包。此时数据之间就没有了边界, 就产生了粘包问题</p><p>TCP粘包/分包的原因：</p><p>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</p><p>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</p><p>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。</p><p>解决方法</p><p><strong>消息定长</strong>：FixedLengthFrameDecoder类</p><p>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类 ：DelimiterBasedFrameDecoder</p><p>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</p><p>**对于UDP协议来说, 是否也存在 “粘包问题” **</p><p>对于UDP, 如果还没有向上层交付数据, UDP的报文长度仍然存在.同时, UDP是一个一个把数据交付给应用层的, 就有很明确的数据边界.<br>站在应用层的角度, 使用UDP的时候, 要么收到完整的UDP报文, 要么不收.不会出现收到 “半个” 的情况.</p><h3 id="半连接攻击和全连接攻击"><a href="#半连接攻击和全连接攻击" class="headerlink" title="半连接攻击和全连接攻击"></a>半连接攻击和全连接攻击</h3><p>tcp通信是一个面向连接的过程，客户端要和服务端连接，必须进行连接才能进行通信。在tcp连接中，有两种连接攻击方式，是半连接攻击机和全连接攻击。</p><h4 id="半连接攻击（syn泛洪）"><a href="#半连接攻击（syn泛洪）" class="headerlink" title="半连接攻击（syn泛洪）"></a>半连接攻击（syn泛洪）</h4><p>半连接攻击是一种攻击协议栈的攻击方式，坦白说就是攻击主机的一种攻击方式。通过将主机的资源消耗殆尽，从而导致应用层的程序无资源可用，导致无法运行。在正常情况下，客户端连接服务端需要通过三次握手，首先客户端构造一个SYN连接数据包发送至服务端，自身进入SYN_SEND状态，当服务端收到客户端的SYN包之后，为其分配内存核心内存，并将其放置在半连接队列中，服务端接收客户SYN包并会向客户端发送一个SYN包和ACK包，此刻服务端进入SYN_RECV态。客户端收到包之后，再次向服务端发送ACK确认包。至此连接建立完成，双方都进入ESTABLSHEDZ状态。半连接就是通过不断地构造客户端的SYN连接数据包发向服务端，等到服务端的半连接队列满的时候，后续的正常用户的连接请求将会被丢弃，从而无法连接到服务端。此为半连接攻击方式。根据服务端的半连接队列的大小，不同主机的抵抗这种SYN攻击的能力也是不一样。</p><p>如何来解决半连接攻击？</p><p>可以通过拓展半连接队列的大小，来进行补救，但缺点是，不能无限制的增加，这样会耗费过多的服务端资源，导致服务端性能地下。这种方式几乎不可取。现主要通syn cookie或者syn中继机制来防范半连接攻，部位半连接分配核心内存的方式来防范。</p><h4 id="全连接攻击"><a href="#全连接攻击" class="headerlink" title="全连接攻击"></a>全连接攻击</h4><p>全连接攻击是通过消费服务端进程数和连接数，只连接而不进行发送数据的一种攻击方式。当客户端连接到服务端，仅仅只是连接，此时服务端会为每一个连接创建一个进程来处理客户端发送的数据。但是客户端只是连接而不发送数据，此时服务端会一直阻塞在recv或者read的状态，如此一来，多个连接，服务端的每个连接都是出于阻塞状态从而导致服务端的崩溃。</p><p>如何来解决全连接攻击？</p><p>可以通过不为全连接分配进程处理的方式来防范全连接攻击，具体的情况是当收到数据之后，在为其分配一个处理线程。具体的处理方式在accept返回之前是不分配处理线程的。直到接收相关的数据之后才为之提供一个处理过程。例如在apache服务中，是通过预创建一定量的子进程作为处理连接继承。所有的自己进程都继承父进程的sockfd，每当有一个连接过来时，只有当accept返回是，才会为该链接分配一个进程来处理连接请求。负责，子进程一直处于等待状态。如果出现值是连接存在，而始终不放数据，该链接的状态是SYN_RECV，在协议栈中，提供一个保活期给该链接，如果超过保活期还没有数据到来，服务端协议栈将会断开该链接。如果没有该保活期，虽然避免了ESTABLESHED状态的数量，但是SYN_RECV的数据量的增长仍旧是不可估算的，所以需要利用保活期来监控该链接是需要清除断开。</p><h2 id="5-3-Socket"><a href="#5-3-Socket" class="headerlink" title="5.3 Socket"></a>5.3 Socket</h2><h3 id="如何使用socket实现可靠连接"><a href="#如何使用socket实现可靠连接" class="headerlink" title="如何使用socket实现可靠连接"></a>如何使用socket实现可靠连接</h3><p>sockets（套接字）编程有三种：流式套接字（SOCK_STREAM），数据报套接字（SOCK_DGRAM），原始套接字（SOCK_RAW）；基于TCP的socket编程是采用的流式套接字。</p><ul><li>服务器端编程的步骤</li></ul><p>（1）加载套接字库，创建套接字(WSAStartup()/socket())；</p><p>（2）绑定套接字到一个IP地址和一个端口上(bind())；</p><p>（3）将套接字设置为监听模式等待连接请求(listen())；</p><p>（4）请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字(accept())；</p><p>（5）用返回的套接字和客户端]进行通信(send()/recv())；</p><p>（6）返回，等待另一连接请求；</p><p>（7）关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。</p><ul><li>客户端编程的步骤：</li></ul><p>（1）加载套接字库，创建套接字(WSAStartup()/socket())；</p><p>（2）向服务器发出连接请求(connect())；</p><p>（3）和服务器端进行通信(send()/recv())；</p><p>（4）关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。</p><hr><h1 id="六、会话层"><a href="#六、会话层" class="headerlink" title="六、会话层"></a>六、会话层</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p><strong>会话层</strong>：会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p><ul><li>会话层的任务：不同主机上各进程间的对话</li><li>会话层的功能：管理主机间的会话进程，包括建立、管理以及终止进程间的会话。是一种<strong>端到端</strong>的服务</li></ul><hr><h1 id="七、表示层"><a href="#七、表示层" class="headerlink" title="七、表示层"></a>七、表示层</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><p><strong>表示层</strong>：表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p><p>负责处理在两个内部数据表示结构不同的通信系统之间交换信息的表示格式，为数据加密和解密以及为提高传输效率提供必需的数据压缩以及解压等功能。</p><hr><h1 id="八、应用层"><a href="#八、应用层" class="headerlink" title="八、应用层"></a>八、应用层</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><p><strong>应用层</strong>：为操作系统或网络应用程序提供访问网络服务的接口。</p><ul><li><p>应用层的任务：提供系统与用户的接口</p></li><li><p>应用层的功能：</p><ul><li>文件传输</li><li>访问和管理</li><li>电子邮件服务</li></ul></li><li><p>协议：FTP、SMTP、POP3、HTTP、DNS、TELnet</p></li></ul><h2 id="8-2-从输入URL到浏览器显示页面的流程"><a href="#8-2-从输入URL到浏览器显示页面的流程" class="headerlink" title="8.2 从输入URL到浏览器显示页面的流程"></a>8.2 从输入URL到浏览器显示页面的流程</h2><h3 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h3><h4 id="1、地址解析"><a href="#1、地址解析" class="headerlink" title="1、地址解析"></a>1、地址解析</h4><p>浏览器会根据你的输入来判断该输入是一条合法的URL，还是需要被搜索的关键词。并且根据你输入的内容进行自动完成、字符编码等操作。</p><h4 id="2、其他操作"><a href="#2、其他操作" class="headerlink" title="2、其他操作"></a>2、其他操作</h4><p>目前大部分浏览器都会<strong>强制客户端使用HTTPS协议</strong>以保证信息传输的安全性。同时还会进行一些额外的操作，比如安全检查、访问限制等。</p><h4 id="3、缓存检查"><a href="#3、缓存检查" class="headerlink" title="3、缓存检查"></a>3、缓存检查</h4><p>有时候博客在gitee上进行了更新，但是通过谷歌浏览器查看博客时，仍是更新前的博客，这是因为浏览器中缓存了之前的博客界面。</p><p>浏览器会先检测是否缓存了目标URL的页面，如果有且缓存未过期，则直接展示缓存页面，无需再向服务器进行请求</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210415185211636.png" alt="image-20210415185211636"></p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p><strong>DNS解析是寻找所需要的资源的IP地址的过程</strong>。因为互联网中每一台连网的机器都有<strong>唯一IP作为标识</strong>，但是它是一串数字，记忆太过困难。所以就需要将网址和IP地址进行转换，也就是DNS解析。其具体步骤如下。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210415185234770.png" alt="image-20210415185234770"></p><h4 id="第一步：检查浏览器缓存中是否缓存过该域名对应的IP地址"><a href="#第一步：检查浏览器缓存中是否缓存过该域名对应的IP地址" class="headerlink" title="第一步：检查浏览器缓存中是否缓存过该域名对应的IP地址"></a>第一步：检查浏览器缓存中是否缓存过该域名对应的IP地址</h4><p>用户通过浏览器浏览过某网站之后，浏览器就会自动缓存该网站域名对应的地址，当用户再次访问的时候，浏览器就会从缓存中查找该域名对应的IP地址，因为缓存不仅是有大小限制，而且还有时间限制（域名被缓存的时间通过属性来设置），所以存在域名对应的找不到的情况。当浏览器从缓存中找到了该网站域名对应的地址，那么整个解析过程结束，如果没有找到，将进行下一步骤。对于的缓存时间问题，不宜设置太长的缓存时间，时间太长，如果域名对应的发生变化，那么用户将在一段时间内无法正常访问到网站，如果太短，那么又造成频繁解析域名。</p><h4 id="第二步：如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP"><a href="#第二步：如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP" class="headerlink" title="第二步：如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP"></a>第二步：如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP</h4><p>如果第一个步骤没有完成对域名的解析过程，那么浏览器会去系统缓存中查找系统是否缓存过这个域名对应的地址，也可以理解为系统自己也具备域名解析的基本能力。在系统中，可以通过设置文件来将域名手动绑定到某上，文件位置在。对于普通用户，并不推荐自己手动绑定域名和，对于开发者来说，通过绑定域名和，可以轻松切换环境，可以从测试环境切换到开发环境，方便开发和测试。在系统中，黑客常常修改他的电脑的文件，将用户常常访问的域名绑定到他指定的上，从而实现了本地解析，导致这些域名被劫持。在或者系统中，文件在，修改该文件也可以实现同样的目的。</p><ul><li>查找<strong>路由器缓存</strong>，通过路由器看看有没有DNS缓存</li></ul><p>前两步都是在本机上完成的，所以没有在上面示例图上展示出来，从第三步开始，才正在地向远程DNS服务器发起解析域名的请求。</p><h4 id="第三步：向本地域名解析服务系统发起域名解析的请求"><a href="#第三步：向本地域名解析服务系统发起域名解析的请求" class="headerlink" title="第三步：向本地域名解析服务系统发起域名解析的请求"></a>第三步：向本地域名解析服务系统发起域名解析的请求</h4><p>如果在本机上无法完成域名的解析，那么系统只能请求本地域名解析服务系统进行解析，本地域名系统一般都是本地区的域名服务器，比如你连接的校园网，那么域名解析系统就在你的校园机房里，如果你连接的是电信、移动或者联通的网络，那么本地域名解析服务器就在本地区，由各自的运营商来提供服务。对于本地服务器地址，系统使用命令就可以查看，在和系统下，直接使用命令来查看服务地址。一般都缓存了大部分的域名解析的结果，当然缓存时间也受域名失效时间控制，大部分的解析工作到这里就差不多已经结束了，负责了大部分的解析工作。</p><h4 id="第四步：向根域名解析服务器发起域名解析请求"><a href="#第四步：向根域名解析服务器发起域名解析请求" class="headerlink" title="第四步：向根域名解析服务器发起域名解析请求"></a>第四步：向根域名解析服务器发起域名解析请求</h4><p>本地域名解析器还没有完成解析的话，那么本地域名解析服务器将向根域名服务器发起解析请求。</p><h4 id="第五步：根域名服务器返回gTLD（通用顶级域名）域名解析服务器地址"><a href="#第五步：根域名服务器返回gTLD（通用顶级域名）域名解析服务器地址" class="headerlink" title="第五步：根域名服务器返回gTLD（通用顶级域名）域名解析服务器地址"></a>第五步：根域名服务器返回gTLD（通用顶级域名）域名解析服务器地址</h4><p>本地域名解析向根域名服务器发起解析请求，根域名服务器返回的是所查域的通用顶级域（）地址，常见的通用顶级域有cn、com、edu等。</p><h4 id="第六步：向gTLD服务器发起解析请求"><a href="#第六步：向gTLD服务器发起解析请求" class="headerlink" title="第六步：向gTLD服务器发起解析请求"></a>第六步：向gTLD服务器发起解析请求</h4><p>本地域名解析服务器向gTLD服务器发起请求。</p><h4 id="第七步：gTLD服务器接收请求并返回Name-Server服务器"><a href="#第七步：gTLD服务器接收请求并返回Name-Server服务器" class="headerlink" title="第七步：gTLD服务器接收请求并返回Name Server服务器"></a>第七步：gTLD服务器接收请求并返回Name Server服务器</h4><p>服务器接收本地域名服务器发起的请求，并根据需要解析的域名，找到该域名对应的域名服务器，通常情况下，这个服务器就是你注册的域名服务器，那么你注册的域名的服务商的服务器将承担起域名解析的任务。</p><h4 id="第八步：Name-Server服务器返回IP地址给本地服务器"><a href="#第八步：Name-Server服务器返回IP地址给本地服务器" class="headerlink" title="第八步：Name Server服务器返回IP地址给本地服务器"></a>第八步：Name Server服务器返回IP地址给本地服务器</h4><p>服务器查找域名对应的地址，将地址连同值返回给本地域名服务器。</p><h4 id="第九步：本地域名服务器缓存解析结果"><a href="#第九步：本地域名服务器缓存解析结果" class="headerlink" title="第九步：本地域名服务器缓存解析结果"></a>第九步：本地域名服务器缓存解析结果</h4><p>本地域名服务器缓存解析后的结果，缓存时间由时间来控制。</p><blockquote><p>概述版：</p><ul><li>查询缓存</li></ul><p>我们的浏览器、操作系统、路由器都会缓存一些URL对应的IP地址，统称为<strong>DNS高速缓存</strong>。这是为了加快DNS解析速度，使得不必每次都到根域名服务器中去查询。</p><ul><li>递归解析</li></ul><p>输入<code>www.baidu.com</code>网址后，首先在高速缓存中查找，没找到去根域名服务器查找，没有再去<code>com</code>顶级域名服务器查找，依次类推，直到找到IP地址，然后把它记录在本地告诉缓存中，供下次使用。</p><p>大致过程就是<code>.</code>-&gt; <code>.com</code> -&gt;<code>baidu.com.</code> -&gt; <code>www.baidu.com.</code></p><p>其中<code>.</code>代表根域名服务器。</p><ul><li>DNS负载均衡</li></ul><p>访问<code>baidu.com</code>的时候，每次响应的可能并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，DNS可以返回一个<strong>合适的机器的IP</strong>给用户，例如可以<strong>根据每台机器的负载量，该机器离用户地理位置的距离</strong>等等，这种过程就是DNS负载均衡。</p></blockquote><h3 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h3><p>TCP/IP 分为四层，在发送数据时，<strong>每层都要对数据进行封装</strong></p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/20201209141851.png" alt="img"></p><p><a href="#tcp">TCP协议</a></p><h3 id="发送HTTPS请求"><a href="#发送HTTPS请求" class="headerlink" title="发送HTTPS请求"></a>发送HTTPS请求</h3><p><a href="#https">HTTPS协议</a></p><p><strong>大致过程如下</strong></p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921110642708.png" alt="image-20210921110642708"></p><h3 id="查询MAC地址"><a href="#查询MAC地址" class="headerlink" title="查询MAC地址"></a>查询MAC地址</h3><p>这一步主要负责为打包好的<code>数据+TCP首部+IP首部</code>寻找传输路线，<strong>找到IP对应的物理机</strong>，这里会用到ARP协议。</p><p><a href="#arp">ARP协议</a></p><h3 id="请求在Tomcat中的处理流程"><a href="#请求在Tomcat中的处理流程" class="headerlink" title="请求在Tomcat中的处理流程"></a>请求在Tomcat中的处理流程</h3><p>Web 容器以<strong>进程</strong>的方式在计算机上运行，<strong>它主要负责接收请求，并将其投送至特定的应用</strong>，但Web容器并不属于计算机网络的组成部分。接下来将以Tomcat为例介绍Web容器的核心组件。</p><h4 id="Tomcat的核心组件"><a href="#Tomcat的核心组件" class="headerlink" title="Tomcat的核心组件"></a>Tomcat的核心组件</h4><p>Tomcat的核心组件主要有：<strong>Server、Service、Connector、Engine、Host和Context</strong>。</p><p><strong>一个Server可以包含多个Service，一个Service可以包含多个Connector，但只能包含一个Engine，一个Engine可以包含多个Host，一个Host可以包含多个Context</strong>。</p><p><strong>它们之间的关系如下图所示</strong></p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921111523133.png" alt="image-20210921111523133"></p><p><strong>配置文件的结构如下</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Server</span>&gt;</span>                              <br>    <span class="hljs-tag">&lt;<span class="hljs-name">Service</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Engine</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Host</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Context</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Host</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Context</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Engine</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Service</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Server</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p>Server 是整个配置文件的<strong>唯一根元素</strong>，代表整个 Tomcat 容器。Server 内部可以包含多个 Service，其主要职责就是管理多个 Service，对外提供给客户端访问，同时维护所有 Service 的生命周期，包括初始化服务、结束服务、定位客户端要访问的 Service 等等。</p><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>Service 的主要职责就是将 Engine 与 Connector 装配在一起对外提供服务。一个 Service 可以包含多个 Connector，但只能包含一个 Engine，<strong>其中 Connector 负责从客户端接收请求，Engine 负责处理 Connector 接收进来的请求。</strong></p><h5 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h5><p><strong>Connector是主要负责接收请求的组件</strong>。</p><p><strong>Tomcat有以下两种工作模式</strong></p><ul><li>作为Web服务器，直接接收客户端的请求</li><li>作为Java Web服务器，接收前置Web服务器的请求</li></ul><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921111734338.png" alt="image-20210921111734338"></p><p>每个 Service 可以有一个或多个 Connector，不同工作模式下，Tomcat 需要为各种类型的请求分别定义相应的 Connector，这样才能正确接收客户端对应协议的请求。定义 Connector 可以使用多种属性，某些属性只适用于某种特定的 Connector 类型。</p><p>一般说来，常见的 Connector 有 4 种类型</p><ul><li><strong>HTTP</strong></li><li><strong>HTTPS</strong></li><li><strong>AJP</strong></li><li><strong>Proxy</strong></li></ul><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921111805468.png" alt="image-20210921111805468"></p><p>Connector作为通信接口，<strong>它为其所属特定的 Service 接收外部客户端请求，以及回送应答至外部客户端</strong>。具体职责包括创建 Request、Response 对象用于跟外部客户端交换数据，并<strong>将 Request 交给配套的 Engine 来处理</strong>。</p><h5 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h5><p>Engine 是 Service 组件中<strong>负责请求处理的组件</strong>，其内部可以包含多个 Host。Engine 从一个或多个 Connector 中接收请求并处理，并将处理结果封装成应答交给 Connector，最终回传给外部客户端。</p><h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><p><strong>Host 代表一个虚拟主机，它对应计算机网络上的一个实体</strong>。即某个在 DNS 服务器上注册过的域名或者 IP 地址，例如：<code>www.baidu.com</code>或 201.187.10.21。Host 内部可以包含多个 Context，<strong>每个 Context 表示一个 Web 应用</strong>。Host 负责安装、展开、启动和结束每个 Web 应用。</p><p>客户端在填写目标地址时会通过主机名来标识它希望访问的服务器，Tomcat 将从 HTTP 请求头的 Host 字段提取主机名，然后再匹配对应的虚拟主机。如果没有找到匹配的，HTTP 请求将被发送至默认主机 defaultHost。</p><h5 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h5><p>Context 代表在特定虚拟主机上运行的一个 Web 应用，<strong>负责处理某个特定 Web 应用的所有请求</strong>。</p><h4 id="Tomcat处理HTTP请求"><a href="#Tomcat处理HTTP请求" class="headerlink" title="Tomcat处理HTTP请求"></a>Tomcat处理HTTP请求</h4><p>当以 HTTP 请求到达Tomcat服务器（Server）以后，Tomcat会进行以下几个步骤，将请求交给对应的Web应用进行处理</p><ul><li>根据协议类型和端口号选定 Service 和 Engine<ul><li>Connector 主要负责接收请求。当 Connector 接收到特定协议和特定端口的请求后，<strong>其所属的 Service 和 Service 下的 Engine 也就确定了</strong></li></ul></li><li>根据域名或 IP 地址选定 Host<ul><li>Engine一旦确定了，就会根据 IP 来选择对应的虚拟主机Host来处理请求。如果匹配失败了，则会使用默认虚拟主机来处理请求</li></ul></li><li>根据 URI 选定 Context<ul><li>URI 中的 context-path 指定了 HTTPS 请求将要访问的 Web 应用</li><li>当请求抵达时，Tomcat 将根据 Context 的属性 path 取值与 URI 中的 context-path 的匹配程度来选择 Web 应用处理相应请求</li></ul></li></ul><hr><h3 id="请求在Web应用中的处理流程"><a href="#请求在Web应用中的处理流程" class="headerlink" title="请求在Web应用中的处理流程"></a>请求在Web应用中的处理流程</h3><p>请求被 Web 容器中的 Connector 捕获，选取对应的 Server 中的 Engine ，Engine 再根据IP选择对应的虚拟主机，虚拟主机根据URI将请求交给对应的Web应用进行处理。接下来将介绍请求在Web请求中的处理过程。</p><p>介绍处理过程前，先对Web应用的基本组件进行简单介绍。</p><h4 id="Web应用核心组件"><a href="#Web应用核心组件" class="headerlink" title="Web应用核心组件"></a>Web应用核心组件</h4><h5 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h5><p>监听器 Listener 主要用于监听 Application、Session、Request 等对象的变化，每当这些对象发生变化就会回调用对应的监听方法。</p><h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><p>过滤器 Filter 负责对请求做<strong>预处理</strong>，接着将请求交给 Servlet 进行处理并生成响应，最后 Filter 再对响应进行后处理。</p><p>从请求的处理过程来看，Filter 主要参与以下几个环节</p><ul><li>在 HttpServletRequest <strong>到达 Servlet 之前，拦截客户的 HttpServletRequest</strong></li><li>根据需要检查 HttpServletRequest，也可以修改 HttpServletRequest 报文头和数据</li><li>在 Servlet 生成的 HttpServletResponse <strong>抵达客户端之前，拦截 HttpServletResponse</strong></li><li>根据需要检查 HttpServletResponse，也可以修改 HttpServletResponse 报文头和数据</li></ul><p><strong>简单来说就是在真正处理请求以及返回响应之前，通过过滤器对内容再进行一些修改</strong></p><h5 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h5><p><strong>Servlet 负责处理客户端访问动态资源的 HTTP 请求</strong>，接口 javax.servlet.Servlet 定义了所有 Servlet 必须要实现的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Servlet</span> </span>&#123;<br>    <span class="hljs-comment">// 由 Servlet 容器调用，完成 Servlet 初始化，启动对外服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig var1)</span> <span class="hljs-keyword">throws</span> ServletException</span>;<br><br>    <span class="hljs-comment">// 获取 Servlet 初始化和启动时参数的配置信息对象 ServletConfig</span><br>    <span class="hljs-function">ServletConfig <span class="hljs-title">getServletConfig</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 由 Servlet 容器调用，让 Servlet 处理某个 HTTP 请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest var1, ServletResponse var2)</span> <span class="hljs-keyword">throws</span> ServletException, IOException</span>;<br><br>    <span class="hljs-comment">// 获取 Servlet 的说明信息，包括：作者、版本和版权等等</span><br>    <span class="hljs-function">String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 由 Servlet 容器调用，用于关闭停止 Servlet 提供的服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从 HTTP 请求的处理过程来看，Servlet 主要参与以下几个环节</p><ul><li>接收请求<ul><li>客户端请求会被封装成 HttpServletRequest 对象，包含报文头参数和报文体等信息</li></ul></li><li>处理请求<ul><li>通常调用 Servlet 的方法 service、doPost 或 doGet 等方法处理请求，并<strong>进一步调用业务层相应逻辑对其进行处理等</strong></li></ul></li><li>反回响应<ul><li>处理完请求后，可以转发（forward）、重定向（redirect）到某个视图页面或者直接返回结果数据</li></ul></li></ul><h4 id="Web应用处理HTTP请求流程"><a href="#Web应用处理HTTP请求流程" class="headerlink" title="Web应用处理HTTP请求流程"></a>Web应用处理HTTP请求流程</h4><p>Web 应用处理 HTTP 请求的流程主要是<strong>穿越 Listener 和多个 Filters，最终抵达 Servlet 的过程</strong>，Servlet再进行下一步的处理。</p><p><strong>具体流程如下图</strong></p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921112418359.png" alt="image-20210921112418359"></p><hr><h3 id="请求在Spring-Web应用中的处理流程"><a href="#请求在Spring-Web应用中的处理流程" class="headerlink" title="请求在Spring Web应用中的处理流程"></a>请求在Spring Web应用中的处理流程</h3><p>因为使用 SSM 框架，所以 Spring MVC 中的 DispatcherServlet 充当了 Web 应用中的 Serlvet，负责将任务分配给对应的Controller，并将最终视图返回给 Web 容器。</p><h4 id="Spring-MVC的核心组件"><a href="#Spring-MVC的核心组件" class="headerlink" title="Spring MVC的核心组件"></a>Spring MVC的核心组件</h4><h5 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h5><p>DispatcherServlet 是整个流程<strong>控制的中心</strong>，由它来<strong>接收请求并调用其它组件处理用户的请求</strong>，同时还负责响应结果。DispatcherServlet的存在降低了组件之间的耦合性。</p><h5 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h5><p>HandlerMapping 负责<strong>根据用户请求映射获得对应的 Handler和 HandlerInterceptor</strong>。处理方法为从 URL 获得 URI，在通过 URI 从 HandlerMapping 中找到对应的 Handler 和 HandlerInterceptor，即处理器和拦截器。</p><h5 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h5><p>HandlerAdapter 负责按照特定规则去执行 Handler。</p><p>如果 Handler 有对应的 HandlerAdapater，<strong>HandlerAdapater 则会在调用 Handler 之前执行 HandlerInterceptor 的 preHandler() 方法对 Handler 进行拦截</strong>。</p><h5 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h5><p>HandlerInterceptor 主要负责在执行 Handler 前对其进行拦截。HandlerInterceptor 中的 preHandler() 方法将会提取 HTTP 请求中的数据填充到处理器 Handler 的中。</p><h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p>Handler <strong>即Controller ，是处理业务代码的核心器件</strong>。这部分由程序员自行编写，一般的SSM框架中，其下层还有Service和Dao。</p><h4 id="Spring-MVC处理请求流程"><a href="#Spring-MVC处理请求流程" class="headerlink" title="Spring MVC处理请求流程"></a>Spring MVC处理请求流程</h4><p>当 Web 容器中的 Host 会选择对应的 Web应用来处理请求，这里将请求交给了 Spring MVC 中的 DispatcherServlet 来进一步处理请求。</p><ul><li>DispatcherServlet 通过解析 HTTP 请求的 URL 获得 URI，再根据该 URI <strong>从 HandlerMapping 当中获得该请求对应的 Handler 和 HandlerInterceptor</strong></li><li>DispatcherServlet 根据获得的 Handler 选择合适的 HandlerAdapter。如果成功获得 HandlerAdapter，<strong>HandlerAdapater 则会在调用 Handler 之前执行 HandlerInterceptor 的 preHandler() 方法对 Handler 进行拦截</strong></li><li>Handler 即 Controller 会进行请求的处理，并向下调用 Service 和 Dao 来处理请求</li><li>Hander 处理完成请求后会返回模型数据，模型数据由 DispatcherServlet 封装后返回给Web 容器</li></ul><p><strong>处理的流程图如下</strong></p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921112655885.png" alt="image-20210921112655885"></p><hr><h3 id="返回过程"><a href="#返回过程" class="headerlink" title="返回过程"></a>返回过程</h3><p>Web 应用处理完请求并将结果返回给 Web 容器后，容器会将响应结果返回给客户端，这是上面流程的逆过程。浏览器收到响应结果后，会对结果进行解析和渲染。这样我们就能看到浏览器给我们显示的网页了。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921113017358.png" alt="image-20210921113017358"></p><hr><h2 id="8-3-HTTP协议"><a href="#8-3-HTTP协议" class="headerlink" title="8.3 HTTP协议"></a>8.3 HTTP协议</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>HTTP（HyperText Transfer Protocol）：<strong>超文本传输协议</strong>，HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><p>尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。</p><ul><li>超文本：超文本指的是HTML，css，JavaScript和图片等，HTTP的出现是为了接收和发布HTML页面，经过不断的发展也可以用于接收一些音频，视频，文件等内容。</li></ul><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210910145213312.png" alt="image-20210910145213312"></p><hr><h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p>报文结构：<strong>起始行 + 头部 + 空行 + 实体</strong></p><blockquote><p> http <code>请求报文</code>和<code>响应报文</code>是有一定区别</p></blockquote><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915150323696.png" alt="image-20210915150323696"></p><h4 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h4><h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><ul><li>请求报文 GET /home HTTP/1.1，也就是<strong>方法 + 路径 + http版本</strong></li></ul><p><a href="#http%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95">HTTP请求方法</a></p><p><a href="#uri%E4%B8%8Eurl">URI与URL</a></p><p><a href="#http%E7%89%88%E6%9C%AC">HTTP版本</a></p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1625556960701-67d07a26-61ea-4708-b378-a33ce98e5907.webp" alt="img"></p><h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><ul><li>响应报文 HTTP/1.1 200 OK ，由<strong>http版本、状态码和原因</strong>三部分组成</li></ul><p><a href="#http%E7%89%88%E6%9C%AC">HTTP版本</a></p><p><a href="#http%E7%8A%B6%E6%80%81%E7%A0%81">HTTP状态码</a></p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1625556999909-c5905faf-64de-41a8-a43b-780207247fa8.webp" alt="img"></p><blockquote><p>在起始行中，每两个部分之间用<strong>空格</strong>隔开，最后一个部分后面应该接一个<strong>换行</strong>，严格遵循<code>ABNF</code>语法规范。</p></blockquote><h4 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h4><h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915151245871.png" alt="image-20210915151245871"></p><p>Cache-Control：</p><ul><li><p><strong>private：</strong> 仅浏览器可以缓存</p></li><li><p><strong>public：</strong> 浏览器和代理服务器都可以缓存（对于private和public，前端可以认为一样，不用深究</p></li><li><p><strong>max-age=xxx</strong> 过期时间（重要）</p></li><li><p><strong>no-cache</strong> 不进行强缓存（重要）,使用任何缓存前都要向服务器验证</p></li><li><p><strong>no-store</strong> 真正的不缓存</p></li></ul><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915151401084.png" alt="image-20210915151401084"></p><p>Content-Type：</p><p>常见的媒体格式：text/html,text/plain,image/gif</p><p>application开头的媒体格式类型：application/xml, appliation/json</p><p>multipart/form-data</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915151540851.png" alt="image-20210915151540851"></p><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><h5 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h5><h5 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h5><hr><h3 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a><span id="http请求方法">HTTP 请求方法</span></h3><p><code>http/1.1</code>规定了以下请求方法(注意，都是大写):</p><ul><li>GET: 通常用来获取资源</li><li>HEAD: 获取资源的元信息</li><li>POST: 提交数据，即上传数据</li><li>PUT: 修改数据</li><li>DELETE: 删除资源(几乎用不到)</li><li>CONNECT: 建立连接隧道，用于代理服务器</li><li>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求</li><li>TRACE: 追踪请求-响应的传输路径</li></ul><h4 id="get请求与post请求的区别"><a href="#get请求与post请求的区别" class="headerlink" title="get请求与post请求的区别"></a>get请求与post请求的区别</h4><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</li><li><strong>GET请求只能进行url编码，而POST支持多种编码方式</strong>。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li><strong>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</strong>。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li><li>从<strong>幂等性</strong>的角度，<code>GET</code>是<strong>幂等</strong>的，而<code>POST</code>不是。(<code>幂等</code>表示执行相同的操作，结果也是相同的)</li></ul><hr><h3 id="HTTP-版本"><a href="#HTTP-版本" class="headerlink" title="HTTP 版本"></a><span id="http版本">HTTP 版本</span></h3><h4 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h4><ul><li>HTTP 1.0 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个TCP连接</li></ul><h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><ul><li><p>新增Connection字段，用于<strong>支持提供TCP持久连接</strong> Connection: keep-alive</p><ul><li>即TCP连接默认不关闭，可以被多个请求复用</li><li>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着。（<strong>HTTP队头阻塞</strong>）</li></ul></li><li><p>增加更多请求头和响应头来完善功能</p></li><li><p>新增 Host 字段，用于支持虚拟主机</p></li><li><p>缓存策略：If-Match，If-None-Match</p></li><li><p>添加了新的请求方法 put, delete, options</p></li></ul><blockquote><p>队头阻塞</p><p>”队头阻塞“与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。</p><p>因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。</p><p>队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</p><p>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。</p></blockquote><p>因为“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP/1.1 里无法解决，只能缓解</p><ul><li><p>这在 HTTP 里就是“并发连接”（concurrent connections），也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。但这种方式也存在缺陷。如果每个客户端都想自己快，建立很多个连接，用户数×并发数就会是个天文数字。服务器的资源根本就扛不住，或者被服务器认为是恶意攻击，反而会造成“拒绝服务”。所以，HTTP 协议建议客户端使用并发，但不能“滥用”并发。RFC2616 里明确限制每个客户端最多并发 2 个连接。不过实践证明这个数字实在是太小了，众多浏览器都“无视”标准，把这个上限提高到了 6~8。后来修订的 RFC7230 也就“顺水推舟”，取消了这个“2”的限制。</p></li><li><p>“域名分片”（domain sharding）技术，还是用数量来解决质量的思路。HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.chrono.com、shard2.chrono.com，而这些域名都指向同一台服务器 <a href="http://www.chrono.com,这样实际长连接的数量就又上去了/">www.chrono.com，这样实际长连接的数量就又上去了</a></p></li></ul><h4 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h4><ul><li><p><strong>支持服务端推送</strong></p><ul><li>允许服务端推送资源给客户端，在响应一个页面请求中，可以把需要的其他资源一起发给客户端，免得需要再次发送请求，适合加载静态资源，比如请求html时，把css也传过去</li></ul></li><li><p><strong>支持TCP连接IO多路复用</strong></p><ul><li>在一个连接里，客户端和服务器都可以同时发送多个请求或回应，避免队头阻塞</li></ul></li><li><p><strong>二进制分帧（而非文本格式）</strong></p><ul><li>支持多个连接穿插执行，避免队头阻塞</li></ul></li><li><p>首部压缩：HPACK算法</p><ul><li>首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把<strong>索引</strong>(比如0，1，2，…)传给对方即可，对方拿到索引查表就行了。这种<strong>传索引</strong>的方式，可以说让请求头字段得到极大程度的精简和复用。废除了起始行的概念。<ul><li>HTTP2.0当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个”:”前缀，用来和其它请求头区分开。</li><li>其次是对于整数和字符串进行<strong>哈夫曼编码</strong>，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>索引序列</strong>，可以达到非常高的压缩率。</li></ul></li></ul></li></ul><hr><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a><span id="http状态码">HTTP 状态码</span></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></p><p>RFC 规定 HTTP 的状态码为<strong>三位数</strong>，被分为五类:</p><ul><li><p><strong>1xx</strong>: 表示目前是协议处理的中间状态，还需要后续操作。</p><ul><li><p><strong>100 Continue</strong>：迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</p></li><li><p><strong>101 Switching Protocols</strong>：在<code>HTTP</code>升级为<code>WebSocket</code>的时候，如果服务器同意变更（切换协议），就会发送状态码 101。</p></li><li><p><strong>102 Processing</strong>：服务器已收到并正在处理该请求，但没有响应可用</p></li></ul></li><li><p><strong>2xx</strong>: 表示成功状态。</p><ul><li><strong>200 OK</strong>：请求成功。</li><li><strong>201 Created</strong>：该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。</li><li><strong>202 Accepted</strong>：请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。</li><li><strong>204 No Content</strong>：含义与 200 相同，但响应头后没有 body 数据。</li><li><strong>206 Partial Content</strong>：表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段<code>Content-Range</code>。</li></ul></li><li><p><strong>3xx</strong>: 重定向状态，资源位置发生变动，需要重新请求。</p><ul><li><p><strong>301 Moved Permanently</strong>：永久重定向，求的URL已被移除时使用</p><p>比如网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回<code>301</code>，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。</p></li><li><p><strong>302 Found</strong>：临时重定向，请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p></li><li><p><strong>304 Not Modified</strong>: 当协商缓存命中时会返回这个状态码。如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p></li></ul></li><li><p><strong>4xx</strong>: 请求报文有误。</p><ul><li><p><strong>400 Bad Request</strong>: </p><ul><li>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</li><li>2、请求参数有误。</li></ul></li><li><p><strong>401 Unauthorized</strong>：未授权，当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。</p></li><li><p><strong>403 Forbidden</strong>：服务器已经理解请求，但是拒绝执行它。这并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。</p></li><li><p><strong>404 Not Found</strong>：资源未找到，表示没在服务器上找到相应的资源。</p></li><li><p><strong>405 Method Not Allowed</strong>：请求方法不被服务器端允许。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。</p></li><li><p><strong>406 Not Acceptable</strong>: 资源无法满足客户端的条件。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</p></li><li><p><strong>408 Request Timeout</strong>：服务器等待了太长时间。请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</p></li><li><p><strong>409 Conflict</strong>：多个请求发生了冲突。</p></li><li><p><strong>413 Request Entity Too Large</strong>：请求体的数据过大。</p></li><li><p><strong>414 Request-URI Too Long</strong>：请求行里的 URI 太大。</p></li><li><p><strong>429 Too Many Request</strong>：客户端发送的请求过多。</p></li><li><p><strong>431 Request Header Fields Too Large</strong>：请求头的字段内容太大。</p></li></ul></li><li><p><strong>5xx</strong>: 服务器端发生错误。</p><ul><li><strong>500 Internal Server Error</strong>：服务器遇到了不知道如何处理的情况。</li><li><strong>501 Not Implemented</strong>：客户端请求的功能还不支持。此请求方法不被服务器支持且无法被处理。只有<code>GET</code>和<code>HEAD</code>是要求服务器支持的，它们必定不会返回此错误代码。</li><li><strong>502 Bad Gateway</strong>：此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。服务器自身是正常的，但访问的时候出错了。</li><li><strong>503 Service Unavailable</strong>：服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 </li><li><strong>504 Gateway Timeout</strong>：当服务器作为网关，不能及时得到响应时返回此错误代码。</li><li><strong>505 HTTP Version Not Supported</strong>：服务器不支持请求中所使用的HTTP协议版本。</li></ul></li></ul><hr><h3 id="URI与URL"><a href="#URI与URL" class="headerlink" title="URI与URL"></a><span id="uri与url">URI与URL</span></h3><ul><li><strong>URI</strong>：Uniform Resource Identifier，统一资源标识符</li><li><strong>URL</strong>：Uniform Resource Locator，统一资源定位符，不仅标识了资源，还指定了操作或者获取方式，同时指出了主要访问机制和网络位置；</li><li><strong>URN</strong>：Uniform Resource Name，统一资源名称，用特定命名空间的名字标识资源，使用URN可以在不知道其网络位置及访问方式的情况下讨论资源。</li></ul><h4 id="URI结构"><a href="#URI结构" class="headerlink" title="URI结构"></a>URI结构</h4><p>URI 真正最完整的结构是这样的。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915233628185.png" alt="image-20210915233628185"></p><ul><li><p><strong>scheme</strong> 表示协议名，比如<code>http</code>, <code>https</code>, <code>file</code>等等。后面必须和<code>://</code>连在一起。</p></li><li><p><strong>user:passwd</strong>@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。</p></li><li><p><strong>host:port</strong>表示主机名和端口。</p></li><li><p><strong>path</strong>表示请求路径，标记资源所在位置。</p></li><li><p><strong>query</strong>表示查询参数，为<code>key=val</code>这种形式，多个键值对之间用<code>&amp;</code>隔开。</p></li><li><p><strong>fragment</strong>表示 URI 所定位的资源内的一个<strong>锚点</strong>，浏览器可以根据这个锚点跳转到对应的位置。</p></li></ul><p>URI 只能使用<code>ASCII</code>, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。</p><p>因此，URI 引入了<code>编码</code>机制，将所有<strong>非 ASCII 码字符</strong>和<strong>界定符</strong>转为十六进制字节值，然后在前面加个<code>%</code>。</p><p>如，空格被转义成了<code>%20</code>。</p><p>URI允许统一识别资源。URI另外被分组为定位符，名称或两者，这意味着它可以描述URL，URN或两者。</p><blockquote><p><strong>URL和URN都是URI的子集</strong>。换而言之，URL和URN都是URI，但是URI不一定是URL或者URN。</p></blockquote><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/640" alt="图片"></p><p>举例如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">构造一个URI<br>http:*<span class="hljs-regexp">//</span>bitpoetry.io<span class="hljs-regexp">/posts/</span>hello.html<span class="hljs-comment">#intro</span><br><br>其中<br>   http:<span class="hljs-regexp">//</span>  <span class="hljs-regexp">//</span> 是定义如何访问资源的方式<br>   bitpoetry.io<span class="hljs-regexp">/posts/</span>hello.html  <span class="hljs-regexp">//</span> 是资源存放的位置<br>   <span class="hljs-comment">#intro  // 是资源</span><br>   <br>URL是URI的一个子集，告诉我们访问资源位置的方式。在例子中，URL应该如下所示：   <br>    http:<span class="hljs-regexp">//</span>bitpoetry.io<span class="hljs-regexp">/posts/</span>hello.html<br>    <br>URN是URI的子集，包括名字（给定的命名空间内），但是不包括访问方式。在例子中，URN如下所示：  <br> bitpoetry.io<span class="hljs-regexp">/posts/</span>hello.html<span class="hljs-comment">#intro</span><br></code></pre></td></tr></table></figure><hr><h3 id="HTTP-传输定长和不定长的数据"><a href="#HTTP-传输定长和不定长的数据" class="headerlink" title="HTTP 传输定长和不定长的数据"></a>HTTP 传输定长和不定长的数据</h3><h4 id="定长数据"><a href="#定长数据" class="headerlink" title="定长数据"></a>定长数据</h4><ul><li>对于定长包体而言，发送端在传输的时候一般会带上 <code>Content-Length</code>, 来指明包体的长度<ul><li>用一个<code>nodejs</code>服务器来模拟一下:</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br><span class="hljs-keyword">const</span> server = http.createServer();<br><br>server.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(req.url === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>    res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/plain&#x27;</span>);<br>    res.setHeader(<span class="hljs-string">&#x27;Content-Length&#x27;</span>, <span class="hljs-number">10</span>);<br>    res.write(<span class="hljs-string">&quot;helloworld&quot;</span>);<br>  &#125;<br>&#125;)<br><br>server.listen(<span class="hljs-number">8081</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;成功启动&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>启动后访问: <strong>localhost:8081</strong>。</p><p>浏览器中显示如下:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">helloworld</span><br></code></pre></td></tr></table></figure><p>这是长度正确的情况，那不正确的情况是如何处理的呢</p><p>我们试着把这个长度设置的小一些:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.setHeader</span>(<span class="hljs-string">&#x27;Content-Length&#x27;</span>, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>重启服务，再次访问，现在浏览器中内容如下:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hellowor</span><br></code></pre></td></tr></table></figure><p>那后面的<code>ld</code>哪里去了呢？实际上在 http 的响应体中直接被截去了。</p><p>然后我们试着将这个长度设置得大一些:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.setHeader</span>(<span class="hljs-string">&#x27;Content-Length&#x27;</span>, <span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><p>此时浏览器显示如下：</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210916161841752.png" alt="image-20210916161841752"></p><p>直接无法显示了。可以看到<code>Content-Length</code>对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。</p><h4 id="不定长包体"><a href="#不定长包体" class="headerlink" title="不定长包体"></a>不定长包体</h4><p>上述是针对于<code>定长包体</code>，那么对于<code>不定长包体</code>而言是如何传输的呢？</p><p>这里就必须介绍另外一个 http 头部字段了:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">Transfer</span>-Encoding: chunked<br></code></pre></td></tr></table></figure><p>表示分块传输数据，设置这个字段后会自动产生两个效果:</p><ul><li>Content-Length 字段会被忽略</li><li>基于长连接持续推送动态内容</li></ul><p>我们依然以一个实际的例子来模拟分块传输，nodejs 程序如下:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br>const server = http.createServer();<br><br>server.<span class="hljs-literal">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(req.url === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>    res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf8&#x27;</span>);<br>    res.setHeader(<span class="hljs-string">&#x27;Content-Length&#x27;</span>, <span class="hljs-number">10</span>);<br>    res.setHeader(<span class="hljs-string">&#x27;Transfer-Encoding&#x27;</span>, <span class="hljs-string">&#x27;chunked&#x27;</span>);<br>    res.write(<span class="hljs-string">&quot;&lt;p&gt;来啦&lt;/p&gt;&quot;</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      res.write(<span class="hljs-string">&quot;第一次传输&lt;br/&gt;&quot;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      res.write(<span class="hljs-string">&quot;第二次传输&quot;</span>);<br>      res.end()<br>    &#125;, <span class="hljs-number">2000</span>);<br>  &#125;<br>&#125;)<br><br>server.listen(<span class="hljs-number">8009</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;成功启动&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>访问效果入下:</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210917105352387.png" alt="image-20210917105352387"></p><hr><h3 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h3><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921105357172.png" alt="image-20210921105357172"></p><hr><h2 id="8-4-HTTPS协议"><a href="#8-4-HTTPS协议" class="headerlink" title="8.4 HTTPS协议"></a><span id="https">8.4 HTTPS协议</span></h2><p>顾名思义，就是在HTTP（超文本传输协议）的基础上再加一层TLS（传输层安全性协议）或者SSL（安全套接层），说白了就是为了应付HTTP是明文传输的缺点，容易被中间人窃听或者篡改，导致隐私和信息安全出现问题的解决方案。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918144054923.png" alt="image-20210918144054923"></p><h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><h4 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h4><p>握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 <strong>Random1</strong>、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918151748632.png" alt="image-20210918151748632"></p><h4 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h4><p>第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 <strong>Random2</strong>。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918151908297.png" alt="image-20210918151908297"></p><h4 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h4><p>这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918152228237.png" alt="image-20210918152228237"></p><h4 id="Certificate-Verify"><a href="#Certificate-Verify" class="headerlink" title="Certificate Verify"></a>Certificate Verify</h4><p>客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 <strong>Random3</strong>，再用服务端公钥非对称加密 <strong>Random3</strong> 生成 <strong>PreMaster Key</strong>。</p><h4 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h4><p>上面客户端根据服务器传来的公钥生成了 <strong>PreMaster Key</strong>，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 <strong>PreMaster Key</strong> 得到客户端生成的 <strong>Random3</strong>。至此，客户端和服务端都拥有 <strong>Random1</strong> + <strong>Random2</strong> + <strong>Random3</strong>，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。客户端将 <strong>PreMaster Key</strong> 传给服务端的过程如下图所示：</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918152355695.png" alt="image-20210918152355695"></p><h4 id="Encrypted-Handshake-Message-Client"><a href="#Encrypted-Handshake-Message-Client" class="headerlink" title="Encrypted Handshake Message(Client)"></a>Encrypted Handshake Message(Client)</h4><p>这一步对应的是 Client Finish 消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918152438216.png" alt="image-20210918152438216"></p><h4 id="Change-Cipher-Spec-Server"><a href="#Change-Cipher-Spec-Server" class="headerlink" title="Change Cipher Spec(Server)"></a>Change Cipher Spec(Server)</h4><p>这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。</p><h4 id="Encrypted-Handshake-Message-Server"><a href="#Encrypted-Handshake-Message-Server" class="headerlink" title="Encrypted Handshake Message(Server)"></a>Encrypted Handshake Message(Server)</h4><p>这一步对应的是 Server Finish 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918152522642.png" alt="image-20210918152522642"></p><h4 id="Application-Data"><a href="#Application-Data" class="headerlink" title="Application Data"></a>Application Data</h4><p>到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。</p><hr><h3 id="传输过程-1"><a href="#传输过程-1" class="headerlink" title="传输过程"></a>传输过程</h3><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921105440452.png" alt="image-20210921105440452"></p><ul><li><strong>HTTPS传输过程最多会比HTTP多7个RTT</strong></li></ul><p>step1：正常的TCP连接三次握手，这不必说</p><p>step2：然后链接会跳转到HTTPS的网站，毕竟协议都不同，考虑到不可能人会把网址打全，所以还需要跳转一步。</p><p>step3：又是TCP连接，这里需要又一步TCP连接是因为HTTPS的传输端口不同（这个是传输层的，http是80，https是443）。</p><p>step4：完成加密套件的协商和证书的身份确认，这次交互客户端和服务端会协商出相同的密钥交换算法、对称加密算法、内容一致性校验算法、证书签名算法等等。浏览器获取到证书之后，也要验证证书的有效性，是否过期是否撤销。</p><p>step5：浏览器获取CA域名，如果没有命中CA域名的缓存，还需要进行DNS解析，又需要多一次交互。</p><p>step6：解析成功解析ip之后，需要和CA网站进行tcp三次握手。</p><p>step7：这里OCSP请求，全称是Online Certificate Status Protocol，在线证书状态协议，顾名思义用来获取证书状态的请求，这里的状态包括有效、过期、未知。并且可以宽限一段客户端访问证书的时间。</p><p>step8：主要进行密钥协商。</p><hr><h3 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h3><ul><li>CA是Certificate Authority的缩写，也叫“证书授权中心”。它是负责管理和签发证书的第三方机构，作用是检查证书持有者身份的合法性，并签发证书，以防证书被伪造或篡改。</li><li>CA 证书就是CA颁发的证书。 CA证书也就我们常说的数字证书，包含证书拥有者的身份信息，CA机构的签名，公钥和私钥。身份信息用于证明证书持有者的身份；CA签名用于保证身份的真实性；公钥和私钥用于通信过程中加解密，从而保证通讯信息的安全性。</li></ul><h4 id="CA证书内容"><a href="#CA证书内容" class="headerlink" title="CA证书内容"></a>CA证书内容</h4><ul><li>颁发者</li><li>使用者</li><li>版本</li><li>签名算法</li><li>签名哈希算法</li><li>使用者</li><li>公钥</li><li>指纹</li><li>指纹算法</li></ul><hr><h1 id="九、其它"><a href="#九、其它" class="headerlink" title="九、其它"></a>九、其它</h1><h2 id="9-1-Cookie与Session"><a href="#9-1-Cookie与Session" class="headerlink" title="9.1 Cookie与Session"></a>9.1 Cookie与Session</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>存储位置不同：<strong>cookie存放于客户端；session存放于服务端</strong>。</li><li>存储容量不同：单个cookie保存的数据&lt;=4KB，一个站点最多保存20个cookie；而session并没有上限。</li><li>存储方式不同：cookie只能保存ASCII字符串，并需要通过编码当时存储为Unicode字符或者二进制数据；session中能够存储任何类型的数据，例如字符串、整数、集合等。</li><li>隐私策略不同：cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的；session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</li><li>生命周期不同：可以通过设置cookie的属性，达到cookie长期有效的效果；session依赖于名为JSESSIONID的cookie，而该cookie的默认过期时间为-1，只需关闭窗口该session就会失效，因此session不能长期有效。</li><li>服务器压力不同：cookie保存在客户端，不占用服务器资源；session保管在服务器上，每个用户都会产生一个session，如果并发量大的话，则会消耗大量的服务器内存。</li><li>浏览器支持不同：cookie是需要浏览器支持的，如果客户端禁用了cookie，则会话跟踪就会失效；运用session就需要使用URL重写的方式，所有用到session的URL都要进行重写，否则session会话跟踪也会失效。</li><li>跨域支持不同：cookie支持跨域访问，session不支持跨域访问。</li></ol><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="Cookie-属性"><a href="#Cookie-属性" class="headerlink" title="Cookie 属性"></a>Cookie 属性</h4><h5 id="生存周期"><a href="#生存周期" class="headerlink" title="生存周期"></a>生存周期</h5><p>Cookie 的有效期可以通过<strong>Expires</strong>和<strong>Max-Age</strong>两个属性来设置。</p><ul><li><strong>Expires</strong>即<code>过期时间</code></li><li><strong>Max-Age</strong>用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。</li></ul><p>若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>关于作用域也有两个属性: <strong>Domain</strong>和<strong>path</strong>, 给 <strong>Cookie</strong> 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，<code>/</code>表示域名下的任意路径都允许使用 Cookie。</p><h5 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h5><p>如果带上<code>Secure</code>，说明只能通过 HTTPS 传输 cookie。</p><p>如果 cookie 字段带上<code>HttpOnly</code>，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。</p><p>相应的，对于 CSRF 攻击的预防，也有<code>SameSite</code>属性。</p><p><code>SameSite</code>可以设置为三个值，<code>Strict</code>、<code>Lax</code>和<code>None</code>。</p><p><strong>a.</strong> 在<code>Strict</code>模式下，浏览器完全禁止第三方请求携带Cookie。比如请求<code>sanyuan.com</code>网站只能在<code>sanyuan.com</code>域名当中请求才能携带 Cookie，在其他网站请求都不能。</p><p><strong>b.</strong> 在<code>Lax</code>模式，就宽松一点了，但是只能在 <code>get 方法提交表单</code>况或者<code>a 标签发送 get 请求</code>的情况下可以携带 Cookie，其他情况均不能。</p><p><strong>c.</strong> 在<code>None</code>模式下，也就是默认模式，请求会自动携带上 Cookie。</p><h4 id="Cookie-的缺点"><a href="#Cookie-的缺点" class="headerlink" title="Cookie 的缺点"></a>Cookie 的缺点</h4><ol><li>容量缺陷。Cookie 的体积上限只有<code>4KB</code>，只能用来存储少量的信息。</li><li>性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过<code>Domain</code>和<code>Path</code>指定<strong>作用域</strong>来解决。</li><li>安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在<code>HttpOnly</code>为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</li></ol><hr><h2 id="9-2-跨域"><a href="#9-2-跨域" class="headerlink" title="9.2 跨域"></a>9.2 跨域</h2><p>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918143407829.png" alt="image-20210918143407829"></p><h3 id="跨域问题出现原因"><a href="#跨域问题出现原因" class="headerlink" title="跨域问题出现原因"></a>跨域问题出现原因</h3><p>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p><p><strong>同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互</strong>。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</p><h3 id="非同源限制"><a href="#非同源限制" class="headerlink" title="非同源限制"></a>非同源限制</h3><ul><li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</li><li>无法接触非同源网页的 DOM</li><li>无法向非同源地址发送 AJAX 请求</li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><a href="https://igotcha.gitee.io/2021/06/03/JavaWeb/SpringBoot%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F/">后端解决方式</a></p><hr><h2 id="9-3-XSS、CSRF"><a href="#9-3-XSS、CSRF" class="headerlink" title="9.3 XSS、CSRF"></a>9.3 XSS、CSRF</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>XSS：跨站脚本攻击（Cross Site Scripting），攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID等，进而危害数据安全。</p><p>XSS分为存储型XSS、反射型XSS、DOM型XSS</p><ul><li>存储型XSS的恶意代码存在数据库里</li><li>反射型XSS的恶意代码存在URL里。</li><li>DOM型XSS属于前端JavaScript自身的安全漏洞，</li></ul><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><ul><li>窃取cookies</li><li>配合其他漏洞，如CSRF</li><li>插入广告</li></ul><h4 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h4><p>防止 HTML 中出现注入，防止 JavaScript 执行时，执行恶意代码。</p><p>存储型XSS、反射型XSS</p><ul><li><p>纯前端渲染，但是还是要注意避免DOM型XSS漏洞（onload事件和href中的javascript:xxx）</p></li><li><p>转义HTML</p></li><li><p>白名单过滤</p></li></ul><p>DOM型XSS</p><ul><li><p>如果不使用框架，避免直接使用innerHTML，尽量使用.textContent、.setAttribute</p></li><li><p>避免内联事件（onClick,onLoad）等</p></li><li><p>set-cookies设置Http-Only</p></li></ul><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>CSRF：跨站请求伪造（Cross-site request forgery），挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</p><h4 id="危害-1"><a href="#危害-1" class="headerlink" title="危害"></a>危害</h4><p>攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：<strong>个人隐私泄露以及财产安全</strong>。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921115900826.png" alt="image-20210921115900826"></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ul><li>登录受信任网站A，并在本地生成Cookie。</li><li>在不登出A的情况下，访问危险网站B。</li></ul><h4 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h4><ul><li><p>cookies不随着跨域请求发送</p></li><li><p>请求头中的Referer请求头来判断请求来源</p></li><li><p>使用Token</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>计算机网络基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven多模块打包的方式</title>
    <link href="/2021/08/15/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/Maven/Maven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/08/15/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/Maven/Maven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、需求介绍"><a href="#一、需求介绍" class="headerlink" title="一、需求介绍"></a>一、需求介绍</h1><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>最近在做一个基于SpringCloud的微服务项目，项目整体有多个模块。模块分级如下</p><p>其中parent为项目文件夹，下分common、infrastructure、service三个子模块</p><p><img src="/2021/08/15/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/Maven/Maven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E7%9A%84%E6%96%B9%E5%BC%8F/image-20210817160025454.png" alt="image-20210817160025454"></p><h3 id="common模块"><a href="#common模块" class="headerlink" title="common模块"></a>common模块</h3><p>common模块主要包括common-utils、service-base、spring_security模块，这部分都是不需要部署的</p><ul><li><p>common-utils主要定义了一些通用的工具类、异常类、统一返回类以及在微服务里共用的VO</p></li><li><p>service-base中设置了统一处理的配置如Swagger、MybatisPlus，其中<strong>service-base会用到common-utils包下内容</strong></p></li><li><p>spring_security主要是基于Filter实现的统一授权与鉴权</p></li></ul><p><img src="/2021/08/15/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/Maven/Maven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E7%9A%84%E6%96%B9%E5%BC%8F/image-20210817160344186.png" alt="image-20210817160344186"></p><h3 id="infrastructure模块"><a href="#infrastructure模块" class="headerlink" title="infrastructure模块"></a>infrastructure模块</h3><p>infrastructure模块主要包括gateway网关模块，这部分需要部署</p><h3 id="service模块"><a href="#service模块" class="headerlink" title="service模块"></a>service模块</h3><p>service模块主要是业务功能</p><h1 id="二、需要注意的点"><a href="#二、需要注意的点" class="headerlink" title="二、需要注意的点"></a>二、需要注意的点</h1><p>parent模块下，pom文件配置，dependencyManagement管理jar包的版本，与打包插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dependencyManagement管理jar包的版本，让子项目中引用一个依赖而不用显示的列出版本号</span><br><span class="hljs-comment">这个里面的依赖不会立即下载，所以可能报红--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>common下各模块，被依赖的maven子模块的maven插件配置如下(其余maven子模块就不需要配置)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>exec<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>我们现在整合后的maven项目有一个parent工程，打包类型为pom，下面多个spring-boot工程作为它的module，分别为子模块和moduleA,moduleB。假如moduleA依赖于子模块。如果你在子模块中使用了spring-boot-maven-plugin的默认配置build，或者在parent工程中使用spring-boot-maven-plugin的默认配置build。那么在clean package的时候会发现moduleA找不到子模块中的类。原因就是默认打包出来的jar是不可依赖的。</p><p>解决方案：</p><p> 官方告诉我们，你如果不想移代码，好吧，我这样来给你解决，给你打两个jar包，一个用来直接执行，一个用来依赖。于是，你需要指定一个属性classifier，这个属性为可执行jar包的名字后缀。比如我设置<classifier>exec</classifier>，原项目名为Vehicle-business。那么会得到两个jar：Vehicle-business.jar和Vehicle-bussiness-exec.jar</p><p>官方文档位置：84.5 Use a Spring Boot application as a dependency</p><p>总结：回到聚合maven上，如果你在parent工程中使用了spring-boot-maven-plugin作为builder，那么你的依赖module一定要用此解决方案来设置。如果你不在parent工程中用spring-boot-maven-plugin作为builder，就在需要打包的module上使用。</p></blockquote><ul><li>service下各模块</li></ul><p>如果使用了*mapper.xml，并且放在了java目录下，需要进行resources位置的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  项目打包时候也会将java目录下*.xml文件也打包  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>如果，service下模块引用了service-base模块，而service-base模块引用了common-utils模块，那就不要在service模块下再次引用common-utils模块，否则可能造成冲突</strong></p>]]></content>
    
    
    <categories>
      
      <category>软件构建</category>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2021/07/03/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/07/03/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p><img src="/2021/07/03/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210706154645819.png"></p><ul><li><p>二叉树深度优先遍历</p><ul><li>前序遍历：5-4-1-2-6-7-8</li><li>中序遍历：1-4-2-5-7-6-8</li><li>后序遍历：1-2-4-7-8-6-5</li></ul></li><li><p>二叉树广度优先遍历</p><ul><li>层序遍历：5-4-6-1-2-7-8</li></ul></li><li><p>节点定义</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//Definition for a binary tree node.</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> val;<br>      TreeNode left;<br>      TreeNode right;<br>      TreeNode() &#123;&#125;<br>      TreeNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;<br>      TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;<br>          <span class="hljs-keyword">this</span>.val = val;<br>          <span class="hljs-keyword">this</span>.left = left;<br>          <span class="hljs-keyword">this</span>.right = right;<br>      &#125;<br>  &#125;<br> <br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>按照访问根节点——左子树——右子树的方式遍历这棵树</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><ul><li>思想</li><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br> <span class="hljs-keyword">public</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        preTravel(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTravel</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.add(node.val);<br>preTravel(node.left);<br>      preTravel(node.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><ul><li>思想<ul><li>第一步，从<strong>根节点</strong>开始，<strong>先将根节点入栈</strong></li><li>第二步，当栈不为空，开始<strong>出栈</strong>。每出栈一个元素（用temp表示），将元素的值保存到结果链表中</li><li>第三步，如果temp节点的<strong>右孩子</strong>，不为null，就入栈</li><li>第四步，如果temp节点的<strong>左孩子</strong>，不为null，就入栈</li><li>重复步骤2-4，<strong>直至栈为空</strong></li></ul></li><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br> <span class="hljs-keyword">public</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        preTravel(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTravel</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>      Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>      stack.add(node);<br>      <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>          TreeNode temp = stack.pop();<br>          res.add(temp.val);<br>          <span class="hljs-keyword">if</span>(temp.right!=<span class="hljs-keyword">null</span>)&#123;<br>              stack.add(temp.right);<br>            &#125;<br>          <span class="hljs-keyword">if</span>(temp.left!=<span class="hljs-keyword">null</span>)&#123;<br>              stack.add(temp.left);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在迭代方式遍历时，主要执行了两项操作</p><ol><li>处理：将元素放进res</li><li>访问：遍历节点</li></ol></blockquote><hr><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>按照访问左子树——根节点——右子树的方式遍历这棵树</p><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><ul><li>思想</li><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br> <span class="hljs-keyword">public</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        midTravel(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midTravel</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>midTravel(node.left);<br>        res.add(node.val);<br>      midTravel(node.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h4><ul><li>思想<ul><li>第一步，从<strong>根节点</strong>开始，扫描<strong>左子树</strong>，每走一步就将<strong>当前节点入栈</strong></li><li>第二步，当节点为空时，开始<strong>出栈</strong>。每出栈一个元素（用temp表示），将元素的值保存到结果链表中</li><li>第三步，扫描temp节点的<strong>左子树</strong>，每走一步就将<strong>当前节点入栈</strong>（重复步骤一）</li><li>重复步骤1-3，<strong>直至栈为空</strong></li></ul></li><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br> <span class="hljs-keyword">public</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        midTravel(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midTravel</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>      <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>      <br>      <span class="hljs-keyword">while</span>(!stack.isEmpty() || node!=<span class="hljs-keyword">null</span>)&#123;<br>          <span class="hljs-keyword">if</span>(node!=<span class="hljs-keyword">null</span>)&#123;<br>            stack.add(node);<br>            node = node.left;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            TreeNode temp = stack.pop();<br>            res.add(temp.val);<br>            node = temp.right;<br>          &#125;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><ul><li>思想</li><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br> <span class="hljs-keyword">public</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        lastTravel(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastTravel</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>lastTravel(node.left);<br>      lastTravel(node.right);<br>        res.add(node.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h4><h5 id="方法一：转为先序遍历变种"><a href="#方法一：转为先序遍历变种" class="headerlink" title="方法一：转为先序遍历变种"></a>方法一：转为先序遍历变种</h5><ul><li><p>思路</p><p>先序遍历是中左右，后续遍历是左右中，那么只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转res链表，得到的顺序就是左右中了</p></li><li><p>代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br> <span class="hljs-keyword">public</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        lastTravel(root);<br>        Collections.reverse(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastTravel</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>      Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>      stack.add(node);<br>      <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>          TreeNode temp = stack.pop();<br>          res.add(temp.val);<br>          <span class="hljs-keyword">if</span>(temp.left!=<span class="hljs-keyword">null</span>)&#123;<br>              stack.add(temp.left);<br>            &#125;<br>          <span class="hljs-keyword">if</span>(temp.right!=<span class="hljs-keyword">null</span>)&#123;<br>              stack.add(temp.right);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="前中后迭代方式统一写法"><a href="#前中后迭代方式统一写法" class="headerlink" title="前中后迭代方式统一写法"></a>前中后迭代方式统一写法</h3><p>迭代法实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了</p><p>其实<strong>针对三种遍历方式，使用迭代法是可以写出统一风格的代码！</strong></p><p>以中序遍历为例，无法同时解决<strong>访问节点</strong>（遍历节点）和<strong>处理节点</strong>（将元素放进结果集）不一致的情况。</p><p>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</p><p>如何标记呢，就是<strong>要处理的节点放入栈之后，紧接着放入一个空指针作为标记</strong>。 这种方法也可以叫做标记法。</p><h4 id="迭代法先序遍历"><a href="#迭代法先序遍历" class="headerlink" title="迭代法先序遍历"></a>迭代法先序遍历</h4><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br> <span class="hljs-keyword">public</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        preTravel(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTravel</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)&#123;<br>            stack.add(node);<br>        &#125; <br>        <span class="hljs-keyword">while</span> (!stack.empty()) &#123;<br>        TreeNode temp = stack.peek();<br>            <span class="hljs-keyword">if</span> (temp != <span class="hljs-keyword">null</span>) &#123;<br>                stack.pop(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>                <span class="hljs-keyword">if</span> (temp.right!=<span class="hljs-keyword">null</span>)&#123;<br>                    stack.add(temp.right);<span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (temp.left!=<span class="hljs-keyword">null</span>)&#123;<br>                    stack.add(temp.left);<span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>                &#125;<br>                stack.add(temp);<span class="hljs-comment">// 添加中节点</span><br>                stack.add(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br>          &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                stack.pop();           <span class="hljs-comment">// 将空节点弹出</span><br>                temp = stack.peek();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                stack.pop();<br>                res.add(temp.val); <span class="hljs-comment">// 加入到结果集</span><br>         &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迭代法中序遍历"><a href="#迭代法中序遍历" class="headerlink" title="迭代法中序遍历"></a>迭代法中序遍历</h4><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br> <span class="hljs-keyword">public</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        midTravel(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midTravel</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)&#123;<br>            stack.add(node);<br>        &#125; <br>        <span class="hljs-keyword">while</span> (!stack.empty()) &#123;<br>        TreeNode temp = stack.peek();<br>            <span class="hljs-keyword">if</span> (temp != <span class="hljs-keyword">null</span>) &#123;<br>                stack.pop(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>                <span class="hljs-keyword">if</span> (temp.right!=<span class="hljs-keyword">null</span>)&#123;<br>                    stack.add(temp.right);<span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br>                &#125;<br>                stack.add(temp);<span class="hljs-comment">// 添加中节点</span><br>                stack.add(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br>                <span class="hljs-keyword">if</span> (temp.left!=<span class="hljs-keyword">null</span>)&#123;<br>                    stack.add(temp.left);<span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>                &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                stack.pop();           <span class="hljs-comment">// 将空节点弹出</span><br>                temp = stack.peek();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                stack.pop();<br>                res.add(temp.val); <span class="hljs-comment">// 加入到结果集</span><br>         &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迭代法后序遍历"><a href="#迭代法后序遍历" class="headerlink" title="迭代法后序遍历"></a>迭代法后序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br> <span class="hljs-keyword">public</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        lastTravel(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastTravel</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)&#123;<br>            stack.add(node);<br>        &#125; <br>        <span class="hljs-keyword">while</span> (!stack.empty()) &#123;<br>        TreeNode temp = stack.peek();<br>            <span class="hljs-keyword">if</span> (temp != <span class="hljs-keyword">null</span>) &#123;<br>                stack.pop(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br> stack.add(temp);<span class="hljs-comment">// 添加中节点</span><br>                stack.add(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br>                <span class="hljs-keyword">if</span> (temp.right!=<span class="hljs-keyword">null</span>)&#123;<br>                    stack.add(temp.right);<span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (temp.left!=<span class="hljs-keyword">null</span>)&#123;<br>                    stack.add(temp.left);<span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>                &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                stack.pop();           <span class="hljs-comment">// 将空节点弹出</span><br>                temp = stack.peek();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                stack.pop();<br>                res.add(temp.val); <span class="hljs-comment">// 加入到结果集</span><br>         &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><ul><li>思路</li></ul><p>使用广度优先搜索，核心在于队列</p><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>)&#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">int</span> length = queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>                TreeNode node = queue.poll();<br>                temp.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left!=<span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right!=<span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(node.right);<br>                &#125;<br>                <br>            &#125;<br>            res.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h2><p><img src="/2021/07/03/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210706220942585.png" alt="image-20210706220942585"></p><h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        TreeNode temp = root.left;<br>        root.left = root.right;<br>        root.right = temp;<br>        invertTree(root.left);<br>        invertTree(root.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非递归-3"><a href="#非递归-3" class="headerlink" title="非递归"></a>非递归</h3><ul><li>思路</li></ul><p>利用先、中、后、层四种方式之一遍历，依次对节点交换左右子树</p><ul><li>代码</li></ul><p>以先序遍历为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)&#123;<br>            stack.add(root);<br>        &#125; <br>        <span class="hljs-keyword">while</span> (!stack.empty()) &#123;<br>        TreeNode temp = stack.peek();<br>            <span class="hljs-keyword">if</span> (temp != <span class="hljs-keyword">null</span>) &#123;<br>                stack.pop(); <br>                <span class="hljs-keyword">if</span> (temp.right!=<span class="hljs-keyword">null</span>)&#123;<br>                    stack.add(temp.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (temp.left!=<span class="hljs-keyword">null</span>)&#123;<br>                    stack.add(temp.left);<br>                &#125;<br>                stack.add(temp);<br>                stack.add(<span class="hljs-keyword">null</span>); <br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.pop();          <br>                temp = stack.peek();<br>                stack.pop();<br>                <span class="hljs-comment">// 交换左右子树的位置</span><br>                TreeNode left = temp.left;<br>                temp.left = temp.right;<br>                temp.right = left;<br>         &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>针对⼆叉树的问题，解题之前⼀定要想清楚究竟是前中后序遍历，还是层序遍历。</p></blockquote><hr><h2 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h2><h3 id="根据先序遍历和中序遍历构造"><a href="#根据先序遍历和中序遍历构造" class="headerlink" title="根据先序遍历和中序遍历构造"></a>根据先序遍历和中序遍历构造</h3><p><img src="/2021/07/03/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210708110026568.png" alt="image-20210708110026568"></p><ul><li>思路<ul><li>第一步，确定递归终止条件，数组左界限index大于右界限index，返回null</li><li>第二步，取出，先序遍历数组中左界限preorderLeftIndex，作为根节点</li><li>第三步，查找根节点在中序遍历数组对应index，设为inorderRootIndex</li><li>第四步，通过inorderRootIndex- inorderLeftIndex计算左子树长度，用于确定先序遍历中子树右界限</li><li>第五步，递归构造左子树，并连接到根节点</li><li>第六步，递归构造右子树，并连接到根节点</li><li>最后返回根节点</li></ul></li><li>分析图</li></ul><p><img src="/2021/07/03/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210708111313650.png" alt="image-20210708111313650"></p><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Map&lt;Integer,Integer&gt; indexMap;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = inorder.length;<br>        indexMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer,Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i++)&#123;<br>            indexMap.put(inorder[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> buildTree(preorder,inorder,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> preorderLeftIndex, <span class="hljs-keyword">int</span> preorderRightIndex, <span class="hljs-keyword">int</span> inorderLeftIndex, <span class="hljs-keyword">int</span> inorderRightIndex)</span> </span>&#123;<br>            <span class="hljs-comment">// 递归终止判断</span><br>            <span class="hljs-keyword">if</span>(preorderLeftIndex &gt; preorderRightIndex)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 先序遍历第一个点即为根节点</span><br>            <span class="hljs-keyword">int</span> preorderRootIndex = preorderLeftIndex;<br>            <span class="hljs-comment">// 在中序遍历中找的这个点</span><br>            <span class="hljs-keyword">int</span> inorderRootIndex = indexMap.get(preorder[preorderRootIndex]);<br><br>            <span class="hljs-comment">// 建立根节点</span><br>            TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[preorderLeftIndex]);<br><br>            <span class="hljs-comment">// 左子树节点数目</span><br>            <span class="hljs-keyword">int</span> leftSubtreeNum = inorderRootIndex - inorderLeftIndex;<br><br>            <span class="hljs-comment">// 递归构造左子树，并连接到根节点</span><br>            root.left = buildTree(preorder,inorder,preorderLeftIndex+<span class="hljs-number">1</span>,preorderLeftIndex+leftSubtreeNum,inorderLeftIndex,inorderRootIndex-<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// 递归构造右子树，并连接到根节点</span><br>            root.right = buildTree(preorder,inorder,preorderLeftIndex+leftSubtreeNum+<span class="hljs-number">1</span>,preorderRightIndex,inorderRootIndex+<span class="hljs-number">1</span>,inorderRightIndex);<br><br>            <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="根据后序遍历和中序遍历构造"><a href="#根据后序遍历和中序遍历构造" class="headerlink" title="根据后序遍历和中序遍历构造"></a>根据后序遍历和中序遍历构造</h3><p>与根据先序遍历和中序遍历构造方法同理</p><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Map&lt;Integer,Integer&gt; indexMap;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;<br>        indexMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer,Integer&gt;();<br>        <span class="hljs-keyword">int</span> n = inorder.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i++)&#123;<br>            indexMap.put(inorder[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> buildTree(inorder,postorder,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder,<span class="hljs-keyword">int</span> inorderLeftIndex , <span class="hljs-keyword">int</span> inorderRightIndex,<span class="hljs-keyword">int</span> postorderLeftIndex,<span class="hljs-keyword">int</span> postorderRightIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(postorderLeftIndex &gt; postorderRightIndex)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> postorderRootIndex = postorderRightIndex;<br>        <span class="hljs-keyword">int</span> inorderRootIndex = indexMap.get(postorder[postorderRootIndex]);<br>        <br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(postorder[postorderRootIndex]);<br><br>        <span class="hljs-keyword">int</span> leftSubtreeNum = inorderRootIndex - inorderLeftIndex;<br><br>        root.left = buildTree(inorder,postorder,inorderLeftIndex,inorderRootIndex-<span class="hljs-number">1</span>,postorderLeftIndex,postorderLeftIndex + leftSubtreeNum-<span class="hljs-number">1</span>);<br>        root.right = buildTree(inorder,postorder,inorderRootIndex+<span class="hljs-number">1</span>,inorderRightIndex,postorderLeftIndex + leftSubtreeNum,postorderRightIndex-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;    <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-软件设计模式的产生背景"><a href="#1-1-软件设计模式的产生背景" class="headerlink" title="1.1 软件设计模式的产生背景"></a>1.1 软件设计模式的产生背景</h2><p>“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p><p>1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。</p><p>1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。  </p><h2 id="1-2-概念"><a href="#1-2-概念" class="headerlink" title="1.2 概念"></a>1.2 概念</h2><p>软件设计模式（Software Design Pattern），又称<strong>设计模式</strong>，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><h2 id="1-3-设计模式分类"><a href="#1-3-设计模式分类" class="headerlink" title="1.3 设计模式分类"></a>1.3 设计模式分类</h2><ul><li><p><strong>创建型模式</strong></p><p>用于描述“怎样创建对象”，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</p></li><li><p><strong>结构型模式</strong></p><p>用于描述<strong>如何将类或对象按某种布局组成更大的结构</strong>，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p></li><li><p><strong>行为型模式</strong></p><p>用于描述<strong>类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责</strong>。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p></li></ul><h1 id="二、UML图"><a href="#二、UML图" class="headerlink" title="二、UML图"></a>二、UML图</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><p><strong>统一建模语言</strong>（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p><p>UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。</p><h2 id="2-2-类图"><a href="#2-2-类图" class="headerlink" title="2.2 类图"></a>2.2 类图</h2><h3 id="2-2-1-类图概述"><a href="#2-2-1-类图概述" class="headerlink" title="2.2.1 类图概述"></a>2.2.1 类图概述</h3><p>类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p><h3 id="2-2-2-类图作用"><a href="#2-2-2-类图作用" class="headerlink" title="2.2.2 类图作用"></a>2.2.2 类图作用</h3><ul><li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li><li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li></ul><h3 id="2-2-3-类图表示法"><a href="#2-2-3-类图表示法" class="headerlink" title="2.2.3 类图表示法"></a>2.2.3 类图表示法</h3><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 </p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608105004359.png" alt="image-20210608105004359"></p><p>属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：</p><ul><li><p>+：表示public</p></li><li><p>-：表示private</p></li><li><p>#：表示protected</p></li></ul><p>属性的完整表示方式是： <strong>可见性  名称 ：类型 [ = 缺省值]</strong>  </p><p>方法的完整表示方式是： <strong>可见性  名称(参数列表) [ ： 返回类型]</strong></p><blockquote><p>注意：</p><ul><li><p>中括号中的内容表示是可选的</p></li><li><p>也有将类型放在变量名前面，返回值类型放在方法名前面</p></li></ul></blockquote><h3 id="2-2-4-类与类之间关系的表示方式"><a href="#2-2-4-类与类之间关系的表示方式" class="headerlink" title="2.2.4 类与类之间关系的表示方式"></a>2.2.4 类与类之间关系的表示方式</h3><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p><p>关联又可以分为单向关联，双向关联，自关联。</p><h5 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h5><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/customer_address.png"></p><p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p><h5 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h5><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/customer_product.png"></p><p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p><p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List&lt;Product&gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p><h5 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h5><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/node.png"></p><p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p><h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608105351706.png" alt="image-20210608105351706"></p><h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608105455748.png" alt="image-20210608105455748"></p><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608105514595.png" alt="image-20210608105514595"></p><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p><p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608105533186.png" alt="image-20210608105533186"></p><h4 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h4><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如下图所示。</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608105558393.png" alt="image-20210608105558393"></p><h1 id="三、软件设计原则"><a href="#三、软件设计原则" class="headerlink" title="三、软件设计原则"></a>三、软件设计原则</h1><h2 id="3-1-开闭原则"><a href="#3-1-开闭原则" class="headerlink" title="3.1 开闭原则"></a>3.1 开闭原则</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p><p>想要达到这样的效果，我们需要使用接口和抽象类。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>下面以 <code>搜狗输入法</code> 的皮肤为例介绍开闭原则的应用。</p><p>【例】<code>搜狗输入法</code> 的皮肤设计。</p><p>分析：<code>搜狗输入法</code> 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/open-close.png"></p><h2 id="3-2-里氏代换原则"><a href="#3-2-里氏代换原则" class="headerlink" title="3.2 里氏代换原则"></a>3.2 里氏代换原则</h2><p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>下面看一个里氏替换原则中经典的一个例子</p><p>【例】正方形不是长方形。</p><p>在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%8D%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2.png"></p><p>代码如下：</p><p><strong>长方形类（Rectangle）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> length;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> width;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.length = length;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> width;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-keyword">double</span> width)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.width = width;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>正方形（Square）：</strong></p><p>由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-keyword">double</span> width)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setLength(width);<br>        <span class="hljs-keyword">super</span>.setWidth(width);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setLength(length);<br>        <span class="hljs-keyword">super</span>.setWidth(length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RectangleDemo</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(Rectangle rectangle)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) &#123;<br>            rectangle.setWidth(rectangle.getWidth() + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//打印长方形的长和宽</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLengthAndWidth</span><span class="hljs-params">(Rectangle rectangle)</span> </span>&#123;<br>        System.out.println(rectangle.getLength());<br>        System.out.println(rectangle.getWidth());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Rectangle rectangle = <span class="hljs-keyword">new</span> Rectangle();<br>        rectangle.setLength(<span class="hljs-number">20</span>);<br>        rectangle.setWidth(<span class="hljs-number">10</span>);<br>        resize(rectangle);<br>        printLengthAndWidth(rectangle);<br><br>        System.out.println(<span class="hljs-string">&quot;============&quot;</span>);<br><br>        Rectangle rectangle1 = <span class="hljs-keyword">new</span> Square();<br>        rectangle1.setLength(<span class="hljs-number">10</span>);<br>        resize(rectangle1);<br>        printLengthAndWidth(rectangle1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。<br>我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p><p>如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608155207583.png" alt="image-20210608155207583"></p><h2 id="3-3-依赖倒转原则"><a href="#3-3-依赖倒转原则" class="headerlink" title="3.3 依赖倒转原则"></a>3.3 依赖倒转原则</h2><p><strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象</strong>。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>下面看一个例子来理解依赖倒转原则</p><p>【例】组装电脑</p><p>现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。</p><p><strong>不满足依赖倒转类图如下：</strong></p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608155951685.png" alt="image-20210608155951685"></p><p><strong>满足依赖倒转类图如下：</strong></p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608160101862.png" alt="image-20210608160101862"></p><h2 id="3-4-接口隔离原则"><a href="#3-4-接口隔离原则" class="headerlink" title="3.4 接口隔离原则"></a>3.4 接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p><p>下面看一个例子来理解接口隔离原则</p><p>【例】安全门案例</p><p>我们需要创建一个<code>黑马</code>品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.png"></p><p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.png"></p><h2 id="3-5-迪米特法则"><a href="#3-5-迪米特法则" class="headerlink" title="3.5 迪米特法则"></a>3.5 迪米特法则</h2><p>迪米特法则又叫最少知识原则。</p><p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p><p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>下面看一个例子来理解迪米特法则</p><p>【例】明星与经纪人的关系实例</p><p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><p>类图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608160752181.png" alt="image-20210608160752181"></p><h2 id="3-6-合成复用原则"><a href="#3-6-合成复用原则" class="headerlink" title="3.6 合成复用原则"></a>3.6 合成复用原则</h2><p>合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><p>通常类的复用分为<strong>继承复用</strong>和<strong>合成复用</strong>两种。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><p>下面看一个例子来理解合成复用原则</p><p>【例】汽车分类管理程序</p><p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： </p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608161520389.png" alt="image-20210608161520389"></p><p>从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608161528523.png" alt="image-20210608161528523"></p><hr><h1 id="四、创建型模式"><a href="#四、创建型模式" class="headerlink" title="四、创建型模式"></a>四、创建型模式</h1><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。</p><p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p><p>创建型模式分为：</p><ul><li>单例模式</li><li>工厂方法模式</li><li>抽象工程模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="4-1-单例模式"><a href="#4-1-单例模式" class="headerlink" title="4.1 单例模式"></a>4.1 单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时<strong>确保只有单个对象被创建</strong>。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h3 id="4-1-1-单例模式的结构"><a href="#4-1-1-单例模式的结构" class="headerlink" title="4.1.1 单例模式的结构"></a>4.1.1 单例模式的结构</h3><p>单例模式的主要有以下角色：</p><ul><li>单例类。只能创建一个实例的类</li><li>访问类。使用单例类</li></ul><h3 id="4-1-2-单例模式的实现"><a href="#4-1-2-单例模式的实现" class="headerlink" title="4.1.2 单例模式的实现"></a>4.1.2 单例模式的实现</h3><blockquote><p>单例设计模式分类两种：</p><p>​    饿汉式：类加载就会导致该单实例对象被创建    </p><p>​    懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></blockquote><ol><li><p>饿汉式-方式1（静态变量方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 饿汉式</span><br><span class="hljs-comment"> *      静态变量创建类的对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">说明：</font></p><p>​    该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p></li><li><p>饿汉式-方式2（静态代码块方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 恶汉式</span><br><span class="hljs-comment"> *      在静态代码块中创建该类对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">说明：</font></p><p>​    该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p></li><li><p>懒汉式-方式1（线程不安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *  线程不安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">说明：</font></p><p>​    从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p></li><li><p>懒汉式-方式2（线程安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *  线程安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">说明：</font></p><p>该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p></li><li><p>懒汉式-方式3（双重检查锁）</p><p>再来讨论一下懒汉模式中加锁的问题，对于 <code>getInstance()</code> 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123; <br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>   <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//抢到锁之后再次判断是否为null</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 <code>volatile</code> 关键字, <code>volatile</code> 关键字可以保证可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>   <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//抢到锁之后再次判断是否为空</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">小结：</font></p><p>添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p></li></ol><ol start="6"><li><p>懒汉式-方式4（静态内部类方式）</p><p>静态内部类单例模式中实例由内部类创建，由于 <strong>JVM在加载外部类的过程中, 是不会加载静态内部类的</strong>, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 静态内部类方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">说明：</font></p><p>​    第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p><p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><p><font color="red">小结：</font></p><p>静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p></li><li><p>枚举方式</p><p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 枚举方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">说明：</font></p><p>​    枚举方式属于饿汉方式。</p></li></ol><h3 id="4-1-3-存在的问题"><a href="#4-1-3-存在的问题" class="headerlink" title="4.1.3 存在的问题"></a>4.1.3 存在的问题</h3><h4 id="4-1-3-1-问题演示"><a href="#4-1-3-1-问题演示" class="headerlink" title="4.1.3.1 问题演示"></a>4.1.3.1 问题演示</h4><p>破坏单例模式：</p><p>使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。</p><ul><li><p>序列化反序列化</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//往文件中写对象</span><br>        <span class="hljs-comment">//writeObject2File();</span><br>        <span class="hljs-comment">//从文件中读取对象</span><br>        Singleton s1 = readObjectFromFile();<br>        Singleton s2 = readObjectFromFile();<br><br>        <span class="hljs-comment">//判断两个反序列化后的对象是否是同一个对象</span><br>        System.out.println(s1 == s2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">readObjectFromFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建对象输入流对象</span><br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));<br>        <span class="hljs-comment">//第一个读取Singleton对象</span><br>        Singleton instance = (Singleton) ois.readObject();<br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject2File</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//获取Singleton类的对象</span><br>        Singleton instance = Singleton.getInstance();<br>        <span class="hljs-comment">//创建对象输出流</span><br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));<br>        <span class="hljs-comment">//将instance对象写出到文件中</span><br>        oos.writeObject(instance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式。</p></blockquote></li><li><p>反射</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//获取Singleton类的字节码对象</span><br>        Class clazz = Singleton.class;<br>        <span class="hljs-comment">//获取Singleton类的私有无参构造方法对象</span><br>        Constructor constructor = clazz.getDeclaredConstructor();<br>        <span class="hljs-comment">//取消访问检查</span><br>        constructor.setAccessible(<span class="hljs-keyword">true</span>);<br><br>        <span class="hljs-comment">//创建Singleton类的对象s1</span><br>        Singleton s1 = (Singleton) constructor.newInstance();<br>        <span class="hljs-comment">//创建Singleton类的对象s2</span><br>        Singleton s2 = (Singleton) constructor.newInstance();<br><br>        <span class="hljs-comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span><br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式</p></blockquote></li></ul><blockquote><p><font color="red">注意：</font>枚举方式不会出现这两个问题。</p></blockquote><h4 id="4-1-3-2-问题的解决"><a href="#4-1-3-2-问题的解决" class="headerlink" title="4.1.3.2 问题的解决"></a>4.1.3.2 问题的解决</h4><ul><li><p>序列化、反序列方式破坏单例模式的解决方法</p><p>在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下面是为了解决序列化反序列化破解单例模式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>源码解析：</strong></p><p>ObjectInputStream类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">readObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException</span>&#123;<br>    ...<br>    <span class="hljs-comment">// if nested read, passHandle contains handle of enclosing object</span><br>    <span class="hljs-keyword">int</span> outerHandle = passHandle;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object obj = readObject0(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//重点查看readObject0方法</span><br>    .....<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readObject0</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>...<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">switch</span> (tc) &#123;<br>...<br><span class="hljs-keyword">case</span> TC_OBJECT:<br><span class="hljs-keyword">return</span> checkResolve(readOrdinaryObject(unshared));<span class="hljs-comment">//重点查看readOrdinaryObject方法</span><br>...<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        depth--;<br>        bin.setBlockDataMode(oldMode);<br>    &#125;    <br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readOrdinaryObject</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>...<br><span class="hljs-comment">//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，</span><br>    obj = desc.isInstantiable() ? desc.newInstance() : <span class="hljs-keyword">null</span>; <br>    ...<br>    <span class="hljs-comment">// 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span><br>    <span class="hljs-keyword">if</span> (obj != <span class="hljs-keyword">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="hljs-keyword">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;<br>    <span class="hljs-comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span><br>    <span class="hljs-comment">// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。</span><br>    Object rep = desc.invokeReadResolve(obj);<br>     ...<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>反射方式破解单例的解决方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           反射破解单例模式需要添加的代码</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">说明:</font></p><p>​    这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此操作。</p></li></ul><h3 id="4-1-4-JDK源码解析-Runtime类"><a href="#4-1-4-JDK源码解析-Runtime类" class="headerlink" title="4.1.4 JDK源码解析-Runtime类"></a>4.1.4 JDK源码解析-Runtime类</h3><p>Runtime类就是使用的单例设计模式。</p><ol><li><p>通过源代码查看使用的是哪儿种单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runtime</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Runtime currentRuntime = <span class="hljs-keyword">new</span> Runtime();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the runtime object associated with the current Java application.</span><br><span class="hljs-comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span><br><span class="hljs-comment">     * methods and must be invoked with respect to the current runtime object.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><br><span class="hljs-comment">     *          Java application.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title">getRuntime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br><br>    <span class="hljs-comment">/** Don&#x27;t let anyone else instantiate this class */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Runtime</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面源代码中可以看出Runtime类使用的是饿汉式（静态属性）方式来实现单例模式的。</p></li><li><p>使用Runtime类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RuntimeDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//获取Runtime类对象</span><br>        Runtime runtime = Runtime.getRuntime();<br><br>        <span class="hljs-comment">//返回 Java 虚拟机中的内存总量。</span><br>        System.out.println(runtime.totalMemory());<br>        <span class="hljs-comment">//返回 Java 虚拟机试图使用的最大内存量。</span><br>        System.out.println(runtime.maxMemory());<br><br>        <span class="hljs-comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span><br>        Process process = runtime.exec(<span class="hljs-string">&quot;ipconfig&quot;</span>);<br>        <span class="hljs-comment">//获取命令执行后的结果，通过输入流获取</span><br>        InputStream inputStream = process.getInputStream();<br>        <span class="hljs-keyword">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>* <span class="hljs-number">100</span>];<br>        <span class="hljs-keyword">int</span> b = inputStream.read(arr);<br>        System.out.println(<span class="hljs-keyword">new</span> String(arr,<span class="hljs-number">0</span>,b,<span class="hljs-string">&quot;gbk&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-2-工厂模式"><a href="#4-2-工厂模式" class="headerlink" title="4.2 工厂模式"></a>4.2 工厂模式</h2><h3 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h3><p>需求：设计一个咖啡店点餐系统。</p><p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p><p>具体类的设计如下：</p><p>   <img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608165703360.png" alt="image-20210608165703360"></p><p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p><p>   在本教程中会介绍三种工厂的使用</p><ul><li>简单工厂模式（不属于GOF的23种经典设计模式）</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h3 id="4-2-2-简单工厂模式"><a href="#4-2-2-简单工厂模式" class="headerlink" title="4.2.2 简单工厂模式"></a>4.2.2 简单工厂模式</h3><p>   简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p><h4 id="4-2-2-1-结构"><a href="#4-2-2-1-结构" class="headerlink" title="4.2.2.1 结构"></a>4.2.2.1 结构</h4><p>   简单工厂包含如下角色：</p><ul><li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品 ：实现或者继承抽象产品的子类</li><li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li></ul><h4 id="4-2-2-2-实现"><a href="#4-2-2-2-实现" class="headerlink" title="4.2.2.2 实现"></a>4.2.2.2 实现</h4><p>   现在使用简单工厂对上面案例进行改进，类图如下：</p><p>   <img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210608165922546.png" alt="image-20210608165922546"></p><p>   工厂类代码如下：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        Coffee coffee = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;americano&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> AmericanoCoffee();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;latte&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> LatteCoffee();<br>        &#125;<br>        <span class="hljs-keyword">return</span> coffee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p><p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p><h4 id="4-2-2-4-优缺点"><a href="#4-2-2-4-优缺点" class="headerlink" title="4.2.2.4 优缺点"></a>4.2.2.4 优缺点</h4><p><strong>优点：</strong></p><p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p><p><strong>缺点：</strong></p><p>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p><h4 id="4-2-2-3-扩展"><a href="#4-2-2-3-扩展" class="headerlink" title="4.2.2.3 扩展"></a>4.2.2.3 扩展</h4><p><strong>静态工厂</strong></p><p>在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        Coffee coffee = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;americano&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> AmericanoCoffee();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;latte&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> LatteCoffee();<br>        &#125;<br>        <span class="hljs-keyword">return</span> coffe;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-工厂方法模式"><a href="#4-2-3-工厂方法模式" class="headerlink" title="4.2.3 工厂方法模式"></a>4.2.3 工厂方法模式</h3><p>   针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><h4 id="4-2-3-1-概念"><a href="#4-2-3-1-概念" class="headerlink" title="4.2.3.1 概念"></a>4.2.3.1 概念</h4><p>   定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p><h4 id="4-2-3-2-结构"><a href="#4-2-3-2-结构" class="headerlink" title="4.2.3.2 结构"></a>4.2.3.2 结构</h4><p>   工厂方法模式的主要角色：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><h4 id="4-2-3-3-实现"><a href="#4-2-3-3-实现" class="headerlink" title="4.2.3.3 实现"></a>4.2.3.3 实现</h4><p>   使用工厂方法模式对上例进行改进，类图如下：</p>   <img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/JAVA学习/黑马-设计模式/资料-java设计模式（图解+框架源码分析+实战）/Java设计模式资料day02/笔记/img/工厂方法模式.png" style="zoom:70%;"><p>代码如下：</p><p>抽象工厂：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoffeeFactory</span> </span>&#123;<br>    <span class="hljs-function">Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体工厂：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LatteCoffeeFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CoffeeFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LatteCoffee();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmericanCoffeeFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CoffeeFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AmericanCoffee();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>咖啡店类：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeStore</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> CoffeeFactory factory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CoffeeStore</span><span class="hljs-params">(CoffeeFactory factory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.factory = factory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">orderCoffee</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        Coffee coffee = factory.createCoffee();<br>        coffee.addMilk();<br>        coffee.addsugar();<br>        <span class="hljs-keyword">return</span> coffee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p><p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p><h4 id="4-2-3-4-优缺点"><a href="#4-2-3-4-优缺点" class="headerlink" title="4.2.3.4 优缺点"></a>4.2.3.4 优缺点</h4><p><strong>优点：</strong></p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li></ul><p><strong>缺点：</strong></p><ul><li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li></ul><h3 id="4-2-4-抽象工厂模式"><a href="#4-2-4-抽象工厂模式" class="headerlink" title="4.2.4 抽象工厂模式"></a>4.2.4 抽象工厂模式</h3><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机等。</p><p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p><p>   <img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210609101939879.png" alt="image-20210609101939879"> </p><h4 id="4-2-4-1-概念"><a href="#4-2-4-1-概念" class="headerlink" title="4.2.4.1 概念"></a>4.2.4.1 概念</h4><p>抽象工厂是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><h4 id="4-2-4-2-结构"><a href="#4-2-4-2-结构" class="headerlink" title="4.2.4.2 结构"></a>4.2.4.2 结构</h4><p>抽象工厂模式的主要角色如下：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li></ul><h4 id="4-2-4-2-实现"><a href="#4-2-4-2-实现" class="headerlink" title="4.2.4.2 实现"></a>4.2.4.2 实现</h4><p>现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：</p><p>   <img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210609103158165.png" alt="image-20210609103158165"></p><p>代码如下：</p><p>抽象工厂：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DessertFactory</span> </span>&#123;<br><br>    <span class="hljs-function">Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Dessert <span class="hljs-title">createDessert</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体工厂：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//美式甜点工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmericanDessertFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DessertFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AmericanCoffee();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Dessert <span class="hljs-title">createDessert</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MatchaMousse();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//意大利风味甜点工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItalyDessertFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DessertFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LatteCoffee();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Dessert <span class="hljs-title">createDessert</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Tiramisu();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。</p><h4 id="4-2-4-3-优缺点"><a href="#4-2-4-3-优缺点" class="headerlink" title="4.2.4.3 优缺点"></a>4.2.4.3 优缺点</h4><p><strong>优点：</strong></p><p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong></p><p>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><h4 id="4-2-4-4-使用场景"><a href="#4-2-4-4-使用场景" class="headerlink" title="4.2.4.4 使用场景"></a>4.2.4.4 使用场景</h4><ul><li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</p></li><li><p>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</p></li><li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p></li></ul><p>如：输入法换皮肤，一整套一起换。</p><h3 id="4-2-5-模式扩展"><a href="#4-2-5-模式扩展" class="headerlink" title="4.2.5 模式扩展"></a>4.2.5 模式扩展</h3><p><strong>简单工厂+配置文件解除耦合</strong></p><p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p><p>第一步：定义配置文件</p><p>为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties</p>   <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">american</span>=<span class="hljs-string">top.igotcha.config_factory.AmericanCoffee</span><br><span class="hljs-attr">latte</span>=<span class="hljs-string">top.igotcha.config_factory.LatteCoffee</span><br></code></pre></td></tr></table></figure><p>   第二步：改进工厂类</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,Coffee&gt; map = <span class="hljs-keyword">new</span> HashMap();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        Properties p = <span class="hljs-keyword">new</span> Properties();<br>        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;bean.properties&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            p.load(is);<br>            <span class="hljs-comment">//遍历Properties集合对象</span><br>            Set&lt;Object&gt; keys = p.keySet();<br>            <span class="hljs-keyword">for</span> (Object key : keys) &#123;<br>                <span class="hljs-comment">//根据键获取值（全类名）</span><br>                String className = p.getProperty((String) key);<br>                <span class="hljs-comment">//获取字节码对象</span><br>                Class clazz = Class.forName(className);<br>                Coffee obj = (Coffee) clazz.newInstance();<br>                map.put((String)key,obj);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> map.get(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</p><h3 id="4-2-6-JDK源码解析-Collection-iterator方法"><a href="#4-2-6-JDK源码解析-Collection-iterator方法" class="headerlink" title="4.2.6 JDK源码解析-Collection.iterator方法"></a>4.2.6 JDK源码解析-Collection.iterator方法</h3>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;令狐冲&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;风清扬&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;任我行&quot;</span>);<br><br>        <span class="hljs-comment">//获取迭代器对象</span><br>        Iterator&lt;String&gt; it = list.iterator();<br>        <span class="hljs-comment">//使用迭代器遍历</span><br>        <span class="hljs-keyword">while</span>(it.hasNext()) &#123;<br>            String ele = it.next();<br>            System.out.println(ele);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：</p><p>   <img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210609110524636.png" alt="image-20210609110524636"></p><p>Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。</p><blockquote><p>另：</p><ul><li><p>DateForamt类中的getInstance()方法使用的是工厂模式；</p></li><li><p>Calendar类中的getInstance()方法使用的是工厂模式；</p></li></ul></blockquote><hr><h2 id="4-3-原型模式"><a href="#4-3-原型模式" class="headerlink" title="4.3 原型模式"></a>4.3 原型模式</h2><h3 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><h3 id="4-3-2-结构"><a href="#4-3-2-结构" class="headerlink" title="4.3.2 结构"></a>4.3.2 结构</h3><p>原型模式包含如下角色：</p><ul><li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><p>接口类图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png"></p><h3 id="4-3-3-实现"><a href="#4-3-3-实现" class="headerlink" title="4.3.3 实现"></a>4.3.3 实现</h3><p>原型模式的克隆分为浅克隆和深克隆。</p><blockquote><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p></blockquote><p>Java中的Object类中提供了 <code>clone()</code> 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：</p><p><strong>Realizetype（具体的原型类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Realizetype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Realizetype</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;具体的原型对象创建完成！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Realizetype <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;具体原型复制成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> (Realizetype) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>PrototypeTest（测试访问类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        Realizetype r1 = <span class="hljs-keyword">new</span> Realizetype();<br>        Realizetype r2 = r1.clone();<br><br>        System.out.println(<span class="hljs-string">&quot;对象r1和r2是同一个对象？&quot;</span> + (r1 == r2)); <span class="hljs-comment">//输出 false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-4-案例"><a href="#4-3-4-案例" class="headerlink" title="4.3.4 案例"></a>4.3.4 案例</h3><p><strong>用原型模式生成“三好学生”奖状</strong></p><p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p><p>类图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210609145501782.png" alt="image-20210609145501782"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//奖状类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Citation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;同学：在2021学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Citation <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (Citation) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试访问类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CitationTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        Citation c1 = <span class="hljs-keyword">new</span> Citation();<br>        c1.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">//复制奖状</span><br>        Citation c2 = c1.clone();<br>        <span class="hljs-comment">//将奖状的名字修改李四</span><br>        c2.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br><br>        c1.show();<br>        c2.show();<br>        System.out.println(<span class="hljs-string">&quot;对象c1和c2是同一个对象？&quot;</span> + (c1 == c2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210609155316736.png" alt="image-20210609155316736"></p><h3 id="4-3-5-使用场景"><a href="#4-3-5-使用场景" class="headerlink" title="4.3.5 使用场景"></a>4.3.5 使用场景</h3><ul><li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li><li>性能和安全要求比较高。</li></ul><h3 id="4-3-6-扩展（深克隆）"><a href="#4-3-6-扩展（深克隆）" class="headerlink" title="4.3.6 扩展（深克隆）"></a>4.3.6 扩展（深克隆）</h3><p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//奖状类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Citation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Student stu;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getStu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStu</span><span class="hljs-params">(Student stu)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.stu = stu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(stu.getName() + <span class="hljs-string">&quot;同学：在2021学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Citation <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (Citation) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//学生类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CitationTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br><br>        Citation c1 = <span class="hljs-keyword">new</span> Citation();<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;西安&quot;</span>);<br>        c1.setStu(stu);<br><br>        <span class="hljs-comment">//复制奖状</span><br>        Citation c2 = c1.clone();<br>        <span class="hljs-comment">//获取c2奖状所属学生对象</span><br>        Student stu1 = c2.getStu();<br>        stu1.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br><br>        <span class="hljs-comment">//判断stu对象和stu1对象是否是同一个对象</span><br>        System.out.println(<span class="hljs-string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));<br><br>        c1.show();<br>        c2.show();<br>        System.out.println(<span class="hljs-string">&quot;对象c1和c2是同一个对象？&quot;</span> + (c1 == c2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210609155847661.png" alt="image-20210609155847661"></p><ul><li>方法一</li></ul><p>stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CitationTest1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Citation c1 = <span class="hljs-keyword">new</span> Citation();<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;西安&quot;</span>);<br>        c1.setStu(stu);<br><br>        <span class="hljs-comment">//创建对象输出流对象</span><br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));<br>        <span class="hljs-comment">//将c1对象写出到文件中</span><br>        oos.writeObject(c1);<br>        oos.close();<br><br>        <span class="hljs-comment">//创建对象出入流对象</span><br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));<br>        <span class="hljs-comment">//读取对象</span><br>        Citation c2 = (Citation) ois.readObject();<br>        <span class="hljs-comment">//获取c2奖状所属学生对象</span><br>        Student stu1 = c2.getStu();<br>        stu1.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br><br>        <span class="hljs-comment">//判断stu对象和stu1对象是否是同一个对象</span><br>        System.out.println(<span class="hljs-string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));<br><br>        c1.show();<br>        c2.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。</p></blockquote><ul><li>方法二</li></ul><p>递归属性后克隆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CitationTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br><br>        Citation c1 = <span class="hljs-keyword">new</span> Citation();<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;西安&quot;</span>);<br>        c1.setStu(stu);<br><br>        <span class="hljs-comment">//复制奖状</span><br>        Citation c2 = c1.clone();<br>        <span class="hljs-comment">//获取c2奖状所属学生对象</span><br>        Student stu1 = c2.getStu().clone();<br>        stu1.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br>        c2.setStu(stu1);<br>        <span class="hljs-comment">//判断stu对象和stu1对象是否是同一个对象</span><br>        System.out.println(<span class="hljs-string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));<br><br>        c1.show();<br>        c2.show();<br>        System.out.println(<span class="hljs-string">&quot;对象c1和c2是同一个对象？&quot;</span> + (c1 == c2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210609161502530.png" alt="image-20210609161502530"></p><blockquote><p>Citation类和Student类必须实现Cloneable接口</p><p>如果不<code>implements Cloneable</code>，当调用clone()时会抛出CloneNotSupportedException异常</p></blockquote><h2 id="4-4-建造者模式"><a href="#4-4-建造者模式" class="headerlink" title="4.4 建造者模式"></a>4.4 建造者模式</h2><h3 id="4-4-1-概述"><a href="#4-4-1-概述" class="headerlink" title="4.4.1 概述"></a>4.4.1 概述</h3><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210609162853444.png" alt="image-20210609162853444"></p><ul><li>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</li><li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</li><li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</li></ul><h3 id="4-4-2-结构"><a href="#4-4-2-结构" class="headerlink" title="4.4.2 结构"></a>4.4.2 结构</h3><p>建造者（Builder）模式包含如下角色：</p><ul><li><p><strong>抽象建造者类（Builder）</strong>：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 </p></li><li><p><strong>具体建造者类（ConcreteBuilder）</strong>：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 </p></li><li><p><strong>产品类（Product）</strong>：要创建的复杂对象。</p></li><li><p><strong>指挥者类（Director）</strong>：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 </p></li></ul><p>类图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210609164025743.png" alt="image-20210609164025743"></p><h3 id="4-4-3-实例"><a href="#4-4-3-实例" class="headerlink" title="4.4.3 实例"></a>4.4.3 实例</h3><p><strong>创建共享单车</strong></p><p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。</p><p>这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210609164607456.png" alt="image-20210609164607456"></p><p>具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自行车类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bike</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String frame;<br>    <span class="hljs-keyword">private</span> String seat;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> frame;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFrame</span><span class="hljs-params">(String frame)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.frame = frame;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSeat</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> seat;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSeat</span><span class="hljs-params">(String seat)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.seat = seat;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 抽象 builder 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Bike bike = <span class="hljs-keyword">new</span> Bike();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFrame</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSeat</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Bike <span class="hljs-title">createBike</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//摩拜单车Builder类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobikeBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        bike.setFrame(<span class="hljs-string">&quot;铝合金车架&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSeat</span><span class="hljs-params">()</span> </span>&#123;<br>        bike.setSeat(<span class="hljs-string">&quot;真皮车座&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bike <span class="hljs-title">createBike</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> bike;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//ofo单车Builder类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OfoBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        bike.setFrame(<span class="hljs-string">&quot;碳纤维车架&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSeat</span><span class="hljs-params">()</span> </span>&#123;<br>         bike.setSeat(<span class="hljs-string">&quot;橡胶车座&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bike <span class="hljs-title">createBike</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> bike;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//指挥者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Builder builder;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.builder = builder;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bike <span class="hljs-title">construct</span><span class="hljs-params">()</span> </span>&#123;<br>        builder.buildFrame();<br>        builder.buildSeat();<br>        <span class="hljs-keyword">return</span> builder.createBike();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;构建ofo自行车&quot;</span>);<br>        showBike(<span class="hljs-keyword">new</span> OfoBuilder());<br>        System.out.println(<span class="hljs-string">&quot;构建mobike自行车&quot;</span>);<br>        showBike(<span class="hljs-keyword">new</span> MobikeBuilder());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showBike</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        Director director = <span class="hljs-keyword">new</span> Director(builder);<br>        Bike bike = director.construct();<br>        System.out.println(bike.getFrame());<br>        System.out.println(bike.getSeat());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210609165539400.png" alt="image-20210609165539400"></p><p><strong>注意：</strong></p><p>上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以<strong>把指挥者类和抽象建造者进行结合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象 builder 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Bike mBike = <span class="hljs-keyword">new</span> Bike();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFrame</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSeat</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Bike <span class="hljs-title">createBike</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bike <span class="hljs-title">construct</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.buildFrame();<br>        <span class="hljs-keyword">this</span>.BuildSeat();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.createBike();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。</p><h3 id="4-4-4-优缺点"><a href="#4-4-4-优缺点" class="headerlink" title="4.4.4 优缺点"></a>4.4.4 优缺点</h3><p><strong>优点：</strong></p><ul><li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</li><li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</li></ul><p><strong>缺点：</strong></p><p>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><h3 id="4-4-5-使用场景"><a href="#4-4-5-使用场景" class="headerlink" title="4.4.5 使用场景"></a>4.4.5 使用场景</h3><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><ul><li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li><li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li></ul><h3 id="4-4-6-模式扩展"><a href="#4-4-6-模式扩展" class="headerlink" title="4.4.6 模式扩展"></a>4.4.6 模式扩展</h3><p>建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。</p><p>重构前代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String cpu;<br>    <span class="hljs-keyword">private</span> String screen;<br>    <span class="hljs-keyword">private</span> String memory;<br>    <span class="hljs-keyword">private</span> String mainboard;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Phone</span><span class="hljs-params">(String cpu, String screen, String memory, String mainboard)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cpu = cpu;<br>        <span class="hljs-keyword">this</span>.screen = screen;<br>        <span class="hljs-keyword">this</span>.memory = memory;<br>        <span class="hljs-keyword">this</span>.mainboard = mainboard;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCpu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCpu</span><span class="hljs-params">(String cpu)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getScreen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> screen;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScreen</span><span class="hljs-params">(String screen)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.screen = screen;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMemory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemory</span><span class="hljs-params">(String memory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMainboard</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mainboard;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMainboard</span><span class="hljs-params">(String mainboard)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mainboard = mainboard;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Phone&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//构建Phone对象</span><br>        Phone phone = <span class="hljs-keyword">new</span> Phone(<span class="hljs-string">&quot;intel&quot;</span>,<span class="hljs-string">&quot;三星屏幕&quot;</span>,<span class="hljs-string">&quot;金士顿&quot;</span>,<span class="hljs-string">&quot;华硕&quot;</span>);<br>        System.out.println(phone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。</p><p>重构后代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String cpu;<br>    <span class="hljs-keyword">private</span> String screen;<br>    <span class="hljs-keyword">private</span> String memory;<br>    <span class="hljs-keyword">private</span> String mainboard;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Phone</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        cpu = builder.cpu;<br>        screen = builder.screen;<br>        memory = builder.memory;<br>        mainboard = builder.mainboard;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String cpu;<br>        <span class="hljs-keyword">private</span> String screen;<br>        <span class="hljs-keyword">private</span> String memory;<br>        <span class="hljs-keyword">private</span> String mainboard;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">cpu</span><span class="hljs-params">(String val)</span> </span>&#123;<br>            cpu = val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">screen</span><span class="hljs-params">(String val)</span> </span>&#123;<br>            screen = val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">memory</span><span class="hljs-params">(String val)</span> </span>&#123;<br>            memory = val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">mainboard</span><span class="hljs-params">(String val)</span> </span>&#123;<br>            mainboard = val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Phone <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Phone(<span class="hljs-keyword">this</span>);&#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Phone&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Phone phone = <span class="hljs-keyword">new</span> Phone.Builder()<br>                .cpu(<span class="hljs-string">&quot;intel&quot;</span>)<br>                .mainboard(<span class="hljs-string">&quot;华硕&quot;</span>)<br>                .memory(<span class="hljs-string">&quot;金士顿&quot;</span>)<br>                .screen(<span class="hljs-string">&quot;三星&quot;</span>)<br>                .build();<br>        System.out.println(phone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。</p><h2 id="4-5-创建者模式对比"><a href="#4-5-创建者模式对比" class="headerlink" title="4.5 创建者模式对比"></a>4.5 创建者模式对比</h2><h3 id="4-5-1-工厂方法模式VS建造者模式"><a href="#4-5-1-工厂方法模式VS建造者模式" class="headerlink" title="4.5.1 工厂方法模式VS建造者模式"></a>4.5.1 工厂方法模式VS建造者模式</h3><p>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。</p><p>我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</p><h3 id="4-5-2-抽象工厂模式VS建造者模式"><a href="#4-5-2-抽象工厂模式VS建造者模式" class="headerlink" title="4.5.2 抽象工厂模式VS建造者模式"></a>4.5.2 抽象工厂模式VS建造者模式</h3><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p><p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p><p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</p><hr><h1 id="五、结构型模式"><a href="#五、结构型模式" class="headerlink" title="五、结构型模式"></a>五、结构型模式</h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下 7 种：</p><ul><li>代理模式</li><li>适配器模式</li><li>装饰者模式</li><li>桥接模式</li><li>外观模式</li><li>组合模式</li><li>享元模式</li></ul><h2 id="5-1-代理模式"><a href="#5-1-代理模式" class="headerlink" title="5.1 代理模式"></a>5.1 代理模式</h2><h3 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h3><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><p>Java中的代理按照代理类生成时机不同又分为<strong>静态代理</strong>和<strong>动态代理</strong>。<strong>静态代理代理类在编译期就生成</strong>，而<strong>动态代理代理类则是在Java运行时动态生成</strong>。动态代理又有JDK代理和CGLib代理两种。</p><h3 id="5-1-2-结构"><a href="#5-1-2-结构" class="headerlink" title="5.1.2 结构"></a>5.1.2 结构</h3><p>代理（Proxy）模式分为三种角色：</p><ul><li>抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li><li>代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li></ul><h3 id="5-1-3-静态代理"><a href="#5-1-3-静态代理" class="headerlink" title="5.1.3 静态代理"></a>5.1.3 静态代理</h3><p>【例】火车站卖票</p><p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615104119516.png" alt="image-20210615104119516"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//卖票接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrainStation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;火车站卖票&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代售点</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TrainStation station = <span class="hljs-keyword">new</span> TrainStation();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用&quot;</span>);<br>        station.sell();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ProxyPoint pp = <span class="hljs-keyword">new</span> ProxyPoint();<br>        pp.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615104153581.png" alt="image-20210615104153581"></p><h3 id="5-1-4-JDK动态代理"><a href="#5-1-4-JDK动态代理" class="headerlink" title="5.1.4 JDK动态代理"></a>5.1.4 JDK动态代理</h3><p>接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//卖票接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrainStation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;火车站卖票&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理工厂，用来创建代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TrainStation station = <span class="hljs-keyword">new</span> TrainStation();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SellTickets <span class="hljs-title">getProxyObject</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//使用Proxy获取代理对象</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            newProxyInstance()方法参数说明：</span><br><span class="hljs-comment">                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span><br><span class="hljs-comment">                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口</span><br><span class="hljs-comment">                InvocationHandler h ： 代理对象的调用处理程序</span><br><span class="hljs-comment">         */</span><br>        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),<br>                station.getClass().getInterfaces(),<br>                <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                        InvocationHandler中invoke方法参数说明：</span><br><span class="hljs-comment">                            proxy ： 代理对象</span><br><span class="hljs-comment">                            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span><br><span class="hljs-comment">                            args ： 代理对象调用接口方法时传递的实际参数</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>                        System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);<br>                        <span class="hljs-comment">//执行真实对象</span><br>                        Object result = method.invoke(station, args);<br>                        <span class="hljs-keyword">return</span> result;<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-keyword">return</span> sellTickets;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//获取代理对象</span><br>        ProxyFactory factory = <span class="hljs-keyword">new</span> ProxyFactory();<br>        <br>        SellTickets proxyObject = factory.getProxyObject();<br>        proxyObject.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615110246074.png" alt="image-20210615110246074"></p><blockquote><p>ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sun.proxy;<br><br><span class="hljs-keyword">import</span> top.igotcha.demo02.SellTickets;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.UndeclaredThrowableException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;<br>        <span class="hljs-keyword">super</span>(invocationHandler);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>            m3 = Class.forName(<span class="hljs-string">&quot;top.igotcha.demo02.SellTickets&quot;</span>).getMethod(<span class="hljs-string">&quot;sell&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(noSuchMethodException.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(classNotFoundException.getMessage());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m1, <span class="hljs-keyword">new</span> Object[]&#123;object&#125;);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(throwable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m2, <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(throwable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m0, <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(throwable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(throwable);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>从上面的类中，我们可以看到以下几个信息：</p><ul><li>代理类（$Proxy0）实现了SellTickets。说明真实类和代理类实现同样的接口。</li><li>代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。</li></ul></li><li><p>动态代理的执行流程如下</p><pre><code>1. 在测试类中通过代理对象调用sell()方法2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</code></pre></li></ul><h3 id="5-1-5-CGLIB动态代理"><a href="#5-1-5-CGLIB动态代理" class="headerlink" title="5.1.5 CGLIB动态代理"></a>5.1.5 CGLIB动态代理</h3><p>同样是上面的案例，我们再次使用CGLIB代理实现。</p><p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为<strong>JDK动态代理要求必须定义接口，对接口进行代理</strong>。</p><p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p><p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//火车站</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrainStation</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;火车站卖票&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TrainStation target = <span class="hljs-keyword">new</span> TrainStation();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TrainStation <span class="hljs-title">getProxyObject</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span><br>        Enhancer enhancer =<span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">//设置父类的字节码对象</span><br>        enhancer.setSuperclass(target.getClass());<br>        <span class="hljs-comment">//设置回调函数</span><br>        enhancer.setCallback(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">//创建代理对象</span><br>        TrainStation obj = (TrainStation) enhancer.create();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        intercept方法参数说明：</span><br><span class="hljs-comment">            o ： 代理对象</span><br><span class="hljs-comment">            method ： 真实对象中的方法的Method实例</span><br><span class="hljs-comment">            args ： 实际参数</span><br><span class="hljs-comment">            methodProxy ：代理对象中的方法的method实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TrainStation <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);<br>        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建代理工厂对象</span><br>        ProxyFactory factory = <span class="hljs-keyword">new</span> ProxyFactory();<br>        <span class="hljs-comment">//获取代理对象</span><br>        TrainStation proxyObject = factory.getProxyObject();<br><br>        proxyObject.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615110931015.png" alt="image-20210615110931015"></p><h3 id="5-1-6-三种代理的对比"><a href="#5-1-6-三种代理的对比" class="headerlink" title="5.1.6 三种代理的对比"></a>5.1.6 三种代理的对比</h3><ul><li><p>jdk代理和CGLIB代理</p><p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p><p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。</p></li><li><p>动态代理和静态代理</p><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p><p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p></li></ul><h3 id="5-1-7-优缺点"><a href="#5-1-7-优缺点" class="headerlink" title="5.1.7 优缺点"></a>5.1.7 优缺点</h3><p><strong>优点：</strong></p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的复杂度；</li></ul><h3 id="5-1-8-使用场景"><a href="#5-1-8-使用场景" class="headerlink" title="5.1.8 使用场景"></a>5.1.8 使用场景</h3><ul><li><p>远程（Remote）代理</p><p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。</p></li><li><p>防火墙（Firewall）代理</p><p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</p></li><li><p>保护（Protect or Access）代理</p><p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</p></li></ul><hr><h2 id="5-2-适配器模式"><a href="#5-2-适配器模式" class="headerlink" title="5.2 适配器模式"></a>5.2 适配器模式</h2><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h3><p>如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615113910099.png" alt="image-20210615113910099"></p><p><strong>定义：</strong></p><p>​    将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><p>​    适配器模式分为<strong>类适配器模式</strong>和<strong>对象适配器模式</strong>，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><h3 id="5-2-2-结构"><a href="#5-2-2-结构" class="headerlink" title="5.2.2 结构"></a>5.2.2 结构</h3><p>适配器模式（Adapter）包含以下主要角色：</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><h3 id="5-2-3-类适配器模式"><a href="#5-2-3-类适配器模式" class="headerlink" title="5.2.3 类适配器模式"></a>5.2.3 类适配器模式</h3><p>实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><p>【例】读卡器</p><p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。</p><p>类图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615114002146.png" alt="image-20210615114002146"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SD卡的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SDCard</span> </span>&#123;<br>    <span class="hljs-comment">//读取SD卡方法</span><br>    <span class="hljs-function">String <span class="hljs-title">readSD</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//写入SD卡功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeSD</span><span class="hljs-params">(String msg)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//SD卡实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDCardImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SDCard</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readSD</span><span class="hljs-params">()</span> </span>&#123;<br>        String msg = <span class="hljs-string">&quot;SD卡读取到一条消息 :hello word SD&quot;</span>;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeSD</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;SD卡写入了一条消息 : &quot;</span> + msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//电脑类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readSD</span><span class="hljs-params">(SDCard sdCard)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sdCard == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;没有找到SD卡&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sdCard.readSD();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//TF卡接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TFCard</span> </span>&#123;<br>    <span class="hljs-comment">//读取TF卡方法</span><br>    <span class="hljs-function">String <span class="hljs-title">readTF</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//写入TF卡功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeTF</span><span class="hljs-params">(String msg)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//TF卡实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TFCardImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TFCard</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readTF</span><span class="hljs-params">()</span> </span>&#123;<br>        String msg =<span class="hljs-string">&quot;TF卡读取了一条消息 : hello word tf card&quot;</span>;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeTF</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;TF卡写入了一条消息 : &quot;</span> + msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//定义适配器类（SD兼容TF）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDAdapterTF</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TFCardImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SDCard</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readSD</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;读取操作，本来是要读取SD卡，适配器将TF卡转换为SD卡&quot;</span>);<br>        <span class="hljs-keyword">return</span> readTF();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeSD</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;写入操作，本来是要写入SD卡，适配器将TF卡转换为SD卡&quot;</span>);<br>        writeTF(msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Computer computer = <span class="hljs-keyword">new</span> Computer();<br>        SDCard sdCard = <span class="hljs-keyword">new</span> SDCardImpl();<br>        System.out.println(computer.readSD(sdCard));<br><br>        System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br><br>        SDAdapterTF adapter = <span class="hljs-keyword">new</span> SDAdapterTF();<br>        System.out.println(computer.readSD(adapter));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615152948556.png" alt="image-20210615152948556"></p><p>类适配器模式违背了合成复用原则。<strong>类适配器是客户类有一个接口规范的情况下可用，反之不可用</strong>。</p><h3 id="5-2-4-对象适配器模式"><a href="#5-2-4-对象适配器模式" class="headerlink" title="5.2.4 对象适配器模式"></a>5.2.4 对象适配器模式</h3><p>实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p><p>【例】读卡器</p><p>我们使用对象适配器模式将读卡器的案例进行改写。类图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615160737955.png" alt="image-20210615160737955"></p><p>代码如下：</p><p>类适配器模式的代码，只需要修改适配器类（SDAdapterTF）和测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建适配器对象（SD兼容TF）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDAdapterTF</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">SDCard</span> </span>&#123;<br><br>    <span class="hljs-comment">//声明适配者类</span><br>    <span class="hljs-keyword">private</span> TFCard tfCard;<br><span class="hljs-comment">//声明有参构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SDAdapterTF</span><span class="hljs-params">(TFCard tfCard)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tfCard = tfCard;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readSD</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;读取操作，本来是要读取SD卡，适配器将TF卡转换为SD卡&quot;</span>);<br>        <span class="hljs-keyword">return</span> tfCard.readTF();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeSD</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;写入操作，本来是要写入SD卡，适配器将TF卡转换为SD卡&quot;</span>);<br>        tfCard.writeTF(msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Computer computer = <span class="hljs-keyword">new</span> Computer();<br>        SDCard sdCard = <span class="hljs-keyword">new</span> SDCardImpl();<br>        System.out.println(computer.readSD(sdCard));<br><br>        System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br><br>SDAdapterTF adapter = <span class="hljs-keyword">new</span> SDAdapterTF(<span class="hljs-keyword">new</span> TFCardImpl());<br>        System.out.println(computer.readSD(adapter));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615162315118.png" alt="image-20210615162315118"></p><blockquote><p>注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。</p></blockquote><h3 id="5-2-5-应用场景"><a href="#5-2-5-应用场景" class="headerlink" title="5.2.5 应用场景"></a>5.2.5 应用场景</h3><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h3 id="5-2-6-JDK源码解析"><a href="#5-2-6-JDK源码解析" class="headerlink" title="5.2.6 JDK源码解析"></a>5.2.6 JDK源码解析</h3><p>Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。</p><p>InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">return</span> sd.read();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> cbuf[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">return</span> sd.read(cbuf, offset, length);<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615163404196.png" alt="image-20210615163404196"></p><p>从上图可以看出：</p><ul><li>InputStreamReader是对同样实现了Reader的StreamDecoder的封装。</li><li>StreamDecoder不是Java SE API中的内容，是Sun  JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。</li></ul><p><font color="red">结论：</font></p><p>从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式(对象适配器)。</p><hr><h2 id="5-3-装饰者模式"><a href="#5-3-装饰者模式" class="headerlink" title="5.3 装饰者模式"></a>5.3 装饰者模式</h2><h3 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h3><p>我们先来看一个快餐店的例子。</p><p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p><p>使用继承如下图所示</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615164023632.png" alt="image-20210615164023632"></p><p>使用继承的方式存在的问题：</p><ul><li><p>扩展性不好</p><p>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p></li><li><p>产生过多的子类</p></li></ul><p><strong>定义：</strong></p><p>​    指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p><h3 id="5-3-2-结构"><a href="#5-3-2-结构" class="headerlink" title="5.3.2 结构"></a>5.3.2 结构</h3><p>装饰（Decorator）模式中的角色：</p><ul><li>抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ul><h3 id="5-3-3-案例"><a href="#5-3-3-案例" class="headerlink" title="5.3.3 案例"></a>5.3.3 案例</h3><p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p><p>类图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615164205352.png" alt="image-20210615164205352"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//快餐接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastFood</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> price;<br>    <span class="hljs-keyword">private</span> String desc;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FastFood</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FastFood</span><span class="hljs-params">(<span class="hljs-keyword">float</span> price, String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.price = price;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(<span class="hljs-keyword">float</span> price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> desc;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span><span class="hljs-params">(String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//获取价格</span><br>&#125;<br><br><span class="hljs-comment">//炒饭</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FriedRice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FastFood</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FriedRice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;炒饭&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPrice();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//炒面</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FriedNoodles</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FastFood</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FriedNoodles</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-number">12</span>, <span class="hljs-string">&quot;炒面&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPrice();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//配料类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Garnish</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FastFood</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> FastFood fastFood;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FastFood <span class="hljs-title">getFastFood</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> fastFood;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFastFood</span><span class="hljs-params">(FastFood fastFood)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.fastFood = fastFood;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Garnish</span><span class="hljs-params">(FastFood fastFood, <span class="hljs-keyword">float</span> price, String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(price,desc);<br>        <span class="hljs-keyword">this</span>.fastFood = fastFood;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//鸡蛋配料</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Egg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Garnish</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Egg</span><span class="hljs-params">(FastFood fastFood)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(fastFood,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;鸡蛋&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPrice() + getFastFood().getPrice();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getDesc() + getFastFood().getDesc();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//培根配料</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bacon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Garnish</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bacon</span><span class="hljs-params">(FastFood fastFood)</span> </span>&#123;<br><br>        <span class="hljs-keyword">super</span>(fastFood,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;培根&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPrice() + getFastFood().getPrice();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getDesc() + getFastFood().getDesc();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//点一份炒饭</span><br>        FastFood food = <span class="hljs-keyword">new</span> FriedRice();<br>        <span class="hljs-comment">//花费的价格</span><br>        System.out.println(food.getDesc() + <span class="hljs-string">&quot; &quot;</span> + food.cost() + <span class="hljs-string">&quot;元&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>        <span class="hljs-comment">//点一份加鸡蛋的炒饭</span><br>        FastFood food1 = <span class="hljs-keyword">new</span> FriedRice();<br><br>        food1 = <span class="hljs-keyword">new</span> Egg(food1);<br>        <span class="hljs-comment">//花费的价格</span><br>        System.out.println(food1.getDesc() + <span class="hljs-string">&quot; &quot;</span> + food1.cost() + <span class="hljs-string">&quot;元&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>        <span class="hljs-comment">//点一份加培根的炒面</span><br>        FastFood food2 = <span class="hljs-keyword">new</span> FriedNoodles();<br>        food2 = <span class="hljs-keyword">new</span> Bacon(food2);<br>        <span class="hljs-comment">//花费的价格</span><br>        System.out.println(food2.getDesc() + <span class="hljs-string">&quot; &quot;</span> + food2.cost() + <span class="hljs-string">&quot;元&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615165714470.png" alt="image-20210615165714470"></p><p><strong>好处：</strong></p><ul><li><p>饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p></li><li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p></li></ul><h3 id="5-3-4-使用场景"><a href="#5-3-4-使用场景" class="headerlink" title="5.3.4 使用场景"></a>5.3.4 使用场景</h3><ul><li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p><p>不能采用继承的情况主要有两类：</p><ul><li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li><li>第二类是因为类定义不能继承（如final类）</li></ul></li><li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p></li><li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p></li></ul><h3 id="5-3-5-JDK源码解析"><a href="#5-3-5-JDK源码解析" class="headerlink" title="5.3.5 JDK源码解析"></a>5.3.5 JDK源码解析</h3><p>IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。</p><p>我们以BufferedWriter举例来说明，先看看如何使用BufferedWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//创建BufferedWriter对象</span><br>        <span class="hljs-comment">//创建FileWriter对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>);<br>        BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(fw);<br><br>        <span class="hljs-comment">//写数据</span><br>        bw.write(<span class="hljs-string">&quot;hello Buffered&quot;</span>);<br><br>        bw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用起来感觉确实像是装饰者模式，接下来看它们的结构：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615195547677.png" alt="image-20210615195547677"></p><blockquote><p>BufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率。</p></blockquote><h3 id="5-3-6-代理和装饰者的区别"><a href="#5-3-6-代理和装饰者的区别" class="headerlink" title="5.3.6 代理和装饰者的区别"></a>5.3.6 代理和装饰者的区别</h3><p>静态代理和装饰者模式的区别：</p><ul><li>相同点：<ul><li>都要实现与目标类相同的业务接口</li><li><strong>在两个类中都要声明目标对象</strong>，要把目标对象聚合进来</li><li>都可以在不修改目标类的前提下增强目标方法</li></ul></li><li>不同点：<ul><li>目的不同<br>装饰者是为了增强目标对象<br>静态代理是为了保护和隐藏目标对象</li><li>获取目标对象构建的地方不同<br>装饰者是由外界传递进来，可以通过构造方法传递<br>静态代理是在代理类内部创建，以此来隐藏目标对象</li></ul></li></ul><hr><h2 id="5-4-桥接模式"><a href="#5-4-桥接模式" class="headerlink" title="5.4 桥接模式"></a>5.4 桥接模式</h2><h3 id="5-4-1-概述"><a href="#5-4-1-概述" class="headerlink" title="5.4.1 概述"></a>5.4.1 概述</h3><p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615205237542.png" alt="image-20210615205237542"></p><p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。</p><p>试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p><p><strong>定义：</strong></p><p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><h3 id="5-4-2-结构"><a href="#5-4-2-结构" class="headerlink" title="5.4.2 结构"></a>5.4.2 结构</h3><p>桥接（Bridge）模式包含以下主要角色：</p><ul><li>抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。</li><li>扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li>实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。</li><li>具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。</li></ul><h3 id="5-4-3-案例"><a href="#5-4-3-案例" class="headerlink" title="5.4.3 案例"></a>5.4.3 案例</h3><p>【例】视频播放器</p><p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p><p>类图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615210835968.png" alt="image-20210615210835968"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//操作系统版本</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OperatingSystemVersion</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> VideoFile videoFile;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OperatingSystemVersion</span><span class="hljs-params">(VideoFile videoFile)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.videoFile = videoFile;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String fileName)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//Windows版本</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Windows</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OperatingSystemVersion</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Windows</span><span class="hljs-params">(VideoFile videoFile)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(videoFile);<br>    &#125;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String fileName)</span> </span>&#123;<br>        videoFile.decode(fileName);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//mac版本</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mac</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OperatingSystemVersion</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mac</span><span class="hljs-params">(VideoFile videoFile)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(videoFile);<br>    &#125;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String fileName)</span> </span>&#123;<br>videoFile.decode(fileName);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        OperatingSystem os = <span class="hljs-keyword">new</span> Windows(<span class="hljs-keyword">new</span> AVIFile());<br>        os.play(<span class="hljs-string">&quot;战狼3&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210615210809921.png" alt="image-20210615210809921"></p><p><strong>好处：</strong></p><ul><li><p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p><p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。</p></li><li><p>实现细节对客户透明</p></li></ul><h3 id="5-4-4-使用场景"><a href="#5-4-4-使用场景" class="headerlink" title="5.4.4 使用场景"></a>5.4.4 使用场景</h3><ul><li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li></ul><hr><h2 id="5-5-外观模式"><a href="#5-5-外观模式" class="headerlink" title="5.5 外观模式"></a>5.5 外观模式</h2><h3 id="5-5-1-概述"><a href="#5-5-1-概述" class="headerlink" title="5.5.1 概述"></a>5.5.1 概述</h3><p>有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。</p><p><strong>定义：</strong></p><p>外挂模式又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p>外观（Facade）模式是“迪米特法则”的典型应用</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210616093954192.png" alt="image-20210616093954192"></p><h3 id="5-5-2-结构"><a href="#5-5-2-结构" class="headerlink" title="5.5.2 结构"></a>5.5.2 结构</h3><p>外观（Facade）模式包含以下主要角色：</p><ul><li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li></ul><h3 id="5-5-3-案例"><a href="#5-5-3-案例" class="headerlink" title="5.5.3 案例"></a>5.5.3 案例</h3><p>【例】智能家电控制</p><p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210616094351741.png" alt="image-20210616094351741"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//灯类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Light</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打开了灯....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;关闭了灯....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//电视类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TV</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打开了电视....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;关闭了电视....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//控制类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirCondition</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打开了空调....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;关闭了空调....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//智能音箱</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartAppliancesFacade</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Light light;<br>    <span class="hljs-keyword">private</span> TV tv;<br>    <span class="hljs-keyword">private</span> AirCondition airCondition;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmartAppliancesFacade</span><span class="hljs-params">()</span> </span>&#123;<br>        light = <span class="hljs-keyword">new</span> Light();<br>        tv = <span class="hljs-keyword">new</span> TV();<br>        airCondition = <span class="hljs-keyword">new</span> AirCondition();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(message.contains(<span class="hljs-string">&quot;打开&quot;</span>)) &#123;<br>            on();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(message.contains(<span class="hljs-string">&quot;关闭&quot;</span>)) &#123;<br>            off();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我还听不懂你说的！！！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//起床后一键开电器</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;起床了&quot;</span>);<br>        light.on();<br>        tv.on();<br>        airCondition.on();<br>    &#125;<br><br>    <span class="hljs-comment">//睡觉一键关电器</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;睡觉了&quot;</span>);<br>        light.off();<br>        tv.off();<br>        airCondition.off();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建外观对象</span><br>        SmartAppliancesFacade facade = <span class="hljs-keyword">new</span> SmartAppliancesFacade();<br>        <span class="hljs-comment">//客户端直接与外观对象进行交互</span><br>        facade.say(<span class="hljs-string">&quot;打开家电&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;===================&quot;</span>);<br>        facade.say(<span class="hljs-string">&quot;关闭家电&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210616095627669.png" alt="image-20210616095627669"></p><p><strong>好处：</strong></p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li></ul><p><strong>缺点：</strong></p><ul><li>不符合开闭原则，修改很麻烦</li></ul><h3 id="5-5-4-使用场景"><a href="#5-5-4-使用场景" class="headerlink" title="5.5.4 使用场景"></a>5.5.4 使用场景</h3><ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li></ul><h3 id="5-5-5-源码解析"><a href="#5-5-5-源码解析" class="headerlink" title="5.5.5 源码解析"></a>5.5.5 源码解析</h3><p>使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210616095817950.png" alt="image-20210616095817950"></p><p>RequestFacade类就使用了外观模式。先看结构图：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210616095945097.png" alt="image-20210616095945097"></p><p><strong>为什么在此处使用外观模式呢？</strong></p><p>定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request  的实现。然后，将 RequestFacade上转为 ServletRequest  传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。</p><hr><h2 id="5-6-组合模式"><a href="#5-6-组合模式" class="headerlink" title="5.6 组合模式"></a>5.6 组合模式</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h3><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210616100831341.png" alt="image-20210616100831341"></p><p>对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。</p><p><strong>定义：</strong></p><p>又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><h3 id="5-6-2-结构"><a href="#5-6-2-结构" class="headerlink" title="5.6.2 结构"></a>5.6.2 结构</h3><p>组合模式主要包含三种角色：</p><ul><li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li><li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li><li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li></ul><h3 id="5-6-3-案例实现"><a href="#5-6-3-案例实现" class="headerlink" title="5.6.3 案例实现"></a>5.6.3 案例实现</h3><p>【例】软件菜单</p><p>如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210616104020793.png" alt="image-20210616104020793"></p><p>要实现该案例，我们先画出类图：</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210616104051747.png" alt="image-20210616104051747"></p><p><strong>代码实现：</strong></p><p>不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。</p><p>这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//菜单组件  不管是菜单还是菜单项，都应该继承该类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuComponent</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> level;<br><br>    <span class="hljs-comment">//添加菜单</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent menuComponent)</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br><br>    <span class="hljs-comment">//移除菜单</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent menuComponent)</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br><br>    <span class="hljs-comment">//获取指定的子菜单</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br><br>    <span class="hljs-comment">//获取菜单名称</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;MenuComponent&gt; menuComponentList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Menu</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> level)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.level = level;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        menuComponentList = <span class="hljs-keyword">new</span> ArrayList&lt;MenuComponent&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;<br>        menuComponentList.add(menuComponent);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;<br>        menuComponentList.remove(menuComponent);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> menuComponentList.get(i);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; level; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;--&quot;</span>);<br>        &#125;<br>        System.out.println(name);<br>        <span class="hljs-keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;<br>            menuComponent.print();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MenuItem</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> level)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.level = level;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; level; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;--&quot;</span>);<br>        &#125;<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MenuComponent menu1 = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">&quot;菜单管理&quot;</span>, <span class="hljs-number">2</span>);<br>        menu1.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;新增页面&quot;</span>,<span class="hljs-number">3</span>));<br>        menu1.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;删除页面&quot;</span>,<span class="hljs-number">3</span>));<br>        menu1.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;修改页面&quot;</span>,<span class="hljs-number">3</span>));<br>        menu1.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;查询页面&quot;</span>,<span class="hljs-number">3</span>));<br><br>        MenuComponent menu2 = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">&quot;权限管理&quot;</span>, <span class="hljs-number">2</span>);<br>        menu2.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;页面访问&quot;</span>,<span class="hljs-number">3</span>));<br>        menu2.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;提交保存&quot;</span>,<span class="hljs-number">3</span>));<br><br>        MenuComponent menu3 = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">&quot;角色管理&quot;</span>, <span class="hljs-number">2</span>);<br>        menu3.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;新增角色&quot;</span>,<span class="hljs-number">3</span>));<br>        menu3.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;删除角色&quot;</span>,<span class="hljs-number">3</span>));<br>        menu3.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;修改角色&quot;</span>,<span class="hljs-number">3</span>));<br>        menu3.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;查询角色&quot;</span>,<span class="hljs-number">3</span>));<br><br>        MenuComponent menu = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">&quot;系统管理&quot;</span>, <span class="hljs-number">1</span>);<br><br>        menu.add(menu1);<br>        menu.add(menu2);<br>        menu.add(menu3);<br><br>        menu.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210616104903809.png" alt="image-20210616104903809"></p><h3 id="5-6-4-组合模式的分类"><a href="#5-6-4-组合模式的分类" class="headerlink" title="5.6.4 组合模式的分类"></a>5.6.4 组合模式的分类</h3><p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。</p><ul><li><p>透明组合模式</p><p>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 <code>MenuComponent</code> 声明了 <code>add</code>、<code>remove</code> 、<code>getChild</code> 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</p><p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p></li><li><p>安全组合模式</p><p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 <code>Menu</code> 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p></li></ul><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210616105034431.png" alt="image-20210616105034431"></p><h3 id="5-6-5-优点"><a href="#5-6-5-优点" class="headerlink" title="5.6.5 优点"></a>5.6.5 优点</h3><ul><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li><li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ul><h3 id="5-6-6-使用场景"><a href="#5-6-6-使用场景" class="headerlink" title="5.6.6 使用场景"></a>5.6.6 使用场景</h3><p>组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p><hr><h2 id="5-7-享元模式"><a href="#5-7-享元模式" class="headerlink" title="5.7 享元模式"></a>5.7 享元模式</h2><h3 id="5-7-1-概述"><a href="#5-7-1-概述" class="headerlink" title="5.7.1 概述"></a>5.7.1 概述</h3><p><strong>定义：</strong></p><p>运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><h3 id="5-7-2-结构"><a href="#5-7-2-结构" class="headerlink" title="5.7.2 结构"></a>5.7.2 结构</h3><p>享元（Flyweight ）模式中存在以下两种状态：</p><ol><li>内部状态，即不会随着环境的改变而改变的可共享部分。</li><li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</li></ol><p>享元模式的主要有以下角色：</p><ul><li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li>具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li><li>非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li><li>享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ul><h3 id="5-7-3-案例实现"><a href="#5-7-3-案例实现" class="headerlink" title="5.7.3 案例实现"></a>5.7.3 案例实现</h3><p>【例】俄罗斯方块</p><p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210616105934050.png" alt="image-20210616105934050"></p><p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210616110050022.png" alt="image-20210616110050022"></p><p><strong>代码如下：</strong></p><p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractBox</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getShape</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(String color)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;方块形状：&quot;</span> + <span class="hljs-keyword">this</span>.getShape() + <span class="hljs-string">&quot; 颜色：&quot;</span> + color);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBox</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getShape</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBox</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getShape</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;L&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBox</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getShape</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;O&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoxFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BoxFactory</span><span class="hljs-params">()</span> </span>&#123;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;String, AbstractBox&gt;();<br>        AbstractBox iBox = <span class="hljs-keyword">new</span> IBox();<br>        AbstractBox lBox = <span class="hljs-keyword">new</span> LBox();<br>        AbstractBox oBox = <span class="hljs-keyword">new</span> OBox();<br>        map.put(<span class="hljs-string">&quot;I&quot;</span>, iBox);<br>        map.put(<span class="hljs-string">&quot;L&quot;</span>, lBox);<br>        map.put(<span class="hljs-string">&quot;O&quot;</span>, oBox);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BoxFactory <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BoxFactory INSTANCE = <span class="hljs-keyword">new</span> BoxFactory();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBox <span class="hljs-title">getBox</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.get(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-7-5-优缺点和使用场景"><a href="#5-7-5-优缺点和使用场景" class="headerlink" title="5.7.5 优缺点和使用场景"></a>5.7.5 优缺点和使用场景</h3><p><strong>1，优点</strong></p><ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li><li>享元模式中的外部状态相对独立，且不影响内部状态</li></ul><p><strong>2，缺点：</strong></p><p>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</p><p><strong>3，使用场景：</strong></p><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><h3 id="5-7-6-JDK源码解析"><a href="#5-7-6-JDK源码解析" class="headerlink" title="5.7.6 JDK源码解析"></a>5.7.6 JDK源码解析</h3><p>Integer类使用了享元模式。我们先看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer i1 = <span class="hljs-number">127</span>;<br>        Integer i2 = <span class="hljs-number">127</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;i1和i2对象是否是同一个对象？&quot;</span> + (i1 == i2));<br><br>        Integer i3 = <span class="hljs-number">128</span>;<br>        Integer i4 = <span class="hljs-number">128</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;i3和i4对象是否是同一个对象？&quot;</span> + (i3 == i4));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面代码，结果如下：</p><img src="/2021/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/JAVA学习/黑马-设计模式/资料-java设计模式（图解+框架源码分析+实战）/Java设计模式资料day04/笔记/img/image-20200208212930857.png" style="zoom:80%;"><p>为什么第一个输出语句输出的是true，第二个输出语句输出的是false？通过反编译软件进行反编译，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer i1 = Integer.valueOf((<span class="hljs-keyword">int</span>)<span class="hljs-number">127</span>);<br>        Integer i2 Integer.valueOf((<span class="hljs-keyword">int</span>)<span class="hljs-number">127</span>);<br>        System.out.println((String)<span class="hljs-keyword">new</span> StringBuilder().append((String)<span class="hljs-string">&quot;i1\u548ci2\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="hljs-keyword">boolean</span>)(i1 == i2)).toString());<br>        Integer i3 = Integer.valueOf((<span class="hljs-keyword">int</span>)<span class="hljs-number">128</span>);<br>        Integer i4 = Integer.valueOf((<span class="hljs-keyword">int</span>)<span class="hljs-number">128</span>);<br>        System.out.println((String)<span class="hljs-keyword">new</span> StringBuilder().append((String)<span class="hljs-string">&quot;i3\u548ci4\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="hljs-keyword">boolean</span>)(i3 == i4)).toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 <code>valueOf()</code> ，所以只需要看该方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Integer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerCache</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>            String integerCacheHighPropValue =<br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                    i = Math.max(i, <span class="hljs-number">127</span>);<br>                    <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                &#125;<br>            &#125;<br>            high = h;<br>            cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> j = low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>                cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IntegerCache</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code> 之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象。</p><hr><h1 id="6、行为型模式"><a href="#6、行为型模式" class="headerlink" title="6、行为型模式"></a>6、行为型模式</h1><p>行为型模式用于<strong>描述程序在运行时复杂的流程控制</strong>，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为<strong>类行为模式</strong>和<strong>对象行为模式</strong>，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式分为：</p><ul><li>模板方法模式</li><li>策略模式</li><li>命令模式</li><li>职责链模式</li><li>状态模式</li><li>观察者模式</li><li>中介者模式</li><li>迭代器模式</li><li>访问者模式</li><li>备忘录模式</li><li>解释器模式</li></ul><p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p><h2 id="6-1-模板方法模式"><a href="#6-1-模板方法模式" class="headerlink" title="6.1 模板方法模式"></a>6.1 模板方法模式</h2><h3 id="6-1-1-概述"><a href="#6-1-1-概述" class="headerlink" title="6.1.1 概述"></a>6.1.1 概述</h3><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p><p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p><p><strong>定义：</strong></p><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><h3 id="6-1-2-结构"><a href="#6-1-2-结构" class="headerlink" title="6.1.2 结构"></a>6.1.2 结构</h3><p>模板方法（Template Method）模式包含以下主要角色：</p><ul><li><p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p><ul><li><p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p></li><li><p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</p><ul><li><p>抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</p></li><li><p>具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p></li><li><p>钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p><p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</p></li></ul></li></ul></li><li><p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p></li></ul><h3 id="6-1-3-案例实现"><a href="#6-1-3-案例实现" class="headerlink" title="6.1.3 案例实现"></a>6.1.3 案例实现</h3><p>【例】炒菜</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot中实现跨域的5种方式</title>
    <link href="/2021/06/03/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/06/03/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p><p><img src="/2021/06/03/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F/image-20210603102556100.png" alt="image-20210603102556100"></p><h2 id="跨域问题出现原因"><a href="#跨域问题出现原因" class="headerlink" title="跨域问题出现原因"></a>跨域问题出现原因</h2><p>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p><p><strong>同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互</strong>。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</p><h2 id="非同源限制"><a href="#非同源限制" class="headerlink" title="非同源限制"></a>非同源限制</h2><ul><li><p>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</p></li><li><p>无法接触非同源网页的 DOM</p></li><li><p>无法向非同源地址发送 AJAX 请求</p></li></ul><h1 id="二、后端解决方式"><a href="#二、后端解决方式" class="headerlink" title="二、后端解决方式"></a>二、后端解决方式</h1><ul><li>返回新的CorsFilter</li><li>重写 WebMvcConfigurer</li><li>使用注解 @CrossOrigin</li><li>手动设置响应头 (HttpServletResponse)</li><li>自定web filter 实现跨域</li></ul><blockquote><p>注意:</p><ul><li>CorFilter / WebMvConfigurer / @CrossOrigin 需要 SpringMVC 4.2以上版本才支持，对应springBoot 1.3版本以上</li><li>上面前两种方式属于全局 CORS 配置，后两种属于局部 CORS配置。如果使用了局部跨域是会覆盖全局跨域的规则，所以可以通过 @CrossOrigin 注解来进行细粒度更高的跨域资源控制。</li><li>其实无论哪种方案，最终目的都是修改响应头，向响应头中添加浏览器所要求的数据，进而实现跨域</li></ul></blockquote><h2 id="2-1-返回新的-CorsFilter-全局跨域"><a href="#2-1-返回新的-CorsFilter-全局跨域" class="headerlink" title="2.1 返回新的 CorsFilter(全局跨域)"></a>2.1 返回新的 CorsFilter(全局跨域)</h2><p>在任意配置类，返回一个 新的 CorsFIlter Bean ，并添加映射路径和具体的CORS配置路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCorsConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//1. 添加 CORS配置信息</span><br>        CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();<br>        <span class="hljs-comment">//放行哪些原始域</span><br>        config.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">//是否发送 Cookie</span><br>        config.setAllowCredentials(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//放行哪些请求方式</span><br>        config.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">//放行哪些原始请求头部信息</span><br>        config.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">//暴露哪些头部信息</span><br>        config.addExposedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">//2. 添加映射路径</span><br>        UrlBasedCorsConfigurationSource corsConfigurationSource = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();<br>        corsConfigurationSource.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>,config);<br>        <span class="hljs-comment">//3. 返回新的CorsFilter</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(corsConfigurationSource);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-重写-WebMvcConfigurer-全局跨域"><a href="#2-2-重写-WebMvcConfigurer-全局跨域" class="headerlink" title="2.2 重写 WebMvcConfigurer(全局跨域)"></a>2.2 重写 WebMvcConfigurer(全局跨域)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;<br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//是否发送Cookie</span><br>                .allowCredentials(<span class="hljs-keyword">true</span>)<br>                <span class="hljs-comment">//放行哪些原始域</span><br>                .allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)<br>                .allowedMethods(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>&#125;)<br>                .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)<br>                .exposedHeaders(<span class="hljs-string">&quot;*&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-使用自定义filter实现跨域-全局跨域"><a href="#2-3-使用自定义filter实现跨域-全局跨域" class="headerlink" title="2.3 使用自定义filter实现跨域(全局跨域)"></a>2.3 使用自定义filter实现跨域(全局跨域)</h2><p>编写一个过滤器，实现filter接口，并用@WebFilter注解配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter(filterName = &quot;GlobalCorsConfig&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCorsConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        HttpServletResponse response = (HttpServletResponse) res;<br>        HttpServletRequest request = (HttpServletRequest) req;<br><br>        String origin = request.getHeader(<span class="hljs-string">&quot;origin&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(origin)) &#123;<br>            origin = <span class="hljs-string">&quot;*&quot;</span>;<br>        &#125;<br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, origin);<br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;POST, GET, PATCH, DELETE, PUT&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Max-Age&quot;</span>, <span class="hljs-string">&quot;3600&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;Origin, X-Requested-With, Content-Type, Accept&quot;</span>);<br>        chain.doFilter(req, res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-使用注解-局部跨域"><a href="#2-4-使用注解-局部跨域" class="headerlink" title="2.4 使用注解 (局部跨域)"></a>2.4 使用注解 (局部跨域)</h2><p>在控制器(类上)上使用注解 @CrossOrigin：表示该类的所有方法允许跨域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@CrossOrigin(origins = &quot;*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在方法上使用注解 @CrossOrigin：表示该方法允许跨域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-meta">@CrossOrigin(origins = &quot;*&quot;)</span><br><span class="hljs-comment">//@CrossOrigin(value = &quot;http://localhost:8081&quot;) //指定具体ip允许跨域</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-手动设置响应头-局部跨域"><a href="#2-5-手动设置响应头-局部跨域" class="headerlink" title="2.5 手动设置响应头(局部跨域)"></a>2.5 手动设置响应头(局部跨域)</h2><p>使用 HttpServletResponse 对象添加响应头(Access-Control-Allow-Origin)来授权原始域，这里 Origin的值也可以设置为 “*”,表示全部放行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(HttpServletResponse response)</span> </span>&#123;<br>    response.addHeader(<span class="hljs-string">&quot;Access-Allow-Control-Origin&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>框架</category>
      
      <category>Spring</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InfluxDB基础</title>
    <link href="/2021/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93/InfluxDB/InfluxDB%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93/InfluxDB/InfluxDB%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>InfluxDB是一个由InfluxData开发的开源时序型数据。它由Go写成，着力于高性能地查询与存储时序型数据。InfluxDB被广泛应用于存储系统的监控数据，IoT行业的实时数据等场景。</p><h2 id="1-2-特色功能"><a href="#1-2-特色功能" class="headerlink" title="1.2 特色功能"></a>1.2 特色功能</h2><ul><li>基于时间序列，支持与时间有关的相关函数（如最大，最小，求和等）</li><li>可度量性：你可以实时对大量数据进行计算</li><li>基于事件：它支持任意的事件数据</li></ul><h2 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3 特点"></a>1.3 特点</h2><ul><li>无结构（无模式）：可以是任意数量的列</li><li>可拓展</li><li>支持min, max, sum, count, mean, median 等一系列函数，方便统计</li><li>原生的HTTP支持，内置HTTP API</li><li>强大的类SQL语法</li><li>自带管理界面，方便使用</li></ul><h2 id="1-4-Docker内安装"><a href="#1-4-Docker内安装" class="headerlink" title="1.4 Docker内安装"></a>1.4 Docker内安装</h2><ol><li>搜索InfluxDB镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search influxdb<br></code></pre></td></tr></table></figure><ol start="2"><li>拉取influxdb镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull influxdb:1.7<br></code></pre></td></tr></table></figure><ol start="3"><li>创建容器，设置端口映射</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id --name=c_influxdb -p 8083:8083 -p 8086:8086 influxdb<br></code></pre></td></tr></table></figure><h2 id="1-5-配置"><a href="#1-5-配置" class="headerlink" title="1.5 配置"></a>1.5 配置</h2><p>InfluxDB默认使用下面的网络端口：</p><ul><li>TCP端口<code>8086</code>用作InfluxDB的客户端和服务端的http api通信</li><li>TCP端口<code>8088</code>给备份和恢复数据的RPC服务使用</li></ul><p>另外，InfluxDB也提供了多个可能需要自定义端口的插件，所以的端口映射都可以通过配置文件修改，对于默认安装的InfluxDB，这个配置文件位于<code>/etc/influxdb/influxdb.conf</code>。</p><ol><li>进入容器</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it c_influxdb /bin/bash<br></code></pre></td></tr></table></figure><ol start="2"><li>因为需要修改配置文件，所以安装vim</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get update<br>apt-get install vim<br></code></pre></td></tr></table></figure><ol start="3"><li>配置admin用户认证登陆</li></ol><p>不管是yum安装，亦或者是docker安装的方式，influxdb默认安装完毕之后，并不会自带用户认证的功能，直接就可以进行访问的了。</p><p>对于这种不设置防备的措施，总体来说，不是很好。因此，需要设置用户认证。</p><ul><li><p>通过shell登录，influxdb</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">infulx</span><br></code></pre></td></tr></table></figure></li></ul><p><img src="/2021/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93/InfluxDB/InfluxDB%E5%9F%BA%E7%A1%80/image-20210508114018443.png" alt="image-20210508114018443"></p><ul><li>创建admin用户</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CREATE USER root with PASSWORD &#x27;123456&#x27; WITH ALL PRIVILEGES<br></code></pre></td></tr></table></figure><ul><li>进行验证</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">auth<br></code></pre></td></tr></table></figure><p><img src="/2021/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93/InfluxDB/InfluxDB%E5%9F%BA%E7%A1%80/image-20210508114313954.png" alt="image-20210508114313954"></p><ul><li>查看是否授权管理员权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">show users<br></code></pre></td></tr></table></figure><p><img src="/2021/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93/InfluxDB/InfluxDB%E5%9F%BA%E7%A1%80/image-20210508114409517.png" alt="image-20210508114409517"></p><ul><li>在配置文件启用认证</li></ul><p>默认情况下，influxdb的配置文件是禁用认证策略的，所以需要修改设置一下。</p><p>编辑配置文件<code>vim /etc/influxdb/influxdb.conf</code>，把 <code>[http]</code> 下的 <code>auth-enabled</code> 选项设置为 <code>true</code> 。docker里安装的influxdb的是没有http这一项，直接加上就好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs conf">[http]<br>  enabled = true<br>  bind-address = &quot;:8086&quot;<br>  auth-enabled = true <br>  log-enabled = true<br>  write-tracing = false<br>  pprof-enabled = false<br>  https-enabled = false<br>  https-certificate = &quot;/etc/ssl/influxdb.pem&quot;<br></code></pre></td></tr></table></figure><ul><li>重启容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart c_influxdb <br></code></pre></td></tr></table></figure><ol start="4"><li>使用外部机器连接容器中的influxdb</li></ol><p><img src="/2021/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93/InfluxDB/InfluxDB%E5%9F%BA%E7%A1%80/image-20210508114911108.png" alt="image-20210508114911108"></p><blockquote><p>之后再访问需要 带上用户名、密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">influx -username &#x27;用户名&#x27; -password &#x27;密码&#x27;<br></code></pre></td></tr></table></figure><p>当配置了admin认证用户之后，进行http的api请求的时候也要带上用户名和密码的参数，不然无法执行</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">curl</span> -G <span class="hljs-string">&quot;http://localhost:8086/query&quot;</span> -u username:password --<span class="hljs-meta">data</span>-urlencode <span class="hljs-string">&quot;q=SHOW DATABASES&quot;</span><br><span class="hljs-symbol">curl</span> -G <span class="hljs-string">&quot;http://localhost:8086/query&quot;</span> --<span class="hljs-meta">data</span>-urlencode <span class="hljs-string">&quot;u=username&quot;</span> --<span class="hljs-meta">data</span>-urlencode <span class="hljs-string">&quot;p=password&quot;</span> --<span class="hljs-meta">data</span>-urlencode <span class="hljs-string">&quot;q=SHOW DATABASES&quot;</span><br><span class="hljs-symbol">curl</span> -G <span class="hljs-string">&quot;http://localhost:8086/query?u=username&amp;p=password&amp;q=SHOW+DATABASES&quot;</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h1><h2 id="2-1-数据格式"><a href="#2-1-数据格式" class="headerlink" title="2.1 数据格式"></a>2.1 数据格式</h2><p>在 InfluxDB 中，我们可以粗略的将要存入的一条数据看作**一个虚拟的 key 和其对应的 value(field value)**。格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cpu_usage</span>,host=server<span class="hljs-number">01</span>,region=us-west value=<span class="hljs-number">0</span>.<span class="hljs-number">64</span> <span class="hljs-number">1434055562000000000</span><br></code></pre></td></tr></table></figure><p>虚拟的 key 包括以下几个部分： database, retention policy, measurement, tag sets, field name, timestamp。</p><ul><li><p><strong>database</strong>：数据库名，在 InfluxDB 中可以创建多个数据库，不同数据库中的数据文件是隔离存放的，存放在磁盘上的不同目录。</p></li><li><p><strong>retention policy</strong>：存储策略，用于设置数据保留的时间，每个数据库刚开始会自动创建一个默认的存储策略 autogen，数据保留时间为<strong>永久</strong>，之后用户可以自己设置，例如保留最近2小时的数据。插入和查询数据时如果不指定存储策略，则使用默认存储策略，且默认存储策略可以修改。InfluxDB 会定期清除过期的数据。</p></li><li><p><strong>measurement</strong>：测量指标名，例如 cpu_usage 表示 cpu 的使用率。</p></li><li><p><strong>tag sets</strong>：tags 在 InfluxDB 中会按照字典序排序，不管是 tagk 还是 tagv，只要不一致就分别属于两个 key，例如 host=server01,region=us-west 和 host=server02,region=us-west 就是两个不同的 tag set。</p><p>tag–标签，在InfluxDB中，tag是一个非常重要的部分，表名+tag一起作为数据库的索引，是“key-value”的形式。</p></li><li><p><strong>field name</strong>：例如上面数据中的 value 就是 fieldName，InfluxDB 中支持一条数据中插入多个 fieldName，这其实是一个语法上的优化，在实际的底层存储中，是当作多条数据来存储。</p></li><li><p><strong>timestamp</strong>：每一条数据都需要指定一个时间戳，在 TSM 存储引擎中会特殊对待，以为了优化后续的查询操作。</p></li></ul><h2 id="2-2-与传统数据库中的名词做比较"><a href="#2-2-与传统数据库中的名词做比较" class="headerlink" title="2.2 与传统数据库中的名词做比较"></a>2.2 与传统数据库中的名词做比较</h2><table><thead><tr><th>influxDB中的名词</th><th>传统数据库中的概念</th></tr></thead><tbody><tr><td>database</td><td>数据库</td></tr><tr><td>measurement</td><td>数据库中的表</td></tr><tr><td>point</td><td>表里面的一行数据</td></tr></tbody></table><h2 id="2-3-point"><a href="#2-3-point" class="headerlink" title="2.3 point"></a>2.3 point</h2><p>Point由时间戳（time）、数据（field）、标签（tags）组成。</p><p>Point相当于传统数据库里的一行数据，如下表所示：</p><table><thead><tr><th>Point属性</th><th>传统数据库中的概念</th></tr></thead><tbody><tr><td>time</td><td>每个数据记录时间，是数据库中的主索引(会自动生成)</td></tr><tr><td>fields</td><td>各种记录值（没有索引的属性）</td></tr><tr><td>tags</td><td>各种有索引的属性</td></tr><tr><td>series</td><td>表示这个表里面的数据，可以在图表上画成几条线：通过tags排列组合算出来。</td></tr></tbody></table><p><strong>注意</strong></p><ul><li><p>time 相当于表的主键，当一条数据的time和tags完全相同时候，新数据会替换掉旧数据，旧数据则丢失（线上环境尤其要注意）。</p></li><li><p>tags 和time可以作为排序字段，field则不可以。如：ORDER BY time DESC</p></li><li><p>设置了保存策略后，若此保存策略为设置成默认保存策略（一个库可以有多个保存策略），则在查询时，表名（measurement）前，要加上保存策略。</p><blockquote><p>保留策略为<code>two-hour</code>不是默认保存策略，则查询时候，需要指定其保存策略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">select * from two-hour.measure where time &gt; now() -10<br></code></pre></td></tr></table></figure></blockquote></li><li><p>fields和tags的字段类型是由存入的第一条记录值决定的。</p></li></ul><h2 id="2-4-数据类型"><a href="#2-4-数据类型" class="headerlink" title="2.4 数据类型"></a>2.4 数据类型</h2><p><strong>fields和tags的字段类型是由存入的第一条记录值决定的。</strong><br>举例：</p><ul><li>如第一条记录fieldA的值为2，想插入一条记录，fieldA字段值为3.14的值，就会报错。因为该字段已经被初始化为整型了。</li><li>如第一条记录fieldB存储的是3,想插入一条记录，fieldB字段值为hello,则也会报错，该字段已被初始化成整型，不能再写入字符串了。</li></ul><p>因此，<strong>建议只使用字符串类型和浮点类型</strong>，把所有的整型，长整型，浮点型，双精度型统一转为小数格式的浮点类型，再写入数据库，字符串类型的不用做转换，这样就不会出现插入数据失败和丢失数据了。</p><h2 id="2-5-Series"><a href="#2-5-Series" class="headerlink" title="2.5 Series"></a>2.5 Series</h2><p>Series 相当于是 InfluxDB 中一些数据的集合，在同一个 database 中，retention policy、measurement、tag sets 完全相同的数据同属于一个 series，同一个 series 的数据在物理上会按照时间顺序排列存储在一起。</p><p>series 的 key 为 measurement + 所有 tags 的序列化字符串，这个 key 在之后会经常用到。</p><h2 id="2-6-Shard"><a href="#2-6-Shard" class="headerlink" title="2.6 Shard"></a>2.6 Shard</h2><p>Shard 在 InfluxDB 中是一个比较重要的概念，它和 retention policy 相关联。每一个存储策略下会存在许多 shard，每一个 shard 存储一个指定时间段内的数据，并且不重复，例如 7点-8点 的数据落入 shard0 中，8点-9点的数据则落入 shard1 中。每一个 shard 都对应一个底层的 tsm 存储引擎，有独立的 cache、wal、tsm file。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>InfluxDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>InfluxDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原码、反码、补码</title>
    <link href="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81/"/>
    <url>/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="一、机器数和真值"><a href="#一、机器数和真值" class="headerlink" title="一、机器数和真值"></a>一、机器数和真值</h1><p>在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.</p><h2 id="1-1-机器数"><a href="#1-1-机器数" class="headerlink" title="1.1 机器数"></a>1.1 机器数</h2><p>一个数在计算机中的二进制表示形式，叫做这个数的<strong>机器数</strong>。机器数是带符号的，在计算机用一个数的最高位存放符号，<strong>正数为0, 负数为1</strong>。</p><p>比如，十进制中的数 +3 。计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。</p><p>那么，这里的 00000011 和 10000011 就是机器数。</p><blockquote><p>字长是CPU的主要技术指标之一，指的是CPU一次能并行处理的二进制位数，字长总是8的整数倍</p></blockquote><h2 id="1-2-真值"><a href="#1-2-真值" class="headerlink" title="1.2 真值"></a>1.2 真值</h2><blockquote><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p></blockquote><p>例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1</p><hr><h1 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h1><h2 id="2-1-原码"><a href="#2-1-原码" class="headerlink" title="2.1 原码"></a>2.1 原码</h2><p>原码就是用最高位表示符号（<strong>正数为0, 负数为1</strong>），其余位表示值。如果是4字节（32位）二进制：</p><blockquote><p>[+3]原 = 0000 0000 0000 0000 0000 0000 0000 0011</p><p>[-3]原 = 1000 0000 0000 0000 0000 0000 0000 0011</p></blockquote><p>第一位是符号位. 因为第一位是符号位, 所以32位二进制数的取值范围就是:</p><blockquote><p>[1111 1111 1111 1111 1111 1111 1111 1111 , 0111 1111 1111 1111 1111 1111 1111 1111]</p></blockquote><p>即</p><blockquote><p>[-2^32 , 2^32-1]，即[-2147483648 , 2147483647]</p></blockquote><p>原码是人脑最容易理解和计算的表示方式。</p><h2 id="2-2-反码"><a href="#2-2-反码" class="headerlink" title="2.2 反码"></a>2.2 反码</h2><ul><li><p><strong>正数的反码即原码本身。</strong></p></li><li><p><strong>负数则在原码的基础上，除符号位之外的其他各位置反。</strong></p></li></ul><blockquote><p>[+3] = [0000 0000 0000 0000 0000 0000 0000 0011]原 = [0000 0000 0000 0000 0000 0000 0000 0011]反</p><p>[-3] = [1000 0000 0000 0000 0000 0000 0000 0011]原 = [1111 1111 1111 1111 1111 1111 1111 1100]反</p></blockquote><p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。</p><h2 id="2-3-补码"><a href="#2-3-补码" class="headerlink" title="2.3 补码"></a>2.3 补码</h2><ul><li><strong>正数的补码即原码本身。</strong></li><li><strong>负数则在反码基础上+1。</strong></li></ul><blockquote><p>[+3] = [0000 0000 0000 0000 0000 0000 0000 0011]原</p><p>​        = [0000 0000 0000 0000 0000 0000 0000 0011]反 </p><pre><code>    = [0000 0000 0000 0000 0000 0000 0000 0011]补</code></pre><p>[-3]  = [1000 0000 0000 0000 0000 0000 0000 0011]原 </p><p>​        = [1111 1111 1111 1111 1111 1111 1111 1100]反</p><p>​        = [1111 1111 1111 1111 1111 1111 1111 1101]补</p></blockquote><p>对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。</p><hr><h1 id="三、意义"><a href="#三、意义" class="headerlink" title="三、意义"></a>三、意义</h1><p>既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？</p><p>首先, 因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对剩余位置的加减。</p><p>但是对于计算机，加减乘除已经是最基础的运算，要设计的尽量简单。计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂。于是人们想出了将符号位也参与运算的方法。</p><p>我们知道，根据运算法则，减去一个正数等于加上一个负数，即：1-1 = 1 + (-1) = 0，所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。</p><h2 id="3-1-例子"><a href="#3-1-例子" class="headerlink" title="3.1 例子"></a>3.1 例子</h2><p>计算十进制的表达式：3 - 5 = -2，以1字节（8位）存储为例</p><p>以下是使用原码进行运算会出现的问题</p><blockquote><p> 3 - 5  = 3 + (-5)= [0000 0011]原 + [1000 0101] 原 = [1000 1000 ] 原 = -8</p></blockquote><p>如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。</p><p>为了解决原码做减法的问题，出现了反码：</p><p>计算十进制的表达式：3 - 5 = -2，以1字节（8位）存储为例</p><p>以下是使用反码，可以正确计算</p><blockquote><p> 3 - 5  = 3 + (-5)= [0000 0011]原 + [1000 0101] 原 = [0000 0011]反 + [1111 1010]反 = [1111 1101]反 = [1000 0010]原 = -2</p></blockquote><p>但是，当计算十进制的表达式：3 - 3 = 0时，会以下出现问题</p><blockquote><p> 3 - 3  = 3 + (-3)= [0000 0011]原 + [1000 0011] 原 = [0000 0011]反 + [1111 1100]反 = [1111 1111]反 = [1000 0000]原 = -0</p></blockquote><p>问题其实就出现在”0”这个特殊的数值上。虽然人们理解上+0和-0是一样的，但是0带符号是没有任何意义的。而且会有 <code>[0000 0000]原</code> 和 <code>[1000 0000]原</code> 两个编码都表示0。</p><p>于是补码的出现，解决了0的符号以及两个编码的问题：</p><blockquote><p> 3 - 3  = 3 + (-3)= [0000 0011]原 + [1000 0011] 原 </p><p>​                         = [0000 0011]反 + [1111 1100]反</p><p>​                         = [0000 0011]补 + [1111 1101]补 </p><p>​                         = [0000 0000]补 </p><p>​                         =  [0000 0000]原 </p><p>​                         = 0</p></blockquote><p>这样0用[0000 0000]表示，而以前出现问题的-0则不存在了。而且<strong>可以用[1000 0000]表示-128</strong></p><blockquote><p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p></blockquote><p>-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补 就是-128。但是注意因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示。(<strong>对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原，这是不正确的</strong>)</p><h2 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h2><p>在Java中，整数是以补码形式存储的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Integer.toBinaryString(<span class="hljs-number">3</span>));<br>        System.out.println(Integer.toBinaryString(-<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81/image-20210507112537323.png" alt="image-20210507112537323"></p><h2 id="3-3-注意"><a href="#3-3-注意" class="headerlink" title="3.3 注意"></a>3.3 注意</h2><p>因为Java中int范围是[-2147483648,2147483647]</p><p>所以当使用Math.abs(-2147483648)仍会得到-2147483648，需要用long类型接收才能得到2147483648</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>原码反码补码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原码反码补码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机是如何存储小数的</title>
    <link href="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/IEEE%20754/IEEE754/"/>
    <url>/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/IEEE%20754/IEEE754/</url>
    
    <content type="html"><![CDATA[<p>计算机中正整数、负整数按照补码存储，那么小数如何存储表示</p><h1 id="一、知识补充"><a href="#一、知识补充" class="headerlink" title="一、知识补充"></a>一、知识补充</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h2 id="十进制与二进制"><a href="#十进制与二进制" class="headerlink" title="十进制与二进制"></a>十进制与二进制</h2><p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/IEEE%20754/IEEE754/image-20210507115242910.png" alt="image-20210507115242910"></p><h2 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h2><p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/IEEE%20754/IEEE754/image-20210507115335826.png" alt="image-20210507115335826"></p><h2 id="二进制科学计数法"><a href="#二进制科学计数法" class="headerlink" title="二进制科学计数法"></a>二进制科学计数法</h2><p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/IEEE%20754/IEEE754/image-20210507115413107.png" alt="image-20210507115413107"></p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/IEEE%20754/IEEE754/image-20210507115539807.png" alt="image-20210507115539807"></p><h1 id="二、概述"><a href="#二、概述" class="headerlink" title="二、概述"></a>二、概述</h1><p>由于不同机器所选用的基数、尾数位长度和阶码位长度不同，因此对浮点数的表示有较大差别，这不利于软件在不同计算机之间的移植。为此，美国IEEE（电器及电子工程师协会）提出了一个从系统角度支持浮点数的表示方法，称为IEEE754标准（IEEE，1985），当今流行的计算机几乎都采用了这一标准。</p><p>以4字节（32位）的浮点数为例</p><p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/IEEE%20754/IEEE754/image-20210507114236822.png" alt="image-20210507114236822"></p><h1 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h1><h2 id="正数实例"><a href="#正数实例" class="headerlink" title="正数实例"></a>正数实例</h2><h3 id="将十进制数转化为浮点数"><a href="#将十进制数转化为浮点数" class="headerlink" title="将十进制数转化为浮点数"></a>将十进制数转化为浮点数</h3><p>$$<br>78_{10} = 0100 1110_2 = 1.001110 × 2^6<br>$$</p><p>分析如下：</p><ul><li>78为正数，所以最高位符号位为0</li><li>指数为6，所以阶码为6+127=133</li><li>由于尾数只存储有效数字的小数部分，所以尾数为001110。<strong>最高位1规定不显式存储</strong>，以隐含方式存在，计算或恢复数值时再把这个1补上</li></ul><p>最终得到的32位浮点数表示为 0-10000101-00111000000000000000000</p><h3 id="将浮点数转化为十进制数"><a href="#将浮点数转化为十进制数" class="headerlink" title="将浮点数转化为十进制数"></a>将浮点数转化为十进制数</h3><p>0-10000101-00110000000000000000000</p><p>分析如下：</p><ul><li>符号位为0，说明为正数</li><li>阶码为10000101 = 133 ，实际指数值为 133 - 127 = 6</li><li>尾数 = 小数部分0.00111000000000000000000+1 = 1.00111</li></ul><p>因此该浮点数表示的实际数值为<br>$$<br>1.001110 × 2^6=0100 1110_2=78_{10}<br>$$</p><h2 id="负数实例"><a href="#负数实例" class="headerlink" title="负数实例"></a>负数实例</h2><h3 id="将十进制数转化为浮点数-1"><a href="#将十进制数转化为浮点数-1" class="headerlink" title="将十进制数转化为浮点数"></a>将十进制数转化为浮点数</h3><p>$$<br>-16_{10} = 1001 0000_2 = -1.0 × 2^4(原码)<br>$$</p><p>分析如下：</p><ul><li>-16为负数，所以最高位符号位为1</li><li>指数为4，所以阶码为4+127=131</li><li>尾数为0</li></ul><p>最终得到的32位浮点数表示为 1-10000011-00000000000000000000000</p><h1 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h1><h2 id="指数为什么要有偏移量"><a href="#指数为什么要有偏移量" class="headerlink" title="指数为什么要有偏移量"></a>指数为什么要有偏移量</h2><p>原因还是为了计算机处理数据的方便，还记得为什么计算机要有补码吗？原因就是希望在加法运算中将减法运算一并处理了，简化CPU中运算器的设计，确实我们通过补码实现了加减法的统一。</p><p>现在我们将浮点数用这种形式保存，那么计算机怎么比较浮点数的大小呢？</p><p>浮点数表示有两个符号位置，一个是数符S，一个是阶码的符号，如果仅仅采用补码作为阶码，由于阶码有正有负，整个数的符号位和阶数的符号位将导致不能进行简单的大小比较，所以阶数采用了一个无符号的正整数存储。阶数的值直接进行二进制计算，符号位置是默认为0的，于是阶数的值可以为0 到 255</p><h2 id="为什么偏移量设置为2-n-1-而不是2-n"><a href="#为什么偏移量设置为2-n-1-而不是2-n" class="headerlink" title="为什么偏移量设置为2^n-1 , 而不是2^n"></a>为什么偏移量设置为2^n-1 , 而不是2^n</h2><p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/IEEE%20754/IEEE754/image-20210507161059758.png" alt="image-20210507161059758"></p><h2 id="为什么隐含最高位1"><a href="#为什么隐含最高位1" class="headerlink" title="为什么隐含最高位1"></a>为什么隐含最高位1</h2><p>由于使用科学计数法表示二进制数时，最高位固定为1。因此通过省略最高位1，浮点数的尾数可以增加1位来更精确的表示数值（即使用23位尾数表示24位二进制数）</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>IEEE 754</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IEEE 754</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2021/04/25/%E5%AE%B9%E5%99%A8%E5%8C%96/Docker/Docker%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/25/%E5%AE%B9%E5%99%A8%E5%8C%96/Docker/Docker%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-Docker概念"><a href="#1-1-Docker概念" class="headerlink" title="1.1 Docker概念"></a>1.1 Docker概念</h2><ul><li><p>Docker 是一个开源的应用容器引擎，诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后改名为Docker Inc）</p></li><li><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。</p></li><li><p>容器是完全使用沙箱机制，相互隔离</p></li><li><p>容器性能开销极低。</p></li><li><p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）</p></li></ul><h2 id="1-2-Docker架构"><a href="#1-2-Docker架构" class="headerlink" title="1.2 Docker架构"></a>1.2 Docker架构</h2><ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li></ul><p><img src="/2021/04/25/%E5%AE%B9%E5%99%A8%E5%8C%96/Docker/Docker%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210427092906682.png" alt="image-20210427092906682"></p><h2 id="1-3-Docker数据卷"><a href="#1-3-Docker数据卷" class="headerlink" title="1.3 Docker数据卷"></a>1.3 Docker数据卷</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>数据卷是宿主机中的一个目录或文件</li><li>当容器目录和数据卷目录绑定后，对方的修改会立即同步</li><li>一个数据卷可以被多个容器同时挂载</li><li>一个容器也可以被挂载多个数据卷</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>容器数据持久化</li><li>外部机器和容器间接通信</li><li>容器之间数据交换</li></ul><p><img src="/2021/04/25/%E5%AE%B9%E5%99%A8%E5%8C%96/Docker/Docker%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210427154519479.png" alt="image-20210427154519479"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>创建启动容器时，使用 –v 参数 设置数据卷</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run ... –v 宿主机目录(文件):容器内目录(文件) ... <br></code></pre></td></tr></table></figure><p>注意：</p><ol><li><p>目录必须是绝对路径</p></li><li><p>如果目录不存在，会自动创建</p></li><li><p>可以挂载多个数据卷</p></li></ol><h2 id="1-4-Docker安装"><a href="#1-4-Docker安装" class="headerlink" title="1.4 Docker安装"></a>1.4 Docker安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、yum 包更新到最新</span> <br>yum update<br><span class="hljs-meta">#</span><span class="bash"> 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span> <br>yum install -y yum-utils device-mapper-persistent-data lvm2<br><span class="hljs-meta">#</span><span class="bash"> 3、 设置yum源</span><br>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br><span class="hljs-meta">#</span><span class="bash"> 4、 安装docker，出现输入的界面都按 y</span> <br>yum install -y docker-ce<br><span class="hljs-meta">#</span><span class="bash"> 5、 查看docker版本，验证是否验证成功</span><br>docker -v<br></code></pre></td></tr></table></figure><hr><h1 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h1><h2 id="2-1-Docker-进程相关命令"><a href="#2-1-Docker-进程相关命令" class="headerlink" title="2.1 Docker 进程相关命令"></a>2.1 Docker 进程相关命令</h2><ul><li>启动docker服务：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start docker <br></code></pre></td></tr></table></figure><ul><li>停止docker服务：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop docker <br></code></pre></td></tr></table></figure><ul><li>重启docker服务：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart docker<br></code></pre></td></tr></table></figure><ul><li>查看docker服务状态：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status docker <br></code></pre></td></tr></table></figure><ul><li>设置开机启动docker服务：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable docker<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-2-Docker-镜像相关命令"><a href="#2-2-Docker-镜像相关命令" class="headerlink" title="2.2 Docker 镜像相关命令"></a>2.2 Docker 镜像相关命令</h2><ul><li>查看镜像：查看本地所有的镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br>docker images –q # 查看所用镜像的id<br></code></pre></td></tr></table></figure><ul><li>搜索镜像：从网络中查找需要的镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search 镜像名称 <br></code></pre></td></tr></table></figure><ul><li><p>拉取镜像：从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。</p><p>如果不知道镜像版本，可以去docker hub 搜索对应镜像查看</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull 镜像名称<br></code></pre></td></tr></table></figure><ul><li>删除镜像：删除本地镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi 镜像id # 删除指定本地镜像<br>docker rmi `docker images -q`  # 删除所有本地镜像<br></code></pre></td></tr></table></figure><h2 id="2-3-Docker-容器相关命令"><a href="#2-3-Docker-容器相关命令" class="headerlink" title="2.3 Docker 容器相关命令"></a>2.3 Docker 容器相关命令</h2><ul><li><p>查看容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps # 查看正在运行的容器<br>docker ps –a # 查看所有容器<br></code></pre></td></tr></table></figure></li><li><p>创建并启动容器</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run 参数<br>参数说明：<br>-i：保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。<br>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。<br>-d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。<br>-it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器<br>--name：为创建的容器命名。<br></code></pre></td></tr></table></figure><ul><li>进入容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec 参数<br>docker exec -it c_mysql /bin/bash<br></code></pre></td></tr></table></figure><ul><li>退出容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 退出容器，容器不会关闭</span><br>exit<br><span class="hljs-meta">#</span><span class="bash"> 或</span><br>按键Ctrl + D<br></code></pre></td></tr></table></figure><ul><li>停止容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop 容器名称<br></code></pre></td></tr></table></figure><ul><li>启动容器<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start 容器名称<br></code></pre></td></tr></table></figure></li><li>删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm 容器名称<br></code></pre></td></tr></table></figure><ul><li>查看容器信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect 容器名称<br></code></pre></td></tr></table></figure></li></ul><hr><h1 id="三、应用部署"><a href="#三、应用部署" class="headerlink" title="三、应用部署"></a>三、应用部署</h1><h2 id="3-1-MySQL部署"><a href="#3-1-MySQL部署" class="headerlink" title="3.1 MySQL部署"></a>3.1 MySQL部署</h2><ol><li>搜索mysql镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search mysql<br></code></pre></td></tr></table></figure><ol start="2"><li>拉取mysql镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull mysql:5.7<br></code></pre></td></tr></table></figure><ol start="3"><li>创建容器，设置端口映射、目录映射</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在/root目录下创建mysql目录用于存储mysql数据信息</span><br>mkdir ~/mysql<br>cd ~/mysql<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id -p 3306:3306 --name=c_mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql<br></code></pre></td></tr></table></figure><ul><li>参数说明：<ul><li><strong>-p 3306:3306</strong>：将容器的 3306 端口映射到宿主机的 3306端口。</li><li><strong>-v $PWD/conf:/etc/mysql/conf.d</strong>：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。配置目录</li><li><strong>-v $PWD/logs:/logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 /logs。日志目录</li><li><strong>-v $PWD/data:/var/lib/mysql</strong> ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。数据目录</li><li><strong>-e MYSQL_ROOT_PASSWORD=123456：</strong>初始化 root 用户的密码。</li></ul></li></ul><ol start="4"><li>进入容器，操作mysql</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it c_mysql /bin/bash<br></code></pre></td></tr></table></figure><ol start="5"><li>操作mysql，设置可以远程连接</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -uroot -p<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> plugin <span class="hljs-keyword">FROM</span> mysql.user <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">User</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="5"><li>使用外部机器连接容器中的mysql</li></ol><h2 id="3-2-Nginx部署"><a href="#3-2-Nginx部署" class="headerlink" title="3.2 Nginx部署"></a>3.2 Nginx部署</h2><ol><li>搜索nginx镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search nginx<br></code></pre></td></tr></table></figure><ol start="2"><li>拉取nginx镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull nginx<br></code></pre></td></tr></table></figure><ol start="3"><li>创建容器，设置端口映射、目录映射</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在/root目录下创建nginx目录用于存储nginx数据信息</span><br>mkdir ~/nginx<br>cd ~/nginx<br>mkdir conf<br>cd conf<br><span class="hljs-meta">#</span><span class="bash"> 在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容</span><br>vim nginx.conf<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>user  nginx;<br>worker_processes  1;<br><br>error_log  /var/log/nginx/error.log warn;<br>pid        /var/run/nginx.pid;<br><br><br>events &#123;<br>    worker_connections  1024;<br>&#125;<br><br><br>http &#123;<br>    include       /etc/nginx/mime.types;<br>    default_type  application/octet-stream;<br><br>    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;<br>                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;<br>                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;<br><br>    access_log  /var/log/nginx/access.log  main;<br><br>    sendfile        on;<br>    #tcp_nopush     on;<br><br>    keepalive_timeout  65;<br><br>    #gzip  on;<br><br>    include /etc/nginx/conf.d/*.conf;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id  --name=c_nginx -p 80:80 -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/var/log/nginx -v $PWD/html:/usr/share/nginx/htmld nginx<br></code></pre></td></tr></table></figure><ul><li>参数说明：<ul><li><strong>-p 80:80</strong>：将容器的 80端口映射到宿主机的 80 端口。</li><li><strong>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf</strong>：将主机当前目录下的 /conf/nginx.conf 挂载到容器的 :/etc/nginx/nginx.conf。配置目录</li><li><strong>-v $PWD/logs:/var/log/nginx</strong>：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx。日志目录</li></ul></li></ul><ol start="4"><li>使用外部机器访问nginx</li></ol><h2 id="3-3-Redis部署"><a href="#3-3-Redis部署" class="headerlink" title="3.3 Redis部署"></a>3.3 Redis部署</h2><ol><li>搜索redis镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search redis<br></code></pre></td></tr></table></figure><ol start="2"><li>拉取redis镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull redis<br></code></pre></td></tr></table></figure><ol start="3"><li>创建容器，设置端口映射</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id --name=c_redis -p 6379:6379 redis<br></code></pre></td></tr></table></figure><ol start="4"><li>使用外部机器连接redis</li></ol><h2 id="3-4-InfluxDB部署"><a href="#3-4-InfluxDB部署" class="headerlink" title="3.4 InfluxDB部署"></a>3.4 InfluxDB部署</h2><ol><li>搜索InfluxDB镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search influxdb<br></code></pre></td></tr></table></figure><ol start="2"><li>拉取influxdb镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull influxdb<br></code></pre></td></tr></table></figure><ol start="3"><li>创建容器，设置端口映射</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id --name=c_influxdb -p 8083:8083 -p 8086:8086 influxdb<br></code></pre></td></tr></table></figure><ol start="4"><li>使用外部机器连接influxdb</li></ol><h2 id="3-5-Tomcat部署"><a href="#3-5-Tomcat部署" class="headerlink" title="3.5 Tomcat部署"></a>3.5 Tomcat部署</h2><ol><li>搜索tomcat镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search tomcat<br></code></pre></td></tr></table></figure><ol start="2"><li>拉取tomcat镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull tomcat<br></code></pre></td></tr></table></figure><ol start="3"><li>创建容器，设置端口映射、目录映射</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在/root目录下创建tomcat目录用于存储tomcat数据信息</span><br>mkdir ~/tomcat<br>cd ~/tomcat<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id --name=c_tomcat -p 8080:8080 -v $PWD:/usr/local/tomcat/webapps tomcat <br></code></pre></td></tr></table></figure><ul><li>参数说明：<ul><li><p><strong>-p 8080:8080：</strong>将容器的8080端口映射到主机的8080端口</p><p><strong>-v $PWD:/usr/local/tomcat/webapps：</strong>将主机中当前目录挂载到容器的webapps</p></li></ul></li></ul><ol start="4"><li>使用外部机器访问tomcat</li></ol><h2 id="3-6-grafana部署"><a href="#3-6-grafana部署" class="headerlink" title="3.6 grafana部署"></a>3.6 grafana部署</h2><ol><li>搜索grafana镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search grafana<br></code></pre></td></tr></table></figure><ol start="2"><li>拉取grafana镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull grafana/grafana<br></code></pre></td></tr></table></figure><ol start="3"><li>创建容器，设置端口映射、目录映射</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在/root目录下创建grafana目录用于存储grafana数据信息</span><br>mkdir ~/grafana<br>cd ~/grafana<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=c_grafana  -p 3000:3000 grafana/grafana<br></code></pre></td></tr></table></figure><ol start="4"><li>使用外部机器访问grafana，打开 IP:3000</li></ol><ul><li><p>登录页面输入 超级管理员的账号密码</p><p>第一次登录 默认账号 <em><strong>admin</strong></em>，密码<em><strong>admin</strong></em></p></li><li><p>登录成功后第一步先添加数据源，在设置菜单中选择添加数据源</p></li></ul><p><img src="/2021/04/25/%E5%AE%B9%E5%99%A8%E5%8C%96/Docker/Docker%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210510152639624.png" alt="image-20210510152639624"></p>]]></content>
    
    
    <categories>
      
      <category>容器化</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud入门</title>
    <link href="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/"/>
    <url>/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-系统架构演变"><a href="#1-1-系统架构演变" class="headerlink" title="1.1 系统架构演变"></a>1.1 系统架构演变</h2><pre><code class=" mermaid">graph LR;1[集中式架构] --&gt; 2[垂直拆分]2 --&gt; 3[分布式服务]3 --&gt; 4[SOA面向服务架构]4 --&gt; 5[微服务架构]</code></pre><h3 id="1-1-1-集中式架构"><a href="#1-1-1-集中式架构" class="headerlink" title="1.1.1 集中式架构"></a>1.1.1 集中式架构</h3><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/1.1.png"></p><ul><li>优点： <ul><li>系统开发速度快</li><li>维护成本低</li><li>适用于并发要求较低的系统</li></ul></li><li>缺点： <ul><li>代码耦合度高，后期维护困难</li><li>无法针对不同模块进行针对性优化</li><li>无法水平扩展</li><li>单点容错率低，并发能力差</li></ul></li></ul><h3 id="1-1-2-垂直拆分架构"><a href="#1-1-2-垂直拆分架构" class="headerlink" title="1.1.2 垂直拆分架构"></a>1.1.2 垂直拆分架构</h3><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/1.2.png"></p><ul><li>优点：<ul><li>系统拆分实现了流量分担，解决了并发问题</li><li>可以针对不同模块进行优化</li><li>方便水平扩展，负载均衡，容错率提高</li></ul></li><li>缺点：<ul><li>系统间相互独立，会有很多重复开发工作，影响开发效率</li></ul></li></ul><h3 id="1-1-3-分布式服务架构"><a href="#1-1-3-分布式服务架构" class="headerlink" title="1.1.3 分布式服务架构"></a>1.1.3 分布式服务架构</h3><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/1.3.png"></p><ul><li>优点：<ul><li>将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率</li></ul></li><li>缺点：<ul><li>系统间耦合度变高，调用关系错综复杂，难以维护</li></ul></li></ul><h3 id="1-1-4-面向服务架构（SOA）"><a href="#1-1-4-面向服务架构（SOA）" class="headerlink" title="1.1.4 面向服务架构（SOA）"></a>1.1.4 面向服务架构（SOA）</h3><p>SOA（Service Oriented Architecture）面向服务的架构：它是一种设计方法，其中包含多个服务， 服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在与操作系统进程中。<strong>各个服务之间通过网络调用</strong>。</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/1.4.png"></p><blockquote><p>ESB（企业服务总线），简单来说ESB就是一根管道，用来连接各个服务节点。为了集成不同系统，不同协议的服务，<strong>ESB做了消息的转化解释和路由工作</strong>，让不同的服务互联互通。</p></blockquote><ul><li>缺点：<ul><li>每个供应商提供的ESB产品有偏差，自身实现较为复杂</li><li>应用服务粒度较大，ESB集成整合所有服务和协议、数据转换使得运维、测试部署困难</li><li>所有服务都通过一个通路通信，直接降低了通信速度</li></ul></li></ul><h3 id="1-1-5-微服务架构"><a href="#1-1-5-微服务架构" class="headerlink" title="1.1.5 微服务架构"></a>1.1.5 微服务架构</h3><p>微服务架构是使用一套小服务来开发单个应用的方式或途径，<strong>每个服务基于单一业务能力构建</strong>，运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，并能够通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/1.5.png"></p><blockquote><p>API Gateway网关是一个服务器，是系统的唯一入口。为每个客户端提供一个定制的API。API网关核心是，<strong>所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能</strong>。如它还可以具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。通常，网关提供RESTful/HTTP的方式访问服务。而<strong>服务端通过服务注册中心进行服务注册和管理</strong>。</p></blockquote><ul><li>特点：<ul><li><strong>单一职责</strong>：微服务中每一个服务都对应唯一的业务能力，做到单一职责</li><li><strong>微</strong>：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。</li><li><strong>面向服务</strong>：面向服务是说每个服务都要对外暴露Rest风格服务接口API，并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 </li><li><strong>自治</strong>：自治是说服务间互相独立，互不干扰<ul><li>团队独立：每个服务都是一个独立的开发团队，人数不能过多。</li><li>技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉</li><li>前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动端开发不同接口</li><li>数据库分离：每个服务都使用自己的数据源。</li><li>部署独立：服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护</li></ul></li></ul></li></ul><h2 id="1-2-服务调用方式"><a href="#1-2-服务调用方式" class="headerlink" title="1.2 服务调用方式"></a>1.2 服务调用方式</h2><p>常见的远程调用方式有以下2种：</p><ul><li><strong>RPC</strong>（Remote Produce Call）：远程过程调用，RPC<strong>基于Socket</strong>，<strong>工作在会话层</strong>。自定义数据格式，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型代表</li><li><strong>Http</strong>：http其实是一种网络传输协议，基于TCP，<strong>工作在应用层</strong>，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。典型代表：RESTful，Spring Cloud</li></ul><h2 id="1-3-SpringCloud简介"><a href="#1-3-SpringCloud简介" class="headerlink" title="1.3 SpringCloud简介"></a>1.3 SpringCloud简介</h2><p>Spring Cloud是Spring旗下的项目之一，官网地址：<a href="http://projects.spring.io/spring-cloud/">http://projects.spring.io/spring-cloud/</a> </p><p>Spring Cloud将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由， 负载均衡，熔断器，控制总线，集群状态等功能；协调分布式环境中各个系统，为各类服务提供模板性配置。其主要涉及的组件包括：</p><ul><li>Eureka：注册中心</li><li>Zuul、Gateway：服务网关</li><li>Ribbon：负载均衡</li><li>Feign：服务调用</li><li>Hystrix或Resilience4j：熔断器</li></ul><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/1.6.png"></p><blockquote><p>Spring Cloud不是一个组件，而是许多组件的集合</p><p>它的版本命名比较特殊，是以A到Z的为首字母的一些单词（伦敦地铁站的名字）组成</p></blockquote><hr><h1 id="二、微服务场景模拟"><a href="#二、微服务场景模拟" class="headerlink" title="二、微服务场景模拟"></a>二、微服务场景模拟</h1><h2 id="2-1-创建父工程"><a href="#2-1-创建父工程" class="headerlink" title="2.1 创建父工程"></a>2.1 创建父工程</h2><p>创建Maven空工程springcloud-demo01，导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>top.igotcha<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-demo01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-comment">&lt;!--这是之后加的--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>user-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>consumer-demo<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Greenwich.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper.starter.version</span>&gt;</span>2.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">mapper.starter.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>5.1.46<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-comment">&lt;!--对子项目通用依赖进行管理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- springCloud --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 通用Mapper启动器 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>tk.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mapper.starter.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-2-创建用户服务工程模块"><a href="#2-2-创建用户服务工程模块" class="headerlink" title="2.2 创建用户服务工程模块"></a>2.2 创建用户服务工程模块</h2><h3 id="2-2-1-创建新module"><a href="#2-2-1-创建新module" class="headerlink" title="2.2.1 创建新module"></a>2.2.1 创建新module</h3><p>创建Maven模块，user-service</p><h3 id="2-2-2-导入Maven依赖"><a href="#2-2-2-导入Maven依赖" class="headerlink" title="2.2.2 导入Maven依赖"></a>2.2.2 导入Maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-demo01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>top.igotcha<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>user-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>tk.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Eureka客户端 --&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;dependency&gt;</span><br><span class="hljs-comment">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="hljs-comment">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="hljs-comment">    &lt;/dependency&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-3-编写配置文件"><a href="#2-2-3-编写配置文件" class="headerlink" title="2.2.3 编写配置文件"></a>2.2.3 编写配置文件</h3><p>创建 user-service\src\main\resources\application.yml 文件，设置相关信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9091</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/springcloud-demo01</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root01</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">top.igotcha.user.pojo</span><br></code></pre></td></tr></table></figure><p>并新建springcloud-demo01数据库，导入SQL数据</p><h3 id="2-2-4-编写Bean"><a href="#2-2-4-编写Bean" class="headerlink" title="2.2.4 编写Bean"></a>2.2.4 编写Bean</h3><p>编写实体类<code>user-service\src\main\java\top\igotcha\user\pojo\User.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Table(name = &quot;tb_user&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@KeySql(useGeneratedKeys = true)</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String userName; <span class="hljs-comment">// 用户名</span><br>    <span class="hljs-keyword">private</span> String password; <span class="hljs-comment">// 密码</span><br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 姓名</span><br>    <span class="hljs-keyword">private</span> Integer age;<span class="hljs-comment">// 年龄</span><br>    <span class="hljs-keyword">private</span> Integer sex;<span class="hljs-comment">// 性别，1男性，2女性</span><br>    <span class="hljs-keyword">private</span> Date birthday;<span class="hljs-comment">// 出生日期</span><br>    <span class="hljs-keyword">private</span> Date created;<span class="hljs-comment">// 创建时间</span><br>    <span class="hljs-keyword">private</span> Date updated;<span class="hljs-comment">// 更新时间</span><br>    <span class="hljs-keyword">private</span> String note;<span class="hljs-comment">// 备注</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-5-编写Mapper"><a href="#2-2-5-编写Mapper" class="headerlink" title="2.2.5 编写Mapper"></a>2.2.5 编写Mapper</h3><p>编写<code>user-service\src\main\java\top\igotcha\user\mapper\UserMapper.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-6-编写Service"><a href="#2-2-6-编写Service" class="headerlink" title="2.2.6 编写Service"></a>2.2.6 编写Service</h3><p>编写<code>user-service\src\main\java\top\igotcha\user\service\UserService.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> userMapper.selectByPrimaryKey(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-7-编写Controller"><a href="#2-2-7-编写Controller" class="headerlink" title="2.2.7 编写Controller"></a>2.2.7 编写Controller</h3><p>编写<code>user-service\src\main\java\top\igotcha\user\controller\UserController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> userService.queryById(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-8-编写启动器Application"><a href="#2-2-8-编写启动器Application" class="headerlink" title="2.2.8 编写启动器Application"></a>2.2.8 编写启动器Application</h3><p>编写<code>user-service/src/main/java/top/igotcha/user/UserApplication.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;top.igotcha.user.mapper&quot;)</span><br><span class="hljs-comment">//@EnableDiscoveryClient // 开启Eureka客户端发现功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(UserApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-9-运行项目"><a href="#2-2-9-运行项目" class="headerlink" title="2.2.9 运行项目"></a>2.2.9 运行项目</h3><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.1.png"></p><hr><h2 id="2-3-创建服务调用模块"><a href="#2-3-创建服务调用模块" class="headerlink" title="2.3 创建服务调用模块"></a>2.3 创建服务调用模块</h2><h3 id="2-3-1-创建新module"><a href="#2-3-1-创建新module" class="headerlink" title="2.3.1 创建新module"></a>2.3.1 创建新module</h3><p>创建Maven模块，consumer-demo</p><h3 id="2-3-2-导入Maven依赖"><a href="#2-3-2-导入Maven依赖" class="headerlink" title="2.3.2 导入Maven依赖"></a>2.3.2 导入Maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-demo01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>top.igotcha<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>consumer-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-3-编写Bean"><a href="#2-3-3-编写Bean" class="headerlink" title="2.3.3 编写Bean"></a>2.3.3 编写Bean</h3><p>编写实体类<code>springcloud-demo01/consumer-demo/src/main/java/top/igtocha/consumer/pojo/User.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String userName; <span class="hljs-comment">// 用户名</span><br>    <span class="hljs-keyword">private</span> String password; <span class="hljs-comment">// 密码</span><br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 姓名</span><br>    <span class="hljs-keyword">private</span> Integer age;<span class="hljs-comment">// 年龄</span><br>    <span class="hljs-keyword">private</span> Integer sex;<span class="hljs-comment">// 性别，1男性，2女性</span><br>    <span class="hljs-keyword">private</span> Date birthday;<span class="hljs-comment">// 出生日期</span><br>    <span class="hljs-keyword">private</span> Date created;<span class="hljs-comment">// 创建时间</span><br>    <span class="hljs-keyword">private</span> Date updated;<span class="hljs-comment">// 更新时间</span><br>    <span class="hljs-keyword">private</span> String note;<span class="hljs-comment">// 备注</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-4-编写Controller"><a href="#2-3-4-编写Controller" class="headerlink" title="2.3.4 编写Controller"></a>2.3.4 编写Controller</h3><p>编写<code>springcloud-demo01/consumer-demo/src/main/java/top/igtocha/consumer/controller/ConsumerController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/consumer&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br>    <span class="hljs-meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;<br>        String url = <span class="hljs-string">&quot;http://localhost:9091/user/&quot;</span> + id;<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(url, User.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-5-编写启动器Application"><a href="#2-3-5-编写启动器Application" class="headerlink" title="2.3.5 编写启动器Application"></a>2.3.5 编写启动器Application</h3><p>编写<code>springcloud-demo01/consumer-demo/src/main/java/top/igtocha/consumer/ConsumerApplication.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ConsumerApplication.class, args);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-6-运行项目"><a href="#2-3-6-运行项目" class="headerlink" title="2.3.6 运行项目"></a>2.3.6 运行项目</h3><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.2.png"></p><hr><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p>以上代码实现了</p><ul><li>user-service：对外提供了查询用户的接口</li><li>consumer-demo：通过RestTemplate访问 <a href="http://locahost:9091/user/%7Bid%7D">http://locahost:9091/user/{id}</a> 接口，查询用户数据</li></ul><p>存在如下问题</p><ul><li>服务管理<ul><li>如何自动注册和发现</li><li>如何实现状态监管</li><li>如何实现动态路由</li></ul></li><li>服务如何实现负载均衡</li><li>服务如何解决容灾问题</li><li>服务如何实现统一配置</li></ul><hr><h2 id="2-5-创建Eureka注册中心模块"><a href="#2-5-创建Eureka注册中心模块" class="headerlink" title="2.5 创建Eureka注册中心模块"></a>2.5 创建Eureka注册中心模块</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Eureka的主要功能是进行服务管理，定期检查服务状态，返回服务地址列表。</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.3.png"></p><ul><li><p><strong>Eureka</strong>：就是服务注册中心（可以是一个集群），对外暴露自己的地址</p></li><li><p><strong>提供者</strong>：启动后向Eureka注册自己信息（地址，提供什么服务）</p></li><li><p><strong>消费者</strong>：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</p></li><li><p>**心跳(续约)**：提供者定期通过http方式向Eureka刷新自己的状态</p></li></ul><blockquote><p>Eureka是服务注册中心，只做服务注册；自身并不提供服务也不消费服务。可以搭建web工程使用Eureka，可以使用Spring Boot方式搭建。</p></blockquote><h3 id="2-5-1-创建新module"><a href="#2-5-1-创建新module" class="headerlink" title="2.5.1 创建新module"></a>2.5.1 创建新module</h3><p>创建Maven模块，eureka-server</p><h3 id="2-5-2-导入Maven依赖"><a href="#2-5-2-导入Maven依赖" class="headerlink" title="2.5.2 导入Maven依赖"></a>2.5.2 导入Maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-demo01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>top.igotcha<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-3-编写配置文件"><a href="#2-5-3-编写配置文件" class="headerlink" title="2.5.3 编写配置文件"></a>2.5.3 编写配置文件</h3><p>创建 springcloud-demo01/eureka-server/src/main/resources/application.yml文件，设置相关信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span> <span class="hljs-comment"># 应用名称，会在Eureka中作为服务的id标识（serviceId）</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>   <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer的地址，现在是自己的地址，如果是集群，需要写其它Server的地址。</span><br>     <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br>   <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 不注册自己</span><br>   <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#不拉取</span><br></code></pre></td></tr></table></figure><h3 id="2-5-4-编写启动器Application"><a href="#2-5-4-编写启动器Application" class="headerlink" title="2.5.4 编写启动器Application"></a>2.5.4 编写启动器Application</h3><p>编写<code>springcloud-demo01/eureka-server/src/main/java/top/igotcha/EurekaServerApplication.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaServerApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaServerApplication.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-5-运行项目"><a href="#2-5-5-运行项目" class="headerlink" title="2.5.5 运行项目"></a>2.5.5 运行项目</h3><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.4.png"></p><hr><h2 id="2-6-服务注册与发现"><a href="#2-6-服务注册与发现" class="headerlink" title="2.6 服务注册与发现"></a>2.6 服务注册与发现</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li><strong>服务注册</strong>：在服务提供工程user-service上添加Eureka客户端依赖；自动将服务注册到EurekaServer服务地址列表。<ul><li>添加依赖；</li><li>改造启动引导类；添加开启Eureka客户端发现的注解；</li><li>修改配置文件；设置Eureka 服务地址</li></ul></li><li><strong>服务发现</strong>：在服务消费工程consumer-demo上添加Eureka客户端依赖；可以使用工具类根据服务名称获取对应的服务地址列表。<ul><li>添加依赖；</li><li>改造启动引导类；添加开启Eureka客户端发现的注解；</li><li>修改配置文件；设置Eureka 服务地址；</li><li>改造处理器类ConsumerController，可以使用工具类DiscoveryClient根据服务名称获取对应服务地址列表。</li></ul></li></ul><h3 id="2-6-1-服务注册"><a href="#2-6-1-服务注册" class="headerlink" title="2.6.1 服务注册"></a>2.6.1 服务注册</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>在user-service的pom.xml中添加Eureka客户端依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Eureka客户端 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="修改启动类"><a href="#修改启动类" class="headerlink" title="修改启动类"></a>修改启动类</h4><p>通过添加 <code>@EnableDiscoveryClient</code> 来开启Eureka客户端功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;top.igotcha.user.mapper&quot;)</span><br><span class="hljs-meta">@EnableDiscoveryClient</span> <span class="hljs-comment">// 开启Eureka客户端发现功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(UserApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9091</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/springcloud-demo01</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root01</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-comment">#应用名</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">user-service</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">top.igotcha.user.pojo</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:10086/eureka</span><br></code></pre></td></tr></table></figure><blockquote><p>这里添加了spring.application.name属性来指定应用名称，将来会作为服务的id使用。</p></blockquote><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>重启项目后，发现 user-service已经注册到Eureka中</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.5.png"></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>服务提供者在启动时，会检测配置属性中的： eureka.client.register-with-erueka=true 参数是否正确，事实上，默认就是true。</p><p>如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个<strong>双层Map</strong>结构中。 </p><ul><li><p>第一层Map的Key就是服务id，一般是配置中的 spring.application.name 属性</p></li><li><p>第二层Map的key是服务的实例id。一般host+ serviceId + port，例如： localhost:user-service:8081 值则是服务的实例对象，也就是说一个服务，可以同时启动多个不同实例，形成集群</p></li></ul><h3 id="2-6-2-服务发现"><a href="#2-6-2-服务发现" class="headerlink" title="2.6.2 服务发现"></a>2.6.2 服务发现</h3><h4 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>在consumer-demo的pom.xml中添加Eureka客户端依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Eureka客户端 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="修改启动类-1"><a href="#修改启动类-1" class="headerlink" title="修改启动类"></a>修改启动类</h4><p>通过添加 <code>@EnableDiscoveryClient</code> 来开启Eureka客户端功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ConsumerApplication.class, args);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="新增配置文件"><a href="#新增配置文件" class="headerlink" title="新增配置文件"></a>新增配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">consumer-demo</span> <span class="hljs-comment"># 应用名称</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>   <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer地址</span><br>     <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-7-Eureka高可用配置"><a href="#2-7-Eureka高可用配置" class="headerlink" title="2.7 Eureka高可用配置"></a>2.7 Eureka高可用配置</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>Eureka架构中的三个核心角色：</p><ul><li><p><strong>服务注册中心</strong></p><p>Eureka的服务端应用，提供服务注册和发现功能。（就是eureka-server）</p></li><li><p><strong>服务提供者</strong> </p><p>提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。（就是user-service）</p></li><li><p><strong>服务消费者</strong></p><p>消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。（就是consumer-demo）</p></li></ul><blockquote><p>事实上EurekaServer也可以是一 个集群，形成高可用的Eureka中心。</p><p>多个Eureka Server之间也会<strong>互相注册</strong>为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一 个节点，都可以获取到完整的服务列表信息。</p><p><strong>作为客户端，需要把信息注册到每个Eureka中</strong></p></blockquote><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.6.png"></p><h3 id="2-7-1-修改Eureka配置"><a href="#2-7-1-修改Eureka配置" class="headerlink" title="2.7.1 修改Eureka配置"></a>2.7.1 修改Eureka配置</h3><p>新建一个分支，方便之后切换回单机模式</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-string">$&#123;port:10086&#125;</span> <span class="hljs-comment">#读取启动项目时设置的port值，默认为10086</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span> <span class="hljs-comment"># 应用名称，会在Eureka中作为服务的id标识（serviceId）</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>   <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer的地址，如果是集群，需要写其它Server的地址。</span><br>     <span class="hljs-comment">#defaultZone: http://127.0.0.1:10086/eureka</span><br>     <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">$&#123;defaultZone:http://127.0.0.1:10086/eureka&#125;</span><br>   <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 注册自己</span><br>   <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#拉取</span><br></code></pre></td></tr></table></figure><p>所谓的高可用注册中心，就是<strong>把EurekaServer自己也作为一个服务，注册到其它EurekaServer上，这样多个 EurekaServer之间就能互相发现对方，从而形成集群</strong>。</p><blockquote><p>在上述配置文件中的${}表示在jvm启动时候若能找到对应port或者defaultZone参数则使用，若无则使用后面的默认值</p></blockquote><h3 id="2-7-2-修改Run-Configurations"><a href="#2-7-2-修改Run-Configurations" class="headerlink" title="2.7.2 修改Run Configurations"></a>2.7.2 修改Run Configurations</h3><p>修改原来的启动配置组件；在VM options 中 设置<code>-Dport=10087 -DdefaultZone=http:127.0.0.1:10086/eureka</code>，并复制一份设置<code>-Dport=10087 -DdefaultZone=http:127.0.0.1:10086/eureka</code></p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.7.png"></p><h3 id="2-7-3-修改user-service配置"><a href="#2-7-3-修改user-service配置" class="headerlink" title="2.7.3 修改user-service配置"></a>2.7.3 修改user-service配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9091</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/springcloud-demo01</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root01</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-comment">#应用名</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">user-service</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">top.igotcha.user.pojo</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer地址,多个地址以逗号隔开</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka</span><br></code></pre></td></tr></table></figure><h3 id="2-7-4-修改consumer-demo配置"><a href="#2-7-4-修改consumer-demo配置" class="headerlink" title="2.7.4 修改consumer-demo配置"></a>2.7.4 修改consumer-demo配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">consumer-demo</span> <span class="hljs-comment"># 应用名称</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>   <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer地址,多个地址以逗号隔开</span><br>     <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka</span><br></code></pre></td></tr></table></figure><h3 id="2-7-5-运行项目"><a href="#2-7-5-运行项目" class="headerlink" title="2.7.5 运行项目"></a>2.7.5 运行项目</h3><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.8.png"></p><hr><h2 id="2-8-Eureka客户端与服务端配置"><a href="#2-8-Eureka客户端与服务端配置" class="headerlink" title="2.8 Eureka客户端与服务端配置"></a>2.8 Eureka客户端与服务端配置</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>主要对如下部分进行配置</p><ul><li>Eureka客户端工程<ul><li>user-service 服务提供<ul><li>服务地址使用ip方式</li><li>续约</li></ul></li><li>consumer-demo 服务消费<ul><li>获取服务地址的频率</li></ul></li></ul></li><li>Eureka服务端工程 eureka-server<ul><li>失效剔除</li><li>自我保护</li></ul></li></ul><h3 id="客户端服务者配置"><a href="#客户端服务者配置" class="headerlink" title="客户端服务者配置"></a>客户端服务者配置</h3><p>默认注册时使用的是主机名或者localhost，如果想用ip进行注册，可以在 user-service 中添加配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># ip地址</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 更倾向于使用ip，而不是host名</span><br>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">90</span> <span class="hljs-comment">#服务失效时间，默认值90秒</span><br>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">30</span> <span class="hljs-comment">#服务续约(renew)的间隔，默认为30秒</span><br></code></pre></td></tr></table></figure><blockquote><p>默认情况下每隔30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳， EurekaServer就会认为该服务宕机，会定时（eureka.server.eviction-interval-timer-in-ms设定的时间）从服务列表中移除，这两个值在生产环境不要修改，默认即可。</p></blockquote><h3 id="客户端消费者配置"><a href="#客户端消费者配置" class="headerlink" title="客户端消费者配置"></a>客户端消费者配置</h3><p>当消费者启动时，会检测 <code>eureka.client.fetch-registry=true </code>参数的值，如果为true，则会从Eureka Server服务的列表拉取只读备份，然后缓存在本地。并且每隔30秒会重新拉取并更新数据。可以在 consumer-demo 项目中通过下面的参数来修改：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>   <span class="hljs-attr">registry-fetch-interval-seconds:</span> <span class="hljs-number">30</span> <span class="hljs-comment">#消费者启动时，会从EurekaServer服务的列表拉取只读备份，然后缓存在本地。并且每隔30秒会重新拉取并更新数据。</span><br></code></pre></td></tr></table></figure><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><h4 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h4><p>当服务进行正常关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线 了”。服务中心接受到请求之后，将该服务置为下线状态。</p><h4 id="失效剔除"><a href="#失效剔除" class="headerlink" title="失效剔除"></a>失效剔除</h4><p>有时服务由于内存溢出或网络故障等原因使得服务不能正常的工作，而服务注册中心并未收到“服务下线”的请求。相对于服务提供者的“服务续约”操作，服务注册中心在启动时会创建一个定时任务，默认每隔一段时间 （默认为60秒）将当前清单中超时（默认为90秒）没有续约的服务剔除，这个操作被称为失<strong>效剔除</strong>。 可以通过 <code>eureka.server.eviction-interval-timer-in-ms</code> 参数对其进行修改，单位是毫秒。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">server:</span><br>    <span class="hljs-string">eviction-interval-timer-in-ms`:</span> <span class="hljs-number">60000</span> <span class="hljs-comment">#服务失效剔除时间间隔，默认60秒</span><br></code></pre></td></tr></table></figure><h4 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h4><p>关停一个服务时，很可能会在Eureka面板看到一条警告：</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.9.png"></p><p>这是因为触发了Eureka的自我保护机制。当服务未按时进行心跳续约时，Eureka会统计服务实例最近15分钟心跳续约的比例是否低于了85%。</p><p>在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。打开自我保护后，Eureka在这段时间内不会剔除任何服务实例，直到网络恢复正常。生产环境下这很有效，保证了大多数服务依然可用，不过也有可能获取到失败的服务实例，因此服务调用者必须做好服务的失败容错。 可以通过下面的配置来关停自我保护：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">server:</span><br>    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#关闭自我保护模式（缺省为打开）</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-9-Ribbon负载均衡配置"><a href="#2-9-Ribbon负载均衡配置" class="headerlink" title="2.9 Ribbon负载均衡配置"></a>2.9 Ribbon负载均衡配置</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>Ribbon是Netflix发布的<strong>负载均衡器</strong>，它有助于控制HTTP和TCP客户端的行为。为Ribbon 配置服务提供者地址列表后，Ribbon就可基于某种负载均衡算法，自动地帮助服务消费者去请求。Ribbon默认为提供了很多的负载均衡算法，例如轮询、随机等。当然，也可为Ribbon实现自定义的负载均衡算法。</p><h3 id="2-9-1-启动两个user-service实例"><a href="#2-9-1-启动两个user-service实例" class="headerlink" title="2.9.1 启动两个user-service实例"></a>2.9.1 启动两个user-service实例</h3><p>将user-service中配置文件中端口号修改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-string">$&#123;port:9091&#125;</span><br></code></pre></td></tr></table></figure><p>在VM options 中 设置<code>-Dport=9091</code>，并复制一份设置<code>-Dport=9092</code></p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.10.png"></p><p>将两个实例启动后，可以在Eureka中看到</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.11.png"></p><h3 id="2-9-2-开启负载均衡"><a href="#2-9-2-开启负载均衡" class="headerlink" title="2.9.2 开启负载均衡"></a>2.9.2 开启负载均衡</h3><p>因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。 直接修改<code>springcloud-demo01/consumer-demo/src/main/java/top/igtocha/consumer/ConsumerApplication.java</code>，在<code>RestTemplate</code>的配置方法上添加 <code>@LoadBalanced</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ConsumerApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-9-3-修改Controller"><a href="#2-9-3-修改Controller" class="headerlink" title="2.9.3 修改Controller"></a>2.9.3 修改Controller</h3><p>修改<code>springcloud-demo01/consumer-demo/src/main/java/top/igtocha/consumer/controller/ConsumerController.java</code>调用方式，不再手动获取ip和端口，而是直接通过服务名称调用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/consumer&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><br><span class="hljs-comment">/*    @GetMapping(&quot;&#123;id&#125;&quot;)</span><br><span class="hljs-comment">    public User queryById(@PathVariable Long id)&#123;</span><br><span class="hljs-comment">        String url = &quot;http://localhost:9091/user/&quot; + id;</span><br><span class="hljs-comment">        return restTemplate.getForObject(url, User.class);</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;<br>        <span class="hljs-comment">//获取eureka中注册的user-service实例列表</span><br>        <span class="hljs-comment">//List&lt;ServiceInstance&gt; serviceInstanceList = discoveryClient.getInstances(&quot;user-service&quot;);</span><br>        <span class="hljs-comment">//ServiceInstance serviceInstance = serviceInstanceList.get(0);</span><br>        <span class="hljs-comment">//String url = &quot;http://&quot; + serviceInstance.getHost() + &quot;:&quot; + serviceInstance.getPort() + &quot;/user/&quot; + id;</span><br>        <span class="hljs-comment">//return restTemplate.getForObject(url, User.class);</span><br>        <span class="hljs-comment">//调用方式，不再手动获取ip和端口，而是直接通过服务名称调用；</span><br>        String url = <span class="hljs-string">&quot;http://user-service/user/&quot;</span> + id;<br>        User user = restTemplate.getForObject(url, User.class);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-9-4-运行项目"><a href="#2-9-4-运行项目" class="headerlink" title="2.9.4 运行项目"></a>2.9.4 运行项目</h3><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.12.png"></p><blockquote><p>Ribbon默认的负载均衡策略是轮询。SpringBoot提供了修改负载均衡规则的配置入口，在consumerdemo的配置文件中添加如下，就变成随机的了：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">user-service:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span><br></code></pre></td></tr></table></figure><p>格式是： <code>&#123;服务名称&#125;.ribbon.NFLoadBalancerRuleClassName</code></p></blockquote><hr><h2 id="2-10-Hystrix熔断器配置"><a href="#2-10-Hystrix熔断器配置" class="headerlink" title="2.10 Hystrix熔断器配置"></a>2.10 Hystrix熔断器配置</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>Hystrix是Netflix开源的一个延迟和容错库，<strong>用于隔离访问远程服务、第三方库，防止出现级联失败。</strong></p><h4 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h4><p>微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路。当某个服务发生异常时，会造成请求阻塞，用户的请求得到不到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞。</p><p>服务器支持的线程和并发数有限，请求一直阻塞，会<strong>导致服务器资源耗尽，从而导致所有其它服务都不可用</strong>，形成雪崩效应。</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.13.png"></p><p>Hystrix解决雪崩问题的手段主要是<strong>服务降级</strong>，包括： </p><ul><li><strong>线程隔离</strong></li><li><strong>服务熔断</strong></li></ul><h4 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h4><ul><li><p>Hystrix为每个依赖服务调用分配一个小的线程池，<strong>如果线程池已满调用将被立即拒绝，默认不采用排队，加速失败判定时间</strong>。</p></li><li><p>用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，<strong>如果线程池已满，或者请求超时，则会进行降级处理</strong>；</p><blockquote><p>服务降级：优先保证核心服务，而非核心服务不可用或弱可用。</p></blockquote></li><li><p>服务降级<strong>虽然会导致请求失败，但是不会导致阻塞</strong>，而且最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有影响。</p></li></ul><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.14.png"></p><h3 id="2-10-1-引入依赖"><a href="#2-10-1-引入依赖" class="headerlink" title="2.10.1 引入依赖"></a>2.10.1 引入依赖</h3><p>在<code>consumer-demo</code>消费端系统的pom.xml文件添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Hystrix熔断器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-10-2-开启熔断"><a href="#2-10-2-开启熔断" class="headerlink" title="2.10.2 开启熔断"></a>2.10.2 开启熔断</h3><p>在启动类ConsumerApplication上添加注解：<code>@EnableCircuitBreaker</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如下三个可以合并为@SpringCloudApplication</span><br><span class="hljs-comment">//@SpringBootApplication</span><br><span class="hljs-comment">//@EnableDiscoveryClient</span><br><span class="hljs-comment">//@EnableCircuitBreaker</span><br><span class="hljs-meta">@SpringCloudApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ConsumerApplication.class, args);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在微服务中，经常会引入上面的三个注解，于是Spring就提供了一个组合注 解：@SpringCloudApplication</p></blockquote><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.15.png"></p><h3 id="2-10-3-编写降级逻辑"><a href="#2-10-3-编写降级逻辑" class="headerlink" title="2.10.3 编写降级逻辑"></a>2.10.3 编写降级逻辑</h3><p>改造<code>springcloud-demo01/consumer-demo/src/main/java/top/igtocha/consumer/controller/ConsumerController.java</code>处理器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/consumer&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-comment">//发生熔断时默认的回调函数</span><br><span class="hljs-meta">@DefaultProperties(defaultFallback = &quot;defaultFallback&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><br>    <span class="hljs-meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span><br>    <span class="hljs-comment">//发生熔断时的回调函数，当括号内容为空时，使用类中默认的</span><br>    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;queryByIdFallback&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;<br>        String url = <span class="hljs-string">&quot;http://user-service/user/&quot;</span> + id;<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(url, User.class).toString();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryByIdFallback</span><span class="hljs-params">(Long id)</span></span>&#123;<br>        log.error(<span class="hljs-string">&quot;查询用户信息失败。id：&#123;&#125;&quot;</span>, id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;对不起，网络太拥挤了！&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">defaultFallback</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;默认提示：对不起，网络太拥挤了！&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>因为熔断的降级逻辑方法必须跟正常逻辑方法保证：<strong>相同的参数列表和返回值声明</strong>。</li><li>@HystrixCommand(fallbackMethod = “queryByIdFallBack”)：用来声明一个降级逻辑的方法</li></ul></blockquote><h3 id="2-10-4-超时设置与熔断设置"><a href="#2-10-4-超时设置与熔断设置" class="headerlink" title="2.10.4 超时设置与熔断设置"></a>2.10.4 超时设置与熔断设置</h3><p>Hystrix的默认超时时长为1秒，可以通过配置修改这个值</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">hystrix:</span><br>  <span class="hljs-attr">command:</span><br>    <span class="hljs-attr">default:</span><br>      <span class="hljs-attr">execution:</span><br>        <span class="hljs-attr">isolation:</span><br>          <span class="hljs-attr">thread:</span><br>            <span class="hljs-attr">timeoutInMilliseconds:</span> <span class="hljs-number">2000</span> <span class="hljs-comment">#超时熔断，默认1秒</span><br>      <span class="hljs-attr">circuitBreaker:</span><br>        <span class="hljs-attr">errorThresholdPercentage:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 触发熔断错误比例阈值，默认值50%</span><br>        <span class="hljs-attr">sleepWindowInMilliseconds:</span> <span class="hljs-number">10000</span> <span class="hljs-comment"># 熔断后休眠时长，默认值5秒</span><br>        <span class="hljs-attr">requestVolumeThreshold:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 熔断触发最小请求次数，默认值是20</span><br></code></pre></td></tr></table></figure><h3 id="2-10-5-运行项目"><a href="#2-10-5-运行项目" class="headerlink" title="2.10.5 运行项目"></a>2.10.5 运行项目</h3><p>触发熔断后的返回与控制台结果</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.16.png"></p><h3 id="2-10-5-原理"><a href="#2-10-5-原理" class="headerlink" title="2.10.5 原理"></a>2.10.5 原理</h3><p>Hystrix的服务熔断机制，可以实现<strong>弹性容错</strong>；当服务请求情况好转之后，可以自动重连。通过断路的方式，将后续请求直接拒绝，一段时间（默认5秒）之后允许部分请求通过，如果调用成功则回到断路器关闭状态，否则继续打开，拒绝请求的服务。</p><p>Hystrix的熔断状态机模型：</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.17.png"></p><p>状态机有3个状态：</p><ul><li>Closed：关闭状态（断路器关闭），所有请求都正常访问。</li><li>Open：打开状态（断路器打开），所有请求都会被降级。Hystrix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次。</li><li>Half Open：半开状态，不是永久的，断路器打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求都是健康的，则会关闭断路器，否则继续保持打开，再次进行休眠计时</li></ul><hr><h2 id="2-11-Feign远程调用配置"><a href="#2-11-Feign远程调用配置" class="headerlink" title="2.11 Feign远程调用配置"></a>2.11 Feign远程调用配置</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>Feign远程调用，核心就是通过一系列的封装和处理，将以JAVA注解的方式定义的远程调用API接口，最终转换成HTTP的请求形式，然后将HTTP的请求的响应结果，解码成JAVA Bean，放回给调用者。Feign远程调用的基本流程，大致如下图所示。</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.18.png"></p><h3 id="2-11-1-引入依赖"><a href="#2-11-1-引入依赖" class="headerlink" title="2.11.1 引入依赖"></a>2.11.1 引入依赖</h3><p>在<code>consumer-demo</code>消费端系统的pom.xml文件添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--feign--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-11-2-编写Feign客户端"><a href="#2-11-2-编写Feign客户端" class="headerlink" title="2.11.2 编写Feign客户端"></a>2.11.2 编写Feign客户端</h3><p>在<code>consumer-demo</code>中编写如下Feign客户端接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;user-service&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserClient</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这是一个接口，<strong>Feign会通过动态代理，生成实现类</strong>。（这点跟mybatis的mapper很像） </p></li><li><p><code>@FeignClient </code>，声明这是一个Feign客户端，同时通过 value 属性指定服务名称</p></li><li><p>接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解生成URL，并访问获取结果</p></li></ul><h3 id="2-11-3-编写控制器"><a href="#2-11-3-编写控制器" class="headerlink" title="2.11.3 编写控制器"></a>2.11.3 编写控制器</h3><p>编写新的控制器类<code>ConsumerFeignController</code>，使用UserClient访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/cf&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerFeignController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserClient userClient;<br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> userClient.queryById(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-11-4-修改启动器"><a href="#2-11-4-修改启动器" class="headerlink" title="2.11.4 修改启动器"></a>2.11.4 修改启动器</h3><p>在<code>ConsumerApplication</code>启动类上，添加注解，开启Feign功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringCloudApplication</span><br><span class="hljs-comment">//开启Feign功能</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ConsumerApplication.class, args);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Feign中已经自动集成了Ribbon负载均衡，因此不需要自己定义RestTemplate进行负载均衡的配置</p></blockquote><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.21.png"></p><h3 id="2-11-5-内置负载均衡配置"><a href="#2-11-5-内置负载均衡配置" class="headerlink" title="2.11.5 内置负载均衡配置"></a>2.11.5 内置负载均衡配置</h3><p>Feign中本身已经集成了Ribbon依赖和自动配置，因此不需要自己定义RestTemplate进行负载均衡的配置</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.20.png"></p><p>Fegin内置的ribbon默认设置了请求超时时长，默认是1000，可以通过手动配置来修改这个超时时长，因为ribbon内部有重试机制，一旦超时，会自动重新发起请求。如果不希望重试，可以添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">1000</span> <span class="hljs-comment"># 连接超时时长</span><br>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">2000</span> <span class="hljs-comment"># 数据通信超时时长</span><br>  <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 当前服务器的重试次数</span><br>  <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 重试多少次服务</span><br>  <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否对所有的请求方式都重试</span><br></code></pre></td></tr></table></figure><h3 id="2-11-6-内置Hystrix熔断器配置"><a href="#2-11-6-内置Hystrix熔断器配置" class="headerlink" title="2.11.6 内置Hystrix熔断器配置"></a>2.11.6 内置Hystrix熔断器配置</h3><p>Feign默认也有对Hystrix的集成：</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.21.png"></p><h4 id="开启熔断器"><a href="#开启熔断器" class="headerlink" title="开启熔断器"></a>开启熔断器</h4><p>默认情况下熔断器是关闭的。需要在<code>consumer-demo\src\main\resources\application.yml</code>添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启Feign内置的熔断功能</span><br></code></pre></td></tr></table></figure><h4 id="定义fallback处理类"><a href="#定义fallback处理类" class="headerlink" title="定义fallback处理类"></a>定义fallback处理类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserClient</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setId(id);<br>        user.setName(<span class="hljs-string">&quot;用户异常&quot;</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在UserFeignClient中，指定刚才编写的实现类"><a href="#在UserFeignClient中，指定刚才编写的实现类" class="headerlink" title="在UserFeignClient中，指定刚才编写的实现类"></a>在UserFeignClient中，指定刚才编写的实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;user-service&quot;,fallback = UserClientFallback.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserClient</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><p>重启<code>consumer-demo </code>并关闭 <code>user-service</code> 服务，模拟故障发生</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.22.png"></p><h3 id="2-11-7-请求压缩配置"><a href="#2-11-7-请求压缩配置" class="headerlink" title="2.11.7 请求压缩配置"></a>2.11.7 请求压缩配置</h3><p>Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。同时，也可以对请求的数据类型，以及触发压缩的大小下限进行设置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启Feign内置的熔断功能</span><br>  <span class="hljs-attr">compression:</span><br>    <span class="hljs-attr">request:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启请求压缩</span><br>      <span class="hljs-attr">mime-types:</span> <span class="hljs-string">text/html,application/xml,application/json</span> <span class="hljs-comment"># 设置压缩的数据类型</span><br>      <span class="hljs-attr">min-request-size:</span> <span class="hljs-number">2048</span> <span class="hljs-comment"># 设置触发压缩的大小下限</span><br>    <span class="hljs-attr">response:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>  <br></code></pre></td></tr></table></figure><h3 id="2-11-8-日志配置"><a href="#2-11-8-日志配置" class="headerlink" title="2.11.8 日志配置"></a>2.11.8 日志配置</h3><p>通过<code>logging.level.xx=debug</code>来设置的日志级别。对Fegin客户端不会产生效果。因为<code>@FeignClient</code>注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。需要额外指定这个日志的级别才可以。</p><h4 id="设置统一日志级别"><a href="#设置统一日志级别" class="headerlink" title="设置统一日志级别"></a>设置统一日志级别</h4><p>修改<code>consumer-demo\src\main\resources\application.yml</code>，添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">top.igotcha:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h4 id="编写FeignConfig配置类"><a href="#编写FeignConfig配置类" class="headerlink" title="编写FeignConfig配置类"></a>编写FeignConfig配置类</h4><p>在<code>consumer-demo</code>编写<code>FeignConfig</code>配置类，定义日志级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    Logger.<span class="hljs-function">Level <span class="hljs-title">feignLoggerLevel</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//记录所有请求和响应的明细，包括头信息、请求体、元数据</span><br>        <span class="hljs-keyword">return</span> Logger.Level.FULL;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里指定的Level级别是FULL，Feign支持4种级别：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul></blockquote><h4 id="在接口类上指定配置类"><a href="#在接口类上指定配置类" class="headerlink" title="在接口类上指定配置类"></a>在接口类上指定配置类</h4><p>在<code>consumer-demo</code>的<code>UserClient</code>接口类上的@FeignClient注解中指定配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;user-service&quot;,fallback = UserClientFallback.class,configuration = FeignConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserClient</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行项目-1"><a href="#运行项目-1" class="headerlink" title="运行项目"></a>运行项目</h4><p>以debug模式重启<code>consumer-demo</code>，查看控制台</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/2.23.png"></p><hr><h1 id="三、-Spring-Cloud-Gateway网关"><a href="#三、-Spring-Cloud-Gateway网关" class="headerlink" title="三、 Spring Cloud Gateway网关"></a>三、 Spring Cloud Gateway网关</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ul><li><p>Spring Cloud Gateway基于<strong>Filter</strong>链提供网关基本功能：安全、监控／埋点、限流等。 </p></li><li><p>Spring Cloud Gateway组件的核心是一系列的过滤器，通过这些过滤器可以将客户端发送的请求转发（路由）到对应的微服务。 Spring Cloud Gateway是加在整个微服务最前沿的防火墙和代理器，<strong>隐藏微服务结点IP端口信息</strong>，从而加强安全保护。<strong>Spring Cloud Gateway本身也是一个微服务，需要注册到Eureka服务注册中心</strong>。</p></li></ul><p>网关的核心功能是：<strong>过滤</strong>和<strong>路由</strong></p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/3.1.png"></p><ul><li>不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都可经过网关，然后再由网关来实现 鉴权、动态路由等等操作。Gateway就是服务的统一入口。</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>路由（route）</strong> 路由信息的组成：由一个ID、一个目的URL、一组断言工厂、一组Filter组成。如果路由断言为真，说明请求URL和配置路由匹配。 </li><li><strong>断言（Predicate）</strong> Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的 ServerWebExchange。Spring Cloud Gateway的断言函数允许开发者去定义匹配来自于Http Request中的任何信息比如请求头和参数。</li><li><strong>过滤器（Filter）</strong> 一个标准的Spring WebFilter。 Spring Cloud Gateway中的Filter分为两种类型的Filter，分别 是Gateway Filter和Global Filter。过滤器Filter将会对请求和响应进行修改处理</li></ul><h2 id="3-2-配置网关模块"><a href="#3-2-配置网关模块" class="headerlink" title="3.2 配置网关模块"></a>3.2 配置网关模块</h2><h3 id="创建新module"><a href="#创建新module" class="headerlink" title="创建新module"></a>创建新module</h3><p>创建Maven模块，gateway</p><h3 id="导入Maven依赖"><a href="#导入Maven依赖" class="headerlink" title="导入Maven依赖"></a>导入Maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-demo01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>top.igotcha<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-comment"># 路由id，可以随意写</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service-route</span><br>        <span class="hljs-comment"># 代理的服务地址，lb表示从eureka中获取具体服务（动态路由）</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:9091</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-service</span><br>        <span class="hljs-comment"># 路由断言，可以配置映射路径</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>使用动态路由注意事项：</p><p>lb 之后编写的服务名必须要在eureka中注册才能使用</p></blockquote><h3 id="编写启动器Application"><a href="#编写启动器Application" class="headerlink" title="编写启动器Application"></a>编写启动器Application</h3><p>编写<code>springcloud-demo01/gateway/src/main/java/top/igotcha/gateway/GatewayApplication.java</code>启动器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GatewayApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(GatewayApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行项目-2"><a href="#运行项目-2" class="headerlink" title="运行项目"></a>运行项目</h3><p>可以从10010网关端口进行访问了</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/3.2.png"></p><blockquote><p>路由配置中uri所用的协议为lb时（以uri: lb://user-service为例），gateway将使用 LoadBalancerClient把 user-service通过eureka解析为实际的主机和端口，并进行ribbon负载均衡。</p></blockquote><hr><h2 id="3-3-路由前缀"><a href="#3-3-路由前缀" class="headerlink" title="3.3 路由前缀"></a>3.3 路由前缀</h2><h3 id="添加前缀"><a href="#添加前缀" class="headerlink" title="添加前缀"></a>添加前缀</h3><p>在gateway中可以通过配置路由的过滤器PrefixPath，实现映射路径中地址的添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-comment"># 路由id，可以随意写</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service-route</span><br>        <span class="hljs-comment"># 代理的服务地址，lb表示从eureka中获取具体服务</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:9091</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-service</span><br>        <span class="hljs-comment"># 路由断言，可以配置映射路径</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-comment"># 添加请求路径的前缀</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">PrefixPath=/user</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li>通过 PrefixPath=/xxx 来指定了路由要添加的前缀。<strong>对请求地址添加前缀路径之后再作为代理的服务地址</strong></li></ul><p><code>PrefixPath = /user</code>，实现了 <a href="http://localhost:10010/1">http://localhost:10010/1</a> –》<a href="http://localhost:9091/user/1%EF%BC%8C%EF%BC%88%E6%B7%BB%E5%8A%A0%E5%89%8D%E7%BC%80%E8%B7%AF%E5%BE%84/user%EF%BC%89">http://localhost:9091/user/1，（添加前缀路径/user）</a></p><p>测试运行如下</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/3.3.png"></p><h3 id="去除前缀"><a href="#去除前缀" class="headerlink" title="去除前缀"></a>去除前缀</h3><p>在gateway中可以通过配置路由的过滤器StripPrefix，实现映射路径中地址的去除</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-comment"># 路由id，可以随意写</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service-route</span><br>        <span class="hljs-comment"># 代理的服务地址，lb表示从eureka中获取具体服务</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:9091</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-service</span><br>        <span class="hljs-comment"># 路由断言，可以配置映射路径</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/user/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-comment"># 表示过滤1个路径，2表示两个路径，以此类推</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li>通过 StripPrefix=/xxx 来指定了路由要去除前缀的个数。<strong>对请求地址去除前缀路径之后再作为代理的服务地址</strong></li></ul><p><code>StripPrefix=1</code>，实现了 <a href="http://localhost:10010/api/user/1">http://localhost:10010/api/user/1</a> –》<a href="http://localhost:9091/user/1">http://localhost:9091/user/1</a> ，（去除前缀路径/api）</p><p><code>StripPrefix=2</code>，实现了 <a href="http://localhost:10010/api/user/1">http://localhost:10010/api/user/1</a> –》<a href="http://localhost:9091/1%EF%BC%8C%EF%BC%88%E5%8E%BB%E9%99%A4%E5%89%8D%E7%BC%80%E8%B7%AF%E5%BE%84/api/user%EF%BC%89">http://localhost:9091/1，（去除前缀路径/api/user）</a></p><hr><h2 id="3-4-过滤器"><a href="#3-4-过滤器" class="headerlink" title="3.4 过滤器"></a>3.4 过滤器</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p>Gateway作为网关的重要功能，就是实现请求的鉴权。这个动作往往是通过网关提供的过滤器来实现的。 路由前缀的添加和去除功能也是使用过滤器实现的。</p><p>Gateway自带过滤器有几十个，常见自带过滤器有：</p><table><thead><tr><th>过滤器名称</th><th>说明</th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>对匹配上的请求加上Header</td></tr><tr><td>AddRequestParameters</td><td>对匹配上的请求路由添加参数</td></tr><tr><td>AddResponseHeader</td><td>对从网关返回的响应添加Header</td></tr><tr><td>StripPrefix</td><td>对匹配上的请求路径去除前缀</td></tr></tbody></table><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>Gateway实现方式上，有两种过滤器； </p><ul><li><strong>局部过滤器</strong>：<ul><li>通过<code>spring.cloud.gateway.routes.filters</code>配置在具体路由下，只作用在当前路由上</li></ul></li><li><strong>全局过滤器</strong>：<ul><li>不需要在配置文件中配置，作用在所有的路由上；实现<code>GlobalFilter</code>接口即可。</li><li>如果配置<code>spring.cloud.gateway.default-filters</code>上会对所有路由生效也算是全局的过滤器；但是这些过滤器的实现上，都是要实现GatewayFilterFactory接口（实现上还是和局部过滤器一样）。</li></ul></li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Spring Cloud Gateway 的 Filter 的生命周期也类似Spring MVC的拦截器有两个：“pre” 和 “post”。“pre”和 “post” 分别会在请求被执行前调用和被执行后调用。</p><p>这里的<code>pre</code>和<code>post</code>可以通过过滤器的<code>GatewayFilterChain</code>执行<code>filter</code>方法前后来实现。</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/3.4.png"></p><h3 id="自定义局部过滤器"><a href="#自定义局部过滤器" class="headerlink" title="自定义局部过滤器"></a>自定义局部过滤器</h3><h4 id="编写过滤器"><a href="#编写过滤器" class="headerlink" title="编写过滤器"></a>编写过滤器</h4><p>在gateway工程编写过滤器工厂类<code>MyParamGatewayFilterFactor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyParamGatewayFilterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractGatewayFilterFactory</span>&lt;<span class="hljs-title">MyParamGatewayFilterFactory</span>.<span class="hljs-title">Config</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//值要与Config配置类中一致</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PARAM_NAME = <span class="hljs-string">&quot;param&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyParamGatewayFilterFactory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(Config.class);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">shortcutFieldOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Arrays.asList(PARAM_NAME);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> GatewayFilter <span class="hljs-title">apply</span><span class="hljs-params">(Config config)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ((exchange, chain) -&gt; &#123;<br>            <span class="hljs-comment">//获取请求参数中param对应的参数名称</span><br>            ServerHttpRequest request = exchange.getRequest();<br>            <span class="hljs-keyword">if</span> (request.getQueryParams().containsKey(config.param))&#123;<br>                request.getQueryParams().get(config.param)<br>                        .forEach(value-&gt;System.out.printf(<span class="hljs-string">&quot;-----局部过滤器-----%s=%s&quot;</span>,config.param,value));<br>            &#125;<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>&#123;<br>        <span class="hljs-comment">//对应在配置在自定义过滤器中指定的参数</span><br>        <span class="hljs-keyword">private</span> String param;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getParam</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> param;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setParam</span><span class="hljs-params">(String param)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.param = param;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修改配置文件-1"><a href="#修改配置文件-1" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>修改<code>springcloud-demo01/gateway/src/main/resources/application.yml</code>配置文件，添加自定义过滤器</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span><br>  <span class="hljs-attr">cloud:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-comment"># 路由id，可以随意写</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service-route</span><br>        <span class="hljs-comment"># 代理的服务地址，lb表示从eureka中获取具体服务</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:9091</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-service</span><br>        <span class="hljs-comment"># 路由断言，可以配置映射路径</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/user/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-comment"># 表示过滤1个路径，2表示两个路径，以此类推</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>            <span class="hljs-comment"># 自定义过滤器中值</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">MyParam=name</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="运行项目-3"><a href="#运行项目-3" class="headerlink" title="运行项目"></a>运行项目</h4><p>重启项目后，当请求参数含有name属性时，会打印name的值</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/3.5.png"></p><h3 id="全局默认过滤器"><a href="#全局默认过滤器" class="headerlink" title="全局默认过滤器"></a>全局默认过滤器</h3><p>对于自带的过滤器，可以设置为对所有路由生效，也就是配置成为默认过滤器：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-comment"># 默认过滤器，对所有路由生效</span><br>      <span class="hljs-attr">default-filters:</span><br>        <span class="hljs-comment"># 响应头过滤器，对输出的响应设置其头部属性名称为X-Response-Default-MyName，值为Gotcha；如果有多个参数多则重写一行设置不同的参数</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddResponseHeader=X-Response-Default-MyName,</span> <span class="hljs-string">Gotcha</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-comment"># 路由id，可以随意写</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service-route</span><br>        <span class="hljs-comment"># 代理的服务地址，lb表示从eureka中获取具体服务</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:9091</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-service</span><br>        <span class="hljs-comment"># 路由断言，可以配置映射路径</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/user/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-comment"># 表示过滤1个路径，2表示两个路径，以此类推</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>            <span class="hljs-comment"># 自定义过滤器中值</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">MyParam=name</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br><br></code></pre></td></tr></table></figure><p>设置后，在响应头中可以查看到响应信息</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/3.6.png"></p><h3 id="全局自定义过滤器"><a href="#全局自定义过滤器" class="headerlink" title="全局自定义过滤器"></a>全局自定义过滤器</h3><h4 id="编写全局过滤器"><a href="#编写全局过滤器" class="headerlink" title="编写全局过滤器"></a>编写全局过滤器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;-----全局过滤器MyGlobalFilter-----&quot;</span>);<br>        String token = exchange.getRequest().getQueryParams().getFirst(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(token)) &#123;<br>            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>        &#125;<br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//值越小越先执行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实现<code>GlobalFilter</code>接口的全局过滤器，不需要在配置文件中配置，作用在所有的路由上。</p></blockquote><ul><li>未携带token，返回401未授权</li></ul><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/3.7.png"></p><ul><li>携带token，正常访问</li></ul><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/3.8.png"></p><h2 id="3-5-负载均衡和熔断配置"><a href="#3-5-负载均衡和熔断配置" class="headerlink" title="3.5 负载均衡和熔断配置"></a>3.5 负载均衡和熔断配置</h2><p>Gateway中默认就已经集成了Ribbon负载均衡和Hystrix熔断机制。所有的超时策略都是默认值。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">hystrix:</span><br>  <span class="hljs-attr">command:</span><br>    <span class="hljs-attr">default:</span><br>      <span class="hljs-attr">execution:</span><br>        <span class="hljs-attr">isolation:</span><br>          <span class="hljs-attr">thread:</span><br>            <span class="hljs-attr">timeoutInMilliseconds:</span> <span class="hljs-number">6000</span><br><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">1000</span><br>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">2000</span><br>  <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="3-5-跨域配置"><a href="#3-5-跨域配置" class="headerlink" title="3.5 跨域配置"></a>3.5 跨域配置</h2><p>在访问Spring Cloud Gateway网关服务器的时候，出现跨域问题的话，可以在网关服务器中通过配置解决，允许哪些服务是可以跨域请求的。具体配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-comment"># 默认过滤器，对所有路由生效</span><br>      <span class="hljs-attr">default-filters:</span><br>        <span class="hljs-comment"># 响应头过滤器，对输出的响应设置其头部属性名称为X-Response-Default-MyName，值为Gotcha；如果有多个参数多则重写一行设置不同的参数</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddResponseHeader=X-Response-Default-MyName,</span> <span class="hljs-string">Gotcha</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-comment"># 路由id，可以随意写</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service-route</span><br>        <span class="hljs-comment"># 代理的服务地址，lb表示从eureka中获取具体服务</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:9091</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-service</span><br>        <span class="hljs-comment"># 路由断言，可以配置映射路径</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/user/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-comment"># 表示过滤1个路径，2表示两个路径，以此类推</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>            <span class="hljs-comment"># 自定义过滤器中值</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">MyParam=name</span><br>      <span class="hljs-attr">globalcors:</span><br>        <span class="hljs-attr">corsConfigurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span><br>            <span class="hljs-comment">#allowedOrigins: * # 这种写法或者下面的都可以，*表示全部</span><br>            <span class="hljs-attr">allowedOrigins:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;http://docs.spring.io&quot;</span><br>            <span class="hljs-attr">allowedMethods:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">GET</span><br></code></pre></td></tr></table></figure><blockquote><p>上述配置表示：可以允许来自 <a href="http://docs.spring.io/">http://docs.spring.io</a> 的get请求方式获取服务数据。 allowedOrigins 指定允许访问的服务器地址，如：<a href="http://localhost:10000/">http://localhost:10000</a> 也是可以的。 ‘[/**]’ 表示对所有访问到网关服务器的请求地址</p></blockquote><blockquote><p>Gateway网关一般直接给终端请求使用；Feign一般用在微服务之间调用。</p></blockquote><hr><h1 id="四、-Spring-Cloud-Config分布式配置中心"><a href="#四、-Spring-Cloud-Config分布式配置中心" class="headerlink" title="四、 Spring Cloud Config分布式配置中心"></a>四、 Spring Cloud Config分布式配置中心</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>在分布式系统中，由于服务数量非常多，配置文件分散在不同的微服务项目中，管理不方便。为了方便配置文件集中管理，需要分布式配置中心组件。</p><p>在Spring Cloud中，提供了Spring Cloud Config，它支持配置文件放在配置服务的本地，也支持放在远程Git仓库（GitHub、码云）。 使用Spring Cloud Config配置中心后的架构如下图：</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/4.1.png"></p><blockquote><p>spring cloud config实现了，通过修改在git仓库中的配置文件实现其它所有微服务的配置文件的修改。</p></blockquote><hr><h1 id="五、Spring-Cloud-Bus服务总线"><a href="#五、Spring-Cloud-Bus服务总线" class="headerlink" title="五、Spring Cloud Bus服务总线"></a>五、Spring Cloud Bus服务总线</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Spring Cloud Bus是用轻量的消息代理将分布式的节点连接起来，可以用于广播配置文件的更改或者服务的监控管理。也就是消息总线可以为微服务做监控，也可以实现应用程序之间相互通信。 Spring Cloud Bus可选的消息代理有RabbitMQ和Kafka。使用Spring Cloud Bus服务总线后的架构如下图：</p><p><img src="/2021/01/25/Java/%E6%A1%86%E6%9E%B6/SpringCloud/SpringCloud%E5%85%A5%E9%97%A8/SpringCloud%E5%85%A5%E9%97%A8/5.1.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>框架</category>
      
      <category>Spring</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot中异常处理的3种方式</title>
    <link href="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、不处理异常"><a href="#一、不处理异常" class="headerlink" title="一、不处理异常"></a>一、不处理异常</h1><p>假如SpringMvc我们不对异常进行任何处理，界面上显示的是这样的。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213505335-1513644054.png" alt="img"></p><h1 id="二、解决方式"><a href="#二、解决方式" class="headerlink" title="二、解决方式"></a>二、解决方式</h1><h2 id="2-1-Controller层面处理-ExceptionHandler"><a href="#2-1-Controller层面处理-ExceptionHandler" class="headerlink" title="2.1 Controller层面处理@ExceptionHandler"></a>2.1 Controller层面处理@ExceptionHandler</h2><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>说明:针对可能出问题的Controller，新增注解方法@ExceptionHandler。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/testController&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br> <br>    <span class="hljs-meta">@RequestMapping(&quot;/demo1&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">demo1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Date();<br>    &#125;<br> <br>    <span class="hljs-meta">@ExceptionHandler(&#123;RuntimeException.class&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">fix</span><span class="hljs-params">(Exception ex)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;do This&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>,<span class="hljs-keyword">new</span> ModelMap(<span class="hljs-string">&quot;ex&quot;</span>,ex.getMessage()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意事项:</p><ol><li>一个Controller下多个@ExceptionHandler上的异常类型不能出现一样的，否则运行时抛异常：Ambiguous @ExceptionHandler method mapped for;</li><li>@ExceptionHandler下方法返回值类型支持多种，常见的ModelAndView，@ResponseBody注解标注，ResponseEntity等类型都OK.</li></ol></blockquote><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>代码片段位于：<code>org.springframework.web.servlet.DispatcherServlet#doDispatch</code></p><p>执行@RequestMapping方法抛出异常后，Spring框架 try-catch的方法捕获异常，正常逻辑发不发生异常都会走processDispatchResult流程 ，区别在于异常的参数是否为null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">HandlerExecutionChain mappedHandler = <span class="hljs-keyword">null</span>;<br>    Exception dispatchException = <span class="hljs-keyword">null</span>;<br>    ModelAndView mv = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span>&#123;  <br>        mappedHandler=getHandler(request); <span class="hljs-comment">//根据请求查找handlerMapping找到controller</span><br>        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());<span class="hljs-comment">//找到处理器适配器HandlerAdapter</span><br>         <br>        <span class="hljs-keyword">if</span>(!mappedHandler.applyPreHandle(request,response))&#123; <span class="hljs-comment">//拦截器preHandle</span><br>            <span class="hljs-keyword">return</span> ;<br>        &#125;       <br>        mv=ha.handle(request,response); <span class="hljs-comment">//调用处理器适配器执行@RequestMapping方法</span><br>        mappedHandler.applyPostHandle(request,response,mv);  <span class="hljs-comment">//拦截器postHandle</span><br>    &#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br>        dispatchException=ex;<br>    &#125;<br>        processDispatchResult(request,response,mappedHandler,mv,dispatchException) <span class="hljs-comment">//将异常信息传入</span><br></code></pre></td></tr></table></figure><p>代码片段位于：<code>org.springframework.web.servlet.DispatcherServlet#processDispatchResult</code></p><p>如果@RequestMapping方法抛出异常，拦截器的postHandle方法不执行，进入 processDispatchResult，判断入参 dispatchException，不为null , 代表发生异常，调用processHandlerException处理。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213505888-2030203515.png" alt="image"></p><p>代码片段位于：<code>org.springframework.web.servlet.DispatcherServlet#processHandlerException</code></p><p>this当前对象指dispatchServlet，handlerExceptionResolvers可以看到有三个HandlerExceptionResolver，这三个是&lt;mvc:annotation-driven /&gt;帮我们注册的。遍历有序集合handlerExceptionResolvers，调用接口的resolveException方法。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213506844-1654136479.png" alt="image"></p><p>记录<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>注册的第一个 HandlerExceptionResolver : ExceptionHandlerExceptionResolver，继承关系如下面所示。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213507487-117467346.png" alt="image"></p><p>代码片段位于：<code>org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#resolveException</code></p><p>AbstractHandlerExceptionResolver 和 AbstractHandlerMethodExceptionResolver名字看起来非常相似。这里AbstractHandlerExceptionResolver 的shouldApplyTo都返回 true，logException用来记录日志、prepareResponse方法用来设置response的Cache-Control。异常处理方法就位于doResolveException。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213508459-1480757473.png" alt="image"></p><p>代码片段位于：<code>org.springframework.web.servlet.handler.AbstractHandlerMethodExceptionResolver#shouldApplyTo</code></p><p>接口方法实现是AbstractHandlerExceptionResolver的resolveException，先判断 shouldApplyTo，AbstractHandlerExceptionResolver 和子类AbstractHandlerMethodExceptionResolver都实现了shouldApplyTo方法，子类的shouldApplyTo都调用父类AbstractHandlerExceptionResolver的shouldApplyTo。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213509235-794344844.png" alt="image"></p><p>查看父类AbstractHandlerExceptionResolver的shouldApplyTo方法.</p><p>代码片段位于：<code>org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#shouldApplyTo</code></p><p>Spring初始化的时候并没有额外配置，所以mappedHandlers和mappedHandlerClasses都为null，可以在这块扩展进行筛选 ，AbstractHandlerExceptionResolver提供了 setMappedHandlerClasses 、setMappedHandlers用于扩展。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213510217-865137658.png" alt="image"></p><p>代码片段位于：<code>org.springframework.web.servlet.handler.AbstractHandlerMethodExceptionResolver#doResolveException</code></p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213511032-81051857.png" alt="image"></p><p>代码片段位于：<code>org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#doResolveHandlerMethodException</code></p><p>似曾相识的ServletInvocableHandlerMethod，<strong>getExceptionHandlerMethod</strong>目的就是获取针对异常的处理方法，没找到的话这里就直接返回了，找到了执行异常处理方法；</p><p>之后同Spring请求方法执行一样的处理方式，设置argumentResolvers、returnValueHandlers，之后进行调用异常处理方法，</p><p><strong>@ExceptionHandler的方法入参支持：Exception ；SessionAttribute 、 RequestAttribute注解 ； HttpServletRequest 、HttpServletResponse、HttpSession.</strong></p><p><strong>@ExceptionHandler方法返回值常见的可以是: ModelAndView 、@ResponseBody注解、ResponseEntity;</strong></p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213512288-1219310442.png" alt="image"></p><p><strong>getExceptionHandlerMethod说明： 获取对应的@ExceptionHandler方法，封装成ServletInvocableHandlerMethod返回.</strong></p><p>代码片段位于：<code>org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getExceptionHandlerMethod</code></p><p><strong>exceptionHandlerCache是针对Controller层面的@ExceptionHandler的处理方式，而exceptionHandlerAdviceCache是针对@ControllerAdvice的处理方式。这两个属性都位于ExceptionHandlerExceptionResolver中。</strong></p><p>handlerType指代Controller的class属性，尝试从<strong>缓存A</strong> exceptionHandlerCache 中根据controller的class 查找ExceptionHandlerMethodResolver； <strong>缓存A</strong>之前没存储过Controller的class ，所以新建一个ExceptionHandlerMethodResolver 加入缓存中。ExceptionHandlerMethodResolver 的初始化工作一定做了某些工作。</p><p>resolveMethod方法：根据异常对象让 ExceptionHandlerMethodResolver 解析得到 method ， 匹配到异常处理方法 就直接封装成对象 ServletInvocableHandlerMethod ； 就不会再去走@ControllerAdvice里的异常处理器了。这里说明了，ExceptionHandlerMethodResolver 初始化的时候完成存储 @ExceptionHandler。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213513211-1902635389.png" alt="image"></p><p><strong>查看ExceptionHandlerMethodResolver 初始化工作内容:</strong></p><p>代码片段位于：<code>org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#ExceptionHandlerMethodResolver</code></p><p>handlerType为传入的Controller的class属性，通过EXCEPTION_HANDLER_METHODS选出 class 中标注@ExceptionHandler的方法，解析@Exception注解的value值(class类型的数组)，并加入到当前ExceptionHandlerMethodResolver的mappedMethods集合中，key为 异常类型 ，value为 method。</p><p><strong>如果@ExceptionHandler的 value属性为空，就会将方法入参中的Throwable的子类作为异常类型。@ExceptionHandler的value属性和方法入参不能同时都为空，否则会抛出异常。</strong></p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/image-20220112170104666.png" alt="image-20220112170104666"></p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213515732-1845386764.png" alt="image"></p><p><strong>ExceptionHandlerMethodResolver完成了初始化工作，如何根据当前发生异常类型查找到对应方法?</strong></p><p>代码片段位于：<code>org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#resolveMethod</code></p><p><strong>resolveMethodByExceptionType</strong>根据当前抛出异常寻找 匹配的方法，并且做了缓存，以后遇到同样的异常可以直接走缓存取出method，</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213516357-941731817.png" alt="image"></p><p>代码片段位于：<code>org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#resolveMethodByExceptionType</code></p><p><strong>resolveMethodByExceptionType</strong>方法，尝试从<strong>缓存A</strong>：exceptionLookupCache中根据 异常class类型获取Method ，初始时候肯定缓存为空 ，就去遍历ExceptionHandlerMethodResolver的mappedMethods(上面提及了key为异常类型，value为method), exceptionType为当前@RequestMapping方法抛出的异常，判断当前异常类型是不是@ExceptionHandler中value声明的子类或本身，满足条件就代表匹配上了；可能存在多个匹配的方法，使用ExceptionDepthComparator排序，排序规则是按照继承顺序来(继承关系越靠近数值越小，当前类最小为0,顶级父类Throwable为int最大值)，排序之后选取继承关系最靠近的那个，并且存入ExceptionHandlerMethodResolver的exceptionLookupCache中，key为当前抛出的异常，value为解析出来的匹配method。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213517347-1230556380.png" alt="image"></p><p>至此 @ExceptionHandler Spring读取到并解析出来完毕了，后续流程和Spring正常请求流程一样，包括@ExceptionHandler的方法入参、方法返回值。</p><p><strong>@ExceptionHandler的方法入参支持：Exception ；SessionAttribute 、 RequestAttribute注解 ； HttpServletRequest 、HttpServletResponse、HttpSession.</strong></p><p><strong>@ExceptionHandler方法返回值常见的可以是: ModelAndView 、@ResponseBody注解、ResponseEntity;</strong></p><hr><h2 id="2-2-全局级别异常处理，实现HandlerExceptionResolver接口"><a href="#2-2-全局级别异常处理，实现HandlerExceptionResolver接口" class="headerlink" title="2.2 全局级别异常处理，实现HandlerExceptionResolver接口"></a>2.2 全局级别异常处理，实现HandlerExceptionResolver接口</h2><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandlerExceptionResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;发生全局异常!&quot;</span>);<br>        ModelMap mmp=<span class="hljs-keyword">new</span> ModelMap();<br>        mmp.addAttribute(<span class="hljs-string">&quot;ex&quot;</span>,ex.getMessage());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>,mmp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方式： <strong>只需要将该Bean加入到Spring容器，可以通过Xml配置，也可以通过注解方式加入容器;</strong> </p><p><strong>方法返回值不为null才有意义，如果方法返回值为null，可能异常就没有被捕获.</strong></p><blockquote><p>缺点分析：比如这种方式全局异常处理返回JSP、velocity等视图比较方便，返回json或者xml等格式的响应就需要自己实现了。如下是实现的发生全局异常返回JSON的简单例子。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandlerExceptionResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;发生全局异常!&quot;</span>);<br>        ModelMap mmp=<span class="hljs-keyword">new</span> ModelMap();<br>        mmp.addAttribute(<span class="hljs-string">&quot;ex&quot;</span>,ex.getMessage());<br>        response.addHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>,<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">new</span> ObjectMapper().writeValue(response.getWriter(),ex.getMessage());<br>            response.getWriter().flush();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>之前介绍了 DispatcherServlet的HandlerExceptionResolver集合，这种方式的HandlerExceptionResolver就是从DispatcherServlet的HandlerExceptionResolver集合入手的。</p><p>代码片段位于：<code>org.springframework.web.servlet.DispatcherServlet#processHandlerException</code></p><p>this对象指代DispatcherServlet，和上面方式对比，发现我们只是将MyHandlerExceptionResolver 加入到Spring容器，dispatchServlet 的 handlerExceptionResolvers属性就多了我们自己定义的全局异常解析器；</p><p>ExceptionHandlerMethodResolver是用来解析@Controller层面的@ExceptionHandler注解，当前Controller没有找到@ExceptionHandler来处理自己抛出的异常，才遍历下一个HandlerExceptionResolver；</p><p><strong>HandlerExceptionResolver是个有序集合，Spring注册的HandlerExceptionResolver调用resolveException都失败之后，才轮到我们自定义的MyHandlerExceptionResolver ；而且我们自定义的MyHandlerExceptionResolver 就没法使用SpringMvc的注解等等.</strong></p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213518226-1400160846.png" alt="image"></p><p><strong>我们只是将HandlerExceptionResolver加入到Spring容器中,Spring是如何通知给DispatcherServlet呢?</strong></p><p>代码片段位于：<code>org.springframework.web.servlet.DispatcherServlet#initHandlerExceptionResolvers</code></p><p><strong>initHandlerExceptionResolvers只是DispatcherServlet初始化策略方法initStrategies中的一小步，可以看到只要是SpringMvc父子容器中注册的HandlerExceptionResolver类型实例，DispatcherServlet都会自动将其加入到DispatcherServlet的handlerExceptionResolvers中。所以我们需要做的只是实现HandlerExceptionResolver接口，并且纳入Spring容器管理即可。</strong></p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213519385-76841028.png" alt="image"></p><hr><h2 id="2-3-全局级别异常处理器-Controller-ExceptionHandler"><a href="#2-3-全局级别异常处理器-Controller-ExceptionHandler" class="headerlink" title="2.3 全局级别异常处理器@Controller+@ExceptionHandler"></a>2.3 全局级别异常处理器@Controller+@ExceptionHandler</h2><h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalController</span> </span>&#123;<br> <br>    <span class="hljs-meta">@ExceptionHandler(RuntimeException.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">fix1</span><span class="hljs-params">(Exception e)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;全局的异常处理器&quot;</span>);<br>        ModelMap mmp=<span class="hljs-keyword">new</span> ModelMap();<br>        mmp.addAttribute(<span class="hljs-string">&quot;ex&quot;</span>,e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>,mmp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用法说明: <strong>这种情况下 @ExceptionHandler 与第一种方式用法相同，返回值支持ModelAndView，@ResponseBody等多种形式.</strong></p><h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><p><strong>方式一提到ExceptionHandlerExceptionResolver不仅维护@Controller级别的@ExceptionHandler，同时还维护的@ControllerAdvice级别的@ExceptionHandler.</strong></p><p>代码片段位于：<code>org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getExceptionHandlerMethod</code></p><p> isApplicableToBeanType方法是用来做条件判断的，@ControllerAdvice注解有很多属性用来设置条件，basePackageClasses、assignableTypes、annotations等，比如我限定了annotations为注解X， 那标注了@X 的ControllerA就可以走这个异常处理器，ControllerB就不能走这个异常处理器。</p><p>现在问题的关键就只剩下了exceptionHandlerAdviceCache是什么时候扫描@ControllerAdvice的，下面的逻辑和@ExceptionHandler的逻辑一样了。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213520405-253670661.png" alt="image"></p><p><strong>exceptionHandlerAdviceCache初始化逻辑:</strong></p><p>代码片段位于：<code>org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#afterPropertiesSet</code></p><p>afterPropertiesSet是Spring bean创建过程中一个重要环节。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213521107-576988204.png" alt="image"></p><p>代码片段位于：<code>org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#initExceptionHandlerAdviceCache</code></p><p>ControllerAdviceBean.findAnnotatedBeans方法查找了SpringMvc父子容器中标注 @ControllerAdvice 的bean，new ExceptionHandlerMethodResolver初始化时候解析了当前的@ControllerAdvice的bean的@ExceptionHandler，加入到<strong>ExceptionHandlerExceptionResolver</strong>的<strong>exceptionHandlerAdviceCache</strong>中，key为ControllerAdviceBean，value为ExceptionHandlerMethodResolver 。到这里exceptionHandlerAdviceCache就初始化完毕。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213522102-1856948808.png" alt="image"></p><p><strong>查找SpringMvc父子容器中所有@ControllerAdivce的bean的方法</strong></p><p>代码片段位于：org.springframework.web.method.ControllerAdviceBean#findAnnotatedBeans</p><p>遍历了SpringMVC父子容器中所有的bean，标注ControllerAdvice注解的bean加入集合返回。</p><p><img src="/2021/01/11/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/1550387-20190321213523591-764129054.png" alt="image"></p><hr><h1 id="三、比较"><a href="#三、比较" class="headerlink" title="三、比较"></a>三、比较</h1><p>@Controller+@ExceptionHandler、HandlerExceptionResolver接口形式、@ControllerAdvice+@ExceptionHandler优缺点说明：</p><p>在Spring4.3.0版本下，</p><ol><li>优先级来说，@Controller+@ExceptionHandler优先级最高，其次是@ControllerAdvice+@ExceptionHandler，最后才是HandlerExceptionResolver，说明假设三种方式并存的情况优先级越高的越先选择，而且被一个捕获处理了就不去执行其他的。</li><li> 三种方式都支持多种返回类型，@Controller+@ExceptionHandler、@ControllerAdvice+@ExceptionHandler可以使用Spring支持的@ResponseBody、ResponseEntity，而HandlerExceptionResolver方法声明返回值类型只能是 ModelAndView，如果需要返回JSON、xml等需要自己实现。</li><li>缓存利用，@Controller+@ExceptionHandler的缓存信息在<strong>ExceptionHandlerExceptionResolver的</strong>exceptionHandlerCache，@ControllerAdvice+@ExceptionHandler的缓存信息在<strong>ExceptionHandlerExceptionResolver的exceptionHandlerAdviceCache</strong>中，而HandlerExceptionResolver接口是不做缓存的，在前面两种方式都fail的情况下才会走自己的HandlerExceptionResolver实现类，多少有点性能损耗。</li></ol><hr><p>文章参考<a href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html">此处</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>框架</category>
      
      <category>Spring</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据基础</title>
    <link href="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>对于“大数据”（Big data）研究机构Gartner给出了这样的定义。“大数据”是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力来适应海量、高增长率和多样化的信息资产。</p><p>麦肯锡全球研究所给出的定义是：一种规模大到在获取、存储、管理、分析方面大大超出了传统数据库软件工具能力范围的数据集合，<strong>具有海量的数据规模</strong>、<strong>快速的数据流转</strong>、<strong>多样的数据类型</strong>和<strong>价值密度低</strong>四大特征</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h3><ol><li><p>创建虚拟机</p><ul><li>安装虚拟机 VMWare</li><li>创建虚拟机</li><li>安装 CentOS</li><li>组成集群</li></ul></li><li><p>配置每台主机</p><ul><li>关闭防火墙</li><li>关闭 SELinux</li><li>设置主机名</li><li>重启</li><li>设置时钟同步服务</li><li>配置用户权限</li><li>免密登录</li></ul></li><li><p>安装辅助软件</p><ul><li>JDK</li><li>Zookeeper</li></ul></li><li><p>安装 Hadoop</p><ul><li><p>下载并解压</p></li><li><p>修改配置</p></li><li><p>分发到每个节点</p></li><li><p>格式化 HDFS</p></li><li><p>启动集群</p></li></ul></li></ol><hr><h3 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h3><ul><li>安装完成虚拟机与CentOS后，对<strong>VmWare生成的网关地址</strong>进行配置，使用NAT模式</li></ul><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.2.png"></p><h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><h5 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h5><ul><li>把虚拟出来的网卡直接连接外部的路由器， 看起来就好像是网络中多出了一台真正的计算机一样</li><li>从路由器来看， 虚拟机等同于局域网内其它的物理机</li></ul><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.3.png"></p><h5 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h5><p>NAT（Network Address Translation，网络地址转换），借助于NAT，私有地址的”内部”网络通过路由器发送数据包时，私有地址被转换成合法的IP地址，一个局域网只需使用少量IP地址（甚至是1个）即可实现私有地址网络内所有计算机与Internet的通信需求。</p><p>NAT将自动修改IP报文的源IP地址和目的IP地址，Ip地址校验则在NAT处理过程中自动完成。有些应用程序将源IP地址嵌入到IP报文的数据部分中，所以还需要同时对报文的数据部分进行修改，以匹配IP头中已经修改过的源IP地址。否则，在报文数据部分嵌入IP地址的应用程序就不能正常工作。</p><ul><li>在宿主机中创建一个子网， 把虚拟机放入子网中， 子网中有一个NAT服务</li></ul><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.4.png"></p><h5 id="仅主机"><a href="#仅主机" class="headerlink" title="仅主机"></a>仅主机</h5><ul><li>创建子网， 把虚拟机放入这个子网</li></ul><h4 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h4><ul><li>在分配<strong>内存</strong>的时候， 需要在总内存大小的基础上，减去2-4G作为物理机系统内存，，剩余的除以3，作为每台虚拟机的内存<ul><li>此台物理PC内存24G，我建立了三个虚拟机，内存都设置的4G</li></ul></li><li>在分配<strong>硬盘</strong>的时候，选用默认的40G</li></ul><h3 id="物理机网络适配器配置"><a href="#物理机网络适配器配置" class="headerlink" title="物理机网络适配器配置"></a>物理机网络适配器配置</h3><p>对物理机中虚拟机网络适配器进行设置，IP设为静态IP，<strong>与VmWare生成的网关地址放在同一个子网内</strong></p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.10.png"></p><h3 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h3><table><thead><tr><th>IP</th><th>主机名</th><th>环境配置</th><th>安装</th></tr></thead><tbody><tr><td>192.168.127.110</td><td>node01</td><td>关防火墙和selinux, host映射, 时钟同步</td><td>JDK, NameNode, ResourceManager, Zookeeper</td></tr><tr><td>192.168.127.120</td><td>node02</td><td>关防火墙和selinux, host映射, 时钟同步</td><td>JDK, DataNode, NodeManager, Zeekeeper</td></tr><tr><td>192.168.127.130</td><td>node03</td><td>关防火墙和selinux, host映射, 时钟同步</td><td>JDK, DataNode, NodeManager, Zeekeeper</td></tr></tbody></table><h4 id="设置MAC地址"><a href="#设置MAC地址" class="headerlink" title="设置MAC地址"></a>设置MAC地址</h4><ul><li>分别找到每一台虚拟机MAC地址，并在虚拟机<code>/etc/udev/rules.d/70-persistent-net.rules</code>文件下配置<ul><li>  <code>vim /etc/udev/rules.d/70-persistent-net.rules</code></li></ul></li></ul><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.5.png"></p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.6.png"></p><h4 id="设置IP地址"><a href="#设置IP地址" class="headerlink" title="设置IP地址"></a>设置IP地址</h4><p>分别在每一台虚拟机的<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>文件下配置IP地址</p><ul><li>  <code>vim /etc/sysconfig/network-scripts/ifcfg-eth0</code></li></ul><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.7.png"></p><h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><p>分别在每一台虚拟机的<code>/ect/sysconfig/network</code>文件下配置主机名</p><ul><li><code>vim /ect/sysconfig/network</code></li></ul><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.8.png"></p><h4 id="设置IP与域名映射"><a href="#设置IP与域名映射" class="headerlink" title="设置IP与域名映射"></a>设置IP与域名映射</h4><p>分别在每一台虚拟机的<code>/ect/hosts</code>文件下配置IP与域名映射关系</p><ul><li>  <code>vim /etc/hosts</code></li></ul><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.9.png"></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="虚拟机关闭防火墙"><a href="#虚拟机关闭防火墙" class="headerlink" title="虚拟机关闭防火墙"></a>虚拟机关闭防火墙</h3><p>三台机器执行以下命令（root用户来执行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">service iptables stop   #关闭防火墙<br>chkconfig iptables off  #禁止开机启动<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.11.png"></p><blockquote><p>关闭防火墙时，如果提示下图</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/image-20211104092404746.png" alt="image-20211104092404746"></p><p>是因为centos7后是使用的基于iptable的systemctl stop firewalld</p><p>解决方法：</p><p><code>yum install iptables-services</code></p><p>查看防火墙状态</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">firewall-cmd <span class="hljs-comment">--state</span><br></code></pre></td></tr></table></figure><p>停止firewall</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">systemctl stop firewalld.service<br></code></pre></td></tr></table></figure><p>禁止firewall开机启动</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-builtin-name">disable</span> firewalld.service<br></code></pre></td></tr></table></figure></blockquote><h3 id="虚拟机关闭selinux"><a href="#虚拟机关闭selinux" class="headerlink" title="虚拟机关闭selinux"></a>虚拟机关闭selinux</h3><ul><li>什么是SELinux<ul><li>SELinux是Linux的一种安全子系统</li><li>Linux中的权限管理是针对于文件的， 而不是针对进程的， 也就是说， 如果root启动了某个进程， 则这个进程可以操作任何一个文件</li><li>SELinux在Linux的文件权限之外， 增加了对进程的限制， 进程只能在进程允许的范围内操作资源</li></ul></li><li>为什么要关闭SELinux<ul><li>如果开启了SELinux， 需要做非常复杂的配置， 才能正常使用系统， 在学习阶段， 在非生产环境， 一般不使用SELinux</li></ul></li><li>SELinux的工作模式<ul><li><code>enforcing</code> 强制模式</li><li><code>permissive</code> 宽容模式</li><li><code>disable</code> 关闭</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改selinux的配置文件</span><br>vi /etc/selinux/config<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.12.png"></p><h3 id="虚拟机免密码登录"><a href="#虚拟机免密码登录" class="headerlink" title="虚拟机免密码登录"></a>虚拟机免密码登录</h3><ul><li><strong>为什么要免密登录</strong><ul><li>Hadoop 节点众多， 所以一般在主节点启动从节点， 这个时候就需要程序自动在主节点登录到从节点中， 如果不能免密就每次都要输入密码， 非常麻烦</li></ul></li><li><strong>免密 SSH 登录的原理</strong><ol><li>需要先在 B节点 配置 A节点 的公钥</li><li>A节点 请求 B节点 要求登录</li><li>B节点 使用 A节点 的公钥， 加密一段随机文本</li><li>A节点 使用私钥解密， 并发回给 B节点</li><li>B节点 验证文本是否正确</li></ol></li></ul><p><strong>第一步：三台机器生成公钥与私钥</strong></p><p>在三台机器执行以下命令，生成公钥与私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>执行该命令之后，按下三个回车即可</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.13.png"></p><p><strong>第二步：拷贝公钥到同一台机器</strong></p><p>三台机器将拷贝公钥到第一台机器</p><p>三台机器执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-copy-id node01<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.14.png"></p><p> <strong>第三步:复制第一台机器的认证到其他机器</strong></p><p>将第一台机器的公钥拷贝到其他机器上</p><p>在第一台机器上面指向以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp /root/.ssh/authorized_keys node02:/root/.ssh<br><br>scp /root/.ssh/authorized_keys node03:/root/.ssh<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.15.png"></p><p>从node01进行远程登录，验证配置是否成功</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/1.16.png"></p><h3 id="虚拟机时钟同步"><a href="#虚拟机时钟同步" class="headerlink" title="虚拟机时钟同步"></a>虚拟机时钟同步</h3><p>为什么需要时间同步</p><ul><li><p>因为很多分布式系统是有状态的， 比如说存储一个数据， A节点 记录的时间是 1， B节点 记录的时间是 2， 就会出问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 安装</span></span><br>yum install -y ntp<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 启动定时任务</span></span><br>crontab -e<br></code></pre></td></tr></table></figure><p>随后在输入界面键入</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">*/1 * * * * /usr/sbin/ntpdate ntp4.aliyun.com;<br></code></pre></td></tr></table></figure><h3 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h3><p> 查看自带的openjdk</p><p><code>rpm -qa | grep java</code></p><p>卸载系统自带的openjdk</p><p><code>rpm -e java-1.6.0-openjdk-1.6.0.41-1.13.13.1.el6_8.x86_64 tzdata-java-2016j-1.el6.noarch java-1.7.0-openjdk-1.7.0.131-2.6.9.0.el6_8.x86_64 --nodeps</code></p><p>上传jdk并解压然后配置环境变量</p><p>所有软件的安装路径</p><p><code>mkdir -p /export/servers</code></p><p>所有软件压缩包的存放路径</p><p><code>mkdir -p /export/softwares</code></p><p>上传jdk到/export/softwares路径下去，并解压</p><p><code>tar -zxvf jdk-8u141-linux-x64.tar.gz -C ../servers/</code></p><p>配置环境变量</p><p><code>vim /etc/profile</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export JAVA_HOME=/export/servers/jdk1.8.0_141<br>export PATH=:$JAVA_HOME/bin:$PATH<br></code></pre></td></tr></table></figure><p>修改完成之后执行<code>source /etc/profile</code>生效</p><h1 id="二、Zookeeper"><a href="#二、Zookeeper" class="headerlink" title="二、Zookeeper"></a>二、Zookeeper</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Zookeeper 是一个开源的分布式协调服务框架 ，主要用来解决分布式集群中 应用系统的一致性问题</li><li>Zookeeper 是 Google Chubby 思想的一个开源实现</li><li>Zookeeper 本质上是一个分布式文件系统， 适合存放小文件， 通过文件系统来实现分布式协调</li></ul><p>它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。简单来说<strong>zookeeper=文件系统+监听通知机制</strong>。</p><h3 id="Zookeeper是分布式的"><a href="#Zookeeper是分布式的" class="headerlink" title="Zookeeper是分布式的"></a>Zookeeper是分布式的</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/2.1.png"></p><p>在上图左侧，Zookeeper 中存储的其实是一个又一个 Znode， Znode 是 Zookeeper 中的节点</p><ul><li>Znode是<strong>有路径</strong>的，例如 <code>/data/host1</code>，<code>/data/host2</code>，这个路径也可以理解为是 Znode 的 Name</li><li>Znode也<strong>可以携带数据</strong>， 例如说某个 Znode 的路径是 <code>/data/host1</code>，其值是一个字符串 <code>&quot;192.168.0.1&quot;</code></li></ul><p>正因为 Znode 的特性，所以 Zookeeper 可以对外提供出一个类似于文件系统的视图， 可以通过操作文件系统的方式操作 Zookeeper，如下图</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/2.1.1.png"></p><p>Zookeeper 分为服务端和客户端的， 客户端有 Java 的客户端，有 Shell 命令行的客户端等，客户端通过一个类似于文件系统的 API 来访问 Zookeeper集群。但是事实上， 客户端最终是直接访问 Zookeeper 集群。 集群中有两大类角色， 一类是<strong>Leader</strong>，一类是<strong>Follower</strong>，其实就是主从的思想。<strong>Leader负责读和写</strong>，<strong>Follower只能读</strong>，遇到会产生修改的请求会转发给Leader 处理，这是因为Zookeeper 质上就是为了在分布式环境中对<strong>消息的一致性</strong>的支持， Zookeeper 所基于的ZAB协议是Paxos协议的一个变种，ZAB 协议中有一个全局的事务生成者，就是 Leader。因此修改设计在分布式环境下对事务达成一致， 必须由 Leader 发起</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>发布订阅</li><li>命名服务</li><li>分布式锁</li><li>分布式协调</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="集群规划-1"><a href="#集群规划-1" class="headerlink" title="集群规划"></a>集群规划</h3><table><thead><tr><th>服务器IP</th><th>主机名</th><th>myid的值</th></tr></thead><tbody><tr><td>192.168.127.110</td><td>node01</td><td>1</td></tr><tr><td>192.168.127.120</td><td>node02</td><td>2</td></tr><tr><td>192.168.127.130</td><td>node03</td><td>3</td></tr></tbody></table><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ul><li><p><strong>第一步：下载zookeeeper的压缩包</strong></p><ul><li><p><a href="http://archive.apache.org/dist/zookeeper/">http://archive.apache.org/dist/zookeeper/</a>，使用的zk版本为3.4.9</p></li><li><p>下载完成之后，上传到的linux的/export/softwares路径下准备进行安装</p></li></ul></li><li><p><strong>第二步：解压</strong></p><p>解压zookeeper的压缩包到/export/servers路径下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/softwares<br><br>tar -zxvf zookeeper-3.4.9.tar.gz -C ../servers/ <br></code></pre></td></tr></table></figure></li><li><p><strong>第三步：修改配置文件</strong></p><p><strong>node01</strong>修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers/zookeeper-3.4.9/conf/<br><br>cp zoo_sample.cfg zoo.cfg<br><br>mkdir -p /export/servers/zookeeper-3.4.9/zkdatas/<br></code></pre></td></tr></table></figure><p><code>vim  zoo.cfg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">dataDir=/export/servers/zookeeper-3.4.9/zkdatas<br><span class="hljs-meta">#</span><span class="bash"> 保留多少个快照</span><br>autopurge.snapRetainCount=3<br><span class="hljs-meta">#</span><span class="bash"> 日志多少小时清理一次</span><br>autopurge.purgeInterval=1<br><span class="hljs-meta">#</span><span class="bash"> 集群中服务器地址</span><br>server.1=node01:2888:3888<br>server.2=node02:2888:3888<br>server.3=node03:2888:3888<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/2.2.png"></p></li></ul><ul><li><strong>第四步：添加myid配置</strong></li></ul><p>在<strong>node01</strong>中</p><p>/export/servers/zookeeper-3.4.9/zkdatas /这个路径下创建一个文件，文件名为myid ，文件内容为1</p><p><code>echo 1 &gt; /export/servers/zookeeper-3.4.9/zkdatas/myid</code> </p><ul><li><p><strong>第五步：安装包分发并修改myid的值</strong></p><ul><li><p>安装包分发到其他机器</p><p>在node01上面执行以下两个命令</p><p><code>scp -r  /export/servers/zookeeper-3.4.9/ node02:/export/servers/</code></p><p><code>scp -r  /export/servers/zookeeper-3.4.9/ node03:/export/servers/</code></p></li><li><p>第二台机器上修改myid的值为2</p><p><code>echo 2 &gt; /export/servers/zookeeper-3.4.9/zkdatas/myid</code></p></li><li><p>第三台机器上修改myid的值为3<br><code>echo 3 &gt; /export/servers/zookeeper-3.4.9/zkdatas/myid</code></p></li></ul></li></ul><ul><li><p><strong>第六步：三台机器启动zookeeper服务</strong></p><ul><li><p>分别在三台设备上执行</p><p><code>/export/servers/zookeeper-3.4.9/bin/zkServer.sh start</code></p></li><li><p>执行如下命令检测，Zookeeper是否启动成功 </p><p><code>/export/servers/zookeeper-3.4.9/bin/zkServer.sh  status</code> </p></li></ul></li></ul><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/2.3.png"></p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/2.4.png"></p><h2 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h2><h3 id="Znode的特点"><a href="#Znode的特点" class="headerlink" title="Znode的特点"></a>Znode的特点</h3><ul><li>文件系统的核心是 <code>Znode</code></li><li>如果想要选取一个 <code>Znode</code>， 需要使用路径的形式， 例如 <code>/test1/test11</code></li><li><strong>Znode本身并不是文件， 也不是文件夹</strong>，Znode 因为具有一个类似于 Name 的路径， 所以可以从逻辑上实现一个树状文件系统</li><li>Zookeeper保证 Znode 访问的<strong>原子性</strong>， 不会出现部分 ZK 节点更新成功， 部分 ZK 节点更新失败的问题</li><li><code>Znode</code> 中数据是有<strong>大小限制</strong>的， 最大只能为<code>1M</code></li><li><code>Znode</code>是由三个部分构成<ul><li><code>stat</code>: 状态， Znode的权限信息， 版本等</li><li><code>data</code>: 数据， 每个Znode都是可以携带数据的， 无论是否有子节点</li><li><code>children</code>: 子节点列表</li></ul></li></ul><h3 id="Znode的类型"><a href="#Znode的类型" class="headerlink" title="Znode的类型"></a>Znode的类型</h3><ul><li><p>每个<code>Znode</code>有两大特性， 可以构成四种不同类型的<code>Znode</code></p><ul><li>持久性<ul><li><code>持久</code> 客户端断开时， 不会删除持有的Znode</li><li><code>临时</code> 客户端断开时， 删除所有持有的Znode， <strong>临时Znode不允许有子Znode</strong></li></ul></li><li>顺序性<ul><li><code>有序</code> 创建的Znode有先后顺序， 顺序就是在后面追加一个序列号， 序列号是由父节点管理的自增</li><li><code>无序</code> 创建的Znode没有先后顺序</li></ul></li></ul></li></ul><h3 id="Znode的属性"><a href="#Znode的属性" class="headerlink" title="Znode的属性"></a>Znode的属性</h3><ul><li><code>dataVersion</code> 数据版本， 每次当<code>Znode</code>中的数据发生变化的时候， <code>dataVersion</code>都会自增一下</li><li><code>cversion</code> 节点版本， 每次当<code>Znode</code>的节点发生变化的时候， <code>cversion</code>都会自增</li><li><code>aclVersion</code> <code>ACL(Access Control List)</code>的版本号， 当<code>Znode</code>的权限信息发生变化的时候aclVersion会自增</li><li><code>zxid</code> 事务ID</li><li><code>ctime</code> 创建时间</li><li><code>mtime</code> 最近一次更新的时间</li><li><code>ephemeralOwner</code> 如果<code>Znode</code>为临时节点， <code>ephemeralOwner</code>表示与该节点关联的<code>SessionId</code></li></ul><h2 id="Shell-客户端操作"><a href="#Shell-客户端操作" class="headerlink" title="Shell 客户端操作"></a>Shell 客户端操作</h2><table><thead><tr><th>命令</th><th>说明</th><th>参数</th></tr></thead><tbody><tr><td><code>create [-s] [-e] path data acl</code></td><td>创建Znode</td><td>-s 指定是顺序节点<br>-e 指定是临时节点</td></tr><tr><td><code>ls path [watch]</code></td><td>列出Path下所有子Znode</td><td></td></tr><tr><td><code>get path [watch]</code></td><td>获取Path对应的Znode的数据和属性</td><td></td></tr><tr><td><code>ls2 path [watch]</code></td><td>查看Path下所有子Znode以及子Znode的属性</td><td></td></tr><tr><td><code>set path data [version]</code></td><td>更新节点</td><td>version 数据版本</td></tr><tr><td><code>delete path [version]</code></td><td>删除节点, 如果要删除的节点有子Znode则无法删除</td><td>version 数据版本</td></tr><tr><td><code>rmr path</code></td><td>删除节点, 如果有子Znode则递归删除</td><td></td></tr><tr><td>`setquota -n</td><td>-b val path`</td><td>修改Znode配额</td></tr><tr><td><code>history</code></td><td>列出历史记录</td><td></td></tr></tbody></table><ul><li><p>创建节点</p><ul><li><p>创建普通节点</p><p><code>create /app1 hello</code></p></li><li><p>创建顺序节点</p><p><code>create -s /app3 world</code></p></li><li><p>创建临时节点</p><p><code>create -e /tempnode world</code></p></li><li><p>创建顺序的临时节点<br><code>create -s -e /tempnode2 aaa</code></p></li></ul></li><li><p>获取节点数据</p><p><code>get /app1</code></p></li><li><p>修改节点数据</p><p><code>set /app1  xxx</code></p></li><li><p>删除节点</p><ul><li><p>delete /app1</p><p>注：删除的节点不能有子节点</p></li><li><p>rmr /app1</p><p>注：递归删除</p></li></ul></li></ul><h2 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h2><ul><li>通知类似于数据库中的触发器, 对某个Znode设置 <code>Watcher</code>, 当Znode发生变化的时候, <code>WatchManager</code>会调用对应的<code>Watcher</code></li><li>当Znode发生删除, 修改, 创建, 子节点修改的时候, 对应的<code>Watcher</code>会得到通知</li><li><code>Watcher</code>的特点<ul><li><strong>一次性触发</strong> 一个 <code>Watcher</code> 只会被触发一次, 如果需要继续监听, 则需要再次添加 <code>Watcher</code></li><li>事件封装: <code>Watcher</code> 得到的事件是被封装过的, 包括三个内容 <code>keeperState, eventType, path</code></li></ul></li></ul><table><thead><tr><th>KeeperState</th><th>EventType</th><th>触发条件</th><th>说明</th></tr></thead><tbody><tr><td></td><td>None</td><td>连接成功</td><td></td></tr><tr><td>SyncConnected</td><td>NodeCreated</td><td>Znode被创建</td><td>此时处于连接状态</td></tr><tr><td>SyncConnected</td><td>NodeDeleted</td><td>Znode被删除</td><td>此时处于连接状态</td></tr><tr><td>SyncConnected</td><td>NodeDataChanged</td><td>Znode数据被改变</td><td>此时处于连接状态</td></tr><tr><td>SyncConnected</td><td>NodeChildChanged</td><td>Znode的子Znode数据被改变</td><td>此时处于连接状态</td></tr><tr><td>Disconnected</td><td>None</td><td>客户端和服务端断开连接</td><td>此时客户端和服务器处于断开连接状态</td></tr><tr><td>Expired</td><td>None</td><td>会话超时</td><td>会收到一个SessionExpiredException</td></tr><tr><td>AuthFailed</td><td>None</td><td>权限验证失败</td><td>会收到一个AuthFailedException</td></tr></tbody></table><p><strong>会话</strong></p><ul><li>在ZK中所有的客户端和服务器的交互都是在某一个<code>Session</code>中的, 客户端和服务器创建一个连接的时候同时也会创建一个<code>Session</code></li><li><code>Session</code>会在不同的状态之间进行切换: <code>CONNECTING</code>, <code>CONNECTED</code>, <code>RECONNECTING</code>, <code>RECONNECTED</code>, <code>CLOSED</code></li><li>ZK中的会话两端也需要进行心跳检测, 服务端会检测如果超过超时时间没收到客户端的心跳, 则会关闭连接, 释放资源, 关闭会话</li></ul><h1 id="三、Hadoop"><a href="#三、Hadoop" class="headerlink" title="三、Hadoop"></a>三、Hadoop</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Hadoop是一个分布式系基础框架，它允许使用简单的编程模型跨大型计算机的大型数据集进行分布式处理.</p><p>它主要解决两个问题</p><ul><li>大数据<strong>存储</strong>问题： HDFS，分布式文件系统</li><li>大数据<strong>计算</strong>问题：MapReduce， 分布式计算系统</li></ul><p><strong>广义上来说，hadoop指代大数据的一个生态圈，包括很多其他的软件</strong></p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/3.1.png"></p><h2 id="Hadoop的组成"><a href="#Hadoop的组成" class="headerlink" title="Hadoop的组成"></a>Hadoop的组成</h2><ul><li><strong>Hadoop分布式文件系统(HDFS)</strong> 提供对应用程序数据的高吞吐量访问的分布式文件系统</li></ul><ul><li><strong>Hadoop Common</strong> 其他Hadoop模块所需的Java库和实用程序。这些库提供文件系统和操作系统级抽象，并包含启动Hadoop所需的必要Java文件和脚本</li><li><strong>Hadoop MapReduce</strong> 基于YARN的大型数据集并行处理系统</li><li><strong>Hadoop YARN</strong> 作业调度和集群资源管理的框架</li></ul><h2 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h2><h3 id="1-X版本架构模型"><a href="#1-X版本架构模型" class="headerlink" title="1.X版本架构模型"></a>1.X版本架构模型</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/3.2.png"></p><ul><li><p>文件系统核心模块：</p><ul><li>NameNode：集群当中的主节点，<strong>管理元数据</strong>(文件的大小，文件的位置，文件的权限)，主要用于管理集群当中的各种数据</li><li>secondaryNameNode：主要能用于hadoop当中元数据信息的辅助管理</li><li>DataNode：集群当中的从节点，主要用于<strong>存储</strong>集群当中的各种数据</li></ul></li><li><p>数据计算核心模块：</p><ul><li>JobTracker：接收用户的计算请求任务，并分配任务给从节点</li><li>TaskTracker：负责执行主节点JobTracker分配的任务</li></ul></li></ul><h3 id="2-X版本架构模型"><a href="#2-X版本架构模型" class="headerlink" title="2.X版本架构模型"></a>2.X版本架构模型</h3><h4 id="第一种：NameNode与ResourceManager单节点架构模型"><a href="#第一种：NameNode与ResourceManager单节点架构模型" class="headerlink" title="第一种：NameNode与ResourceManager单节点架构模型"></a>第一种：NameNode与ResourceManager单节点架构模型</h4><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/3.3.png"></p><ul><li><p>文件系统核心模块：</p><ul><li>NameNode：集群当中的主节点，主要用于<strong>管理</strong>集群当中的各种数据</li><li>secondaryNameNode：主要能用于hadoop当中元数据信息的辅助管理</li><li>DataNode：集群当中的从节点，主要用于<strong>存储</strong>集群当中的各种数据</li></ul></li><li><p>数据计算核心模块：</p><ul><li>ResourceManager：接收用户的计算请求任务，并负责集群的资源分配</li><li>NodeManager：负责执行主节点APPmaster分配的任务</li></ul></li></ul><h4 id="第二种：NameNode单节点与ResourceManager高可用架构模型"><a href="#第二种：NameNode单节点与ResourceManager高可用架构模型" class="headerlink" title="第二种：NameNode单节点与ResourceManager高可用架构模型"></a>第二种：NameNode单节点与ResourceManager高可用架构模型</h4><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/3.4.png"></p><ul><li><p>文件系统核心模块：</p><ul><li>NameNode：集群当中的主节点，主要用于管理集群当中的各种数据</li><li>secondaryNameNode：主要能用于hadoop当中元数据信息的辅助管理</li><li>DataNode：集群当中的从节点，主要用于存储集群当中的各种数据</li></ul></li><li><p>数据计算核心模块：</p><ul><li>ResourceManager：接收用户的计算请求任务，并负责集群的资源分配，以及计算任务的划分，<strong>通过zookeeper实现ResourceManager的高可用</strong></li><li>NodeManager：负责执行主节点ResourceManager分配的任务</li></ul></li></ul><h4 id="第三种：NameNode高可用与ResourceManager单节点架构模型"><a href="#第三种：NameNode高可用与ResourceManager单节点架构模型" class="headerlink" title="第三种：NameNode高可用与ResourceManager单节点架构模型"></a>第三种：NameNode高可用与ResourceManager单节点架构模型</h4><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/3.5.png"></p><ul><li><p>文件系统核心模块：</p><ul><li>NameNode：集群当中的主节点，主要用于管理集群当中的各种数据，<strong>其中nameNode可以有两个，形成高可用状态</strong></li><li>DataNode：集群当中的从节点，主要用于存储集群当中的各种数据</li><li>JournalNode：文件系统元数据信息管理</li></ul></li><li><p>数据计算核心模块：</p><ul><li>ResourceManager：接收用户的计算请求任务，并负责集群的资源分配，以及计算任务的划分</li><li>NodeManager：负责执行主节点ResourceManager分配的任务</li></ul></li></ul><h4 id="第四种：NameNode与ResourceManager高可用架构模型"><a href="#第四种：NameNode与ResourceManager高可用架构模型" class="headerlink" title="第四种：NameNode与ResourceManager高可用架构模型"></a>第四种：NameNode与ResourceManager高可用架构模型</h4><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/3.6.png"></p><ul><li><p>文件系统核心模块：</p><ul><li>NameNode：集群当中的主节点，主要用于管理集群当中的各种数据，一般都是<strong>使用两个，实现高可用</strong></li><li>JournalNode：元数据信息管理进程，一般都是奇数个</li><li>DataNode：从节点，用于数据的存储</li></ul></li><li><p>数据计算核心模块：</p><ul><li>ResourceManager：Yarn平台的主节点，主要用于接收各种任务，<strong>通过两个，构建成高可用</strong></li><li>NodeManager：Yarn平台的从节点，主要用于处理ResourceManager分配的任务</li></ul></li></ul><h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><h3 id="集群规划-2"><a href="#集群规划-2" class="headerlink" title="集群规划"></a>集群规划</h3><table><thead><tr><th>服务器IP</th><th>192.168.127.110</th><th>192.168.127.120</th><th>192.168.127.130</th></tr></thead><tbody><tr><td>主机名</td><td>node01</td><td>node02</td><td>node03</td></tr><tr><td>NameNode</td><td>是</td><td>否</td><td>否</td></tr><tr><td>SecondaryNameNode</td><td>是</td><td>否</td><td>否</td></tr><tr><td>dataNode</td><td>是</td><td>是</td><td>是</td></tr><tr><td>ResourceManager</td><td>是</td><td>否</td><td>否</td></tr><tr><td>NodeManager</td><td>是</td><td>是</td><td>是</td></tr></tbody></table><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><h4 id="第一步：下载Hadoop的压缩包"><a href="#第一步：下载Hadoop的压缩包" class="headerlink" title="第一步：下载Hadoop的压缩包"></a>第一步：下载Hadoop的压缩包</h4><ul><li><p>使用的Hadoop版本为3.1.1</p></li><li><p>下载完成之后，上传到的linux的/export/softwares路径下准备进行安装</p></li></ul><h4 id="第二步：解压"><a href="#第二步：解压" class="headerlink" title="第二步：解压"></a>第二步：解压</h4><p>解压hadoop的压缩包到/export/servers路径下</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/softwares<br>tar xzvf hadoop-3.1.1.tar.gz  -C ../servers<br></code></pre></td></tr></table></figure><h4 id="第三步：修改配置文件"><a href="#第三步：修改配置文件" class="headerlink" title="第三步：修改配置文件"></a>第三步：修改配置文件</h4><p>  配置文件的位置在 <code>hadoop/etc/hadoop</code></p><h5 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h5>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="hljs-comment">  you may not use this file except in compliance with the License.</span><br><span class="hljs-comment">  You may obtain a copy of the License at</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment">  See the License for the specific language governing permissions and</span><br><span class="hljs-comment">  limitations under the License. See accompanying LICENSE file.</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- Put site-specific property overrides in this file. --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://node01:8020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 临时文件存储目录 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/export/servers/hadoop-3.1.1/datas/tmp<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  缓冲区大小，实际工作中根据服务器性能动态调整 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>io.file.buffer.size<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>8192<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  开启hdfs的垃圾桶机制，删除掉的数据可以从垃圾桶中回收，单位分钟 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.trash.interval<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>10080<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h5 id="hadoop-env-sh"><a href="#hadoop-env-sh" class="headerlink" title="hadoop-env.sh"></a>hadoop-env.sh</h5>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export JAVA_HOME=/export/servers/jdk1.8.0_141<br></code></pre></td></tr></table></figure><h5 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h5>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="hljs-comment">  you may not use this file except in compliance with the License.</span><br><span class="hljs-comment">  You may obtain a copy of the License at</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment">  See the License for the specific language governing permissions and</span><br><span class="hljs-comment">  limitations under the License. See accompanying LICENSE file.</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- Put site-specific property overrides in this file. --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- namenode元数据存放路径 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.name.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///export/servers/hadoop-3.1.1/datas/namenode/namenodedatas<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 文件分块大小 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.blocksize<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>134217728<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.handler.count<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- datanode元数据存放路径 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.data.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///export/servers/hadoop-3.1.1/datas/datanode/datanodeDatas<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 浏览器访问hdfs端口 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01:50070<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 文件副本数 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- HDFS权限访问 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.permissions.enabled<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- HDFS日志存储路径 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.checkpoint.edits.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///export/servers/hadoop-3.1.1/datas/dfs/nn/snn/edits<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01.hadoop.com:50090<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.edits.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///export/servers/hadoop-3.1.1/datas/dfs/nn/edits<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.checkpoint.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///export/servers/hadoop-3.1.1/datas/dfs/snn/name<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h5 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h5>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="hljs-comment">  you may not use this file except in compliance with the License.</span><br><span class="hljs-comment">  You may obtain a copy of the License at</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment">  See the License for the specific language governing permissions and</span><br><span class="hljs-comment">  limitations under the License. See accompanying LICENSE file.</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- Put site-specific property overrides in this file. --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.framework.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.map.memory.mb<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1024<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.map.java.opts<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>-Xmx512M<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.reduce.memory.mb<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1024<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.reduce.java.opts<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>-Xmx512M<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.task.io.sort.mb<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>256<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.task.io.sort.factor<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.reduce.shuffle.parallelcopies<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>25<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01.hadoop.com:10020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01.hadoop.com:19888<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.intermediate-done-dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/export/servers/hadoop-3.1.1/datas/jobhsitory/intermediateDoneDatas<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.done-dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/export/servers/hadoop-3.1.1/datas/jobhsitory/DoneDatas<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/export/servers/hadoop-3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.map.env<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/export/servers/hadoop-3.1.1/<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.reduce.env<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/export/servers/hadoop-3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h5>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="hljs-comment">  you may not use this file except in compliance with the License.</span><br><span class="hljs-comment">  You may obtain a copy of the License at</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment">  See the License for the specific language governing permissions and</span><br><span class="hljs-comment">  limitations under the License. See accompanying LICENSE file.</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.handler.count<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01:8032<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01:8030<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01:8031<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.admin.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01:8033<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01:8088<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.scheduler.minimum-allocation-mb<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1024<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.scheduler.maximum-allocation-mb<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2048<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.vmem-pmem-ratio<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2.1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 设置不检查虚拟内存的值，不然内存不够会报错 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.vmem-check-enabled<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.resource.memory-mb<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1024<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.resource.detect-hardware-capabilities<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.local-dirs<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///export/servers/hadoop-3.1.1/datas/nodemanager/nodemanagerDatas<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.log-dirs<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///export/servers/hadoop-3.1.1/datas/nodemanager/nodemanagerLogs<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.log.retain-seconds<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>10800<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.remote-app-log-dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/export/servers/hadoop-3.1.1/datas/remoteAppLog/remoteAppLogs<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.remote-app-log-dir-suffix<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>logs<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>mapreduce_shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>18144000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.log-aggregation.retain-check-interval-seconds<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>86400<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- yarn上面运行一个任务，最少需要1.5G内存，虚拟机没有这么大的内存就调小这个值，不然会报错 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.app.mapreduce.am.resource.mb<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1024<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h5>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-symbol">node01</span><br><span class="hljs-symbol">node02</span><br><span class="hljs-symbol">node03</span><br></code></pre></td></tr></table></figure><h4 id="第四步：创建数据和临时文件夹"><a href="#第四步：创建数据和临时文件夹" class="headerlink" title="第四步：创建数据和临时文件夹"></a>第四步：创建数据和临时文件夹</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /export/servers/hadoop-3.1.1/datas/tmp<br>mkdir -p /export/servers/hadoop-3.1.1/datas/dfs/nn/snn/edits<br>mkdir -p /export/servers/hadoop-3.1.1/datas/namenode/namenodedatas<br>mkdir -p /export/servers/hadoop-3.1.1/datas/datanode/datanodeDatas<br>mkdir -p /export/servers/hadoop-3.1.1/datas/dfs/nn/edits<br>mkdir -p /export/servers/hadoop-3.1.1/datas/dfs/snn/name<br>mkdir -p /export/servers/hadoop-3.1.1/datas/jobhsitory/intermediateDoneDatas<br>mkdir -p /export/servers/hadoop-3.1.1/datas/jobhsitory/DoneDatas<br>mkdir -p /export/servers/hadoop-3.1.1/datas/nodemanager/nodemanagerDatas<br>mkdir -p /export/servers/hadoop-3.1.1/datas/nodemanager/nodemanagerLogs<br>mkdir -p /export/servers/hadoop-3.1.1/datas/remoteAppLog/remoteAppLogs<br></code></pre></td></tr></table></figure><h4 id="第五步：分发安装包到其它机器"><a href="#第五步：分发安装包到其它机器" class="headerlink" title="第五步：分发安装包到其它机器"></a>第五步：分发安装包到其它机器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers<br>scp -r hadoop-3.1.1/ node02:$PWD<br>scp -r hadoop-3.1.1/ node03:$PWD<br></code></pre></td></tr></table></figure><h4 id="第六步：在每个节点配置环境变量"><a href="#第六步：在每个节点配置环境变量" class="headerlink" title="第六步：在每个节点配置环境变量"></a>第六步：在每个节点配置环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/profile<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export HADOOP_HOME=/export/servers/hadoop-3.1.1/<br>export PATH=:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH<br></code></pre></td></tr></table></figure><p><strong>最后记得刷新配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure><h4 id="第七步：格式化HDFS"><a href="#第七步：格式化HDFS" class="headerlink" title="第七步：格式化HDFS"></a>第七步：格式化HDFS</h4><p>为什么要格式化HDFS</p><ul><li>HDFS需要一个格式化的过程来创建存放元数据(image, editlog)的目录</li></ul><p>回到Hadoop主目录，执行下面命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/hdfs namenode -format<br></code></pre></td></tr></table></figure><blockquote><p>仅在NameNode节点格式化HDFS即可</p></blockquote><h4 id="第八步：启动集群"><a href="#第八步：启动集群" class="headerlink" title="第八步：启动集群"></a>第八步：启动集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 会登录进所有的worker启动相关进行, 也可以手动进行, 但是没必要</span><br>/export/servers/hadoop-3.1.1/sbin/start-dfs.sh<br>/export/servers/hadoop-3.1.1/sbin/start-yarn.sh<br>mapred --daemon start historyserver<br></code></pre></td></tr></table></figure><p>此时便可以通过如下三个URL访问Hadoop了</p><ul><li>HDFS: <code>http://192.168.127.110:50070/dfshealth.html#tab-overview</code></li><li>Yarn: <code>http://192.168.127.110:8088/cluster</code></li></ul><p>出现如下报错：对于<strong>所有节点</strong>，设置hadoop-env.sh</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/3.7.png"></p><p><code>vim /export/servers/hadoop-3.1.1/etc/hadoop/hadoop-env.sh </code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">export HDFS_NAMENODE_USER=&quot;root&quot;<br>export HDFS_DATANODE_USER=&quot;root&quot;<br>export HDFS_SECONDARYNAMENODE_USER=&quot;root&quot;<br>export YARN_RESOURCEMANAGER_USER=&quot;root&quot;<br>export YARN_NODEMANAGER_USER=&quot;root&quot;<br></code></pre></td></tr></table></figure><h4 id="第九步：验证启动是否成功"><a href="#第九步：验证启动是否成功" class="headerlink" title="第九步：验证启动是否成功"></a>第九步：验证启动是否成功</h4><p><code>jps</code></p><ul><li><p>NameNode节点</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/3.8.png"></p></li><li><p>DataNode节点</p></li></ul><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/3.9.png"></p><ul><li><p>浏览器可以访问NameNode管理界面</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/3.10.png"></p></li></ul><hr><h1 id="四、HDFS"><a href="#四、HDFS" class="headerlink" title="四、HDFS"></a>四、HDFS</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>HDFS（Hadoop  Distributed  File  System） 是一个 Apache Software Foundation 项目，是 Apache Hadoop 项目的一个子项目。Hadoop 非常适于存储大型数据 (比如 TB 和 PB)，其就是使用 HDFS 作为存储系统。HDFS 使用多台计算机存储文件， 并且提供统一的访问接口，像是访问一个普通文件系统一样使用分布式文件系统。HDFS 对数据文件的访问通过流的方式进行处理，这意味着通过命令和 MapReduce 程序的方式可以直接使用 HDFS。HDFS 是容错的，且提供对大数据集的高吞吐量访问。</p><p>HDFS 的一个非常重要的特点就是<strong>一次写入、多次读取</strong>， 该模型降低了对并发控制的要求，简化了数据聚合性，支持高吞吐量访问。而吞吐量是大数据系统的一个非常重要的指标，吞吐量高意味着能处理的数据量就大。</p><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li>通过跨多个廉价计算机<strong>集群</strong>分布数据和处理来节约成本</li><li>通过自动维护多个<strong>数据副本</strong>和在故障发生时来实现可靠性</li><li>它们为存储和处理超大规模数据提供所需的<strong>扩展</strong>能力。</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/4.1.png"></p><p><strong>HDFS具有主/从架构。HDFS集群由单个NameNode，和多个datanode构成。</strong></p><ul><li><p><strong>NameNode</strong>：管理文件系统命名空间的主服务器和管理客户端对文件的访问组成，如打开，关闭和重命名文件和目录。负责管理文件目录、文件和block的对应关系以及block和datanode的对应关系，维护目录树，接管用户的请求</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/4.2.png"></p><ul><li><p>将文件的元数据保存在一个文件目录树中</p></li><li><p>在磁盘上保存为：fsimage 和 edits</p><ul><li><p><strong>fsimage</strong></p><ul><li>NameNode 中关于元数据的镜像, 一般称为检查点, <code>fsimage</code> 存放了一份比较完整的元数据信息</li><li>因为 <code>fsimage</code> 是 NameNode 的完整的镜像, 如果每次都加载到内存生成树状拓扑结构，这是非常耗内存和CPU, 所以一般开始时对 NameNode 的操作都放在 edits 中</li><li><code>fsimage</code> 内容包含了 NameNode 管理下的所有 DataNode 文件及文件 block 及 block 所在的 DataNode 的元数据信息.</li><li>随着 <code>edits</code> 内容增大, 就需要在一定时间点和 <code>fsimage</code> 合并</li></ul></li><li><p><strong>edits</strong></p><ul><li><code>edits</code> 存放了客户端最近一段时间的操作日志</li><li>客户端对 HDFS 进行写文件时会首先被记录在 <code>edits</code> 文件中</li><li><code>edits</code> 修改时元数据也会更新</li><li>每次 HDFS 更新时 <code>edits</code> 先更新后客户端才会看到最新信息</li></ul></li></ul></li><li><p>保存datanode的数据信息的文件，在系统启动的时候读入内存。</p></li></ul></li><li><p><strong>DataNode</strong>：（数据节点）管理连接到它们运行的节点的存储，负责处理来自文件系统客户端的读写请求。DataNodes还执行块创建，删除</p></li><li><p><strong>Client</strong>：(客户端)代表用户通过与nameNode和datanode交互来访问整个文件系统，HDFS对外开放文件命名空间并允许用户数据以文件形式存储。用户通过客户端（Client）与HDFS进行通讯交互。</p></li></ul><table><thead><tr><th align="left">类别</th><th align="left">NameNode</th><th align="left">DataNode</th></tr></thead><tbody><tr><td align="left">存储内容</td><td align="left">存储元数据</td><td align="left">存储文件内容</td></tr><tr><td align="left">存储位置</td><td align="left">元数据保存在<strong>内存</strong>中</td><td align="left">文件内容保存在磁盘</td></tr><tr><td align="left">作用</td><td align="left">保存文件, block, DataNode 之间的关系</td><td align="left">维护了 block id 到 DataNode 文件之间的关系</td></tr></tbody></table><blockquote><ul><li>副本存放在哪些 DataNode 上由 NameNode 来控制, 根据全局情况作出块放置决定, 读取文件时 NameNode 尽量让用户先读取最近的副本, 降低读取网络开销和读取延时</li><li>NameNode 全权管理数据库的复制, 它周期性的从集群中的每个 DataNode 接收心跳信合和状态报告, 接收到心跳信号意味着 DataNode 节点工作正常, 块状态报告包含了一个该 DataNode 上所有的数据列表</li></ul></blockquote><h2 id="HDFS文件副本和Block块存储"><a href="#HDFS文件副本和Block块存储" class="headerlink" title="HDFS文件副本和Block块存储"></a>HDFS文件副本和Block块存储</h2><p>所有的文件都是以<strong>block块</strong>的方式存放在 HDFS 文件系统当中, 在 Hadoop1 当中, 文件的 block 块默认大小是 64M, hadoop2 当中, 文件的 block 块大小默认是 128M, block 块的大小可以通过 hdfs-site.xml 当中的配置文件进行指定</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.block.size<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>块大小 以字节为单位<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>为什么要以块的形式存储文件，而不是整个文件呢？<br>1、因为一个文件可以特别大，可以大于有个磁盘的容量，所以以块的形式存储，可以用来存储无论大小怎样的文件。<br>2、简化存储系统的设计。因为块是固定的大小，计算磁盘的存储能力就容易多了<br>3、以块的形式存储不需要全部存在一个磁盘上，可以分布在各个文件系统的磁盘上，有利于复制和容错，数据本地化计算</p></blockquote><p><strong>注意：假设一个文件 130M，一个block块128M，则文件会被切分成 2 个 block 块，实际占用磁盘 130M 空间, 而不是占用256M的磁盘空间</strong></p><h3 id="块缓存"><a href="#块缓存" class="headerlink" title="块缓存"></a>块缓存</h3><p>通常 DataNode 从磁盘中读取块， 但对于访问频繁的文件， 其对应的块可能被显式的缓存在 DataNode 的内存中，以堆外块缓存的形式存在。默认情况下，一个块仅缓存在一个 DataNode 的内存中，当然可以针对每个文件配置 DataNode 的数量。作业调度器通过在缓存块的 DataNode 上运行任务，可以利用块缓存的优势提高读操作的性能。</p><h3 id="HDFS的文件权限验证"><a href="#HDFS的文件权限验证" class="headerlink" title="HDFS的文件权限验证"></a>HDFS的文件权限验证</h3><p>HDFS 的文件权限机制与 Linux 系统的文件权限机制类似</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">r:<span class="hljs-built_in">read</span>  w:<span class="hljs-built_in">write</span>  x:<span class="hljs-built_in">execute</span><br></code></pre></td></tr></table></figure><p>权限 <code>x</code> 对于文件表示忽略，对于文件夹表示是否有权限访问其内容</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/4.3.png"></p><h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><p>既然namenode管理着文件系统的命名空间，维护着文件系统树以及整颗树内的所有文件和目录，这些信息以文件的形式永远的保存在本地磁盘上，分别问命名空间镜像文件<strong>fsimage</strong>和编辑日志文件<strong>Edits</strong>。datanode是文件的工作节点，根据需要存储和检索数据块，并且定期的向namenode发送它们所存储的块的列表。那么就知道namenode是多么的重要，一旦那么namenode挂了，那整个分布式文件系统就不可以使用了，所以对于namenode的容错就显得尤为重要了，hadoop为此提供了两种<strong>容错机制</strong></p><h3 id="容错机制一"><a href="#容错机制一" class="headerlink" title="容错机制一"></a>容错机制一</h3><p>通过对那些组成文件系统的元数据持久化，分别问命名空间镜像文件<strong>fsimage</strong>（文件系统的目录树）和编辑日志文件<strong>Edits</strong>（针对文件系统做的修改操作记录）。磁盘上的映像FsImage就是一个Checkpoint同步点，有了一个Checkpoint之后，NameNode在相当长的时间内只是对内存中的目录映像操作，同时也对磁盘上的Edits操作，而不用对FsImage再进行操作，直到关机。下次开机的时候，NameNode要从磁盘上装载目录映像FSImage，那其实就是老的Checkpoint，也许就是上次开机后所保存的映像，而自从上次开机后直到关机为止对于文件系统的所有改变都记录在Edits文件中。将记录在Edits中的操作重演于上一次的FsImage，就得到这一次的新的映像，将其写回磁盘就是新的Checkpoint（也就是fsImage）。</p><p>但是这样有很大一个缺点，如果Edits很大，开机后生成原始映像的过程也会很长，所以对其进行改进：每当 Edits长到一定程度，或者每隔一定的时间，就做一次Checkpoint，但是这样就会给namenode造成很大的负荷，会影响系统的性能。于是就有了<strong>SecondaryNameNode</strong>的需要，这相当于NameNode的助理，专替NameNode做Checkpoint。当然，SecondaryNameNode的负载相比之下是偏轻的。所以如果为NameNode配上了热备份，就可以让热备份兼职，而无须再有专职的SecondaryNameNode。工作流程如下图所示：</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/4.4.png"></p><p>SecondaryNameNode主要负责将NameNode中的fsImage文件和Edits文件，并合并生成新的fsImage文件，并推送给NameNode，工作流程如下：</p><ol><li>SecondaryNameNode请求主NameNode停止使用edits文件，暂时将新的写操作记录到一个新的文件中；</li><li>SecondaryNameNode从主NameNode获取fsimage和edits文件（通过http get）</li><li>SecondaryNameNode将fsimage文件载入内存，逐一执行edits文件中的操作，创建新的fsimage文件。</li><li>SecondaryNameNode将新的fsimage文件发送回主NameNode（使用http post）.</li><li>NameNode用从SecondaryNameNode接收的fsimage文件替换旧的fsimage文件；用步骤1所产生的edits文件替换旧的edits文件。同时，还更新fstime文件来记录检查点执行时间。</li><li>最终，主namenode拥有最新的fsimage文件和一个更小的edits文件。当namenode处在安全模式时，管理员也可调用hadoop dfsadmin –saveNameSpace命令来创建检查点。</li></ol><p>​    从上面的过程中可以清晰的看到<strong>secondarynamenode和主namenode拥有相近内存需求</strong>的原因（因为secondarynamenode也把fsimage文件载入内存）。因此，在大型集群中，secondarynamenode需要运行在一台专用机器上。</p><p><strong>SecondaryNameNode配置</strong></p><ul><li><p>SecondaryNameNode 在 <code>conf/masters</code> 中指定</p></li><li><p>在 masters 指定的机器上, 修改 <code>hdfs-site.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.http.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>host:50070<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>修改 <code>core-site.xml</code>, 这一步不做配置保持默认也可以</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 多久记录一次 HDFS 镜像, 默认 1小时 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.checkpoint.period<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3600<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 一次记录多大, 默认 64M --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.checkpoint.size<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>67108864<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="容错机制二"><a href="#容错机制二" class="headerlink" title="容错机制二"></a>容错机制二</h3><p>高可用方案</p><h2 id="文件存取原理"><a href="#文件存取原理" class="headerlink" title="文件存取原理"></a>文件存取原理</h2><h3 id="HDFS文件读取过程"><a href="#HDFS文件读取过程" class="headerlink" title="HDFS文件读取过程"></a>HDFS文件读取过程</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/4.5.png"></p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/4.6.png"></p><ol><li><p>Client通过FileSystem对象（DistributedFileSystem）的open()方法，通过 RPC 与 NameNode 建立通讯，来确定请求文件block所在的位置；</p></li><li><p>NameNode会判断文件是否存在，是否有权限下载</p></li><li><p>NameNode返回文件的部分或者全部block列表，对于每个block，NameNode 都会返回含有该 block 副本的 DataNode 地址；  这些返回的 DN 地址，会按照集群拓扑结构得出 DataNode 与客户端的距离，然后进行排序，排序两个规则：网络拓扑结构中距离 Client 近的排靠前；心跳机制中超时汇报的 DN 状态为 STALE，这样的排靠后；</p></li><li><p>Client 选取排序靠前的 DataNode 来读取 block，如果客户端本身就是DataNode,那么将从本地直接获取数据(短路读取特性)；</p><ul><li>底层上本质是建立 Socket Stream（FSDataInputStream），重复的调用父类 DataInputStream 的 read 方法，直到这个块上的数据读取完毕；</li></ul></li><li><p>当读完列表的 block 后，若文件读取还没有结束，客户端会继续向NameNode 获取下一批的 block 列表；</p><ul><li><p>读取完一个 block 都会进行 checksum 验证，如果读取 DataNode 时出现错误，客户端会通知 NameNode，然后再从下一个拥有该 block 副本的DataNode 继续读。</p></li><li><p>read 方法是并行的读取 block 信息，不是一块一块的读取；NameNode 只是返回Client请求包含块的DataNode地址，并不是返回请求块的数据；</p></li><li><p>最终读取来所有的 block 会合并成一个完整的最终文件。</p></li></ul></li></ol><blockquote><p>在读取数据的时候，如果DFSInputStream在与datanode通讯时遇到错误，它便会尝试从这个块的另外一个临近datanode读取数据。他也会记住那个故障datanode，以保证以后不会反复读取该节点上后续的块。DFSInputStream也会通过校验和确认从datanode发送来的数据是否完整。如果发现一个损坏的块， DFSInputStream就会在试图从其他datanode读取一个块的复本之前通知namenode。</p></blockquote><blockquote><p>在这个设计中，namenode会告知客户端每个块中最佳的datanode，并让客户端直接联系该datanode且检索数据。由于数据流分散在该集群中的所有datanode，所以这种设计会使HDFS可扩展到大量的并发客户端。同时，namenode仅需要响应位置的请求（这些信息存储在内存中，非常高效），而无需响应数据请求，</p></blockquote><h3 id="HDFS文件写入过程"><a href="#HDFS文件写入过程" class="headerlink" title="HDFS文件写入过程"></a>HDFS文件写入过程</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/4.7.png"></p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/4.8.png"></p><ol><li><p>Client 通过DistributedFileSystem上的create()方法发起文件上传请求，通过 RPC 与 NameNode 建立通讯，指明预创建文件名</p></li><li><p>NameNode 检查目标文件是否已存在，父目录是否存在，是否有创建权限</p></li><li><p>返回是否可以上传</p></li><li><p>Client 请求第一个block该传输到哪些 DataNode 服务器上</p></li><li><p>NameNode根据dataNode信息池检测可以上传的dateNode列表</p><ul><li>NameNode 根据配置文件中指定的备份数量及机架感知原理进行文件分配，返回可用的 DataNode 的地址如: A，B，C</li><li>Hadoop 在设计时考虑到数据的安全与高效，数据文件默认在 HDFS 上存放三份，存储策略为本地一份，同机架内其它某一节点上一份，不同机架的某一节点上一份。</li></ul></li><li><p>将dateNode列表返回给client</p></li><li><p>Client 请求 3 台 DataNode 中的一台 A 上传数据（本质上是一个 RPC 调用，建立 pipeline ）, A 收到请求会继续调用 B，然后 B 调用 C，将整个 pipeline 建立完成，后逐级返回 client</p></li><li><p>Client 开始往 A 上传第一个 block（先从磁盘读取数据放到一个本地内存缓存），数据被分割成一个个 packet（默认64K） 数据包在 pipeline 上依次传输，A 收到一个 packet 就会传给 B，B 传给 C。 A 每传一个 packet 会放入一个应答队列等待应答</p></li><li><p>各个dataNode将数据保存到某一个目录下</p></li><li><p>在 pipeline 反方向上，dataNode逐个发送 ack（命令正确应答），最终由 pipeline 中第一个 DataNode 节点 A 将 pipeline ack 发送给 Client</p></li><li><p>当一个 block 传输完成之后，Client 再次请求 NameNode 上传第二个 block 到服务 1</p></li></ol><blockquote><p>如果某个datanode在写数据的时候当掉了，下面这些对用户透明的步骤会被执行：</p><ul><li><p>管道线关闭，所有确认队列上的数据会被挪到数据队列的首部重新发送，这样可以确保管道线中当掉的datanode下流的datanode不会因为当掉的datanode而丢失数据包。</p></li><li><p>在还在正常运行的datanode上的当前block上做一个标志，这样当当掉的datanode重新启动以后namenode就会知道该datanode上哪个block是刚才当机时残留下的局部损坏block，从而可以把它删掉。</p></li><li><p>已经当掉的datanode从管道线中被移除，未写完的block的其他数据继续被写入到其他两个还在正常运行的datanode中去，namenode知道这个block还处在under-replicated状态（也即备份数不足的状态）下，然后他会安排一个新的replica从而达到要求的备份数，后续的block写入方法同前面正常时候一样。有可能管道线中的多个datanode当掉（虽然不太经常发生），但只要dfs.replication.min（默认为1）个replica被创建，我们就认为该创建成功了。剩余的replica会在以后异步创建以达到指定的replica数。</p></li></ul></blockquote><blockquote><p>hdfs写入过程中，datanode管线的确认应答包并不是每写完一个datanode，就返回一个确认应答，而是<strong>一直写入，直到最后一个datanode写入完毕后，统一返回应答包</strong>。如果中间的一个datanode出现故障，那么返回的应答就是前面完好的datanode确认应答，和故障datanode的故障异常。</p><p>这样我们也就可以理解，在写入数据的过程中，为什么数据包的校验是在最后一个datanode完成。</p></blockquote><h2 id="HDFS命令行"><a href="#HDFS命令行" class="headerlink" title="HDFS命令行"></a>HDFS命令行</h2><p>语法：<code>hdfs dfs 参数</code></p><p>或替换为<code>hadoop fs 参数</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdfs dfs -help #帮助<br>hdfs dfs -ls / #显示根目录信息<br>hdfs dfs -mkdir -p /xx/xxx#在hdfs上递归创建目录<br>hdfs dfs -moveFromLocal test.txt /user/data #从本地剪切粘贴到hdfs<br>hdfs dfs -appendTofile test.txt /user/test.txt #追加一个文件到已经存在的文件末尾<br>hdfs dfs -cat xx#显示文件内容<br>hdfs dfs -tail xx#显示一个文件的末尾<br>hdfs dfs -cp /user/x.txt /user/test #从hdfs的一个路径拷贝到hdfs的另一个路径<br>hdfs dfs -mv /user/x.txt /user/test #在hdfs目录中移动文件<br>hdfs dfs -get /user/x.txt ./ #等同于copyToLocal,就是从hdfs下载文件到本地<br>hdfs dfs -getmerge /user//test/* ./test.txt #合并下载多个文件<br>hdfs dfs -put #等同于copyFromLocal上传<br>hdfs dfs -rm [-r] #递归删除文件或文件夹<br>hdfs dfs -rmdir #删除空目录<br>hdfs dfs -df #统计文件系统的可用空间<br>hdfs dfs -du #统计文件的大小信息<br>hdfs dfs -setrep #设置hdfs中文件的副本量数<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">权限管理命令</span><br>hdfs dfs -chmod -R 777 /xxx #修改权限<br>hdfs dfs -chown -R hadoop:hadoop /xxx#修改用户组<br><br></code></pre></td></tr></table></figure><h2 id="在windows配置Hadoop运行环境"><a href="#在windows配置Hadoop运行环境" class="headerlink" title="在windows配置Hadoop运行环境"></a>在windows配置Hadoop运行环境</h2><ol><li>将apache-hadoop-3.1.1文件夹拷贝到一个没有中文没有空格的路径下</li><li>在windows配置hadoop环境变量：<code>HADOOP_HOME</code></li><li>在path下，新增<code>%HADOOP_HOME%\bin</code></li><li>将bin目录下hadoop.dll文件拷贝到<code>C:\Windows\System32</code></li><li>重启电脑</li></ol><h2 id="HDFS-的-API-操作"><a href="#HDFS-的-API-操作" class="headerlink" title="HDFS 的 API 操作"></a>HDFS 的 API 操作</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>在 Java 中操作 HDFS, 主要涉及以下 Class:</p><ul><li><p><code>Configuration</code></p><ul><li>该类的对象封转了客户端或者服务器的配置</li></ul></li><li><p><code>FileSystem</code></p><ul><li><p>该类的对象是一个文件系统对象, 可以用该对象的一些方法来对文件进行操作, 通过 FileSystem 的静态方法 get 获得该对象</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">FileSystem</span> fs = <span class="hljs-built_in">FileSystem</span>.<span class="hljs-built_in">get</span>(conf)<br></code></pre></td></tr></table></figure><ul><li><code>get</code> 方法从 <code>conf</code> 中的一个参数 <code>fs.defaultFS</code> 的配置值判断具体是什么类型的文件系统</li><li>如果我们的代码中没有指定 <code>fs.defaultFS</code>, 并且工程 ClassPath 下也没有给定相应的配置, <code>conf</code> 中的默认值就来自于 Hadoop 的 Jar 包中的 <code>core-default.xml</code></li><li>默认值为 <code>file:///</code>, 则获取的不是一个 DistributedFileSystem 的实例, 而是一个本地文件系统的客户端对象</li></ul></li></ul></li></ul><h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h3><p>新建工程后导入maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--指定下载地址--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>cloudera<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-hdfs<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-hdfs-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                          <span class="hljs-tag">&lt;<span class="hljs-name">minimizeJar</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">minimizeJar</span>&gt;</span><br>                      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="获取-FileSystem的方式"><a href="#获取-FileSystem的方式" class="headerlink" title="获取 FileSystem的方式"></a>获取 FileSystem的方式</h3><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取文件系统的第一种方式</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getFileSystem</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> URISyntaxException, IOException </span>&#123;<br>    <span class="hljs-comment">//1.获取Configuration对象</span><br>    Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>    <span class="hljs-comment">//2.设置Configuration对象，指定要操作的文件系统</span><br>    configuration.set(<span class="hljs-string">&quot;fs.defaultFS&quot;</span>,<span class="hljs-string">&quot;hdfs://192.168.127.110:8020&quot;</span>);<br>    <span class="hljs-comment">//3.获取指定文件系统，获取了fileSystem就相当于获取了主节点中所有元数据信息</span><br>    FileSystem fileSystem = FileSystem.get(configuration);<br>    System.out.println(fileSystem.toString());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取文件系统的第二种方式</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getFileSystem2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> URISyntaxException, IOException </span>&#123;<br>    FileSystem fileSystem = FileSystem.get(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020&quot;</span>), <span class="hljs-keyword">new</span> Configuration());<br>    System.out.println(fileSystem.toString());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取文件系统的第三种方式</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getFileSystem3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> URISyntaxException, IOException </span>&#123;<br>    FileSystem fileSystem = FileSystem.newInstance(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020&quot;</span>), <span class="hljs-keyword">new</span> Configuration());<br>    System.out.println(fileSystem.toString());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取文件系统的第四种方式</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getFileSystem4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception</span>&#123;<br>    Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>    configuration.set(<span class="hljs-string">&quot;fs.defaultFS&quot;</span>,<span class="hljs-string">&quot;hdfs://192.168.127.110:8020&quot;</span>);<br>    FileSystem fileSystem = FileSystem.newInstance(configuration);<br>    System.out.println(fileSystem.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/4.9.png"></p><h3 id="获取文件元信息"><a href="#获取文件元信息" class="headerlink" title="获取文件元信息"></a>获取文件元信息</h3><p><strong>获取目录及其子目录下所有文件</strong>有如下两种方法</p><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归调用</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>    FileSystem fileSystem = FileSystem.get(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020&quot;</span>), <span class="hljs-keyword">new</span> Configuration());<br>    FileStatus[] fileStatuses = fileSystem.listStatus(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;/&quot;</span>));<br>    <span class="hljs-keyword">for</span> (FileStatus fileStatus : fileStatuses) &#123;<br>        <span class="hljs-keyword">if</span>(fileStatus.isDirectory())&#123;<br>            Path path = fileStatus.getPath();<br>            listAllFiles(fileSystem,path);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;文件路径为&quot;</span>+fileStatus.getPath().toString());<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listAllFiles</span><span class="hljs-params">(FileSystem fileSystem,Path path)</span> <span class="hljs-keyword">throws</span>  Exception</span>&#123;<br>    FileStatus[] fileStatuses = fileSystem.listStatus(path);<br>    <span class="hljs-keyword">for</span> (FileStatus fileStatus : fileStatuses) &#123;<br>        <span class="hljs-keyword">if</span>(fileStatus.isDirectory())&#123;<br>            listAllFiles(fileSystem,fileStatus.getPath());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            Path path1 = fileStatus.getPath();<br>            System.out.println(<span class="hljs-string">&quot;文件路径为&quot;</span>+path1);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="直接使用API"><a href="#直接使用API" class="headerlink" title="直接使用API"></a>直接使用API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listMyFiles</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br>    <span class="hljs-comment">//获取fileSystem类</span><br>    FileSystem fileSystem = FileSystem.get(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020&quot;</span>), <span class="hljs-keyword">new</span> Configuration());<br>    <span class="hljs-comment">//获取RemoteIterator 得到所有的文件或者文件夹，第一个参数指定遍历的路径，第二个参数表示是否要递归遍历</span><br>    RemoteIterator&lt;LocatedFileStatus&gt; locatedFileStatusRemoteIterator = fileSystem.listFiles(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;/&quot;</span>), <span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">while</span> (locatedFileStatusRemoteIterator.hasNext())&#123;<br>        <span class="hljs-comment">//获取每个文件详细信息</span><br>        LocatedFileStatus fileStatus = locatedFileStatusRemoteIterator.next();<br>        <span class="hljs-comment">//打印文件路径</span><br>        System.out.println(fileStatus.getPath().toString());<br>        <span class="hljs-comment">//获取文件Block信息</span><br>        BlockLocation[] blockLocations = fileStatus.getBlockLocations();<br>        <span class="hljs-comment">//打印每个文件副本存储位置</span><br>        <span class="hljs-keyword">for</span> (BlockLocation blockLocation : blockLocations) &#123;<br>            String[] hosts = blockLocation.getHosts();<br>            <span class="hljs-keyword">for</span> (String host : hosts) &#123;<br>                System.out.println(host);<br>            &#125;<br>        &#125;<br>    &#125;<br>    fileSystem.close();<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/4.10.png"></p><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建文件、文件夹(支持创建多级目录)</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mkdirs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception</span>&#123;<br>    FileSystem fileSystem = FileSystem.get(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020&quot;</span>), <span class="hljs-keyword">new</span> Configuration());<br>    <span class="hljs-keyword">boolean</span> isMkdirs01 = fileSystem.mkdirs(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;/test03&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;文件夹创建是否成功：&quot;</span>+isMkdirs01);<br>    <span class="hljs-keyword">boolean</span> isMkdirs02 = fileSystem.mkdirs(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;/test01/a.txt&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;文件创建是否成功：&quot;</span>+isMkdirs02);<br>    fileSystem.close();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/4.11.png"></p><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//文件下载方法一</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getFileToLocal01</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span>  Exception</span>&#123;<br>    <span class="hljs-comment">//1.获取FileSystem对象</span><br>    FileSystem fileSystem = FileSystem.get(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020&quot;</span>), <span class="hljs-keyword">new</span> Configuration());<br>    <span class="hljs-comment">//2.获取HDFS文件输入流</span><br>    FSDataInputStream open = fileSystem.open(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;/test01/hello.sh&quot;</span>));<br>    <span class="hljs-comment">//3.获取本地文件输出流</span><br>    FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;..\\hello01.sh&quot;</span>));<br>    <span class="hljs-comment">//4.实现文件复制</span><br>    IOUtils.copy(open,fileOutputStream);<br>    IOUtils.closeQuietly(open);<br>    IOUtils.closeQuietly(fileOutputStream);<br>    <span class="hljs-comment">//5.关闭fileSystem</span><br>    fileSystem.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//文件下载方法二</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getFileToLocal02</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span>  Exception</span>&#123;<br>    <span class="hljs-comment">//1.获取FileSystem对象</span><br>    FileSystem fileSystem = FileSystem.get(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020&quot;</span>), <span class="hljs-keyword">new</span> Configuration());<br>    <span class="hljs-comment">//2.调用方法直接实现文件下载</span><br>    fileSystem.copyToLocalFile(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;/test01/hello.sh&quot;</span>),<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;..\\hello02.sh&quot;</span>));<br>    <span class="hljs-comment">//3.关闭fileSystem</span><br>    fileSystem.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//文件上传方法</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putFileTOHDFS</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception</span>&#123;<br>    <span class="hljs-comment">//1.获取FileSystem对象</span><br>    FileSystem fileSystem = FileSystem.get(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020&quot;</span>), <span class="hljs-keyword">new</span> Configuration());<br>    <span class="hljs-comment">//2.调用方法直接实现文件下载</span><br>    fileSystem.copyFromLocalFile(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;..\\hello02.sh&quot;</span>),<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;/test03/hello02.sh&quot;</span>));<br>    <span class="hljs-comment">//3.关闭fileSystem</span><br>    fileSystem.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="伪造用户"><a href="#伪造用户" class="headerlink" title="伪造用户"></a>伪造用户</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以指定用户名的用户去操作文件</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getConfig</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span>  Exception</span>&#123;<br>  FileSystem fileSystem = FileSystem.get(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020&quot;</span>), <span class="hljs-keyword">new</span> Configuration(),<span class="hljs-string">&quot;root&quot;</span>);<br>     fileSystem.copyToLocalFile(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;/test03/hello02.sh&quot;</span>),<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;..\\temp.sh&quot;</span>));<br>fileSystem.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小文件合并"><a href="#小文件合并" class="headerlink" title="小文件合并"></a>小文件合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//小文件合并</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception</span>&#123;<br>    <span class="hljs-comment">//1.获取FileSystem文件系统</span><br>    FileSystem fileSystem = FileSystem.get(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020&quot;</span>), <span class="hljs-keyword">new</span> Configuration(),<span class="hljs-string">&quot;hadoop&quot;</span>);<br>    <span class="hljs-comment">//2.在HDFS获取要输出的文件流</span><br>    FSDataOutputStream outputStream = fileSystem.create(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;/bigfile.txt&quot;</span>));<br>    <span class="hljs-comment">//3.获取LocalFileSystem本地文件系统</span><br>    LocalFileSystem local = FileSystem.getLocal(<span class="hljs-keyword">new</span> Configuration());<br>    <span class="hljs-comment">//4.获取通过本地文件集合</span><br>    FileStatus[] fileStatuses = local.listStatus(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;..\\hdfs_api\\temp&quot;</span>));<br>    <span class="hljs-comment">//5.遍历集合进行合并后上传</span><br>    <span class="hljs-keyword">for</span> (FileStatus fileStatus : fileStatuses) &#123;<br>        FSDataInputStream inputStream = local.open(fileStatus.getPath());<br>        IOUtils.copy(inputStream,outputStream);<br>        IOUtils.closeQuietly(inputStream);<br>    &#125;<br>    <span class="hljs-comment">//6.关闭资源</span><br>    IOUtils.closeQuietly(outputStream);<br>    local.close();<br>    fileSystem.close();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="五、MapReduce"><a href="#五、MapReduce" class="headerlink" title="五、MapReduce"></a>五、MapReduce</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>MapReduce是一个分布式运算程序的编程框架，核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的<strong>分布式运算程序</strong>，并发运行在Hadoop集群上。</p><h3 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h3><p>MapReduce的思想核心是“<strong>分而治之</strong>”，适用于大量复杂的任务处理场景（大规模数据处理场景）。</p><ul><li>分而治之<ul><li>对相互间<strong>不具有计算依赖关系</strong>的大数据，实现并行最自然的办法就是采取分而治之的策略。并行计算的第一个重要问题是如何划分计算任务或者计算数据以便对划分的子任务或数据块同时进行计算。不可分拆的计算任务或相互间有依赖关系的数据无法进行并行计算</li><li>统一构架，隐藏系统层细节<ul><li>MapReduce设计并提供了统一的计算框架，隐藏了绝大多数系统层面的处理细节。</li><li>MapReduce最大的亮点在于通过<strong>抽象模型</strong>和<strong>计算框架</strong>把需要做什么(whatneed to do)与具体怎么做(how to do)分开了，提供一个抽象和高层的编程接口和框架。使用者仅需要关心其应用层的具体计算问题，仅需编写少量的处理应用本身计算问题的程序代码。如何具体完成这个并行计算任务所相关的诸多系统层细节被隐藏起来，交给计算框架去处理：从分布代码的执行，到大到数千小到单个节点集群的自动调度使用。</li></ul></li></ul></li><li>构建抽象模型：Map和Reduce<ul><li>MapReduce借鉴了函数式语言中的思想，用Map和Reduce两个函数提供了高层的并行编程抽象模型，MapReduce处理的数据类型是键值对。<ul><li>Map: 对一组数据元素进行某种<strong>重复式</strong>的处理。</li><li>Reduce: 对Map的中间结果进行某种<strong>进一步</strong>的结果整理。</li></ul></li><li><strong>Map负责“分”</strong>，即把复杂的任务分解为若干个“简单的任务”来并行处理。可以进行拆分的前提是这些小任务可以并行计算，彼此间几乎没有依赖关系。</li><li><strong>Reduce负责“合”</strong>，即对map阶段的结果进行全局汇总。</li></ul></li></ul><p>MapReduce运行在yarn集群，<strong>ResourceManager</strong>，<strong>NodeManager</strong>这两个阶段合起来正是MapReduce思想的体现。</p><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.1.png"></p><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.2.png"></p><h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><h3 id="Map阶段"><a href="#Map阶段" class="headerlink" title="Map阶段"></a>Map阶段</h3><ol><li>设置 InputFormat 类, 将数据切分为 Key-Value(<strong>K1和V1</strong>) 对, 输入到第二步</li><li>自定义 Map 逻辑, 将第一步的结果转换成另外的 Key-Value（<strong>K2和V2</strong>） 对, 输出结果</li></ol><h3 id="Shuffle阶段"><a href="#Shuffle阶段" class="headerlink" title="Shuffle阶段"></a>Shuffle阶段</h3><ol start="3"><li>对输出的 Key-Value 对进行<strong>分区</strong></li><li>对不同分区的数据按照相同的 Key <strong>排序</strong></li><li>(可选) 对分组过的数据初步<strong>规约</strong>，降低数据的网络拷贝</li><li>对数据进行**分组,**，相同 Key 的 Value 放入一个集合中</li></ol><h3 id="Reduce阶段"><a href="#Reduce阶段" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h3><ol start="7"><li>对多个 Map 任务的结果进行排序以及合并, 编写 Reduce 函数实现自己的逻辑, 对输入的 Key-Value 进行处理, 转为新的 Key-Value（<strong>K3和V3</strong>）输出</li><li>设置 OutputFormat 处理并保存 Reduce 输出的 Key-Value 数据</li></ol><h2 id="WordCount案例"><a href="#WordCount案例" class="headerlink" title="WordCount案例"></a>WordCount案例</h2><h3 id="步骤分析"><a href="#步骤分析" class="headerlink" title="步骤分析"></a>步骤分析</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.2.1.png"></p><h3 id="第一步：数据准备"><a href="#第一步：数据准备" class="headerlink" title="第一步：数据准备"></a>第一步：数据准备</h3><ul><li><p>创建一个新的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers<br>vim wordcount.txt<br></code></pre></td></tr></table></figure></li><li><p>向其中放入以下内容并保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">hello,world,hadoop<br>hive,sqoop,flume,hello<br>kitty,tom,jerry,world<br>hadoop<br></code></pre></td></tr></table></figure></li><li><p>上传到 HDFS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdfs dfs -mkdir /wordcount/<br>hdfs dfs -put wordcount.txt /wordcount/<br></code></pre></td></tr></table></figure></li></ul><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.3.png"></p><ul><li>新建Maven项目，导入如下依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--指定下载地址--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>cloudera<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-hdfs<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-hdfs-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">minimizeJar</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">minimizeJar</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="第二步：Mapper编写"><a href="#第二步：Mapper编写" class="headerlink" title="第二步：Mapper编写"></a>第二步：Mapper编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@time</span> 2021/1/10</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auth</span> Gotcha</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@describe</span></span><br><span class="hljs-comment"> * Mapper的泛型</span><br><span class="hljs-comment"> *  KEYIN:k1的类型     行偏移量        LongWritable</span><br><span class="hljs-comment"> *  VALUEIN:v1的类型   一行的文本数据   Text</span><br><span class="hljs-comment"> *  KEYOUT:k2的类型    每个单词        Text</span><br><span class="hljs-comment"> *  VALUEOUT:v2的类型  固定值，1       LongWritable</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCountMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">LongWritable</span>,<span class="hljs-title">Text</span>, <span class="hljs-title">Text</span>,<span class="hljs-title">LongWritable</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@describe</span> 是将k1,v1转换为k2,v2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 表示k1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 表示v1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 表示MapReduce上下文对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//第二步要使用的对象</span><br>        Text text = <span class="hljs-keyword">new</span> Text();<br>        LongWritable longWritable = <span class="hljs-keyword">new</span> LongWritable(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//1.对每行数据进行字符串拆分</span><br>        String line = value.toString();<br>        String[] split = line.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-comment">//2.遍历数组获取每个单词</span><br>        <span class="hljs-keyword">for</span> (String word : split) &#123;<br>            text.set(word);<br>            <span class="hljs-comment">//3.将k2,v2写入上下文</span><br>            context.write(text,longWritable);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三步：Reducer编写"><a href="#第三步：Reducer编写" class="headerlink" title="第三步：Reducer编写"></a>第三步：Reducer编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@time</span> 2021/1/10</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auth</span> Gotcha</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@describe</span></span><br><span class="hljs-comment"> *  Reducer的泛型</span><br><span class="hljs-comment"> *  KEYIN:k2的类型     每个单词        Text</span><br><span class="hljs-comment"> *  VALUEIN:v2的类型   集合中泛型的类型   LongWritable</span><br><span class="hljs-comment"> *  KEYOUT:k3的类型    每个单词        Text</span><br><span class="hljs-comment"> *  VALUEOUT:v3的类型  出现的次数       LongWritable</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCountReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">Text</span>, <span class="hljs-title">LongWritable</span>,<span class="hljs-title">Text</span>, <span class="hljs-title">LongWritable</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@describe</span> 是将k2,v2转换为k3,v3</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 表示k2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 表示集合</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 表示MapReduce上下文对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//1.遍历values集合</span><br>        <span class="hljs-keyword">for</span> (LongWritable value : values) &#123;<br>            <span class="hljs-comment">//2.将集合中值相加</span><br>            count+=value.get();<br>        &#125;<br>        <span class="hljs-comment">//3.将k3,v3写入上下文</span><br>        context.write(key,<span class="hljs-keyword">new</span> LongWritable(count));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四步：定义主类-描述-Job-并提交-Job"><a href="#第四步：定义主类-描述-Job-并提交-Job" class="headerlink" title="第四步：定义主类, 描述 Job 并提交 Job"></a>第四步：定义主类, 描述 Job 并提交 Job</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JobMain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Configured</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tool</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(String[] strings)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建一个任务对象</span><br>        Job job = Job.getInstance(<span class="hljs-keyword">super</span>.getConf(), <span class="hljs-string">&quot;计算单词出现次数&quot;</span>);<br>        <span class="hljs-comment">//打包到集群上面运行时候，必须要添加以下配置，指定程序的main函数</span><br>        job.setJarByClass(JobMain.class);<br><br>        <span class="hljs-comment">//第一步：设置读取文件的类，将文件解析成key，value对</span><br>        job.setInputFormatClass(TextInputFormat.class);<br>        TextInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/wordcount&quot;</span>));<br>        <span class="hljs-comment">//第二步：设置mapper类</span><br>        job.setMapperClass(WordCountMapper.class);<br>            <span class="hljs-comment">//设置map阶段完成之后的输出类型</span><br>        job.setMapOutputKeyClass(Text.class);<br>        job.setMapOutputValueClass(LongWritable.class);<br>        <span class="hljs-comment">//第三步，第四步，第五步，第六步采用默认方式（分区、排序、规约、分组）</span><br>        <span class="hljs-comment">//第七步：设置reduce类</span><br>        job.setReducerClass(WordCountReducer.class);<br>            <span class="hljs-comment">//设置reduce阶段完成之后的输出类型</span><br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputValueClass(LongWritable.class);<br>        <span class="hljs-comment">//第八步：设置输出类以及输出路径</span><br>        job.setOutputFormatClass(TextOutputFormat.class);<br>        TextOutputFormat.setOutputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/wordcount_out&quot;</span>));<br>        <span class="hljs-comment">//任务是否执行成功</span><br>        <span class="hljs-keyword">boolean</span> b = job.waitForCompletion(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> b?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>        <span class="hljs-comment">//启动一个任务</span><br>        <span class="hljs-keyword">int</span> run = ToolRunner.run(configuration, <span class="hljs-keyword">new</span> JobMain(), args);<br>        System.exit(run);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第五步：打成jar包上传至服务器，并在服务器运行"><a href="#第五步：打成jar包上传至服务器，并在服务器运行" class="headerlink" title="第五步：打成jar包上传至服务器，并在服务器运行"></a>第五步：打成jar包上传至服务器，并在服务器运行</h3><p><code>hadoop jar /export/softwares/mapReduce-1.0-SNAPSHOT.jar top.igotcha.mapreduce.wordcount.JobMain</code></p><p>执行结果如下</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.4.png"></p><p>生成的结果文件如下</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.5.png"></p><hr><h2 id="分区案例"><a href="#分区案例" class="headerlink" title="分区案例"></a>分区案例</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在MapReduce 中，通过指定分区，会将同一个分区的数据发送到同一个Reduce当中进行处理</p><h3 id="步骤分析-1"><a href="#步骤分析-1" class="headerlink" title="步骤分析"></a>步骤分析</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.6.png"></p><h3 id="自定义Partitioner"><a href="#自定义Partitioner" class="headerlink" title="自定义Partitioner"></a>自定义Partitioner</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@time</span> 2021/1/11</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auth</span> Gotcha</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@describe</span></span><br><span class="hljs-comment"> * Partitioner</span><br><span class="hljs-comment"> *  KEY:k2的类型     每个单词        Text</span><br><span class="hljs-comment"> *  VALUE:v2的类型   固定值，1   LongWritable</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PartitionerOwn</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Partitioner</span>&lt;<span class="hljs-title">Text</span>,<span class="hljs-title">LongWritable</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> text 表示k2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> longWritable 表示v2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i 表示分区个数（reduce个数）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPartition</span><span class="hljs-params">(Text text, LongWritable longWritable, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-comment">//如果单词长度大于等于5，进入第一个分区，第一个ReduceTask，即reduce编号为0</span><br>        <span class="hljs-keyword">if</span> (text.getLength()&gt;=<span class="hljs-number">5</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span>  &#123;<br>        <span class="hljs-comment">//如果单词长度小于5，进入第二个分区，第二个ReduceTask，即reduce编号为1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定义主类job"><a href="#定义主类job" class="headerlink" title="定义主类job"></a>定义主类job</h3><p>主要变化在于多了<strong>第三步，设置分区类</strong>，在<strong>第七步：设置reduce类</strong>中<strong>设置reduce个数</strong>，其他不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JobMain02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Configured</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tool</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(String[] strings)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建一个任务对象</span><br>        Job job = Job.getInstance(<span class="hljs-keyword">super</span>.getConf(), <span class="hljs-string">&quot;计算单词出现次数&quot;</span>);<br>        <span class="hljs-comment">//打包到集群上面运行时候，必须要添加以下配置，指定程序的main函数</span><br>        job.setJarByClass(JobMain02.class);<br>        <span class="hljs-comment">//第一步：设置读取文件的类，将文件解析成key，value对</span><br>        job.setInputFormatClass(TextInputFormat.class);<br>        TextInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/wordcount&quot;</span>));<br>        <span class="hljs-comment">//第二步：设置mapper类</span><br>        job.setMapperClass(WordCountMapper.class);<br>            <span class="hljs-comment">//设置map阶段完成之后的输出类型</span><br>        job.setMapOutputKeyClass(Text.class);<br>        job.setMapOutputValueClass(LongWritable.class);<br>        <span class="hljs-comment">//第三步，第四步，第五步，第六步采用默认方式（分区、排序、规约、分组）</span><br>        <span class="hljs-comment">//第三步，设置分区类</span><br>        job.setPartitionerClass(PartitionerOwn.class);<br>        <span class="hljs-comment">//第七步：设置reduce类</span><br>        job.setReducerClass(WordCountReducer.class);<br>            <span class="hljs-comment">//设置reduce阶段完成之后的输出类型</span><br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputValueClass(LongWritable.class);<br>            <span class="hljs-comment">//设置reduce个数</span><br>        job.setNumReduceTasks(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//第八步：设置输出类以及输出路径</span><br>        job.setOutputFormatClass(TextOutputFormat.class);<br>        TextOutputFormat.setOutputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/wordcount_out&quot;</span>));<br>        <span class="hljs-comment">//任务是否执行成功</span><br>        <span class="hljs-keyword">boolean</span> b = job.waitForCompletion(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> b?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>        <span class="hljs-comment">//启动一个任务</span><br>        <span class="hljs-keyword">int</span> run = ToolRunner.run(configuration, <span class="hljs-keyword">new</span> JobMain02(), args);<br>        System.exit(run);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打成jar包上传至服务器，并在服务器运行"><a href="#打成jar包上传至服务器，并在服务器运行" class="headerlink" title="打成jar包上传至服务器，并在服务器运行"></a>打成jar包上传至服务器，并在服务器运行</h3><p><strong>保持Mapper类和Reducer类不变，上传至服务器并运行</strong>，产生了两个结果文件</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.7.png"></p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.8.png"></p><hr><h2 id="序列化、反序列化和排序案例"><a href="#序列化、反序列化和排序案例" class="headerlink" title="序列化、反序列化和排序案例"></a>序列化、反序列化和排序案例</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>当要在进程间传递对象或持久化对象的时候，就需要序列化对象成字节流，反之当要将接收到或从磁盘读取的字节流转换为对象，就要进行反序列化。</strong></p><ul><li><strong>序列化</strong> (Serialization) 是指把结构化对象转化为字节流</li><li><strong>反序列化</strong> (Deserialization) 是序列化的逆过程。 把字节流转为结构化对象。</li></ul><ul><li>Java 的序列化 (Serializable) 是一个重量级序列化框架, 一个对象被序列化后， 会附带很多额外的信息 (各种校验信息, header, 继承体系等），不便于在网络中高效传输。所以，Hadoop 自己开发了一套序列化机制(Writable)，精简高效。不用像 Java 对象类一样传输多层的父子关系， 需要哪个属性就传输哪个属性值, 大大的减少网络传输的开销</li><li>Writable 是 Hadoop 的序列化格式，Hadoop 定义了这样一个 Writable 接口。一个类要支持可序列化只需实现这个接口即可</li><li>另外 Writable 有一个子接口是 <strong>WritableComparable</strong>, WritableComparable 是既可实现序列化， 也可以对key进行比较，可以通过自定义类实现<br>WritableComparable来实现排序功能</li></ul><h3 id="步骤分析-2"><a href="#步骤分析-2" class="headerlink" title="步骤分析"></a>步骤分析</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.9.png"></p><h3 id="第一步：数据准备-1"><a href="#第一步：数据准备-1" class="headerlink" title="第一步：数据准备"></a>第一步：数据准备</h3><ul><li><p>创建一个新的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers<br>vim sort.txt<br></code></pre></td></tr></table></figure></li><li><p>向其中放入以下内容并保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">a1<br>a9<br>b3<br>a7<br>b8<br>c1<br>b10<br>a5<br></code></pre></td></tr></table></figure></li><li><p>上传到 HDFS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdfs dfs -mkdir -p /input/sort<br>hdfs dfs -put sort.txt /input/sort<br></code></pre></td></tr></table></figure></li><li><p>新建Maven项目，导入依赖（和WordCount案例相同）</p></li></ul><h3 id="第二步：自定义类型和比较器WritableComparable"><a href="#第二步：自定义类型和比较器WritableComparable" class="headerlink" title="第二步：自定义类型和比较器WritableComparable"></a>第二步：自定义类型和比较器WritableComparable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortWritable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WritableComparable</span>&lt;<span class="hljs-title">SortWritable</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> String first;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> second;<br><br>    <span class="hljs-comment">//实现排序规则</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(SortWritable other)</span> </span>&#123;<br>        <span class="hljs-comment">//先比较first,相同则比较second</span><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-keyword">this</span>.first.compareTo(other.getFirst());<br>        <span class="hljs-keyword">if</span> (res!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.second - other.getSecond();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//实现序列化</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(DataOutput dataOutput)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        dataOutput.writeUTF(first);<br>        dataOutput.writeInt(second);<br>    &#125;<br><br>    <span class="hljs-comment">//实现反序列化</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFields</span><span class="hljs-params">(DataInput dataInput)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = dataInput.readUTF();<br>        <span class="hljs-keyword">this</span>.second = dataInput.readInt();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(String first)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSecond</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSecond</span><span class="hljs-params">(<span class="hljs-keyword">int</span> second)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.second = second;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first + <span class="hljs-string">&#x27;\t&#x27;</span> + second ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三步：Mapper编写"><a href="#第三步：Mapper编写" class="headerlink" title="第三步：Mapper编写"></a>第三步：Mapper编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@time</span> 2021/1/10</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auth</span> Gotcha</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@describe</span></span><br><span class="hljs-comment"> * Mapper的泛型</span><br><span class="hljs-comment"> *  KEYIN:k1的类型     行偏移量                    LongWritable</span><br><span class="hljs-comment"> *  VALUEIN:v1的类型   一行的文本数据               Text</span><br><span class="hljs-comment"> *  KEYOUT:k2的类型    可以进行比较及排序的Bean对象   SortWritable</span><br><span class="hljs-comment"> *  VALUEOUT:v2的类型  一行的文本数据               Text</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">LongWritable</span>,<span class="hljs-title">Text</span>,<span class="hljs-title">SortWritable</span>,<span class="hljs-title">Text</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@describe</span> 是将k1,v1转换为k2,v2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 表示k1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 表示v1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 表示MapReduce上下文对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//1.对每行数据进行拆分</span><br>        String[] split = value.toString().split(<span class="hljs-string">&quot;\t&quot;</span>);<br>        <span class="hljs-comment">//2.封装到SortWritable对象中，作为k2</span><br>        SortWritable sortWritable = <span class="hljs-keyword">new</span> SortWritable();<br>        sortWritable.setFirst(split[<span class="hljs-number">0</span>]);<br>        sortWritable.setSecond(Integer.parseInt(split[<span class="hljs-number">1</span>]));<br>        <span class="hljs-comment">//3.将k2,v2写入上下文</span><br>        context.write(sortWritable,value);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四步：Reducer编写"><a href="#第四步：Reducer编写" class="headerlink" title="第四步：Reducer编写"></a>第四步：Reducer编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@time</span> 2021/1/10</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auth</span> Gotcha</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@describe</span></span><br><span class="hljs-comment"> * Reducer的泛型</span><br><span class="hljs-comment"> *  KEYIN:k2的类型     可以进行比较及排序的Bean对象    SortWritable</span><br><span class="hljs-comment"> *  VALUEIN:v2的类型   一行的文本数据                Text</span><br><span class="hljs-comment"> *  KEYOUT:k3的类型    可以进行比较及排序的Bean对象    SortWritable</span><br><span class="hljs-comment"> *  VALUEOUT:v3的类型  空类型，占位符                NullWritable</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">SortWritable</span>,<span class="hljs-title">Text</span>,<span class="hljs-title">SortWritable</span>, <span class="hljs-title">NullWritable</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@describe</span> 是将k2,v2转换为k3,v3</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 表示k2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 表示集合</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 表示MapReduce上下文对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(SortWritable key, Iterable&lt;Text&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-keyword">for</span> (Text value : values) &#123;<br>            context.write(key,NullWritable.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第五步：打成jar包上传至服务器，并在服务器运行-1"><a href="#第五步：打成jar包上传至服务器，并在服务器运行-1" class="headerlink" title="第五步：打成jar包上传至服务器，并在服务器运行"></a>第五步：打成jar包上传至服务器，并在服务器运行</h3><p><code>hadoop jar /export/softwares/mapReduce-1.0-SNAPSHOT.jar top.igotcha.mapreduce.sort.JobMain</code></p><p>生成的结果文件如下</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.10.png"></p><h3 id="常用数据序列化类型"><a href="#常用数据序列化类型" class="headerlink" title="常用数据序列化类型"></a>常用数据序列化类型</h3><table><thead><tr><th>Java 类型</th><th>Hadoop Write 类型</th></tr></thead><tbody><tr><td>boolean</td><td>BooleanWritable</td></tr><tr><td>byte</td><td>ByteWritable</td></tr><tr><td>int</td><td>IntWritable</td></tr><tr><td>float</td><td>FloatWritable</td></tr><tr><td>long</td><td>LongWritable</td></tr><tr><td>double</td><td>DoubleWritable</td></tr><tr><td>String</td><td>Text</td></tr><tr><td>map</td><td>MapWritable</td></tr><tr><td>array</td><td>ArrayWritable</td></tr></tbody></table><hr><h2 id="计数器Counter"><a href="#计数器Counter" class="headerlink" title="计数器Counter"></a>计数器Counter</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>计数器是收集作业统计信息的有效手段之一，用于质量控制或应用级统计。计数器还可辅助诊断系统故障。如果需要将日志信息传输到map或reduce 任务，更好的方法通常是看能否用一个计数器值来记录某一特定事件的发生。对于大型分布式作业而言，使用计数器更为方便。除了因为获取计数器值比输出日志更方便，还有根据计数器值统计特定事件的发生次数要比分析一堆日志文件容易得多。</p><h3 id="hadoop内置计数器"><a href="#hadoop内置计数器" class="headerlink" title="hadoop内置计数器"></a>hadoop内置计数器</h3><table><thead><tr><th>MapReduce任务计数器</th><th>org.apache.hadoop.mapreduce.TaskCounter</th></tr></thead><tbody><tr><td>文件系统计数器</td><td>org.apache.hadoop.mapreduce.FileSystemCounter</td></tr><tr><td>FileInputFormat计数器</td><td>org.apache.hadoop.mapreduce.lib.input.FileInputFormatCounter</td></tr><tr><td>FileOutputFormat计数器</td><td>org.apache.hadoop.mapreduce.lib.output.FileOutputFormatCounter</td></tr><tr><td>作业计数器</td><td>org.apache.hadoop.mapreduce.JobCounter</td></tr></tbody></table><p>示例</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.11.png"></p><h3 id="获取计数器"><a href="#获取计数器" class="headerlink" title="获取计数器"></a>获取计数器</h3><p>以排序案例为例</p><h4 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h4><ul><li>通过<strong>context</strong>上下文对象可以获取计数器，使用计数器进行统计</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">LongWritable</span>,<span class="hljs-title">Text</span>,<span class="hljs-title">SortWritable</span>,<span class="hljs-title">Text</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@describe</span> 是将k1,v1转换为k2,v2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 表示k1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 表示v1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 表示MapReduce上下文对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//自定义计数器</span><br>        Counter counter = context.getCounter(<span class="hljs-string">&quot;MR_COUNT&quot;</span>, <span class="hljs-string">&quot;MapReduceCounter&quot;</span>);<br>        counter.increment(<span class="hljs-number">1L</span>);<br><br>        <span class="hljs-comment">//1.对每行数据进行拆分</span><br>        String[] split = value.toString().split(<span class="hljs-string">&quot;\t&quot;</span>);<br>        <span class="hljs-comment">//2.封装到SortWritable对象中，作为k2</span><br>        SortWritable sortWritable = <span class="hljs-keyword">new</span> SortWritable();<br>        sortWritable.setFirst(split[<span class="hljs-number">0</span>]);<br>        sortWritable.setSecond(Integer.parseInt(split[<span class="hljs-number">1</span>]));<br>        <span class="hljs-comment">//3.将k2,v2写入上下文</span><br>        context.write(sortWritable,value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h4><ul><li>通过enum<strong>枚举类型来定义计数器</strong>，统计reduce端数据的输入的key有多少个，对应的value有多少个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">SortWritable</span>,<span class="hljs-title">Text</span>,<span class="hljs-title">SortWritable</span>, <span class="hljs-title">NullWritable</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//自定义计数器，使用枚举类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Counter</span></span>&#123;<br>        REDUCE_INPUT_KEY_RECORDS, REDUCE_INPUT_VAL_NUMS,<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@describe</span> 是将k2,v2转换为k3,v3</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 表示k2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 表示集合</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 表示MapReduce上下文对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(SortWritable key, Iterable&lt;Text&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//统计Reduce阶段key个数</span><br>        context.getCounter(Counter.REDUCE_INPUT_KEY_RECORDS).increment(<span class="hljs-number">1L</span>);<br>        <span class="hljs-keyword">for</span> (Text value : values) &#123;<br>            <span class="hljs-comment">//统计Reduce阶段value个数</span><br>            context.getCounter(Counter.REDUCE_INPUT_VAL_NUMS).increment(<span class="hljs-number">1L</span>);<br>            context.write(key,NullWritable.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行后输入如下信息</strong></p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.12.png"></p><hr><h2 id="规约Combiner"><a href="#规约Combiner" class="headerlink" title="规约Combiner"></a>规约Combiner</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>每一个 map 都可能会产生大量的本地输出，Combiner 的作用就是<strong>对map端的输出先做一次合并</strong>，以<strong>减少在map和reduce节点之间的数据传输量</strong>，以提高网络IO 性能，是MapReduce 的一种优化手段之一</p><ul><li><p>combiner是 MR 程序中 Mapper 和 Reducer 之外的一种组件</p></li><li><p><strong>combiner 组件的父类就是 Reducer</strong></p></li><li><p>combiner 和 reducer 的区别在于运行的位置</p><ul><li><p>combiner 是在每一个 map task 所在的节点运行</p></li><li><p>reducer 是接收全局所有 Mapper 的输出结果</p></li></ul></li><li><p>combiner 的意义就是对每一个 map task 的输出进行<strong>局部汇总</strong>，以减小网络传输量</p></li></ul><h3 id="步骤分析-3"><a href="#步骤分析-3" class="headerlink" title="步骤分析"></a>步骤分析</h3><ul><li>以wordcount为例</li></ul><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.13.png"></p><h3 id="第一步：自定义combiner继承-Reducer，继承Reducer类，重写reduce方法"><a href="#第一步：自定义combiner继承-Reducer，继承Reducer类，重写reduce方法" class="headerlink" title="第一步：自定义combiner继承 Reducer，继承Reducer类，重写reduce方法"></a>第一步：自定义combiner继承 Reducer，继承Reducer类，重写reduce方法</h3><ul><li><strong>这里直接复制了Reducer类中的代码，因为规约的本质是，在map端执行了reducer的代码，提前整合</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@time</span> 2021/1/10</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auth</span> Gotcha</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@describe</span></span><br><span class="hljs-comment"> * Reducer的泛型</span><br><span class="hljs-comment"> *  KEYIN:k2的类型     每个单词        Text</span><br><span class="hljs-comment"> *  VALUEIN:v2的类型   集合中泛型的类型  LongWritable</span><br><span class="hljs-comment"> *  KEYOUT:k3的类型    每个单词        Text</span><br><span class="hljs-comment"> *  VALUEOUT:v3的类型  出现的次数       LongWritable</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CombinerReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">Text</span>, <span class="hljs-title">LongWritable</span>,<span class="hljs-title">Text</span>, <span class="hljs-title">LongWritable</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@describe</span> 是将k2,v2转换为k3,v3</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 表示k2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 表示集合</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 表示MapReduce上下文对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//1.遍历values集合</span><br>        <span class="hljs-keyword">for</span> (LongWritable value : values) &#123;<br>            <span class="hljs-comment">//2.将集合中值相加</span><br>            count+=value.get();<br>        &#125;<br>        <span class="hljs-comment">//3.将k3,v3写入上下文</span><br>        context.write(key,<span class="hljs-keyword">new</span> LongWritable(count));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二步：在job中进行设置"><a href="#第二步：在job中进行设置" class="headerlink" title="第二步：在job中进行设置"></a>第二步：在job中进行设置</h3><ul><li>主要变化在于多了<strong>第五步，设置规约类</strong>，其他不变</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JobMain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Configured</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tool</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(String[] strings)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建一个任务对象</span><br>        Job job = Job.getInstance(<span class="hljs-keyword">super</span>.getConf(), <span class="hljs-string">&quot;计算单词出现次数&quot;</span>);<br>        <span class="hljs-comment">//打包到集群上面运行时候，必须要添加以下配置，指定程序的main函数</span><br>        job.setJarByClass(JobMain.class);<br><br>        <span class="hljs-comment">//第一步：设置读取文件的类，将文件解析成key，value对</span><br>        job.setInputFormatClass(TextInputFormat.class);<br>        TextInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/wordcount&quot;</span>));<br>        <span class="hljs-comment">//第二步：设置mapper类</span><br>        job.setMapperClass(CombinerMapper.class);<br>            <span class="hljs-comment">//设置map阶段完成之后的输出类型</span><br>        job.setMapOutputKeyClass(Text.class);<br>        job.setMapOutputValueClass(LongWritable.class);<br>        <span class="hljs-comment">//第三步，第四步，第五步，第六步采用默认方式（分区、排序、规约、分组）</span><br>        <span class="hljs-comment">//第五步：设置规约类</span><br>        job.setCombinerClass(MyCombiner.class);<br>        <span class="hljs-comment">//第七步：设置reduce类</span><br>        job.setReducerClass(CombinerReducer.class);<br>            <span class="hljs-comment">//设置reduce阶段完成之后的输出类型</span><br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputValueClass(LongWritable.class);<br>        <span class="hljs-comment">//第八步：设置输出类以及输出路径</span><br>        job.setOutputFormatClass(TextOutputFormat.class);<br>        TextOutputFormat.setOutputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/wordcount_out&quot;</span>));<br>        <span class="hljs-comment">//任务是否执行成功</span><br>        <span class="hljs-keyword">boolean</span> b = job.waitForCompletion(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> b?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>        <span class="hljs-comment">//启动一个任务</span><br>        <span class="hljs-keyword">int</span> run = ToolRunner.run(configuration, <span class="hljs-keyword">new</span> JobMain(), args);<br>        System.exit(run);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其他步骤同WordCount案例</li></ul><hr><h2 id="流量统计案例"><a href="#流量统计案例" class="headerlink" title="流量统计案例"></a>流量统计案例</h2><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>有数据文件，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs txt">13631579850661372623050300-FD-07-A4-72-B8:CMCC120.196.100.82i02.c.aliimg.com游戏娱乐2427248124681200<br>1363157995052 138265441015C-0E-8B-C7-F1-E0:CMCC120.197.40.4jd.com京东购物402640200<br>1363157991076 1392643565620-10-7A-28-CC-0A:CMCC120.196.100.99taobao.com淘宝购物241321512200<br>1363154400022 139262511065C-0E-8B-8B-B1-50:CMCC120.197.40.4cnblogs.com技术门户402400200<br>1363157993044 1821157596194-71-AC-CD-E6-18:CMCC-EASY120.196.100.99iface.qiyi.com视频网站151215272106200<br>1363157995074 841384135C-0E-8B-8C-E8-20:7DaysInn120.197.40.4122.72.52.12未知201641161432200<br>1363157993055 13560439658C4-17-FE-BA-DE-D9:CMCC120.196.100.99sougou.com综合门户18151116954200<br>1363157995033 159201332575C-0E-8B-C7-BA-20:CMCC120.197.40.4sug.so.360.cn信息安全202031562936200<br>1363157983019 1371919941968-A1-B7-03-07-B1:CMCC-EASY120.196.100.82baidu.com综合搜索402400200<br>1363157984041 136605779915C-0E-8B-92-5C-20:CMCC-EASY120.197.40.4s19.cnzz.com站点统计2496960690200<br>1363157973098 150136858585C-0E-8B-C7-F7-90:CMCC120.197.40.4rank.ie.sogou.com搜索引擎282736593538200<br>1363157986029 15989002119E8-99-C4-4E-93-E0:CMCC-EASY120.196.100.99www.umeng.com站点统计331938180200<br>1363157992093 13560439658C4-17-FE-BA-DE-D9:CMCC120.196.100.99zhilian.com招聘门户1599184938200<br>1363157986041 134802531045C-0E-8B-C7-FC-80:CMCC-EASY120.197.40.4csdn.net技术门户33180180200<br>1363157984040 136028465655C-0E-8B-8B-B6-00:CMCC120.197.40.42052.flash2-http.qq.com综合门户151219382910200<br>1363157995093 1392231446600-FD-07-A2-EC-BA:CMCC120.196.100.82img.qfc.cn图片大全121230083720200<br>1363157982040 135024688235C-0A-5B-6A-0B-D4:CMCC-EASY120.196.100.99y0.ifengimg.com综合门户571027335110349200<br>1363157986072 1832017338284-25-DB-4F-10-1A:CMCC-EASY120.196.100.99input.shouji.sogou.com搜索引擎211895312412200<br>1363157990043 1392505741300-1F-64-E1-E6-9A:CMCC120.196.100.55t3.baidu.com搜索引擎69631105848243200<br>1363157988072 1376077871000-FD-07-A4-7B-08:CMCC120.196.100.82http://youku.com/视频网站22120120200<br>1363157985079 1382307000120-7C-8F-70-68-1F:CMCC120.196.100.99img.qfc.cn图片浏览63360180200<br>1363157985069 1360021750200-1F-64-E2-E8-B1:CMCC120.196.100.55www.baidu.com综合门户181381080186852200<br></code></pre></td></tr></table></figure><p>各字段含义如下</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.14.jpg"></p><ul><li><p>将文件上传到服务器</p></li><li><p>将文件上传上传到 HDFS</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdfs dfs -mkdir /input/flowcount<br>hdfs dfs -put data_flow.dat /input/flowcount<br></code></pre></td></tr></table></figure><h3 id="需求一：统计求和"><a href="#需求一：统计求和" class="headerlink" title="需求一：统计求和"></a>需求一：统计求和</h3><p>统计每个手机号的上行流量总和，下行流量总和，上行总流量之和，下行总流量之和<br>分析：以手机号码作为key值，上行流量，下行流量，上行总流量，下行总流量四个字段作为value值，然后以这个key，和value作为map阶段的输出，reduce阶段的输入</p><h4 id="步骤分析-4"><a href="#步骤分析-4" class="headerlink" title="步骤分析"></a>步骤分析</h4><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.15.png"></p><h4 id="第一步：自定义Bean实现Writable接口"><a href="#第一步：自定义Bean实现Writable接口" class="headerlink" title="第一步：自定义Bean实现Writable接口"></a>第一步：自定义Bean实现Writable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Writable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer upFlow;<br>    <span class="hljs-keyword">private</span> Integer downFlow;<br>    <span class="hljs-keyword">private</span> Integer upCountFlow;<br>    <span class="hljs-keyword">private</span> Integer downCountFlow;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getUpFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> upFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpFlow</span><span class="hljs-params">(Integer upFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.upFlow = upFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getDownFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> downFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDownFlow</span><span class="hljs-params">(Integer downFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.downFlow = downFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getUpCountFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> upCountFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpCountFlow</span><span class="hljs-params">(Integer upCountFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.upCountFlow = upCountFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getDownCountFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> downCountFlow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDownCountFlow</span><span class="hljs-params">(Integer downCountFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.downCountFlow = downCountFlow;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> upFlow +<br>                <span class="hljs-string">&quot;\t&quot;</span> + downFlow +<br>                <span class="hljs-string">&quot;\t&quot;</span> + upCountFlow +<br>                <span class="hljs-string">&quot;\t&quot;</span> + downCountFlow;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(DataOutput dataOutput)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        dataOutput.writeInt(upFlow);<br>        dataOutput.writeInt(downFlow);<br>        dataOutput.writeInt(upCountFlow);<br>        dataOutput.writeInt(downCountFlow);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFields</span><span class="hljs-params">(DataInput dataInput)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.upFlow = dataInput.readInt();<br>        <span class="hljs-keyword">this</span>.downFlow = dataInput.readInt();<br>        <span class="hljs-keyword">this</span>.upCountFlow = dataInput.readInt();<br>        <span class="hljs-keyword">this</span>.downCountFlow = dataInput.readInt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第二步：Mapper类编写"><a href="#第二步：Mapper类编写" class="headerlink" title="第二步：Mapper类编写"></a>第二步：Mapper类编写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowCountMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">LongWritable</span>,<span class="hljs-title">Text</span>, <span class="hljs-title">Text</span>, <span class="hljs-title">FlowBean</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//1.对每行数据进行字符串拆分</span><br>        String[] split = value.toString().split(<span class="hljs-string">&quot;\t&quot;</span>);<br>        <span class="hljs-comment">//2.获取手机号</span><br>        String phoneNum = split[<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//3.获取四个流量字段</span><br>        FlowBean flowBean = <span class="hljs-keyword">new</span> FlowBean();<br>        flowBean.setUpFlow(Integer.parseInt(split[<span class="hljs-number">6</span>]));<br>        flowBean.setDownFlow(Integer.parseInt(split[<span class="hljs-number">7</span>]));<br>        flowBean.setUpCountFlow(Integer.parseInt(split[<span class="hljs-number">8</span>]));<br>        flowBean.setDownCountFlow(Integer.parseInt(split[<span class="hljs-number">9</span>]));<br>        <span class="hljs-comment">//4.将k2,v2写入上下文</span><br>        context.write(<span class="hljs-keyword">new</span> Text(phoneNum),flowBean);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第三步：Reducer类编写"><a href="#第三步：Reducer类编写" class="headerlink" title="第三步：Reducer类编写"></a>第三步：Reducer类编写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowCountReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">Text</span>, <span class="hljs-title">FlowBean</span>,<span class="hljs-title">Text</span>, <span class="hljs-title">FlowBean</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(Text key, Iterable&lt;FlowBean&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//封装新的flowBean</span><br>        FlowBean flowBean = <span class="hljs-keyword">new</span> FlowBean();<br>        Integer upFlow = <span class="hljs-number">0</span> ;<br>        Integer downFlow = <span class="hljs-number">0</span> ;<br>        Integer upCountFlow = <span class="hljs-number">0</span> ;<br>        Integer downCountFlow = <span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">for</span> (FlowBean value : values) &#123;<br>            upFlow+=value.getUpFlow();<br>            downFlow+=value.getDownFlow();<br>            upCountFlow+=value.getUpCountFlow();<br>            downCountFlow+=value.getDownCountFlow();<br>        &#125;<br>        flowBean.setUpFlow(upFlow);<br>        flowBean.setDownFlow(downFlow);<br>        flowBean.setUpCountFlow(upCountFlow);<br>        flowBean.setDownCountFlow(downCountFlow);<br>        <span class="hljs-comment">//将k3,v3写入上下文</span><br>        context.write(key,flowBean);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第四步：定义主类job"><a href="#第四步：定义主类job" class="headerlink" title="第四步：定义主类job"></a>第四步：定义主类job</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JobMain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Configured</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tool</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(String[] strings)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建一个任务对象</span><br>        Job job = Job.getInstance(<span class="hljs-keyword">super</span>.getConf(), <span class="hljs-string">&quot;流量统计&quot;</span>);<br>        <span class="hljs-comment">//打包到集群上面运行时候，必须要添加以下配置，指定程序的main函数</span><br>        job.setJarByClass(JobMain.class);<br><br>        <span class="hljs-comment">//第一步：设置读取文件的类，将文件解析成key，value对</span><br>        job.setInputFormatClass(TextInputFormat.class);<br>        TextInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/input/flowcount&quot;</span>));<br>        <span class="hljs-comment">//第二步：设置mapper类</span><br>        job.setMapperClass(FlowCountMapper.class);<br>            <span class="hljs-comment">//设置map阶段完成之后的输出类型</span><br>        job.setMapOutputKeyClass(Text.class);<br>        job.setMapOutputValueClass(FlowBean.class);<br>        <span class="hljs-comment">//第三步，第四步，第五步，第六步采用默认方式（分区、排序、规约、分组）</span><br>        <span class="hljs-comment">//第七步：设置reduce类</span><br>        job.setReducerClass(FlowCountReducer.class);<br>            <span class="hljs-comment">//设置reduce阶段完成之后的输出类型</span><br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputValueClass(FlowBean.class);<br>        <span class="hljs-comment">//第八步：设置输出类以及输出路径</span><br>        job.setOutputFormatClass(TextOutputFormat.class);<br>        TextOutputFormat.setOutputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/output/flowcount_out&quot;</span>));<br>        <span class="hljs-comment">//任务是否执行成功</span><br>        <span class="hljs-keyword">boolean</span> b = job.waitForCompletion(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> b?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>        <span class="hljs-comment">//启动一个任务</span><br>        <span class="hljs-keyword">int</span> run = ToolRunner.run(configuration, <span class="hljs-keyword">new</span> JobMain(), args);<br>        System.exit(run);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第五步：打成jar包上传至服务器，并在服务器运行-2"><a href="#第五步：打成jar包上传至服务器，并在服务器运行-2" class="headerlink" title="第五步：打成jar包上传至服务器，并在服务器运行"></a>第五步：打成jar包上传至服务器，并在服务器运行</h4><p><code>hadoop jar /export/softwares/mapReduce-1.0-SNAPSHOT.jar top.igotcha.mapreduce.flowcount.JobMain</code></p><p>生成的结果文件如下</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.16.png"></p><hr><h3 id="需求二：上行流量倒序排序"><a href="#需求二：上行流量倒序排序" class="headerlink" title="需求二：上行流量倒序排序"></a>需求二：上行流量倒序排序</h3><p>分析，以需求一的输出数据作为排序的输入数据，自定义FlowBean，以FlowBean为map输出的key，以手机号作为Map输出的value，因为MapReduce程序会对Map阶段输出的key进行排序</p><h4 id="第一步：自定义Bean实现WritableComparable接口"><a href="#第一步：自定义Bean实现WritableComparable接口" class="headerlink" title="第一步：自定义Bean实现WritableComparable接口"></a>第一步：自定义Bean实现WritableComparable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WritableComparable</span>&lt;<span class="hljs-title">FlowBean</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer upFlow;<br>    <span class="hljs-keyword">private</span> Integer downFlow;<br>    <span class="hljs-keyword">private</span> Integer upCountFlow;<br>    <span class="hljs-keyword">private</span> Integer downCountFlow;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getUpFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> upFlow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpFlow</span><span class="hljs-params">(Integer upFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.upFlow = upFlow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getDownFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> downFlow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDownFlow</span><span class="hljs-params">(Integer downFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.downFlow = downFlow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getUpCountFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> upCountFlow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpCountFlow</span><span class="hljs-params">(Integer upCountFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.upCountFlow = upCountFlow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getDownCountFlow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> downCountFlow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDownCountFlow</span><span class="hljs-params">(Integer downCountFlow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.downCountFlow = downCountFlow;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> upFlow +<br>                <span class="hljs-string">&quot;\t&quot;</span> + downFlow +<br>                <span class="hljs-string">&quot;\t&quot;</span> + upCountFlow +<br>                <span class="hljs-string">&quot;\t&quot;</span> + downCountFlow;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(DataOutput dataOutput)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        dataOutput.writeInt(upFlow);<br>        dataOutput.writeInt(downFlow);<br>        dataOutput.writeInt(upCountFlow);<br>        dataOutput.writeInt(downCountFlow);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFields</span><span class="hljs-params">(DataInput dataInput)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.upFlow = dataInput.readInt();<br>        <span class="hljs-keyword">this</span>.downFlow = dataInput.readInt();<br>        <span class="hljs-keyword">this</span>.upCountFlow = dataInput.readInt();<br>        <span class="hljs-keyword">this</span>.downCountFlow = dataInput.readInt();<br>    &#125;<br>    <span class="hljs-comment">//按照上行数据包倒序排序</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(FlowBean others)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getUpFlow().compareTo(others.getUpFlow())*-<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第二步：Mapper编写-1"><a href="#第二步：Mapper编写-1" class="headerlink" title="第二步：Mapper编写"></a>第二步：Mapper编写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowSortMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">LongWritable</span>,<span class="hljs-title">Text</span>, <span class="hljs-title">FlowBean</span>,<span class="hljs-title">Text</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//1.对每行数据进行字符串拆分</span><br>        String[] split = value.toString().split(<span class="hljs-string">&quot;\t&quot;</span>);<br>        <span class="hljs-comment">//2.获取手机号</span><br>        String phoneNum = split[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//3.获取四个流量字段</span><br>        FlowBean flowBean = <span class="hljs-keyword">new</span> FlowBean();<br>        flowBean.setUpFlow(Integer.parseInt(split[<span class="hljs-number">1</span>]));<br>        flowBean.setDownFlow(Integer.parseInt(split[<span class="hljs-number">2</span>]));<br>        flowBean.setUpCountFlow(Integer.parseInt(split[<span class="hljs-number">3</span>]));<br>        flowBean.setDownCountFlow(Integer.parseInt(split[<span class="hljs-number">4</span>]));<br>        <span class="hljs-comment">//4.将k2,v2写入上下文</span><br>        context.write(flowBean,<span class="hljs-keyword">new</span> Text(phoneNum));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第三步：FlowSortReducer编写"><a href="#第三步：FlowSortReducer编写" class="headerlink" title="第三步：FlowSortReducer编写"></a>第三步：FlowSortReducer编写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowSortReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">FlowBean</span>,<span class="hljs-title">Text</span>,<span class="hljs-title">Text</span>, <span class="hljs-title">FlowBean</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(FlowBean key, Iterable&lt;Text&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-keyword">for</span> (Text value : values) &#123;<br>            context.write(value,key);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第四步：定义主类job-1"><a href="#第四步：定义主类job-1" class="headerlink" title="第四步：定义主类job"></a>第四步：定义主类job</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JobMain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Configured</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tool</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(String[] strings)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建一个任务对象</span><br>        Job job = Job.getInstance(<span class="hljs-keyword">super</span>.getConf(), <span class="hljs-string">&quot;流量统计-按上行流量倒序&quot;</span>);<br>        <span class="hljs-comment">//打包到集群上面运行时候，必须要添加以下配置，指定程序的main函数</span><br>        job.setJarByClass(JobMain.class);<br><br>        <span class="hljs-comment">//第一步：设置读取文件的类，将文件解析成key，value对</span><br>        job.setInputFormatClass(TextInputFormat.class);<br>        TextInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/output/flowcount_out&quot;</span>));<br>        <span class="hljs-comment">//第二步：设置mapper类</span><br>        job.setMapperClass(FlowSortMapper.class);<br>            <span class="hljs-comment">//设置map阶段完成之后的输出类型</span><br>        job.setMapOutputKeyClass(FlowBean.class);<br>        job.setMapOutputValueClass(Text.class);<br>        <span class="hljs-comment">//第三步，第四步，第五步，第六步采用默认方式（分区、排序、规约、分组）</span><br>        <span class="hljs-comment">//第七步：设置reduce类</span><br>        job.setReducerClass(FlowSortReducer.class);<br>            <span class="hljs-comment">//设置reduce阶段完成之后的输出类型</span><br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputValueClass(FlowBean.class);<br>        <span class="hljs-comment">//第八步：设置输出类以及输出路径</span><br>        job.setOutputFormatClass(TextOutputFormat.class);<br>        TextOutputFormat.setOutputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/output/flowsort_out&quot;</span>));<br>        <span class="hljs-comment">//任务是否执行成功</span><br>        <span class="hljs-keyword">boolean</span> b = job.waitForCompletion(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> b?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>        <span class="hljs-comment">//启动一个任务</span><br>        <span class="hljs-keyword">int</span> run = ToolRunner.run(configuration, <span class="hljs-keyword">new</span> JobMain(), args);<br>        System.exit(run);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第五步：打成jar包上传至服务器，并在服务器运行-3"><a href="#第五步：打成jar包上传至服务器，并在服务器运行-3" class="headerlink" title="第五步：打成jar包上传至服务器，并在服务器运行"></a>第五步：打成jar包上传至服务器，并在服务器运行</h4><p><code>hadoop jar /export/softwares/mapReduce-1.0-SNAPSHOT.jar top.igotcha.mapreduce.flowsort.JobMain</code></p><p>生成的已排序结果文件如下</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.17.png"></p><hr><h3 id="需求三：手机号码分区"><a href="#需求三：手机号码分区" class="headerlink" title="需求三：手机号码分区"></a>需求三：手机号码分区</h3><p>分析，在需求二的基础上，继续完善，将不同的手机号分到不同的数据文件的当中去，需要自定义分区来实现，将以下数字开头的手机号进行分开</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">135 开头数据到一个分区文件<br>136 开头数据到一个分区文件<br>137 开头数据到一个分区文件<br>其他分区<br></code></pre></td></tr></table></figure><h4 id="第一步：自定义Partitioner"><a href="#第一步：自定义Partitioner" class="headerlink" title="第一步：自定义Partitioner"></a>第一步：自定义Partitioner</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowPartition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Partitioner</span>&lt;<span class="hljs-title">FlowBean</span>, <span class="hljs-title">Text</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPartition</span><span class="hljs-params">(FlowBean flowBean, Text text, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        String phoneNum = text.toString();<br>        String phoneStart = phoneNum.substring(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">switch</span> (phoneStart)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;135&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;136&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;137&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第二步：定义主类job"><a href="#第二步：定义主类job" class="headerlink" title="第二步：定义主类job"></a>第二步：定义主类job</h4><p>主要变化在于多了<strong>第三步，设置分区类</strong>，在<strong>第七步：设置reduce类</strong>中<strong>设置reduce个数</strong>，其他不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JobMain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Configured</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tool</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(String[] strings)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建一个任务对象</span><br>        Job job = Job.getInstance(<span class="hljs-keyword">super</span>.getConf(), <span class="hljs-string">&quot;流量统计-按上行流量倒序&quot;</span>);<br>        <span class="hljs-comment">//打包到集群上面运行时候，必须要添加以下配置，指定程序的main函数</span><br>        job.setJarByClass(JobMain.class);<br><br>        <span class="hljs-comment">//第一步：设置读取文件的类，将文件解析成key，value对</span><br>        job.setInputFormatClass(TextInputFormat.class);<br>        TextInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/output/flowcount_out&quot;</span>));<br>        <span class="hljs-comment">//第二步：设置mapper类</span><br>        job.setMapperClass(FlowSortMapper.class);<br>            <span class="hljs-comment">//设置map阶段完成之后的输出类型</span><br>        job.setMapOutputKeyClass(FlowBean.class);<br>        job.setMapOutputValueClass(Text.class);<br>        <span class="hljs-comment">//第三步，第四步，第五步，第六步采用默认方式（分区、排序、规约、分组）</span><br>        <span class="hljs-comment">//第三步，设置分区类</span><br>        job.setPartitionerClass(FlowPartition.class);<br>        <span class="hljs-comment">//第七步：设置reduce类</span><br>        job.setReducerClass(FlowSortReducer.class);<br>            <span class="hljs-comment">//设置reduce阶段完成之后的输出类型</span><br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputValueClass(FlowBean.class);<br>        <span class="hljs-comment">//设置reduce个数</span><br>        job.setNumReduceTasks(<span class="hljs-number">4</span>);<br>        <span class="hljs-comment">//第八步：设置输出类以及输出路径</span><br>        job.setOutputFormatClass(TextOutputFormat.class);<br>        TextOutputFormat.setOutputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/output/flowpartition_out&quot;</span>));<br>        <span class="hljs-comment">//任务是否执行成功</span><br>        <span class="hljs-keyword">boolean</span> b = job.waitForCompletion(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> b?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>        <span class="hljs-comment">//启动一个任务</span><br>        <span class="hljs-keyword">int</span> run = ToolRunner.run(configuration, <span class="hljs-keyword">new</span> JobMain(), args);<br>        System.exit(run);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="第三步：打成jar包上传至服务器，并在服务器运行"><a href="#第三步：打成jar包上传至服务器，并在服务器运行" class="headerlink" title="第三步：打成jar包上传至服务器，并在服务器运行"></a>第三步：打成jar包上传至服务器，并在服务器运行</h4><p><strong>保持Bean类、Mapper类和Reducer类不变，上传至服务器并运行</strong>，产生了四个结果文件</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.18.png"></p><hr><h2 id="MapReduce运行机制"><a href="#MapReduce运行机制" class="headerlink" title="MapReduce运行机制"></a>MapReduce运行机制</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.19.png"></p><h3 id="Map阶段-1"><a href="#Map阶段-1" class="headerlink" title="Map阶段"></a>Map阶段</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.20.png"></p><p>整个Map阶段流程大体如上图所示。<br>简单概述：inputFile通过split被逻辑切分为多个split文件，通过Record<strong>按行读取</strong>内容给map（用户自己实现的）进行处理，数据被map处理结束之后交给OutputCollector收集器，对其结果key进行分区（默认使用hash分区），然后写入buffer，每个map task都有一个内存缓冲区，存储着map的输出结果，当缓冲区快满的时候需要将缓冲区的数据以一个临时文件的方式存放到磁盘，当整个map task结束后再对磁盘中这个map task产生的所有临时文件做合并，生成最终的正式输出文件，然后等待reduce task来拉数据</p><h4 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h4><ul><li>读取数据组件 InputFormat (默认 TextInputFormat) 会通过 getSplits 方法对输入目录中文件进行<strong>逻辑切片规划得到 splits</strong>，有多少个 split 就对应启动多少个<br>MapTask。split 与 block 的对应关系默认是一对一</li><li>将输入文件切分为 splits 之后，由 RecordReader 对象 (默认是LineRecordReader)进行读取，以 \n 作为分隔符，<strong>读取一行数据</strong>，返回 &lt;key，value&gt; 。Key 表示每行首字符偏移值，Value 表示这一行文本内容</li><li>读取split返回 &lt;key,value&gt;，进入用户自己继承的 Mapper 类中，<strong>执行用户重写的 map 函数</strong>，RecordReader 读取一行这里调用一次</li><li>Mapper 逻辑结束之后, 将 Mapper 的每条结果通过 context.write <strong>进行collect数据收集</strong>。在 collect 中, 会先对其进行分区处理，默认使用 HashPartitioner<ul><li>MapReduce 提供 Partitioner 接口, 它的作用就是根据 Key 或 Value 及Reducer 的数量来决定当前的这对输出数据最终应该交由哪个 Reduce task<br>处理，默认对 Key Hash 后再以 Reducer 数量取模。默认的取模方式只是为了平均 Reducer 的处理能力，如果用户自己对 Partitioner 有需求，可以自定义后，再到 Job 上进行设置</li></ul></li><li>接下来，会将数据写入内存，内存中这片区域叫做<strong>环形缓冲区</strong>，缓冲区的作用是批量收集Mapper 结果，减少磁盘 IO 的影响。Key/Value 对以及 Partition 的结果都会被写入缓冲区。当然，写入之前，Key 与 Value 值都会被序列化成字节数组<ul><li>环形缓冲区其实是一个数组，数组中存放着 Key，Value 的序列化数据和 Key。Value 的元数据信息，包括 Partition，Key 的起始位置，Value 的起始位置以及Value 的长度。环形结构是一个抽象概念</li><li>缓冲区是有大小限制，默认是 100MB。当 Mapper 的输出结果很多时，就可能会撑爆内存，所以需要在一定条件下将缓冲区中的数据临时写入磁盘，然后重新利用这块缓冲区。这个从内存往磁盘写数据的过程被称为 Spill，中文可译为<strong>溢写</strong>。这个溢写是由单独线程来完成，不影响往缓冲区写 Mapper 结果的线程。<br>溢写线程启动时不应该阻止 Mapper 的结果输出，所以整个缓冲区有个溢写的比例 spill.percent。这个比例默认是 0.8，也就是当缓冲区的数据已经达到<br>阈值 buffer size * spill percent = 100MB * 0.8 = 80MB ，溢写线程启动，锁定这 80MB 的内存，执行溢写过程。Mapper 的输出结果还可以往剩下的20MB 内存中写，互不影响</li></ul></li><li>当溢写线程启动后，需要对这 80MB 空间内的 Key 做排序 (Sort)。排序是 MapReduce模型默认的行为，这里的排序也是<strong>对序列化的字节做的排序</strong><ul><li>如果 Job 设置过 Combiner，那么现在就是使用 Combiner 的时候了。将有相同 Key 的 Key/Value 对的 Value 加起来，减少溢写到磁盘的数据量。Combiner 会优化 MapReduce 的中间结果，所以它在整个模型中会多次使用</li><li>那哪些场景才能使用 Combiner 呢？从这里分析，Combiner 的输出是Reducer 的输入，<strong>Combiner 绝不能改变最终的计算结果</strong>。Combiner 只应该用<br>于那种 Reduce 的输入 Key/Value 与输出 Key/Value 类型完全一致，且不影响最终结果的场景。比如累加，最大值等。Combiner 的使用一定得慎重，如果用好，它对 Job 执行效率有帮助，反之会影响 Reducer 的最终结果</li></ul></li><li><strong>合并溢写文件</strong>，每次溢写会在磁盘上生成一个临时文件 (写之前判断是否有 Combiner)，如果 Mapper 的输出结果真的很大，有多次这样的溢写发生，磁盘上相应的就会有多个临时文件存在。当整个数据处理结束之后开始对磁盘中的临时文件进行 Merge 合并，因为<strong>最终的文件只有一个</strong>，写入磁盘，并且为这个文件提供了一个索引文件，以记录每个reduce对应数据的偏移量</li></ul><h4 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h4><table><thead><tr><th>配置</th><th>默认值</th><th>解释</th></tr></thead><tbody><tr><td><code>mapreduce.task.io.sort.mb</code></td><td>100</td><td>环型缓冲区的内存值大小</td></tr><tr><td><code>mapreduce.map.sort.spill.percent</code></td><td>0.8</td><td>溢写的比例</td></tr><tr><td><code>mapreduce.cluster.local.dir</code></td><td><code>$&#123;hadoop.tmp.dir&#125;/mapred/local</code></td><td>溢写数据目录</td></tr><tr><td><code>mapreduce.task.io.sort.factor</code></td><td>10</td><td>一次合并多少个溢写文件</td></tr></tbody></table><h3 id="Reduce阶段-1"><a href="#Reduce阶段-1" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.21.png"></p><p>整个Reduce阶段流程大体如上图所示。<br>简单概述：Reduce 大致分为 copy、sort、reduce 三个阶段，重点在前两个阶段。</p><p>copy 阶段包含一个 eventFetcher 来获取已完成的 map 列表，由 Fetcher 线程去 copy 数据，在此过程中会启动两个 merge 线程，分别为 inMemoryMerger 和 onDiskMerger，分别将内存中的数据 merge 到磁盘和将磁盘中的数据进行 merge。待数据 copy 完成之后，copy 阶段就完成了，开始进行 sort 阶段，sort 阶段主要是执行 finalMerge 操作，纯粹的 sort 阶段，完成之后就是 reduce 阶段，调用用户定义的 reduce 函数进行处理</p><h4 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h4><ul><li><strong>Copy阶段，简单地拉取数据</strong>。Reduce进程启动一些数据copy线程(Fetcher)，通过HTTP方式请求maptask获取属于自己的文件。</li><li><strong>Merge阶段</strong>。这里的merge如map端的merge动作，只是数组中存放的是不同map端copy来的数值。Copy过来的数据会先放入内存缓冲区中，这里的缓冲区大小要比map端的更为灵活。merge有三种形式：内存到内存；内存到磁盘；磁盘到磁盘。默认情况下第一种形式不启用。当内存中的数据量到达一定阈值，就启动内存到磁盘的merge。与map 端类似，这也是溢写的过程，这个过程中如果你设置有Combiner，也是会启用的，然后在磁盘中生成了众多的溢写文件。第二种merge方式一直在运行，直到没有map端的数据时才结束，然后启动第三种磁盘到磁盘的merge方式生成最终的文件。</li><li><strong>合并排序</strong>。把分散的数据合并成一个大的数据后，还会再对合并后的数据排序。</li><li>对排序后的键值对调用<strong>reduce方法</strong>，键相等的键值对调用一次reduce方法，每次调用会产生零个或者多个键值对，最后把这些输出的键值对写入到HDFS文件中。</li></ul><h3 id="Shuffle阶段-1"><a href="#Shuffle阶段-1" class="headerlink" title="Shuffle阶段"></a>Shuffle阶段</h3><h4 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h4><p>map 阶段处理的数据如何传递给 reduc 阶段，是 MapReduce 框架中最关键的一个流程，这个流程就叫 <strong>shuffle</strong><br>shuffle: 洗牌、发牌 ——（核心机制：数据<strong>分区，排序，分组，规约</strong>，合并等过程）</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.22.png"></p><h4 id="详细步骤-2"><a href="#详细步骤-2" class="headerlink" title="详细步骤"></a>详细步骤</h4><p>shuffle 是 Mapreduce 的核心，它分布在 Mapreduce 的 map 阶段和 reduce 阶段。一般把从 Map 产生输出开始到 Reduce 取得数据作为输入之前的过程称作 shuffle。</p><ul><li><strong>Collect阶段</strong>：将 MapTask 的结果输出到默认大小为 100M 的环形缓冲区，保存的是key/value，Partition 分区信息等。</li><li><strong>Spill阶段</strong>：当内存中的数据量达到一定的阀值的时候，就会将数据写入本地磁盘，再将数据写入磁盘之前需要对数据进行一次排序的操作，如果配置了 combiner，还会将有相同分区号和 key 的数据进行排序。</li><li><strong>Merge阶段</strong>：把所有溢出的临时文件进行一次合并操作，以确保一个 MapTask 最终只产生一个中间数据文件。</li><li><strong>Copy阶段</strong>：ReduceTask 启动 Fetcher 线程到已经完成 MapTask 的节点上复制一份属于自己的数据，这些数据默认会保存在内存的缓冲区中，当内存的缓冲区达到一定的阀值的时候，就会将数据写到磁盘之上。</li><li><strong>Merge阶段</strong>：在 ReduceTask 远程复制数据的同时，会在后台开启两个线程对内存到本地的数据文件进行合并操作。</li><li><strong>Sort阶段</strong>：在对数据进行合并的同时，会进行排序操作，由于 MapTask 阶段已经对数据进行了局部的排序，ReduceTask 只需保证 Copy 的数据的最终整体有效性即可。</li></ul><blockquote><p>Shuffle 中的缓冲区大小会影响到 mapreduce 程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快</p></blockquote><h2 id="Join案例"><a href="#Join案例" class="headerlink" title="Join案例"></a>Join案例</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>假如数据量巨大，两表的数据是以文件的形式存储在 HDFS 中, 需要用 MapReduce 程序来实现以下 SQL 查询运算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> a.id,a.date,b.name,b.category_id,b.price <span class="hljs-keyword">from</span> t_order a <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> t_product b <span class="hljs-keyword">on</span> a.pid <span class="hljs-operator">=</span> b.id<br></code></pre></td></tr></table></figure><ul><li>订单数据表</li></ul><table><thead><tr><th>id</th><th>date</th><th>pid</th><th>amount</th></tr></thead><tbody><tr><td>1001</td><td>20150710</td><td>P0001</td><td>2</td></tr><tr><td>1002</td><td>20150710</td><td>P0001</td><td>3</td></tr><tr><td>1003</td><td>20150710</td><td>P0002</td><td>3</td></tr></tbody></table><ul><li>商品信息表</li></ul><table><thead><tr><th>id</th><th>pname</th><th>category_id</th><th>price</th></tr></thead><tbody><tr><td>P0001</td><td>小米5</td><td>1000</td><td>2000</td></tr><tr><td>P0002</td><td>锤子T1</td><td>1000</td><td>3000</td></tr></tbody></table><ul><li>实现机制<br>通过将关联的条件作为map输出的key，将两表满足join条件的数据并携带数据所来源的文件信息，发往同一个reduce task，在reduce中进行数据的串联</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.23.png"></p><h3 id="第一步：数据准备-2"><a href="#第一步：数据准备-2" class="headerlink" title="第一步：数据准备"></a>第一步：数据准备</h3><ul><li><p>将文件上传到服务器</p></li><li><p>将文件上传上传到 HDFS</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdfs dfs -mkdir /input/reducejoin<br>hdfs dfs -put orders.txt /input/reducejoin<br>hdfs dfs -put product.txt /input/reducejoin<br></code></pre></td></tr></table></figure><h3 id="第二步：mapper编写"><a href="#第二步：mapper编写" class="headerlink" title="第二步：mapper编写"></a>第二步：mapper编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">LongWritable</span>, <span class="hljs-title">Text</span>,<span class="hljs-title">Text</span>,<span class="hljs-title">Text</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//1.判断数据来自哪个文件</span><br>        FileSplit inputSplit = (FileSplit) context.getInputSplit();<br>        String fileName = inputSplit.getPath().getName();<br>        <span class="hljs-keyword">if</span> (fileName.equals(<span class="hljs-string">&quot;orders.txt&quot;</span>))&#123;<br>            <span class="hljs-comment">//获取pid</span><br>            String[] split = value.toString().split(<span class="hljs-string">&quot;,&quot;</span>);<br>            context.write(<span class="hljs-keyword">new</span> Text(split[<span class="hljs-number">2</span>]),value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//获取pid</span><br>            String[] split = value.toString().split(<span class="hljs-string">&quot;,&quot;</span>);<br>            context.write(<span class="hljs-keyword">new</span> Text(split[<span class="hljs-number">0</span>]),value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三步：reducer编写"><a href="#第三步：reducer编写" class="headerlink" title="第三步：reducer编写"></a>第三步：reducer编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">Text</span>,<span class="hljs-title">Text</span>,<span class="hljs-title">Text</span>,<span class="hljs-title">Text</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(Text key, Iterable&lt;Text&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        String first = <span class="hljs-string">&quot;&quot;</span>;<br>        String second = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (Text value : values) &#123;<br>            <span class="hljs-keyword">if</span> (value.toString().startsWith(<span class="hljs-string">&quot;p&quot;</span>))&#123;<br>                first = value.toString();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                second = value.toString();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (first.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            context.write(key,<span class="hljs-keyword">new</span> Text(<span class="hljs-string">&quot;NULL&quot;</span>+<span class="hljs-string">&quot;\t&quot;</span>+second));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            context.write(key,<span class="hljs-keyword">new</span> Text(first+<span class="hljs-string">&quot;\t&quot;</span>+second));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四步：定义主类-描述-Job-并提交-Job-1"><a href="#第四步：定义主类-描述-Job-并提交-Job-1" class="headerlink" title="第四步：定义主类, 描述 Job 并提交 Job"></a>第四步：定义主类, 描述 Job 并提交 Job</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JobMain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Configured</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tool</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(String[] strings)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建一个任务对象</span><br>        Job job = Job.getInstance(<span class="hljs-keyword">super</span>.getConf(), <span class="hljs-string">&quot;ReduceJoin&quot;</span>);<br>        <span class="hljs-comment">//打包到集群上面运行时候，必须要添加以下配置，指定程序的main函数</span><br>        job.setJarByClass(JobMain.class);<br><br>        <span class="hljs-comment">//第一步：设置读取文件的类，将文件解析成key，value对</span><br>        job.setInputFormatClass(TextInputFormat.class);<br>        TextInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/input/reduceJoin&quot;</span>));<br>        <span class="hljs-comment">//第二步：设置mapper类</span><br>        job.setMapperClass(JoinMapper.class);<br>        <span class="hljs-comment">//设置map阶段完成之后的输出类型</span><br>        job.setMapOutputKeyClass(Text.class);<br>        job.setMapOutputValueClass(Text.class);<br>        <span class="hljs-comment">//第三步，第四步，第五步，第六步采用默认方式（分区、排序、规约、分组）</span><br>        <span class="hljs-comment">//第七步：设置reduce类</span><br>        job.setReducerClass(JoinReducer.class);<br>        <span class="hljs-comment">//设置reduce阶段完成之后的输出类型</span><br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputValueClass(Text.class);<br>        <span class="hljs-comment">//第八步：设置输出类以及输出路径</span><br>        job.setOutputFormatClass(TextOutputFormat.class);<br>        TextOutputFormat.setOutputPath(job,<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;hdfs://192.168.127.110:8020/output/reduceJoin_out&quot;</span>));<br>        <span class="hljs-comment">//任务是否执行成功</span><br>        <span class="hljs-keyword">boolean</span> b = job.waitForCompletion(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> b?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Configuration configuration = <span class="hljs-keyword">new</span> Configuration();<br>        <span class="hljs-comment">//启动一个任务</span><br>        <span class="hljs-keyword">int</span> run = ToolRunner.run(configuration, <span class="hljs-keyword">new</span> JobMain(), args);<br>        System.exit(run);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第五步：打成jar包上传至服务器，并在服务器运行-4"><a href="#第五步：打成jar包上传至服务器，并在服务器运行-4" class="headerlink" title="第五步：打成jar包上传至服务器，并在服务器运行"></a>第五步：打成jar包上传至服务器，并在服务器运行</h3><p><code> hadoop jar /export/softwares/mapReduce-1.0-SNAPSHOT.jar top.igotcha.mapreduce.join.JobMain</code></p><p>生成的结果文件如下</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/5.24.png"></p><hr><h1 id="六、Hive"><a href="#六、Hive" class="headerlink" title="六、Hive"></a>六、Hive</h1><h2 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><p>数据仓库英文名称为<strong>Data Warehouse</strong>，可简写为DW或DWH。数据仓库的目的是<strong>构建面向分析的集成化数据环境</strong>，为企业提供决策支持（Decision Support）。它出于分析性报告和决策支持目的而创建。<br>数据仓库本身并不“生产”任何数据，同时自身也不需要“消费”任何的数据，数据来源于外部，并且开放给外部应用，这也是为什么叫“仓库”，而不叫“工厂”的原因</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>数据仓库是<strong>面向主题</strong>的（Subject-Oriented ）、<strong>集成</strong>的（Integrated）、<strong>非易失</strong>的（Non-Volatile）和<strong>时变</strong>的（Time-Variant ）数据集合，用以支持管理决策。</p><h4 id="面向主题"><a href="#面向主题" class="headerlink" title="面向主题"></a>面向主题</h4><p>传统数据库中，最大的特点是面向应用进行数据的组织，各个业务系统可能是相互分离的。而数据仓库则是面向主题的。<strong>主题是一个抽象的概念，是较高层次上企业信息系统中的数据综合、归类并进行分析利用的抽象</strong>。在逻辑意义上，它是对应企业中某一宏观分析领域所涉及的分析对象。<br>操作型处理（传统数据）对数据的划分并不适用于决策分析。而基于主题组织的数据则不同，它们被划分为各自独立的领域，每个领域有各自的逻辑内涵但互不交叉，在抽象层次上对数据进行完整、一致和准确的描述。一些主题相关的数据通常分布在多个操作型系统中。</p><h4 id="集成性"><a href="#集成性" class="headerlink" title="集成性"></a>集成性</h4><p>通过对分散、独立、异构的数据库数据进行抽取、清理、转换和汇总便得到了数据仓库的数据，这样保证了数据仓库内的数据关于整个企业的一致性。<br>数据仓库中的综合数据不能从原有的数据库系统直接得到。因此在数据进入数据仓库之前，必然要经过统一与综合，这一步是数据仓库建设中最关键、最复杂的一步，所要完成的工作有：</p><ul><li>要<strong>统一</strong>源数据中所有<strong>矛盾</strong>之处，如字段的同名异义、异名同义、单位不统一、字长不一致，等等。</li><li>进行<strong>数据综合和计算</strong>*。数据仓库中的数据综合工作可以在从原有数据库抽取数据时生成，但许多是在数据仓库内部生成的，即进入数据仓库以后进行综合生成的。</li></ul><h4 id="非易失性（不可更新性）"><a href="#非易失性（不可更新性）" class="headerlink" title="非易失性（不可更新性）"></a>非易失性（不可更新性）</h4><ul><li>操作型数据库主要服务于日常的业务操作，使得数据库需要不断地对数据实时更新，以便迅速获得当前最新数据，不至于影响正常的业务运作。在数据仓库中只要保存过去的业务数据，不需要每一笔业务都实时更新数据仓库，而是根据商业需要每隔一段时间把一批较新的数据导入数据仓库。</li><li>数据仓库的数据反映的是<strong>一段相当长的时间内历史数据的内容</strong>，是不同时点的数据库快照的集合，以及基于这些快照进行统计、综合和重组的导出数据。</li><li>数据非易失性主要是针对应用而言。数据仓库的用户对数据的操作大多是数据查询或比较复杂的挖掘，一旦数据进入数据仓库以后，一般情况下被较长时间保留。数据仓库中一般有大量的查询操作，但修改和删除操作很少。因此，数据经加工和集成进入数据仓库后是<strong>极少更新</strong>的，通常只需要定期的加载和更新。</li></ul><h4 id="时变性"><a href="#时变性" class="headerlink" title="时变性"></a>时变性</h4><p>数据仓库包含各种粒度的历史数据。数据仓库中的数据可能与某个特定日期、星期、月份、季度或者年份有关。数据仓库的目的是通过分析企业过去一段时间业务的经营状况，挖掘其中隐藏的模式。虽然数据仓库的用户不能修改数据，但并不是说数据仓库的数据是永远不变的。分析的结果只能反映过去的情况，当业务变化后，挖掘出的模式会失去时效性。因此数据仓库的数据需要更新，以适应决策的需要。从这个角度讲，数据仓库建设是一个项目，更是一个过程 。数据仓库的数据随时间的变化表现在以下几个方面。</p><ul><li>数据仓库的数据时限一般要远远长于操作型数据的数据时限。</li><li>操作型系统存储的是当前数据，而数据仓库中的数据是历史数据。</li><li>数据仓库中的数据是按照时间顺序追加的，它们都带有时间属性。</li></ul><h3 id="数据库与数据仓库的区别"><a href="#数据库与数据仓库的区别" class="headerlink" title="数据库与数据仓库的区别"></a>数据库与数据仓库的区别</h3><p>数据库与数据仓库的区别实际讲的是 OLTP 与 OLAP 的区别。<br><strong>操作型</strong>处理，叫<strong>联机事务处理 OLTP</strong>（On-Line Transaction Processing，），也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询、修改。用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理。<br><strong>分析型</strong>处理，叫<strong>联机分析处理 OLAP</strong>（On-Line Analytical Processing）一般针对某些主题的历史数据进行分析，支持管理决策。</p><p>数据仓库的出现，并不是要取代数据库。</p><ul><li>数据库是面向事务的设计，数据仓库是面向主题设计的。</li><li>数据库一般存储业务数据，数据仓库存储的一般是历史数据。</li><li>数据库设计是尽量避免冗余，一般针对某一业务应用进行设计，比如一张简单的User表，记录用户名、密码等简单数据即可，符合业务应用，但是不符合分析。数据仓库在设计是有意引入冗余，依照分析需求，分析维度、分析指标进行设计。</li><li>数据库是为捕获数据而设计，数据仓库是为分析数据而设计。</li></ul><p><strong>数据仓库，是在数据库已经大量存在的情况下，为了进一步挖掘数据资源、为了决策需要而产生的，它决不是所谓的“大型数据库”。</strong></p><h3 id="数据仓库的架构"><a href="#数据仓库的架构" class="headerlink" title="数据仓库的架构"></a>数据仓库的架构</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.1.png"></p><p>数据仓库的数据来源于不同的源数据，并提供多样的数据应用，数据自下而上流入数据仓库后向上层开放应用，而数据仓库只是中间集成化数据管理的一个平台。<br><strong>源数据层</strong>（ODS） ：此层数据无任何更改，直接沿用外围系统数据结构和数据，不对外开放；为临时存储层，是接口数据的临时存储区域，为后一步的数据处理做准备。<br><strong>数据仓库层</strong>（DW） ：也称为细节层，DW层的数据应该是一致的、准确的、干净的数据，即对源系统数据进行了清洗（去除了杂质）后的数据。<br><strong>数据应用层</strong>（DA或APP） ：前端应用直接读取的数据源；根据报表、专题分析需求而计算生成的数据。</p><h3 id="元数据管理"><a href="#元数据管理" class="headerlink" title="元数据管理"></a>元数据管理</h3><p><strong>元数据</strong>（Meta Date），主要记录数据仓库中<strong>模型的定义</strong>、<strong>各层级间的映射关系</strong>、监控数据仓库的<strong>数据状态</strong>及<strong>ETL的任务运行状态</strong>。一般会通过元数据资料库（Metadata Repository）来统一地存储和管理</p><p>元数据，其主要目的是<strong>使数据仓库的设计、部署、操作和管理能达成协同和一致</strong>。<br>元数据是数据仓库管理系统的重要组成部分，元数据管理是企业级数据仓库中的关键组件，贯穿数据仓库构建的整个过程，直接影响着数据仓库的构建、使用和维护。</p><p>元数据可分为<strong>技术元数据</strong>和<strong>业务元数据</strong>。</p><ul><li><p>技术元数据为开发和管理数据仓库的IT人员使用，它描述了<strong>与数据仓库开发、管理和维护相关的数据</strong>，包括数据源信息、数据转换描述、数据仓库模型、数据清洗与更新规则、数据映射和访问权限等。</p></li><li><p>业务元数据为管理层和业务分析人员服务，<strong>从业务角度描述数据</strong>，包括商务术语、数据仓库中有什么数据、数据的位置和数据的可用性等，帮助业务人员更好地理解数据仓库中哪些数据是可用的以及如何使用。<br>由上可见，元数据不仅定义了数据仓库中数据的模式、来源、抽取和转换规则等，而且是整个数据仓库系统运行的基础，元数据把数据仓库系统中各个松散的组件联系起来，组成了一个有机的整体。</p></li></ul><h2 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h2><p>Hive是基于Hadoop的一个数据仓库工具，可以<strong>将结构化的数据文件映射为一张数据库表</strong>，并提供类SQL查询功能。<br>其本质是<strong>将SQL转换为MapReduce的任务进行运算</strong>，底层由HDFS来提供数据的存储，hive可以理解为一个将SQL转换为MapReduce的任务的工具，甚至更进一步可以说hive就是一个MapReduce的客户端</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>可扩展</strong><br>Hive可以自由的扩展集群的规模，一般情况下不需要重启服务。</li><li><strong>延展性</strong><br>Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。</li><li><strong>容错</strong><br>良好的容错性，节点出现问题SQL仍可完成执行。</li></ul><h3 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h3><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.2.png"></p><ul><li>用户接口： 包括CLI、JDBC/ODBC、WebGUI。其中，CLI(command line interface)为shell命令行；JDBC/ODBC是Hive的JAVA实现，与传统数据库JDBC类似；WebGUI是通过浏览器访问Hive。</li><li>元数据存储： 通常是存储在关系数据库如mysql/derby中。Hive 将元数据存储在数据库中。Hive中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。</li><li>解释器、编译器、优化器、执行器: 完成HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在HDFS 中，并在随后有MapReduce 调用执行。</li></ul><h3 id="Hive与Hadoop的关系"><a href="#Hive与Hadoop的关系" class="headerlink" title="Hive与Hadoop的关系"></a>Hive与Hadoop的关系</h3><p>Hive利用HDFS存储数据，利用MapReduce查询分析数据</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.3.png"></p><h2 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h2><p>选用hive的版本是3.1.0这个release版本，可以兼容对应的hadoop3.x的版本<br>下载地址为：<br><a href="http://archive.apache.org/dist/hive/hive-3.1.0/apache-hive-3.1.0-bin.tar.gz">http://archive.apache.org/dist/hive/hive-3.1.0/apache-hive-3.1.0-bin.tar.gz</a></p><p>下载之后，将安装包上传到<strong>第一台机器</strong>（node01）的/export/softwares目录下面去</p><h3 id="第一步：上传并解压安装包"><a href="#第一步：上传并解压安装包" class="headerlink" title="第一步：上传并解压安装包"></a>第一步：上传并解压安装包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/softwares/<br>tar -zxvf apache-hive-3.1.0-bin.tar.gz -C ../servers/<br></code></pre></td></tr></table></figure><h3 id="第二步：centos6-9安装mysql"><a href="#第二步：centos6-9安装mysql" class="headerlink" title="第二步：centos6.9安装mysql"></a>第二步：centos6.9安装mysql</h3><ul><li><p>在线安装mysql相关的软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install mysql mysql-server mysql-devel<br></code></pre></td></tr></table></figure></li><li><p>启动mysql的服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/etc/init.d/mysqld start<br></code></pre></td></tr></table></figure></li><li><p>通过mysql安装自带脚本进行设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/bin/mysql_secure_installation<br></code></pre></td></tr></table></figure><ul><li>Set root password?     Y  </li><li>Remove anonymous users?     Y</li><li>Disallow root login remotely?     N</li><li>Remove test database and access to it?     N</li><li>Reload privilege tables now?     Y</li></ul></li><li><p>进入mysql的客户端然后进行授权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -r root -p 123456<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27; with grant option;<br>flush privileges;<br></code></pre></td></tr></table></figure></li></ul><h3 id="第三步：修改hive的配置文件"><a href="#第三步：修改hive的配置文件" class="headerlink" title="第三步：修改hive的配置文件"></a>第三步：修改hive的配置文件</h3><h4 id="修改hive-env-sh"><a href="#修改hive-env-sh" class="headerlink" title="修改hive-env.sh"></a>修改hive-env.sh</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers/apache-hive-3.1.0-bin/conf<br>cp hive-env.sh.template hive-env.sh<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">HADOOP_HOME=/<span class="hljs-built_in">export</span>/servers/hadoop-3.1.1<br><span class="hljs-built_in">export</span> HIVE_CONF_DIR=/<span class="hljs-built_in">export</span>/servers/apache-hive-3.1.0-bin/conf<br></code></pre></td></tr></table></figure><h4 id="修改hive-site-xml"><a href="#修改hive-site-xml" class="headerlink" title="修改hive-site.xml"></a>修改hive-site.xml</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers/apache-hive-3.1.0-bin/conf<br>vim hive-site.xml<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="hljs-meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>jdbc:mysql://node01:3306/hive?createDatabaseIfNotExist=true<span class="hljs-symbol">&amp;amp;</span>useSSL=false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.metastore.schema.verification<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>datanucleus.schema.autoCreateAll<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.server2.thrift.bind.host<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">&lt;property&gt;</span><br><span class="hljs-comment">&lt;name&gt;hive.metastore.uris&lt;/name&gt;</span><br><span class="hljs-comment">&lt;value&gt;thrift://node01:9083&lt;/value&gt;</span><br><span class="hljs-comment">&lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;</span><br><span class="hljs-comment">&lt;/property&gt;</span><br><span class="hljs-comment">&lt;property&gt;</span><br><span class="hljs-comment">&lt;name&gt;hive.metastore.local&lt;/name&gt;</span><br><span class="hljs-comment">&lt;value&gt;false&lt;/value&gt;</span><br><span class="hljs-comment">&lt;description&gt;this is local store&lt;/description&gt;</span><br><span class="hljs-comment">&lt;/property&gt;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="第四步：添加mysql的连接驱动包到hive的lib目录下"><a href="#第四步：添加mysql的连接驱动包到hive的lib目录下" class="headerlink" title="第四步：添加mysql的连接驱动包到hive的lib目录下"></a>第四步：添加mysql的连接驱动包到hive的lib目录下</h3><p>hive使用mysql作为元数据存储，必然需要连接mysql数据库，所以需要添加一个mysql的连接驱动包到hive的安装目录下，然后就可以准备启动hive了</p><p>将准备好的mysql-connector-java-5.1.38.jar 这个jar包直接上传到/export/servers/apache-hive-3.1.0-bin/lib 这个目录下即可</p><h3 id="第五步：配置hive的环境变量"><a href="#第五步：配置hive的环境变量" class="headerlink" title="第五步：配置hive的环境变量"></a>第五步：配置hive的环境变量</h3><p>node01服务器执行以下命令配置hive的环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/profile<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">export HIVE_HOME=/export/servers/apache-hive-3.1.0-bin<br>export PATH=:$HIVE_HOME/bin:$PATH<br></code></pre></td></tr></table></figure><h2 id="Hive的交互方式"><a href="#Hive的交互方式" class="headerlink" title="Hive的交互方式"></a>Hive的交互方式</h2><h3 id="第一种交互方式：bin-hive"><a href="#第一种交互方式：bin-hive" class="headerlink" title="第一种交互方式：bin/hive"></a>第一种交互方式：bin/hive</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers/apache-hive-3.1.0-bin/<br>bin/hive<br></code></pre></td></tr></table></figure><ul><li>创建一个数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> mytest;<br></code></pre></td></tr></table></figure><h3 id="第二种交互方式：HiveServer2"><a href="#第二种交互方式：HiveServer2" class="headerlink" title="第二种交互方式：HiveServer2"></a>第二种交互方式：HiveServer2</h3><p>hive官方推荐使用hiveserver2的这种交互方式，需要我们启动hiveserver2这个服务端，然后通过客户端去进行连接</p><ul><li>关闭hive的服务端，在hadoop的配置文件core-site.xml当中添加以下两行配置，然后重启hdfs以及yarn集群</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.proxyuser.hadoop.hosts<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.proxyuser.hadoop.groups<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>启动服务端（前台启动命令如下）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers/apache-hive-3.1.0-bin/<br>bin/hive --service hiveserver2<br></code></pre></td></tr></table></figure><ul><li>重新开一个窗口启动客户端进行连接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers/apache-hive-3.1.0-bin<br>bin/beeline<br>!connect jdbc:hive2://node01:10000<br></code></pre></td></tr></table></figure><h3 id="第三种交互方式：使用sql语句或者sql脚本进行交互"><a href="#第三种交互方式：使用sql语句或者sql脚本进行交互" class="headerlink" title="第三种交互方式：使用sql语句或者sql脚本进行交互"></a>第三种交互方式：使用sql语句或者sql脚本进行交互</h3><p>不进入hive的客户端直接执行hive的hql语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers/apache-hive-3.1.0-bin<br>bin/hive -e &quot;create database if not exists mytest;&quot;<br></code></pre></td></tr></table></figure><p>或者将hql语句写成一个sql脚本然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers<br>vim hive.sql<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> mytest;<br>use mytest;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stu(id <span class="hljs-type">int</span>,name string);<br></code></pre></td></tr></table></figure><p>通过hive -f 执行sql脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hive -f /export/servers/hive.sql<br></code></pre></td></tr></table></figure><h2 id="数据库层面操作"><a href="#数据库层面操作" class="headerlink" title="数据库层面操作"></a>数据库层面操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><h4 id="创建数据库-1"><a href="#创建数据库-1" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> myhive;<br>use myhive;<br></code></pre></td></tr></table></figure><blockquote><p>hive的表存放位置模式是由hive-site.xml当中的一个属性指定的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/user/hive/warehouse<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="创建数据库并指定位置"><a href="#创建数据库并指定位置" class="headerlink" title="创建数据库并指定位置"></a>创建数据库并指定位置</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database myhive2 location <span class="hljs-string">&#x27;/myhive2&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><p>可以使用alter database 命令来修改数据库的一些属性。但是<strong>数据库的元数据信息是不可更改的</strong>，包括数据库的名称以及数据库所在的位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> database myhive2 <span class="hljs-keyword">set</span> dbproperties(<span class="hljs-string">&#x27;createtime&#x27;</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;20210114&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="查看数据库详细信息"><a href="#查看数据库详细信息" class="headerlink" title="查看数据库详细信息"></a>查看数据库详细信息</h3><h4 id="查看数据库基本信息"><a href="#查看数据库基本信息" class="headerlink" title="查看数据库基本信息"></a>查看数据库基本信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">desc</span> database myhive2;<br></code></pre></td></tr></table></figure><h4 id="查看数据库更多详细信息"><a href="#查看数据库更多详细信息" class="headerlink" title="查看数据库更多详细信息"></a>查看数据库更多详细信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">desc</span> database extended myhive2;<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.4.png"></p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><h4 id="删除一个空数据库"><a href="#删除一个空数据库" class="headerlink" title="删除一个空数据库"></a>删除一个空数据库</h4><p><strong>如果数据库下面有数据表，那么就会报错</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> database myhive2;<br></code></pre></td></tr></table></figure><h4 id="强制删除数据库"><a href="#强制删除数据库" class="headerlink" title="强制删除数据库"></a>强制删除数据库</h4><p><strong>包含数据库下面的表一起删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> database myhive cascade;<br></code></pre></td></tr></table></figure><hr><h2 id="数据表层面操作"><a href="#数据表层面操作" class="headerlink" title="数据表层面操作"></a>数据表层面操作</h2><h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">EXTERNAL</span>] <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] table_name<br>[(col_name data_type [COMMENT col_comment], ...)]<br>[COMMENT table_comment]<br>[PARTITIONED <span class="hljs-keyword">BY</span> (col_name data_type [COMMENT col_comment], ...)]<br>[CLUSTERED <span class="hljs-keyword">BY</span> (col_name, col_name, ...)<br>[SORTED <span class="hljs-keyword">BY</span> (col_name [<span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>], ...)] <span class="hljs-keyword">INTO</span> num_buckets BUCKETS]<br>[<span class="hljs-type">ROW</span> FORMAT row_format]<br>[STORED <span class="hljs-keyword">AS</span> file_format]<br>[LOCATION hdfs_path]<br></code></pre></td></tr></table></figure><ul><li><p>CREATE TABLE 创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用IF NOT EXISTS 选项来忽略这个异常。</p></li><li><p>EXTERNAL关键字可以让用户创建一个<strong>外部表</strong>，在建表的同时指定一个指向实际数据的路径（LOCATION）。Hive 创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</p></li><li><p>LIKE 允许用户复制现有的表结构，但是不复制数据。</p></li><li><p>ROW FORMAT DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char] [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char] | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value,property_name=property_value, …)]</p><p>用户在建表的时候可以自定义 SerDe 或者使用自带的 SerDe。如果没有指定 ROW FORMAT 或者ROW FORMAT DELIMITED，将会使用自带的 SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的 SerDe，Hive通过 SerDe 确定表的具体的列的数据。</p></li><li><p>STORED AS SEQUENCEFILE|TEXTFILE|RCFILE  </p><p>如果文件数据是纯文本，可以使用 STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCEFILE。</p></li><li><p>CLUSTERED BY  </p><p>对于每一个表（table）或者分区， Hive可以进一步组织成桶，也就是<strong>说桶是更为细粒度的数据范围划分</strong>。Hive也是 针对某一列进行桶的组织。Hive采用对列值哈希，然后除以桶的个数求余的方式决定该条记录存放在哪个桶当中。<br>把表（或者分区）组织成桶（Bucket）有两个理由：</p><ul><li>获得更高的查询处理效率。桶为表加上了额外的结构，Hive 在处理有些查询时 能利用这个结构。具体而言，连接两个在（包含连接列的）相同列上划分了桶的表，可以使用 Map 端连接（Map-side join）高效的实现。比如JOIN操作。对于JOIN操作两个表有一个相同的列，如果对这两个表都进行了桶操作。那么将保存相同列值的桶进行JOIN操作就可以，可以大大较少JOIN的数据量。</li><li>使取样（sampling）更高效。在处理大规模数据集时，在开发和修改查询的阶段，如果能在数据集的一小部分数据上试运行查询，会带来很多方便。</li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">use myhive;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stu(id <span class="hljs-type">int</span>,name string);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> stu <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,&quot;zhangsan&quot;);<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu;<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.5.png"></p><h4 id="数据库表字段类型"><a href="#数据库表字段类型" class="headerlink" title="数据库表字段类型"></a>数据库表字段类型</h4><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.6.png"></p><h4 id="创建表并指定字段之间的分隔符"><a href="#创建表并指定字段之间的分隔符" class="headerlink" title="创建表并指定字段之间的分隔符"></a>创建表并指定字段之间的分隔符</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> stu2(id <span class="hljs-type">int</span> ,name string) <span class="hljs-type">row</span> format delimited fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\t&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="根据查询结果创建表"><a href="#根据查询结果创建表" class="headerlink" title="根据查询结果创建表"></a>根据查询结果创建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stu3 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu2; # 通过复制表结构和表内容创建新表<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.7.png"></p><h4 id="根据已经存在的表结构创建表"><a href="#根据已经存在的表结构创建表" class="headerlink" title="根据已经存在的表结构创建表"></a>根据已经存在的表结构创建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stu4 <span class="hljs-keyword">like</span> stu2;<br></code></pre></td></tr></table></figure><hr><h3 id="查询表的类型"><a href="#查询表的类型" class="headerlink" title="查询表的类型"></a>查询表的类型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">desc</span> formatted stu2;<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.8.png"></p><hr><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> old_table_name rename <span class="hljs-keyword">to</span> new_table_name;<br></code></pre></td></tr></table></figure><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>把表stu4修改成stu5</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stu4 rename <span class="hljs-keyword">to</span> stu5;<br></code></pre></td></tr></table></figure><hr><h3 id="增加-修改列信息"><a href="#增加-修改列信息" class="headerlink" title="增加/修改列信息"></a>增加/修改列信息</h3><h4 id="查询表结构"><a href="#查询表结构" class="headerlink" title="查询表结构"></a>查询表结构</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">desc</span> stu5;<br></code></pre></td></tr></table></figure><h4 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h4> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stu5 <span class="hljs-keyword">add</span> columns (sex string);<br></code></pre></td></tr></table></figure><h4 id="更新列"><a href="#更新列" class="headerlink" title="更新列"></a>更新列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stu5 change <span class="hljs-keyword">column</span> sex sex_new string;<br></code></pre></td></tr></table></figure><hr><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> stu5;<br></code></pre></td></tr></table></figure><hr><h3 id="外部表"><a href="#外部表" class="headerlink" title="外部表"></a>外部表</h3><p>外部表因为是指定其他的hdfs路径的数据加载到表当中来，所以hive表会认为自己不完全独占这份数据，所以<strong>删除hive表的时候，数据仍然存放在hdfs当中，不会删掉</strong></p><h4 id="创建外部表"><a href="#创建外部表" class="headerlink" title="创建外部表"></a>创建外部表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">external</span> <span class="hljs-keyword">table</span> student (s_id string,s_name string,s_birth string , s_sex string ) <span class="hljs-type">row</span> format delimited fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\t&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><ul><li><p>将student.csv文件上传至<code>/export/servers/hivedatas</code></p></li><li><p>加载student.csv文件</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">load data <span class="hljs-keyword">local</span> inpath <span class="hljs-string">&#x27;/export/servers/hivedatas/student.csv&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> student;<br></code></pre></td></tr></table></figure><blockquote><p>会将linux内文件，复制一份到数据库对应文件夹中</p></blockquote><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.9.png"></p><h4 id="加载数据并覆盖已有数据"><a href="#加载数据并覆盖已有数据" class="headerlink" title="加载数据并覆盖已有数据"></a>加载数据并覆盖已有数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">load data <span class="hljs-keyword">local</span> inpath <span class="hljs-string">&#x27;/export/servers/hivedatas/student.csv&#x27;</span> overwrite <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> student;<br></code></pre></td></tr></table></figure><blockquote><p>会将linux内文件，复制一份到数据库对应文件夹中</p></blockquote><h4 id="从hdfs文件系统向表中加载数据"><a href="#从hdfs文件系统向表中加载数据" class="headerlink" title="从hdfs文件系统向表中加载数据"></a>从hdfs文件系统向表中加载数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers/hivedatas<br>hdfs dfs -mkdir -p /hivedatas<br>hdfs dfs -put techer.csv /hivedatas/<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">load data inpath <span class="hljs-string">&#x27;/hivedatas/techer.csv&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> teacher;<br></code></pre></td></tr></table></figure><blockquote><p>需要提前将数据上传到hdfs文件系统，会将hdfs内文件<strong>剪切</strong>到数据库对应文件夹中</p></blockquote><hr><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>在大数据中，最常用的一种思想就是<strong>分治</strong>，可以把大的文件切割划分成一个个的小的文件，这样每次操作一个小的文件就会很容易了，同样的道理，在hive当中也是支持这种思想的，可以把大的数据，按照每天，或者每小时进行切分成一个个的小的文件，这样去操作小的文件就会容易很多</p><h4 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> score(s_id string,c_id string, s_score <span class="hljs-type">int</span>) partitioned <span class="hljs-keyword">by</span> (<span class="hljs-keyword">month</span> string) <span class="hljs-type">row</span> format delimited fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\t&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="创建一个表带多个分区"><a href="#创建一个表带多个分区" class="headerlink" title="创建一个表带多个分区"></a>创建一个表带多个分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> score2(s_id string,c_id string, s_score <span class="hljs-type">int</span>) partitioned <span class="hljs-keyword">by</span> (<span class="hljs-keyword">year</span> string,<span class="hljs-keyword">month</span> string,<span class="hljs-keyword">day</span> string) <span class="hljs-type">row</span> format delimited fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\t&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="加载数据到分区表"><a href="#加载数据到分区表" class="headerlink" title="加载数据到分区表"></a>加载数据到分区表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">load data <span class="hljs-keyword">local</span> inpath <span class="hljs-string">&#x27;/export/servers/hivedatas/score.csv&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> score <span class="hljs-keyword">partition</span>(<span class="hljs-keyword">month</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;201806&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.10.png"></p><h4 id="加载数据到多分区表"><a href="#加载数据到多分区表" class="headerlink" title="加载数据到多分区表"></a>加载数据到多分区表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">load data <span class="hljs-keyword">local</span> inpath <span class="hljs-string">&#x27;/export/servers/hivedatas/score.csv&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> score2 <span class="hljs-keyword">partition</span>(<span class="hljs-keyword">year</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;2018&#x27;</span>,<span class="hljs-keyword">month</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;06&#x27;</span>,<span class="hljs-keyword">day</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;01&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.11.png"></p><h4 id="多分区表联合查询"><a href="#多分区表联合查询" class="headerlink" title="多分区表联合查询"></a>多分区表联合查询</h4><p><strong>使用 union all</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;201806&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;201806&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.12.png"></p><h4 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> partitions score;<br></code></pre></td></tr></table></figure><h4 id="添加分区"><a href="#添加分区" class="headerlink" title="添加分区"></a>添加分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> score <span class="hljs-keyword">add</span> <span class="hljs-keyword">partition</span>(<span class="hljs-keyword">month</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;201805&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> score <span class="hljs-keyword">drop</span> <span class="hljs-keyword">partition</span>(<span class="hljs-keyword">month</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;201806&#x27;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="分桶表"><a href="#分桶表" class="headerlink" title="分桶表"></a>分桶表</h3><p>将数据按照指定的字段进行分成多个桶中去，说白了就是将数据按照字段进行划分，可以将数据按照字段划分到多个文件当中去</p><ul><li><p>开启Hive的分桶功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> hive.enforce.bucketing<span class="hljs-operator">=</span><span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure></li><li><p>设置Reduce个数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> mapreduce.job.reduces<span class="hljs-operator">=</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="创建桶表"><a href="#创建桶表" class="headerlink" title="创建桶表"></a>创建桶表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> course (c_id string,c_name string,t_id string) clustered <span class="hljs-keyword">by</span>(c_id) <span class="hljs-keyword">into</span> <span class="hljs-number">3</span> buckets <span class="hljs-type">row</span> format delimited fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\t&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h4><p>桶表的数据加载，由于通过<code>hdfs dfs -put文件</code>或者通过<code>load data</code>无法使用，只能通过<code>insert overwrite创建普通表</code>，并通过<code>insert overwrite</code>的方式将普通表的数据通过查询的方式加载到桶表当中去</p><ul><li><p>第一步，创建普通表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> course_common (c_id string,c_name string,t_id string) <span class="hljs-type">row</span> format delimited fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\t&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>第二步，普通表中加载数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">load data <span class="hljs-keyword">local</span> inpath <span class="hljs-string">&#x27;/export/servers/hivedatas/course.csv&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> course_common;<br></code></pre></td></tr></table></figure></li><li><p>第三步，通过insert overwrite给桶表中加载数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> overwrite <span class="hljs-keyword">table</span> course <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> course_common cluster <span class="hljs-keyword">by</span>(c_id);<br></code></pre></td></tr></table></figure></li></ul><p>操作结果如下：</p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.13.png"></p><p><img src="/2021/01/04/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/6.14.png"></p><hr><h2 id="数据表内层面操作"><a href="#数据表内层面操作" class="headerlink" title="数据表内层面操作"></a>数据表内层面操作</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="直接向分区表中插入数据"><a href="#直接向分区表中插入数据" class="headerlink" title="直接向分区表中插入数据"></a>直接向分区表中插入数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> score3 <span class="hljs-keyword">like</span> score;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> score3 <span class="hljs-keyword">partition</span>(<span class="hljs-keyword">month</span> <span class="hljs-operator">=</span><span class="hljs-string">&#x27;201807&#x27;</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;001&#x27;</span>,<span class="hljs-string">&#x27;002&#x27;</span>,<span class="hljs-string">&#x27;100&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="通过查询插入数据"><a href="#通过查询插入数据" class="headerlink" title="通过查询插入数据"></a>通过查询插入数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">load data <span class="hljs-keyword">local</span> inpath <span class="hljs-string">&#x27;/export/servers/hivedatas/score.csv&#x27;</span> overwrite <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> score3 <span class="hljs-keyword">partition</span>(<span class="hljs-keyword">month</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;202101&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> score4 <span class="hljs-keyword">like</span> score;<br><span class="hljs-keyword">insert</span> overwrite <span class="hljs-keyword">table</span> score4 <span class="hljs-keyword">partition</span>(<span class="hljs-keyword">month</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;202101&#x27;</span>) <span class="hljs-keyword">select</span> s_id,c_id,s_score <span class="hljs-keyword">from</span> score;<br></code></pre></td></tr></table></figure><hr><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">ALL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DISTINCT</span>] select_expr, select_expr, ...<br><span class="hljs-keyword">FROM</span> table_reference<br>[<span class="hljs-keyword">WHERE</span> where_condition]<br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> col_list<br>[<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">condition</span>]]<br>[CLUSTER <span class="hljs-keyword">BY</span> col_list<span class="hljs-operator">|</span> [DISTRIBUTE <span class="hljs-keyword">BY</span> col_list] [SORT <span class="hljs-keyword">BY</span><span class="hljs-operator">|</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> col_list]]<br>[LIMIT number]<br></code></pre></td></tr></table></figure><ul><li>order by 会对输入做<strong>全局排序</strong>，因此只有一个reducer，会导致当输入规模较大时，需要较长的计算时间。</li><li>sort by不是全局排序，其在数据进入reducer前完成排序。因此，如果用sort by进行排序，并且设置mapred.reduce.tasks&gt;1，则<strong>sort by只保证每个reducer的输出有序，不保证全局有序</strong>。</li></ul><ol start="3"><li>distribute by(字段)根据指定的字段将数据<strong>分到不同的reducer</strong>，且分发算法是hash散列。</li><li>Cluster by(字段) 除了具有Distribute by的功能外，还会对该字段进行排序。 —&gt; distribute by + sort by</li></ol><p><strong>因此，如果分桶和sort字段是同一个时，此时， cluster by = distribute by + sort by</strong></p><p>分桶表的作用：最大的作用是用来<strong>提高join操作</strong>的效率；</p><h4 id="全表查询"><a href="#全表查询" class="headerlink" title="全表查询"></a>全表查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score2;<br></code></pre></td></tr></table></figure><h4 id="选择特定列"><a href="#选择特定列" class="headerlink" title="选择特定列"></a>选择特定列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s_id ,c_id <span class="hljs-keyword">from</span> score2;<br></code></pre></td></tr></table></figure><h4 id="列别名"><a href="#列别名" class="headerlink" title="列别名"></a>列别名</h4><ul><li>重命名一个列。</li><li>便于计算。</li><li>紧跟列名，也可以在列名和别名之间加入关键字<strong>‘AS’</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s_id <span class="hljs-keyword">as</span> myid ,c_id <span class="hljs-keyword">from</span> score2;<br></code></pre></td></tr></table></figure><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><h5 id="求总行数（count）"><a href="#求总行数（count）" class="headerlink" title="求总行数（count）"></a>求总行数（count）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> score2;<br></code></pre></td></tr></table></figure><h5 id="求分数的最大值（max）"><a href="#求分数的最大值（max）" class="headerlink" title="求分数的最大值（max）"></a>求分数的最大值（max）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(s_score) <span class="hljs-keyword">from</span> score2;<br></code></pre></td></tr></table></figure><h5 id="求分数的最小值（min）"><a href="#求分数的最小值（min）" class="headerlink" title="求分数的最小值（min）"></a>求分数的最小值（min）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(s_score) <span class="hljs-keyword">from</span> score2;<br></code></pre></td></tr></table></figure><h5 id="求分数的总和（sum）"><a href="#求分数的总和（sum）" class="headerlink" title="求分数的总和（sum）"></a>求分数的总和（sum）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(s_score) <span class="hljs-keyword">from</span> score2;<br></code></pre></td></tr></table></figure><h5 id="求分数的平均值（avg）"><a href="#求分数的平均值（avg）" class="headerlink" title="求分数的平均值（avg）"></a>求分数的平均值（avg）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(s_score) <span class="hljs-keyword">from</span> score2;<br></code></pre></td></tr></table></figure><h4 id="LIMIT语句"><a href="#LIMIT语句" class="headerlink" title="LIMIT语句"></a>LIMIT语句</h4><ul><li>LIMIT子句用于限制返回的行数。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score2 limit <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h4 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h4><ul><li>使用WHERE 子句，将不满足条件的行过滤掉。</li></ul><ol start="2"><li>WHERE 子句紧随 FROM 子句。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score2 <span class="hljs-keyword">where</span> s_score <span class="hljs-operator">&gt;</span> <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure><h4 id="LIKE-和-RLIKE"><a href="#LIKE-和-RLIKE" class="headerlink" title="LIKE 和 RLIKE"></a>LIKE 和 RLIKE</h4><ul><li><p>使用LIKE运算选择类似的值</p></li><li><p>选择条件可以包含字符或数字:</p><ul><li>% 代表零个或多个字符(任意个字符)</li><li>_ 代表一个字符</li></ul></li><li><p>RLIKE子句是Hive中这个功能的一个扩展，其可以通过Java的正则表达式这个更强大的语言来指定匹配条件</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score2 <span class="hljs-keyword">where</span> s_score <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;8%&#x27;</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score2 <span class="hljs-keyword">where</span> s_score <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;_9%&#x27;</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score2 <span class="hljs-keyword">where</span> s_score rlike <span class="hljs-string">&#x27;[9]&#x27;</span>;  # 等同于<span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%9%&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>AND</td><td>逻辑并</td></tr><tr><td>OR</td><td>逻辑或</td></tr><tr><td>NOT</td><td>逻辑否</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score2 <span class="hljs-keyword">where</span> s_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;01&#x27;</span>,<span class="hljs-string">&#x27;02&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><h5 id="GROUP-BY-语句"><a href="#GROUP-BY-语句" class="headerlink" title="GROUP BY 语句"></a>GROUP BY 语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s_id ,<span class="hljs-built_in">avg</span>(s_score) <span class="hljs-keyword">from</span> score2 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s_id;<br><span class="hljs-keyword">select</span> s_id ,<span class="hljs-built_in">max</span>(s_score) <span class="hljs-keyword">from</span> score2 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s_id;<br></code></pre></td></tr></table></figure><h5 id="HAVING-语句"><a href="#HAVING-语句" class="headerlink" title="HAVING 语句"></a>HAVING 语句</h5><ul><li>having与where不同点<ul><li>where针对<strong>表中的列</strong>发挥作用，查询数据；having针对<strong>查询结果</strong>中的列发挥作用，筛选数据。</li><li>where后面不能写分组函数，而having后面可以使用分组函数。</li><li>having只用于group by分组统计语句。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s_id ,<span class="hljs-built_in">avg</span>(s_score) <span class="hljs-keyword">from</span> score2 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s_id;<br><span class="hljs-keyword">select</span> s_id ,<span class="hljs-built_in">avg</span>(s_score) avgscore <span class="hljs-keyword">from</span> score2 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s_id <span class="hljs-keyword">having</span> avgscore <span class="hljs-operator">&gt;</span> <span class="hljs-number">85</span>;<br></code></pre></td></tr></table></figure><h4 id="JOIN-语句"><a href="#JOIN-语句" class="headerlink" title="JOIN 语句"></a>JOIN 语句</h4><ul><li>Hive支持通常的SQL JOIN语句，但是只支持等值连接，不支持非等值连接。</li></ul><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><ul><li>内连接：只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> techer t <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> course c <span class="hljs-keyword">on</span> t.t_id <span class="hljs-operator">=</span> c.t_id;<br></code></pre></td></tr></table></figure><h5 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h5><ul><li>左外连接：JOIN操作符左边表中符合WHERE子句的所有记录将会被返回。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> techer t <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> course c <span class="hljs-keyword">on</span> t.t_id <span class="hljs-operator">=</span> c.t_id;<br></code></pre></td></tr></table></figure><h5 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h5><ul><li>右外连接：JOIN操作符右边表中符合WHERE子句的所有记录将会被返回。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher t <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> course c <span class="hljs-keyword">on</span> t.t_id <span class="hljs-operator">=</span> c.t_id;<br></code></pre></td></tr></table></figure><h5 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h5><ul><li>连接 n个表，至少需要n-1个连接条件</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher t <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> course c<br><span class="hljs-keyword">on</span> t.t_id <span class="hljs-operator">=</span> c.t_id<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> score s<br><span class="hljs-keyword">on</span> s.c_id <span class="hljs-operator">=</span> c.c_id<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> student stu<br><span class="hljs-keyword">on</span> s.s_id <span class="hljs-operator">=</span> stu.s_id;<br></code></pre></td></tr></table></figure><blockquote><p>大多数情况下，Hive会对每对JOIN连接对象启动一个MapReduce任务。</p><p>本例中会首先启动一个MapReduce job对表techer和表course进行连接操作，然后会再启动一个MapReduce job将第一个MapReduce job的输出和表score;进行连接操作。</p></blockquote><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><h5 id="全局排序"><a href="#全局排序" class="headerlink" title="全局排序"></a>全局排序</h5><p><strong>Order By：全局排序，一个reduce</strong></p><ul><li><p>使用 ORDER BY 子句排序</p><ul><li>ASC（ascend）: 升序（默认）</li><li>DESC（descend）: 降序</li></ul></li><li><p>ORDER BY 子句在SELECT语句的结尾。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student s <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> score sco <span class="hljs-keyword">ON</span> s.s_id <span class="hljs-operator">=</span> sco.s_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sco.s_score <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h5 id="多个列排序"><a href="#多个列排序" class="headerlink" title="多个列排序"></a>多个列排序</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s_id ,<span class="hljs-built_in">avg</span>(s_score) avg <span class="hljs-keyword">from</span> score <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s_id <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> s_id,avg;<br></code></pre></td></tr></table></figure><h5 id="局部排序"><a href="#局部排序" class="headerlink" title="局部排序"></a>局部排序</h5><p><strong>Sort By：每个MapReduce内部进行排序，对全局结果集来说不是排序。</strong></p><ul><li>设置reduce个数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> mapreduce.job.reduces<span class="hljs-operator">=</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><ul><li>  查看设置reduce个数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> mapreduce.job.reduces;<br></code></pre></td></tr></table></figure><ul><li>查询成绩按照成绩降序排列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score sort <span class="hljs-keyword">by</span> s_score;<br></code></pre></td></tr></table></figure><ul><li>将查询结果导入到文件中（按照成绩降序排列）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> overwrite <span class="hljs-keyword">local</span> directory <span class="hljs-string">&#x27;/export/servers/hivedatas/sort&#x27;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score sort <span class="hljs-keyword">by</span> s_score;<br></code></pre></td></tr></table></figure><h5 id="分区排序"><a href="#分区排序" class="headerlink" title="分区排序"></a>分区排序</h5><p><strong>Distribute By：类似MR中partition，进行分区，结合sort by使用。</strong></p><blockquote><p>注意，Hive要求<strong>DISTRIBUTE BY语句要写在SORT BY语句之前</strong>。<br>对于distribute by进行测试，一定要分配多reduce进行处理，否则无法看到distribute by的效果。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score distribute <span class="hljs-keyword">by</span> s_id<br></code></pre></td></tr></table></figure><h5 id="CLUSTER-BY"><a href="#CLUSTER-BY" class="headerlink" title="CLUSTER BY"></a>CLUSTER BY</h5><p><strong>当distribute by和sort by字段相同时，可以使用cluster by方式。</strong></p><p>cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序只能是倒序排序，不能指定排序规则为ASC或者DESC。<br>以下两种写法等价</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score cluster <span class="hljs-keyword">by</span> s_id;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score distribute <span class="hljs-keyword">by</span> s_id sort <span class="hljs-keyword">by</span> s_id;<br></code></pre></td></tr></table></figure><hr><h2 id="Hive函数"><a href="#Hive函数" class="headerlink" title="Hive函数"></a>Hive函数</h2><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><ul><li>查看系统自带的函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> functions;<br></code></pre></td></tr></table></figure><ul><li>显示自带的函数的用法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">desc</span> <span class="hljs-keyword">function</span> upper;<br></code></pre></td></tr></table></figure><ul><li>详细显示自带的函数的用法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">desc</span> <span class="hljs-keyword">function</span> extended upper;<br></code></pre></td></tr></table></figure><ul><li>常用内置函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 字符串连接函数： concat<br><span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-string">&#x27;def&#x27;</span>,<span class="hljs-string">&#x27;gh&#x27;</span>);<br>        <br># 带分隔符字符串连接函数： concat_ws<br><span class="hljs-keyword">select</span> concat_ws(<span class="hljs-string">&#x27;,&#x27;</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-string">&#x27;def&#x27;</span>,<span class="hljs-string">&#x27;gh&#x27;</span>);<br><br># 类型转换:cast<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">cast</span>(<span class="hljs-number">1.5</span> <span class="hljs-keyword">as</span> <span class="hljs-type">int</span>);<br><br># json解析函数，用来处理json，必须是json格式:get_json_object<br><span class="hljs-keyword">select</span> get_json_object(<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:&quot;20&quot;&#125;&#x27;</span>,<span class="hljs-string">&#x27;$.name&#x27;</span>);<br><br># URL解析函数:parse_url<br><span class="hljs-keyword">select</span> parse_url(<span class="hljs-string">&#x27;http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#x27;</span>, <span class="hljs-string">&#x27;HOST&#x27;</span>);<br># 输出facebook.com<br><br># explode：把map集合中每个键值对或数组中的每个元素都单独生成一行的形式<br></code></pre></td></tr></table></figure><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><ul><li><p>Hive 自带了一些函数，比如：max/min等，但是数量有限，自己可以通过自定义UDF来方便的扩展。</p></li><li><p>当Hive提供的内置函数无法满足业务处理需要时，此时就可以考虑使用用户自定义函数（UDF：user-definedfunction）。</p></li><li><p>根据用户自定义函数类别分为以下三种：</p><ul><li>UDF（User-Defined-Function），一进一出</li><li>UDAF（User-Defined Aggregation Function），聚集函数，多进一出，类似于： count / max / min</li><li>UDTF（User-Defined Table-Generating Functions），一进多出，如 lateral view explore()</li></ul></li><li><p>官方文档地址 <a href="https://cwiki.apache.org/confluence/display/Hive/HivePlugins">https://cwiki.apache.org/confluence/display/Hive/HivePlugins</a></p></li></ul><ul><li><p>编程步骤</p><ul><li>继承org.apache.hadoop.hive.ql.UDF</li><li>需要实现evaluate函数；evaluate函数支持重载；</li></ul></li><li><p>注意事项</p><ul><li>UDF必须要有返回类型，可以返回null，但是返回类型不能为void；</li><li>UDF中常用Text/LongWritable等类型，不推荐使用java类型；</li></ul></li></ul><h4 id="UDF-开发实例"><a href="#UDF-开发实例" class="headerlink" title="UDF 开发实例"></a>UDF 开发实例</h4><h5 id="第一步：新建工程，导入Maven依赖"><a href="#第一步：新建工程，导入Maven依赖" class="headerlink" title="第一步：新建工程，导入Maven依赖"></a>第一步：新建工程，导入Maven依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hive/hive-exec --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hive<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hive-exec<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-common --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="第二步：自定义类继承UDF类"><a href="#第二步：自定义类继承UDF类" class="headerlink" title="第二步：自定义类继承UDF类"></a>第二步：自定义类继承UDF类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将字符串第一个字母大写</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyUDF</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UDF</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Text <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Text str)</span></span>&#123;<br>String tmp_str = str.toString();<br><span class="hljs-keyword">if</span>(str != <span class="hljs-keyword">null</span> &amp;&amp; !tmp_str.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>String str_ret = tmp_str.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase() + tmp_str.substring(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Text(str_ret);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Text(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="第三步：项目打包，并上传到hive的lib目录下"><a href="#第三步：项目打包，并上传到hive的lib目录下" class="headerlink" title="第三步：项目打包，并上传到hive的lib目录下"></a>第三步：项目打包，并上传到hive的lib目录下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /export/servers/apache-hive-3.1.1-bin/lib<br>mv myudf.jar udf.jar<br></code></pre></td></tr></table></figure><h5 id="第四步：添加jar包"><a href="#第四步：添加jar包" class="headerlink" title="第四步：添加jar包"></a>第四步：添加jar包</h5><p>在hive的客户端添加jar包</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">add</span> jar <span class="hljs-operator">/</span>export<span class="hljs-operator">/</span>servers<span class="hljs-operator">/</span>apache<span class="hljs-operator">-</span>hive<span class="hljs-number">-3.1</span><span class="hljs-number">.1</span><span class="hljs-operator">-</span>bin<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>udf.jar;<br></code></pre></td></tr></table></figure><h5 id="第五步：设置函数与自定义函数关联"><a href="#第五步：设置函数与自定义函数关联" class="headerlink" title="第五步：设置函数与自定义函数关联"></a>第五步：设置函数与自定义函数关联</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> temporary <span class="hljs-keyword">function</span> my_upper <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;top.igotcha.udf.MyUDF&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="第六步：使用自定义函数"><a href="#第六步：使用自定义函数" class="headerlink" title="第六步：使用自定义函数"></a>第六步：使用自定义函数</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> my_upper(<span class="hljs-string">&#x27;abc&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>大数据基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
      <tag>Hadoop</tag>
      
      <tag>HDFS</tag>
      
      <tag>MapReduce</tag>
      
      <tag>Hive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 容器</title>
    <link href="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/"/>
    <url>/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/1.1.png"></p><h1 id="二、ArrayList"><a href="#二、ArrayList" class="headerlink" title="二、ArrayList"></a>二、ArrayList</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p><p><code>ArrayList</code>继承于 **<code>AbstractList</code>**，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li><li><code>ArrayList</code> 实现了 <code>java.io.Serializable </code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li></ul><h3 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别"></a>Arraylist 和 Vector 的区别</h3><ol><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[ ]</code>存储，线程安全的。</li></ol><h3 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h3><ol><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code>  底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别）</li><li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h2 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.function.UnaryOperator;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">8683452581122892189L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认初始容量大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 空数组（用于空实例）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>     <span class="hljs-comment">//用于默认大小空实例的共享空数组实例。</span><br>     <span class="hljs-comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存ArrayList数据的数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList 所包含的元素个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <br>    <br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">   *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span><br><span class="hljs-comment">   */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带初始容量参数的构造函数。（用户自己指定容量）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//初始容量大于0</span><br>            <span class="hljs-comment">//创建initialCapacity大小的数组</span><br>            <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//初始容量等于0</span><br>            <span class="hljs-comment">//创建空数组</span><br>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//初始容量小于0，抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        <span class="hljs-comment">//将指定集合转换为数组</span><br>        elementData = c.toArray();<br>        <span class="hljs-comment">//如果elementData数组的长度不为0</span><br>        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span><br>            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>                <span class="hljs-comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span><br>                elementData = Arrays.copyOf(elementData, size, Object[].class);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 其他情况，用空数组代替</span><br>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span><br><span class="hljs-comment">     */</span> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">()</span> </span>&#123;<br>        modCount++;<br>        <span class="hljs-keyword">if</span> (size &lt; elementData.length) &#123;<br>            elementData = (size == <span class="hljs-number">0</span>)<br>              ? EMPTY_ELEMENTDATA<br>              : Arrays.copyOf(elementData, size);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//下面是ArrayList的扩容机制</span><br><span class="hljs-comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span><br><span class="hljs-comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   minCapacity   所需的最小容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span><br>        <span class="hljs-keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>            <span class="hljs-comment">// any size if not default element table</span><br>            ? <span class="hljs-number">0</span><br>            <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>            <span class="hljs-comment">// supposed to be at default size.</span><br>            : DEFAULT_CAPACITY;<br>        <span class="hljs-comment">//如果最小容量大于已有的最大容量</span><br>        <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>            ensureExplicitCapacity(minCapacity);<br>        &#125;<br>    &#125;<br>   <span class="hljs-comment">//得到最小扩容量</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>              <span class="hljs-comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span><br>            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br><br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br>  <span class="hljs-comment">//判断是否需要扩容</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>            grow(minCapacity);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 要分配的最大数组大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>        <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>        <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>        <span class="hljs-comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)  <br>            newCapacity = minCapacity;<br>        <span class="hljs-comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span><br>        <span class="hljs-comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span><br>        <span class="hljs-comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span><br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br>    <span class="hljs-comment">//比较minCapacity和 MAX_ARRAY_SIZE</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>            Integer.MAX_VALUE :<br>            MAX_ARRAY_SIZE;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回此列表中的元素数。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表不包含元素，则返回 true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//注意=和==的区别</span><br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表包含指定的元素，则返回true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br>        <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-comment">//equals()方法比较</span><br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-keyword">super</span>.clone();<br>            <span class="hljs-comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span><br>            v.elementData = Arrays.copyOf(elementData, size);<br>            v.modCount = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-comment">// 这不应该发生，因为我们是可以克隆的</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span><br><span class="hljs-comment">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span><br><span class="hljs-comment">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>        <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span><br><span class="hljs-comment">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span><br><span class="hljs-comment">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span><br><span class="hljs-comment">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span><br><span class="hljs-comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>        <span class="hljs-keyword">if</span> (a.length &lt; size)<br>            <span class="hljs-comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span><br>            <span class="hljs-keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());<br>            <span class="hljs-comment">//调用System提供的arraycopy()方法实现数组之间的复制</span><br>        System.arraycopy(elementData, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>        <span class="hljs-keyword">if</span> (a.length &gt; size)<br>            a[size] = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-comment">// Positional Access Operations</span><br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (E) elementData[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        rangeCheck(index);<br><br>        <span class="hljs-keyword">return</span> elementData(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用指定的元素替换此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>        <span class="hljs-comment">//对index进行界限检查</span><br>        rangeCheck(index);<br><br>        E oldValue = elementData(index);<br>        elementData[index] = element;<br>        <span class="hljs-comment">//返回原来在这个位置的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此列表中的指定位置插入指定的元素。</span><br><span class="hljs-comment">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><br><span class="hljs-comment">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>        rangeCheckForAdd(index);<br><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span><br>        System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                         size - index);<br>        elementData[index] = element;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        rangeCheck(index);<br><br>        modCount++;<br>        E oldValue = elementData(index);<br><br>        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>      <span class="hljs-comment">//从列表中删除的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span><br><span class="hljs-comment">     *返回true，如果此列表包含指定的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Private remove method that skips bounds checking and does not</span><br><span class="hljs-comment">     * return the value removed.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        modCount++;<br>        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// 把数组中所有的元素的值设为null</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            elementData[i] = <span class="hljs-keyword">null</span>;<br><br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        Object[] a = c.toArray();<br>        <span class="hljs-keyword">int</span> numNew = a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        rangeCheckForAdd(index);<br><br>        Object[] a = c.toArray();<br>        <span class="hljs-keyword">int</span> numNew = a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br><br>        <span class="hljs-keyword">int</span> numMoved = size - index;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index, elementData, index + numNew,<br>                             numMoved);<br><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span><br><span class="hljs-comment">     *将任何后续元素移动到左侧（减少其索引）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fromIndex, <span class="hljs-keyword">int</span> toIndex)</span> </span>&#123;<br>        modCount++;<br>        <span class="hljs-keyword">int</span> numMoved = size - toIndex;<br>        System.arraycopy(elementData, toIndex, elementData, fromIndex,<br>                         numMoved);<br><br>        <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-keyword">int</span> newSize = size - (toIndex-fromIndex);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = newSize; i &lt; size; i++) &#123;<br>            elementData[i] = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        size = newSize;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查给定的索引是否在范围内。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rangeCheck</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * add和addAll使用的rangeCheck的一个版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回IndexOutOfBoundsException细节信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">outOfBoundsMsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Index: &quot;</span>+index+<span class="hljs-string">&quot;, Size: &quot;</span>+size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除指定集合中包含的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> </span>&#123;<br>        Objects.requireNonNull(c);<br>        <span class="hljs-comment">//如果此列表被修改则返回true</span><br>        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 仅保留此列表中包含在指定集合中的元素。</span><br><span class="hljs-comment">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> </span>&#123;<br>        Objects.requireNonNull(c);<br>        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-keyword">true</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span><br><span class="hljs-comment">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span><br><span class="hljs-comment">     *返回的列表迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title">listIterator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">&quot;Index: &quot;</span>+index);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ListItr(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回列表中的列表迭代器（按适当的顺序）。</span><br><span class="hljs-comment">     *返回的列表迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title">listIterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ListItr(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *以正确的顺序返回该列表中的元素的迭代器。</span><br><span class="hljs-comment">     *返回的迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Itr();<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><blockquote><p>modCount：表示被修改的次数，字段用于迭代器的快速失败。</p></blockquote><hr><h2 id="扩容机制分析"><a href="#扩容机制分析" class="headerlink" title="扩容机制分析"></a>扩容机制分析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><strong>ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 默认初始容量大小</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<br><br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br> &#125;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//初始容量大于0</span><br>         <span class="hljs-comment">//创建initialCapacity大小的数组</span><br>         <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//初始容量等于0</span><br>         <span class="hljs-comment">//创建空数组</span><br>         <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//初始容量小于0，抛出异常</span><br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                            initialCapacity);<br>     &#125;<br> &#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span><br><span class="hljs-comment"> *如果指定的集合为null，throws NullPointerException。</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>     elementData = c.toArray();<br>     <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>         <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>             elementData = Arrays.copyOf(elementData, size, Object[].class);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// replace with empty array.</span><br>         <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>     &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><p><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p><hr><h3 id="add-方法"><a href="#add-方法" class="headerlink" title="add()方法"></a><code>add()</code>方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br><span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal方法</span><br>     ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>     <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>     elementData[size++] = e;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br> &#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><hr><h3 id="ensureCapacityInternal-方法"><a href="#ensureCapacityInternal-方法" class="headerlink" title="ensureCapacityInternal()方法"></a><code>ensureCapacityInternal()</code>方法</h3><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//得到最小扩容量</span><br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>           <span class="hljs-comment">// 获取默认的容量和传入参数的较大值</span><br>         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>     &#125;<br><br>     ensureExplicitCapacity(minCapacity);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>当空ArrayList要add进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p><hr><h3 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity()方法"></a><code>ensureExplicitCapacity()</code>方法</h3><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断是否需要扩容</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>      modCount++;<br><br>      <span class="hljs-comment">// overflow-conscious code</span><br>      <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>          <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>          grow(minCapacity);<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li><p>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</p></li><li><p>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</p></li><li><p>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</p></li><li><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p></li></ul><hr><h3 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow()方法"></a><code>grow()</code>方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 要分配的最大数组大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ArrayList扩容的核心方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>    <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>    <span class="hljs-comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>   <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span><br>   <span class="hljs-comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><ul><li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li><li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li><li>以此类推······</li></ul><blockquote><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul></blockquote><hr><h3 id="hugeCapacity-方法"><a href="#hugeCapacity-方法" class="headerlink" title="hugeCapacity()方法"></a><code>hugeCapacity()</code>方法</h3><p>如果新容量大于 MAX_ARRAY_SIZE，进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>    <span class="hljs-comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span><br>    <span class="hljs-comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br>    <span class="hljs-comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br>    <span class="hljs-comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>        Integer.MAX_VALUE :<br>    MAX_ARRAY_SIZE;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>向集合中添加元素时，先进行容量检测，在进行添加操作</li><li>容量检测操作如下<ul><li>最小扩容容量为<strong>当前数组元素个数+1</strong></li><li>判断当前数组是否为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，也就是调用了无参构造函数来创建集合<ul><li>如果是，最小容量就变为DEFAULT_CAPACITY(10)和最小容量的较大者</li><li>如果不是，就返回较小容量</li></ul></li><li>返回得到的最小扩容容量</li></ul></li><li>然后调用方法，增加集合被修改的次数（modCount++），然后再次确定最小扩容容量是否大于数组当前的大小（也就是放入元素后会不会大于数组的当前长度，容量不足），如果满足，则调用最重要的grow方法进行数组的扩容，方法执行的操作如下<ul><li>用变量<strong>oldCapacity</strong>保存扩容前数组的大小（<strong>数组中元素的个数</strong>）</li><li>进行扩容，<strong>扩容大小为原容量的1.5倍</strong>（右移一位，表示除以2）</li><li>查看扩容后的容量是否小于最小扩容容量（如果原容量为0，如初始化了集合大小，newCapaticy就还是0，所以需要比较）<ul><li>如果是，就以最小扩容容量来进行扩容</li><li>如果不是，就扩大为原容量的1.5倍</li></ul></li></ul></li></ul><blockquote><p>modCount的作用</p><p>在使用迭代器进行迭代时会用到这个变量。<strong>这个变量是用来保证线程的安全性的</strong>。如果在进行迭代的时候，发现modCount的值被修改了，那么就会抛出ConcurrentModificationException</p></blockquote><h2 id="移除方法"><a href="#移除方法" class="headerlink" title="移除方法"></a>移除方法</h2><h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 判断是否越界</span><br>        rangeCheck(index);<br><br>        modCount++;<br>        E oldValue = elementData(index);<br><br>    <span class="hljs-comment">// 需要移动的元素个数</span><br>        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 从index+1开始，后面的元素全部前移1位</span><br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,numMoved);<br>    <br>    <span class="hljs-comment">// 让最后一个元素置空，让GC来清楚它</span><br>        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br><br>    <span class="hljs-comment">// 返回被移除的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="remove-Object-o-方法"><a href="#remove-Object-o-方法" class="headerlink" title="remove(Object o)方法"></a>remove(Object o)方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-comment">// 被移除的元素为空</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-comment">// 移除为空的元素</span><br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-comment">// 移除指定的元素</span><br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                <span class="hljs-comment">// 每次删除一个元素</span><br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-comment">// 移除失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 这个方法和remove(int index)方法有些类似，只不过不用返回被删除的元素</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        modCount++;<br>        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>    <br>    <span class="hljs-comment">// 让最后一个元素置空，让GC来清除它</span><br>        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>    modCount++;<br><br>    <span class="hljs-comment">// clear to let GC do its work</span><br>    <span class="hljs-comment">// 依次将数组中的元素置为null，方便GC来回收内存</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>        elementData[i] = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 将容量设置为0</span><br>    size = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="set-get方法"><a href="#set-get方法" class="headerlink" title="set/get方法"></a>set/get方法</h2><h3 id="set-int-index-E-element-方法"><a href="#set-int-index-E-element-方法" class="headerlink" title="set(int index, E element)方法"></a>set(int index, E element)方法</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl">public E set(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>, E element) &#123;<br>    <span class="hljs-regexp">//</span> 判断索引是否越界<br>        rangeCheck(<span class="hljs-keyword">index</span>);<br><br>    <span class="hljs-regexp">//</span> 用oldValue保存数组中<span class="hljs-keyword">index</span>位置上的元素<br>        E oldValue = elementData(<span class="hljs-keyword">index</span>);<br>    <br>    <span class="hljs-regexp">//</span> 将要插入的元素插入到数组的<span class="hljs-keyword">index</span>位置上<br>        elementData[<span class="hljs-keyword">index</span>] = element;<br>    <br>    <span class="hljs-regexp">//</span> 返回<span class="hljs-keyword">index</span>原来位置上的元素<br>        <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>set方法在改变数组中指定位置的元素时，<strong>会返回被覆盖的元素</strong></p><h3 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index)方法"></a>get(int index)方法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> E <span class="hljs-keyword">get</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;<br>    // 判断索引是否越界<br>        range<span class="hljs-keyword">Check</span>(<span class="hljs-keyword">index</span>);<br> <br>    // 返回数组中<span class="hljs-keyword">index</span>位置上的元素<br>        <span class="hljs-keyword">return</span> elementData(<span class="hljs-keyword">index</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="转化方法"><a href="#转化方法" class="headerlink" title="转化方法"></a>转化方法</h2><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><p>ArrayList 的 toString 方法调用的是其祖宗类 AbstractCollection 的toString 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCollection</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 获取迭代器</span><br>        Iterator&lt;E&gt; it = iterator();<br>        <span class="hljs-comment">// 如果迭代器为空，就返回&quot;[]&quot;</span><br>        <span class="hljs-keyword">if</span> (! it.hasNext())<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;<br><br>        <span class="hljs-comment">// 使用StringBuilder来进行字符串的拼接</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        sb.append(<span class="hljs-string">&#x27;[&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 获取一个元素</span><br>            E e = it.next();<br>            <br>            <span class="hljs-comment">// 进行拼接操作</span><br>            sb.append(e == <span class="hljs-keyword">this</span> ? <span class="hljs-string">&quot;(this Collection)&quot;</span> : e);<br>            <br>            <span class="hljs-comment">// 看是否还有下一个元素</span><br>            <span class="hljs-keyword">if</span> (! it.hasNext())<br>                <span class="hljs-comment">// 如果没有，就加上&#x27;]&#x27;，并调用toStrng方法转化为String类型</span><br>                <span class="hljs-keyword">return</span> sb.append(<span class="hljs-string">&#x27;]&#x27;</span>).toString();<br>            <br>            <span class="hljs-comment">// 如果还有下一个元素，就加上 &quot;, &quot; 进行分割</span><br>            sb.append(<span class="hljs-string">&#x27;,&#x27;</span>).append(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="清空方法"><a href="#清空方法" class="headerlink" title="清空方法"></a>清空方法</h2><h3 id="clear-方法-1"><a href="#clear-方法-1" class="headerlink" title="clear()方法"></a>clear()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>    modCount++;<br><br>    <span class="hljs-comment">// clear to let GC do its work</span><br>    <span class="hljs-comment">// 依次将数组中的元素置为null，方便GC来回收内存</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>        elementData[i] = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 将容量设置为0</span><br>    size = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="包含方法"><a href="#包含方法" class="headerlink" title="包含方法"></a>包含方法</h2><h3 id="contains-Object-o-方法"><a href="#contains-Object-o-方法" class="headerlink" title="contains(Object o)方法"></a>contains(Object o)方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将参数转为了Object类型</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用 indexOf 方法，查找o的索引。如果索引值大于等于0，就返回true，反之返回false</span><br>    <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-comment">// 传入参数是否为 null</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 依次遍历数组，返回遇到的第一个null的索引</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 遍历数组，返回遇到的第一个o的索引</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    <span class="hljs-comment">// 如果数组中没有该元素，就返回-1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="System-arraycopy-方法"><a href="#System-arraycopy-方法" class="headerlink" title="System.arraycopy() 方法"></a><code>System.arraycopy()</code> 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此列表中的指定位置插入指定的元素。</span><br><span class="hljs-comment">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><br><span class="hljs-comment">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span><br><span class="hljs-comment">     */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    rangeCheckForAdd(index);<br><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">//arraycopy()方法实现数组自己复制自己</span><br>    <span class="hljs-comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>, size - index);<br>    elementData[index] = element;<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试System.arraycopy</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArraycopyTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        a[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        a[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        System.arraycopy(a, <span class="hljs-number">2</span>, a, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>        a[<span class="hljs-number">2</span>]=<span class="hljs-number">99</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>            System.out.print(a[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">99</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="Arrays-copyOf-方法"><a href="#Arrays-copyOf-方法" class="headerlink" title="Arrays.copyOf()方法"></a><code>Arrays.copyOf()</code>方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br> <span class="hljs-comment">//elementData：要复制的数组；size：要复制的长度</span><br>     <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br> &#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试Arrays.copyOf</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayscopyOfTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>        a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        a[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span>[] b = Arrays.copyOf(a, <span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;b.length&quot;</span>+b.length);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="两者联系和区别"><a href="#两者联系和区别" class="headerlink" title="两者联系和区别"></a>两者联系和区别</h3><p><strong>联系：</strong></p><p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong></p><p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 </p><p><code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h3 id="ensureCapacity-方法"><a href="#ensureCapacity-方法" class="headerlink" title="ensureCapacity()方法"></a><code>ensureCapacity()</code>方法</h3><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span>   minCapacity   所需的最小容量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>        <span class="hljs-comment">// any size if not default element table</span><br>        ? <span class="hljs-number">0</span><br>        <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>        <span class="hljs-comment">// supposed to be at default size.</span><br>        : DEFAULT_CAPACITY;<br><br>    <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p><h3 id="使用迭代器遍历元素时，删除最后一个元素"><a href="#使用迭代器遍历元素时，删除最后一个元素" class="headerlink" title="使用迭代器遍历元素时，删除最后一个元素"></a>使用迭代器遍历元素时，删除最后一个元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>arrayList.add(<span class="hljs-string">&quot;tom&quot;</span>);<br>arrayList.add(<span class="hljs-string">&quot;bill&quot;</span>);<br>arrayList.add(<span class="hljs-string">&quot;liming&quot;</span>);<br><br>Iterator iterator = arrayList.iterator();<br><br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>String tempStr = (String) iterator.next();<br>            <span class="hljs-comment">// 移除最后一个元素</span><br><span class="hljs-keyword">if</span>(tempStr.equals(<span class="hljs-string">&quot;liming&quot;</span>)) &#123;<br>arrayList.remove(tempStr);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会报<code>java.util.ConcurrentModificationException</code>异常</p><p><strong>问题分析</strong></p><ul><li><p>每次进行遍历操作调用 next 方法时，在开头都会先调用 方法，<strong>来判断modCount是否和expectedModCount是否一致</strong></p><ul><li>在删除指定元素前的遍历中，看到 modCount 和 expectedModCount 相同，都为3</li></ul></li><li><p>进行删除操作，<strong>删除操作会使得数组的大小-1</strong></p></li><li><p>继续向下执行，会发现在遍历了所有元素之后，<strong>循环并没有第一时间就停下来</strong>！</p><ul><li>hasNext 是<strong>根据光标和数组大小是否一致来判断是否有下一个元素的</strong></li></ul></li><li><p>再次执行next，此时发现<strong>modCount是否和expectedModCount不一致！</strong>便抛出了异常</p><ul><li>modCount的增加是因为<strong>前面进行了删除操作，使得modCount的值+1了</strong></li></ul></li></ul><p><strong>结论</strong>：在使用迭代器进行遍历时，如果中途<strong>移除了最后一个元素</strong>，则会出现<strong>并发修改异常</strong>。因为在遍历过程中modCount的值被修改了</p><p>在遍历ArrayList时，不要对集合中的元素进行增加与修改操作。如果要进行元素的<strong>删除</strong>，最好<strong>使用迭代器自身的 remove() 方法</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">iterator.<span class="hljs-builtin-name">remove</span>();<br></code></pre></td></tr></table></figure><p>因为该方法在进行完删除操作后，更新了 expectedModCount 的值，使得其与modCount一致</p><h1 id="三、LinkedList"><a href="#三、LinkedList" class="headerlink" title="三、LinkedList"></a>三、LinkedList</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>LinkedList是一个实现了List接口和Deque接口的双端链表。 LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性</p><p>LinkedList底层由一个<strong>拥有头、尾指针的双向链表构成</strong></p><p>LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List list=Collections.synchronizedList(<span class="hljs-keyword">new</span> LinkedList(...));<br></code></pre></td></tr></table></figure><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/3.0.png"></p><h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/3.1.png"></p><p>LinkedList类中的<strong>内部私有类Node</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E item;<span class="hljs-comment">//节点值</span><br>    Node&lt;E&gt; next;<span class="hljs-comment">//后继节点</span><br>    Node&lt;E&gt; prev;<span class="hljs-comment">//前驱节点</span><br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-keyword">this</span>.item = element;<br>        <span class="hljs-keyword">this</span>.next = next;<br>        <span class="hljs-keyword">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。</p></blockquote><h2 id="核心源码-1"><a href="#核心源码-1" class="headerlink" title="核心源码"></a>核心源码</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>无参构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>用已有的集合创建链表的构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>();<br>    addAll(c);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="add-方法-1"><a href="#add-方法-1" class="headerlink" title="add()方法"></a><code>add()</code>方法</h3><h4 id="add-E-e-方法：将元素添加到链表尾部"><a href="#add-E-e-方法：将元素添加到链表尾部" class="headerlink" title="add(E e) 方法：将元素添加到链表尾部"></a>add(E e) 方法：将元素添加到链表尾部</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    linkLast(e);<span class="hljs-comment">//这里就只调用了这一个方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 链接使e作为最后一个元素。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);<br>    last = newNode;<span class="hljs-comment">//新建节点</span><br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        l.next = newNode;<span class="hljs-comment">//指向后继元素也就是指向下一个元素</span><br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="add-int-index-E-e-：在指定位置添加元素"><a href="#add-int-index-E-e-：在指定位置添加元素" class="headerlink" title="add(int index,E e)：在指定位置添加元素"></a>add(int index,E e)：在指定位置添加元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    checkPositionIndex(index); <span class="hljs-comment">//检查索引是否处于[0-size]之间</span><br><br>    <span class="hljs-keyword">if</span> (index == size)<span class="hljs-comment">//添加在链表尾部</span><br>        linkLast(element);<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//添加在链表中间</span><br>        linkBefore(element, node(index));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>linkBefore方法需要给定两个参数，一个插入节点的值，一个指定的node，所以我们又调用了Node(index)去找到index对应的node</p></blockquote><h4 id="addAll-Collection-c-：将集合插入到链表尾部"><a href="#addAll-Collection-c-：将集合插入到链表尾部" class="headerlink" title="addAll(Collection c )：将集合插入到链表尾部"></a>addAll(Collection c )：将集合插入到链表尾部</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> addAll(size, c);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="addAll-int-index-Collection-c-：将集合从指定位置开始插入"><a href="#addAll-int-index-Collection-c-：将集合从指定位置开始插入" class="headerlink" title="addAll(int index, Collection c)：将集合从指定位置开始插入"></a>addAll(int index, Collection c)：将集合从指定位置开始插入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-comment">//1:检查index范围是否在size之内</span><br>    checkPositionIndex(index);<br><br>    <span class="hljs-comment">//2:toArray()方法把集合的数据存到对象数组中</span><br>    Object[] a = c.toArray();<br>    <span class="hljs-keyword">int</span> numNew = a.length;<br>    <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">//3：得到插入位置的前驱节点和后继节点</span><br>    Node&lt;E&gt; pred, succ;<br>    <span class="hljs-comment">//如果插入位置为尾部，前驱节点为last，后继节点为null</span><br>    <span class="hljs-keyword">if</span> (index == size) &#123;<br>        succ = <span class="hljs-keyword">null</span>;<br>        pred = last;<br>    &#125;<br>    <span class="hljs-comment">//否则，调用node()方法得到后继节点，再得到前驱节点</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        succ = node(index);<br>        pred = succ.prev;<br>    &#125;<br><br>    <span class="hljs-comment">// 4：遍历数据将数据插入</span><br>    <span class="hljs-keyword">for</span> (Object o : a) &#123;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;<br>        <span class="hljs-comment">//创建新节点</span><br>        Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//如果插入位置在链表头部</span><br>        <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)<br>            first = newNode;<br>        <span class="hljs-keyword">else</span><br>            pred.next = newNode;<br>        pred = newNode;<br>    &#125;<br><br>    <span class="hljs-comment">//如果插入位置在尾部，重置last节点</span><br>    <span class="hljs-keyword">if</span> (succ == <span class="hljs-keyword">null</span>) &#123;<br>        last = pred;<br>    &#125;<br>    <span class="hljs-comment">//否则，将插入的链表与先前链表连接起来</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        pred.next = succ;<br>        succ.prev = pred;<br>    &#125;<br><br>    size += numNew;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面可以看出addAll方法通常包括下面四个步骤：</p><ol><li>检查index范围是否在size之内</li><li>toArray()方法把集合的数据存到对象数组中</li><li>得到插入位置的前驱和后继节点</li><li>遍历数据，将数据插入到指定位置</li></ol><h4 id="addFirst-E-e-：-将元素添加到链表头部"><a href="#addFirst-E-e-：-将元素添加到链表头部" class="headerlink" title="addFirst(E e)： 将元素添加到链表头部"></a>addFirst(E e)： 将元素添加到链表头部</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    linkFirst(e);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>, e, f);<span class="hljs-comment">//新建节点，以头节点为后继节点</span><br>    first = newNode;<br>    <span class="hljs-comment">//如果链表为空，last节点也指向该节点</span><br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>        last = newNode;<br>    <span class="hljs-comment">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span><br>    <span class="hljs-keyword">else</span><br>        f.prev = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="addLast-E-e-：将元素添加到链表尾部，与-add-E-e-方法一样"><a href="#addLast-E-e-：将元素添加到链表尾部，与-add-E-e-方法一样" class="headerlink" title="addLast(E e)：将元素添加到链表尾部，与 add(E e) 方法一样"></a>addLast(E e)：将元素添加到链表尾部，与 <strong>add(E e)</strong> 方法一样</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    linkLast(e);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="get-方法，按索引取数据"><a href="#get-方法，按索引取数据" class="headerlink" title="get()方法，按索引取数据"></a><code>get()</code>方法，按索引取数据</h3><h4 id="get-int-index-：根据指定索引返回数据"><a href="#get-int-index-：根据指定索引返回数据" class="headerlink" title="get(int index)：根据指定索引返回数据"></a>get(int index)：根据指定索引返回数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">//检查index范围是否在size之内</span><br>    checkElementIndex(index);<br>    <span class="hljs-comment">//调用Node(index)去找到index对应的node然后返回它的值</span><br>    <span class="hljs-keyword">return</span> node(index).item;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取头节点（index-0）数据方法"><a href="#获取头节点（index-0）数据方法" class="headerlink" title="获取头节点（index=0）数据方法"></a>获取头节点（index=0）数据方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> f.item;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">element</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getFirst();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : f.item;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : f.item;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>区别：</strong> getFirst(),element(),peek(),peekFirst() 这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null</p><p>其中<strong>getFirst()</strong> 和<strong>element()</strong> 方法将会在链表为空时，抛出异常</p><p>element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出<code>NoSuchElementException</code></p></blockquote><h4 id="获取尾节点（index-1）数据方法"><a href="#获取尾节点（index-1）数据方法" class="headerlink" title="获取尾节点（index=-1）数据方法"></a>获取尾节点（index=-1）数据方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>     <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>     <span class="hljs-keyword">return</span> l.item;<br> &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">return</span> (l == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : l.item;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>区别：</strong> <strong>getLast()</strong> 方法在链表为空时，会抛出<code>NoSuchElementException</code>，而<strong>peekLast()</strong> 则不会，只是会返回 <strong>null</strong>。</p></blockquote><hr><h3 id="indexOf-方法，按数据取索引"><a href="#indexOf-方法，按数据取索引" class="headerlink" title="indexOf()方法，按数据取索引"></a><code>indexOf()</code>方法，按数据取索引</h3><h4 id="int-indexOf-Object-o-：从头遍历找"><a href="#int-indexOf-Object-o-：从头遍历找" class="headerlink" title="int indexOf(Object o)：从头遍历找"></a>int indexOf(Object o)：从头遍历找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//从头遍历</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> index;<br>            index++;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//从头遍历</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item))<br>                <span class="hljs-keyword">return</span> index;<br>            index++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="int-lastIndexOf-Object-o-：从尾遍历找"><a href="#int-lastIndexOf-Object-o-：从尾遍历找" class="headerlink" title="int lastIndexOf(Object o)：从尾遍历找"></a>int lastIndexOf(Object o)：从尾遍历找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = size;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//从尾遍历</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;<br>            index--;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> index;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//从尾遍历</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;<br>            index--;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item))<br>                <span class="hljs-keyword">return</span> index;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="检查链表是否包含某对象"><a href="#检查链表是否包含某对象" class="headerlink" title="检查链表是否包含某对象"></a>检查链表是否包含某对象</h3><h4 id="contains-Object-o-：检查对象o是否存在于链表中"><a href="#contains-Object-o-：检查对象o是否存在于链表中" class="headerlink" title="contains(Object o)：检查对象o是否存在于链表中"></a>contains(Object o)：检查对象o是否存在于链表中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> indexOf(o) != -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h3><h4 id="remove-removeFirst-pop-删除头节点"><a href="#remove-removeFirst-pop-删除头节点" class="headerlink" title="remove() ,removeFirst(),pop(): 删除头节点"></a><strong>remove()</strong> ,removeFirst(),pop(): 删除头节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> removeFirst();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> removeFirst();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br><span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br><span class="hljs-keyword">return</span> unlinkFirst(f);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="removeLast-pollLast-删除尾节点"><a href="#removeLast-pollLast-删除尾节点" class="headerlink" title="removeLast(),pollLast():删除尾节点"></a>removeLast(),pollLast():删除尾节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> unlinkLast(l);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">return</span> (l == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : unlinkLast(l);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>区别：</strong> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p></blockquote><h4 id="remove-Object-o-删除指定元素"><a href="#remove-Object-o-删除指定元素" class="headerlink" title="remove(Object o):删除指定元素"></a>remove(Object o):删除指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-comment">//如果删除对象为null</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//从头开始遍历</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-comment">//找到元素</span><br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//从链表中移除找到的元素</span><br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//从头开始遍历</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-comment">//找到元素</span><br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                <span class="hljs-comment">//从链表中移除找到的元素</span><br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。</p></blockquote><h4 id="unlink-Node-x-方法："><a href="#unlink-Node-x-方法：" class="headerlink" title="unlink(Node x) 方法："></a>unlink(Node x) 方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">E <span class="hljs-title">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> </span>&#123;<br>    <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-keyword">final</span> E element = x.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<span class="hljs-comment">//得到后继节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="hljs-comment">//得到前驱节点</span><br><br>    <span class="hljs-comment">//删除前驱指针</span><br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>) &#123;<br>        first = next;<span class="hljs-comment">//如果删除的节点是头节点,令头节点指向该节点的后继节点</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev.next = next;<span class="hljs-comment">//将前驱节点的后继节点指向后继节点</span><br>        x.prev = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//删除后继指针</span><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>) &#123;<br>        last = prev;<span class="hljs-comment">//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        next.prev = prev;<br>        x.next = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    x.item = <span class="hljs-keyword">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="remove-int-index-：删除指定位置的元素"><a href="#remove-int-index-：删除指定位置的元素" class="headerlink" title="remove(int index)：删除指定位置的元素"></a>remove(int index)：删除指定位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">//检查index范围</span><br>    checkElementIndex(index);<br>    <span class="hljs-comment">//将节点删除</span><br>    <span class="hljs-keyword">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="四、HashMap"><a href="#四、HashMap" class="headerlink" title="四、HashMap"></a>四、HashMap</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。</p><p>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）</p><p>JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时且数组长度大于64，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间，具体可以参考 <code>treeifyBin</code>方法。当移除节点时，红黑树节点个数小于6时，会转换为链表</p><ul><li>键和值的位置都可以为null，但键的位置只能是一个null</li><li>存取无序</li><li>key值唯一</li></ul><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210622153025095.png" alt="image-20210622153025095"></p><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^ ：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。JDK1.7是头插法。多线程扩容时，可能导致循环链表出现</p><blockquote><p><strong>异或</strong>表示当两个数的二进制表示，进行异或运算时，当前位的两个二进制表示不同则为1相同则为0。该方法被广泛推广用来统计一个数的1的位数。</p><p>参与运算的两个值，如果两个相应bit位相同，则结果为0，否则为1。</p></blockquote><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.1.png"></p><h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.2.png"></p><h4 id="红黑树基本介绍"><a href="#红黑树基本介绍" class="headerlink" title="红黑树基本介绍"></a>红黑树基本介绍</h4><p>一种<strong>二叉查找树</strong>，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（<strong>非红即黑</strong>）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保<strong>没有一条路径会比其它路径长出两倍</strong>，因此，红黑树是一种<strong>弱平衡二叉树</strong>（由于是弱平衡，可以看到，<strong>在相同的节点情况下，AVL树的高度低于红黑树）</strong>，相对于要求严格的AVL树来说，它的旋转次数少，所以<strong>对于搜索，插入，删除操作较多的情况下，我们就用红黑树</strong></p><p><strong>性质</strong></p><ul><li>每个节点非红即黑</li><li>根节点（root）是黑的</li><li><strong>不能有两个红色的节点连在一起</strong>（黑色可以）</li><li>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的</li><li>如果一个节点是红的，那么它的两儿子都是黑的</li><li>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点</li><li>每条路径<strong>都包含相同的黑节点</strong></li></ul><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.2.1.png"></p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.2.2.png"></p><p><strong>类的属性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">// 序列号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">362498820763181265L</span>;    <br>    <span class="hljs-comment">// 默认的初始容量是16</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;   <br>    <span class="hljs-comment">// 最大容量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>; <br>    <span class="hljs-comment">// 默认的填充因子</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>; <br>    <span class="hljs-comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">// 桶中结构转化为红黑树对应的table的最小大小</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br>    <span class="hljs-comment">// 存储元素的数组，总是2的幂次倍</span><br>    <span class="hljs-keyword">transient</span> Node&lt;k,v&gt;[] table; <br>    <span class="hljs-comment">// 存放具体元素的集</span><br>    <span class="hljs-keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;<br>    <span class="hljs-comment">// 存放元素的个数，注意这个不等于数组的长度。</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-comment">// 每次扩容和更改map结构的计数器</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;   <br>    <span class="hljs-comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span><br>    <span class="hljs-keyword">int</span> threshold;<br>    <span class="hljs-comment">// 加载因子</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>loadFactor填充因子</strong></p><p>loadFactor填充因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p></li><li><p><strong>threshold</strong></p><p><strong>threshold = capacity * loadFactor</strong>，<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p></li></ul><p><strong>Node节点类源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 继承自 Map.Entry&lt;K,V&gt;</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<span class="hljs-comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span><br>       <span class="hljs-keyword">final</span> K key;<span class="hljs-comment">//键</span><br>       V value;<span class="hljs-comment">//值</span><br>       <span class="hljs-comment">// 指向下一个节点</span><br>       Node&lt;K,V&gt; next;<br>       Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.hash = hash;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br>        <span class="hljs-comment">// 重写hashCode()方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;<br>            V oldValue = value;<br>            value = newValue;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>        <span class="hljs-comment">// 重写 equals() 方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;<br>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>                <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                    Objects.equals(value, e.getValue()))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>树节点类源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// 父</span><br>    TreeNode&lt;K,V&gt; left;    <span class="hljs-comment">// 左</span><br>    TreeNode&lt;K,V&gt; right;   <span class="hljs-comment">// 右</span><br>    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-keyword">boolean</span> red;           <span class="hljs-comment">// 判断颜色</span><br>    TreeNode(<span class="hljs-keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, val, next);<br>    &#125;<br>    <span class="hljs-comment">// 返回根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">root</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="hljs-keyword">this</span>, p;;) &#123;<br>            <span class="hljs-keyword">if</span> ((p = r.parent) == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            r = p;<br>        &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p>HashMap继承关系如下图所示：</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.3.png"></p><p>说明：</p><ul><li>Cloneable 空接口，表示可以克隆。 创建并返回HashMap对象的一个副本。</li><li>Serializable 序列化接口。属于标记性接口。HashMap对象可以被序列化和反序列化。</li><li>AbstractMap 父类提供了Map实现接口。以最大限度地减少实现此接口所需的工作。</li></ul><p>补充：通过上述继承关系我们发现一个很奇怪的现象， 就是HashMap已经继承了AbstractMap而AbstractMap类实现了Map接口，那为什么HashMap还要在实现Map接口呢？同样在ArrayList中LinkedList中都是这种结构</p><blockquote><p>据 java 集合框架的创始人Josh Bloch描述，这样的写法是一个失误。在java集合框架中，类似这样的写法很多，最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改，所以就这样存在下来了。</p></blockquote><hr><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap 中有四个构造方法，它们分别如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认构造函数。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all   other fields defaulted</span><br>    <span class="hljs-comment">//此时没有创建数组</span><br>&#125;<br><br><span class="hljs-comment">// 包含另一个“Map”的构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-keyword">false</span>);<span class="hljs-comment">//下面会分析到这个方法</span><br>&#125;<br><br><span class="hljs-comment">// 指定“容量大小”的构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-comment">// 指定“容量大小”和“加载因子”的构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="hljs-comment">//之后会在put方法中重新计算边界值</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>putMapEntries方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> s = m.size();<br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断table是否已经初始化</span><br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// pre-size</span><br>            <span class="hljs-comment">// 未初始化，s为m的实际元素个数</span><br>            <span class="hljs-keyword">float</span> ft = ((<span class="hljs-keyword">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>; <span class="hljs-comment">// s/loadFactor的结果是小数，加1.0F与(int)ft相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少resize的调用次数。即，加一是为了尽量减少扩容可能性</span><br>            <span class="hljs-keyword">int</span> t = ((ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY) ?<br>                    (<span class="hljs-keyword">int</span>)ft : MAXIMUM_CAPACITY);<br>            <span class="hljs-comment">// 计算得到的t大于阈值，则初始化阈值</span><br>            <span class="hljs-keyword">if</span> (t &gt; threshold)<br>                threshold = tableSizeFor(t);<br>        &#125;<br>        <span class="hljs-comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)<br>            resize();<br>        <span class="hljs-comment">// 将m中的所有元素添加至HashMap中</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;<br>            K key = e.getKey();<br>            V value = e.getValue();<br>            putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, evict);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p><p><strong>对putVal方法添加元素的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素，就直接插入。</li><li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ul><p>ps:下图有一个小问题：直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行。</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.4.png"></p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.5.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1）transient Node&lt;K,V&gt;[] table; 表示存储Map集合中元素的数组。</span><br><span class="hljs-comment">    2）(tab = table) == null 表示将空的table赋值给tab,然后判断tab是否等于null，第一次肯定是null</span><br><span class="hljs-comment">    3）(n = tab.length) == 0 表示将数组的长度0赋值给n,然后判断n是否等于0，n等于0</span><br><span class="hljs-comment">    由于if判断使用双或，满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化。</span><br><span class="hljs-comment">    并将初始化好的数组长度赋值给n.</span><br><span class="hljs-comment">    4）执行完n = (tab = resize()).length，数组tab每个空间都是null</span><br><span class="hljs-comment">    */</span><br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-comment">// 将第一个元素赋值给e，用e来记录</span><br>            e = p;<br>        <span class="hljs-comment">// hash值不相等，即key不相等；为红黑树结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值，转化为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <br>            <span class="hljs-comment">// 记录e的value</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//修改记录次数</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure><p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p><p><strong>对于put方法的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用<strong>头插法</strong>插入元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span></span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(table == EMPTY_TABLE)</span> </span>&#123; <br>    inflateTable(threshold); <br>&#125;  <br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> putForNullKey(value);<br>    <span class="hljs-keyword">int</span> hash = hash(key);<br>    <span class="hljs-keyword">int</span> i = indexFor(hash, table.length);<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123; <span class="hljs-comment">// 先遍历</span><br>        Object k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<br>            V oldValue = e.value;<br>            e.value = value;<br>            e.recordAccess(<span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue; <br>        &#125;<br>    &#125;<br><br>    modCount++;<br>    addEntry(hash, key, value, i);  <span class="hljs-comment">// 再插入</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="将链表转换为红黑树的treeifyBin方法"><a href="#将链表转换为红黑树的treeifyBin方法" class="headerlink" title="将链表转换为红黑树的treeifyBin方法"></a>将链表转换为红黑树的treeifyBin方法</h3><p>节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树，转换红黑树的方法  treeifyBin，整体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>   <span class="hljs-comment">//转换为红黑树 tab表示数组名  hash表示哈希值</span><br>   treeifyBin(tab, hash);<br></code></pre></td></tr></table></figure><p>treeifyBin方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Replaces all linked nodes in bin at index for given hash unless</span><br><span class="hljs-comment"> * table is too small, in which case resizes instead.</span><br><span class="hljs-comment">   替换指定哈希表的索引处桶中的所有链接节点，除非表太小，否则将修改大小。</span><br><span class="hljs-comment">   Node&lt;K,V&gt;[] tab = tab 数组名</span><br><span class="hljs-comment">   int hash = hash表示哈希值</span><br><span class="hljs-comment">*/</span><br>  <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">      如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64),</span><br><span class="hljs-comment">      就去扩容。而不是将节点变为红黑树。</span><br><span class="hljs-comment">      目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，那么重新计算哈希值</span><br><span class="hljs-comment">      ，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。</span><br><span class="hljs-comment">      */</span><br>      <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>          <span class="hljs-comment">//扩容方法</span><br>          resize();<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">          1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化</span><br><span class="hljs-comment">          2）e = tab[index = (n - 1) &amp; hash]表示将数组中的元素取出赋值给e,e是哈希表中指定位置桶里的链表节点，从第一个开始</span><br><span class="hljs-comment">          */</span><br>          <span class="hljs-comment">//hd：红黑树的头结点   tl :红黑树的尾结点</span><br>          TreeNode&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;<br>          <span class="hljs-keyword">do</span> &#123;<br>              <span class="hljs-comment">//新创建一个树的节点，内容和当前链表节点e一致</span><br>              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-keyword">null</span>);<br>              <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)<br>                  <span class="hljs-comment">//将新创键的p节点赋值给红黑树的头结点</span><br>                  hd = p;<br>              <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                   p.prev = tl：将上一个节点p赋值给现在的p的前一个节点</span><br><span class="hljs-comment">                   tl.next = p;将现在节点p作为树的尾结点的下一个节点</span><br><span class="hljs-comment">                  */</span><br>                  p.prev = tl;<br>                  tl.next = p;<br>              &#125;<br>              tl = p;<br>              <span class="hljs-comment">/*</span><br><span class="hljs-comment">              e = e.next 将当前节点的下一个节点赋值给e,如果下一个节点不等于null</span><br><span class="hljs-comment">              则回到上面继续取出链表中节点转换为红黑树</span><br><span class="hljs-comment">              */</span><br>          &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">          让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树</span><br><span class="hljs-comment">          而不是链表数据结构了</span><br><span class="hljs-comment">          */</span><br>          <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-keyword">null</span>)<br>              hd.treeify(tab);<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>小结：上述操作一共做了如下几件事：</p><p>1.根据哈希表中元素个数确定是扩容还是树形化</p><p>2.如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</p><p>3.然后让桶中的第一个元素指向新创建的树根节点，替换桶的链表内容为树形化内容</p><hr><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 数组元素相等</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">// 桶中不止一个节点</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中get</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-comment">// 在链表中get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>小结：</p><p>1.get方法实现的步骤：</p><p>​    1）通过hash值获取该key映射到的桶</p><p>​    2）桶上的key就是要查找的key,则直接找到并返回</p><p>​    3）桶上的key不是要找的key,则查看后续的节点：</p><p>​            a:如果后续节点是红黑树节点，通过调用红黑树的方法根据key获取value</p><p>​            b:如果后续节点是链表节点，则通过循环遍历链表根据key获取value </p><p>2.上述红黑树节点调用的是getTreeNode方法通过树形节点的find方法进行查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">getTreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k)</span> </span>&#123;<br>           <span class="hljs-keyword">return</span> ((parent != <span class="hljs-keyword">null</span>) ? root() : <span class="hljs-keyword">this</span>).find(h, k, <span class="hljs-keyword">null</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;<br>           TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">this</span>;<br>           <span class="hljs-keyword">do</span> &#123;<br>               <span class="hljs-keyword">int</span> ph, dir; K pk;<br>               TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;<br>               <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)<br>                   p = pl;<br>               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>                   p = pr;<br>               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pk = p.key) == k || (k != <span class="hljs-keyword">null</span> &amp;&amp; k.equals(pk)))<br>                   <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//找到之后直接返回</span><br>               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pl == <span class="hljs-keyword">null</span>)<br>                   p = pr;<br>               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pr == <span class="hljs-keyword">null</span>)<br>                   p = pl;<br>               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc != <span class="hljs-keyword">null</span> ||<br>                         (kc = comparableClassFor(k)) != <span class="hljs-keyword">null</span>) &amp;&amp;<br>                        (dir = compareComparables(kc, k, pk)) != <span class="hljs-number">0</span>)<br>                   p = (dir &lt; <span class="hljs-number">0</span>) ? pl : pr;<br>               <span class="hljs-comment">//递归查找</span><br>               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="hljs-keyword">null</span>)<br>                   <span class="hljs-keyword">return</span> q;<br>               <span class="hljs-keyword">else</span><br>                   p = pl;<br>           &#125; <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>);<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>       &#125;<br></code></pre></td></tr></table></figure><p>3.查找红黑树，由于之前添加时已经保证这个树是有序的了，因此查找时基本就是折半查找，效率更高。</p><p>4.这里和插入时一样，如果对比节点的哈希值和要查找的哈希值相等，就会判断key是否相等，相等就直接返回。不相等就从子树中递归查找。</p><p>5.若为树，则在树中通过key.equals(k)查找，O(logn) </p><p>​    若为链表，则在链表中通过key.equals(k)查找，O(n)。</p><hr><h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    <span class="hljs-comment">//得到当前数组</span><br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-comment">//如果当前数组等于null长度返回0，否则返回当前数组的长度</span><br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-comment">//当前阀值点 默认是12(16*0.75)</span><br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//如果老的数组长度大于0</span><br>    <span class="hljs-comment">//开始计算扩容后的大小</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            <span class="hljs-comment">//修改阈值为int的最大值</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的2倍</span><br>        <span class="hljs-comment">// 1)(newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量</span><br>        <span class="hljs-comment">// 2）oldCap &gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-comment">//阈值扩大一倍</span><br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-comment">//老阈值点大于0 直接赋值</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold，老阈值赋值给新的数组长度</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 直接使用默认值</span><br>        <span class="hljs-comment">// signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<span class="hljs-comment">//16</span><br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-comment">// 计算新的resize上限</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    <span class="hljs-comment">//新的阀值 默认原来是12 乘以2之后变为24</span><br>    threshold = newThr;<br>    <span class="hljs-comment">//创建新的哈希表</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    <span class="hljs-comment">//newCap是新的数组长度--》32</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;<br>    <span class="hljs-comment">//判断旧数组是否等于空</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 把每个bucket都移动到新的buckets中</span><br>        <span class="hljs-comment">//遍历旧的哈希表的每个桶，重新计算桶里元素的新位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//原来的数据赋值为null 便于GC回收</span><br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-comment">//判断数组是否有下一个引用</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-comment">//没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                 <span class="hljs-comment">//判断是否是红黑树</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                     <span class="hljs-comment">//说明是红黑树来处理冲突的，则调用相关方法把树分开</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 采用链表处理冲突</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-comment">//来计算节点的新位置</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        <span class="hljs-comment">// 原索引</span><br>                        next = e.next;<br>                        <span class="hljs-comment">//这里来判断如果等于true e这个节点在resize之后不需要移动位置</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 原索引+oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 原索引放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 原索引+oldCap放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。</strong></p><p><strong>图解扩容对链表的重构</strong></p><ul><li>比如哈希表中桶的个数是4个，其中0、4、8、12因为低两位都是0，与 4-1=3(11) 进行按位与后，都被放在了第一个桶中</li></ul><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.6.png"></p><ul><li>然后开始了扩容操作。将元素<strong>哈希值按位与旧容量（不是旧容量-1）</strong>为0的放在lo链表中，不为0的放在hi链表中</li></ul><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.7.png"></p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.8.png"></p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.9.png"></p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.10.png"></p><ul><li>遍历链表，将lo中的放在原来的桶中，hi中的放在增加的桶中</li></ul><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.11.png"></p><p><strong>总结</strong>：</p><ul><li><p>先将原桶中的元素的</p><p>hash值与旧容量进行按位与操作</p><ul><li>如果结果为0，就放入lo链表中</li><li>如果结果不为0，就放入hi链表中</li></ul></li><li><p>lo链表中的元素继续放在新的哈希表中原来的位置</p></li><li><p>hi链表中的元素放在新的哈希表中，扩容后相对于原来的位置上(j+oldCap)</p><ul><li><strong>两个桶之间的间隔数就为增加原来哈希表的容量</strong></li></ul></li></ul><p><strong>好处</strong></p><ul><li>顺序放入，减少了发生死锁的几率</li><li>使得元素<strong>相对均匀</strong>地存在于哈希表中</li></ul><hr><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><p>首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于6的时候要转链表。 </p><p>删除remove方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//remove方法的具体实现在removeNode方法中，所以我们重点看下removeNode方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) == <span class="hljs-keyword">null</span> ?<br>        <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br></code></pre></td></tr></table></figure><p> removeNode方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, index;<br>    <span class="hljs-comment">//根据hash找到位置 </span><br>    <span class="hljs-comment">//如果当前key映射到的桶不为空</span><br>        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>            (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>            Node&lt;K,V&gt; node = <span class="hljs-keyword">null</span>, e; K k; V v;<br>            <span class="hljs-comment">//如果桶上的节点就是要找的key，则将node指向该节点</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                node = p;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//说明节点存在下一个节点</span><br>                <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-comment">//说明是以红黑树来处理的冲突，则获取红黑树要删除的节点</span><br>                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//判断是否以链表方式处理hash冲突，是的话则通过遍历链表来寻找要删除的节点</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                            ((k = e.key) == key ||<br>                             (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                            node = e;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        p = e;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//比较找到的key的value和要删除的是否匹配</span><br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                                 (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;<br>                <span class="hljs-comment">//通过调用红黑树的方法来删除节点</span><br>                <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>                    <span class="hljs-comment">//链表删除</span><br>                    tab[index] = node.next;<br>                <span class="hljs-keyword">else</span><br>                    p.next = node.next;<br>                <span class="hljs-comment">//记录修改次数</span><br>                ++modCount;<br>                <span class="hljs-comment">//变动的数量</span><br>                --size;<br>                afterNodeRemoval(node);<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="当两个对象的hashCode相等时会怎么样"><a href="#当两个对象的hashCode相等时会怎么样" class="headerlink" title="当两个对象的hashCode相等时会怎么样"></a>当两个对象的hashCode相等时会怎么样</h3><p>会发生哈希碰撞，若key相同，则替换旧的value，若key不同，插入到链表（尾插法）/红黑树中</p><h3 id="集合容量设置不是二的n次幂会怎么样"><a href="#集合容量设置不是二的n次幂会怎么样" class="headerlink" title="集合容量设置不是二的n次幂会怎么样"></a>集合容量设置不是二的n次幂会怎么样</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终会在<code>tableSizeFor</code>方法中，返回大于等于这个值的一个2的n次方的值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">假设输入的大小是cap=10</span><br><br>    <span class="hljs-string">int</span> <span class="hljs-string">n</span> <span class="hljs-string">=</span> <span class="hljs-string">cap</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1</span><span class="hljs-string">;</span><br>    <span class="hljs-string">n</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1</span> <span class="hljs-string">=</span> <span class="hljs-number">9</span><br>    <br>    <span class="hljs-string">n</span> <span class="hljs-string">|=</span> <span class="hljs-string">n</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-number">1</span><span class="hljs-string">;</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">1001</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0100</span><br>    <span class="hljs-string">---------------------------------------</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">1101</span><br>    <br>    <span class="hljs-string">n</span> <span class="hljs-string">|=</span> <span class="hljs-string">n</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-number">2</span><span class="hljs-string">;</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">1101</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0011</span><br>    <span class="hljs-string">---------------------------------------</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">1111</span><br>    <br>    <span class="hljs-string">n</span> <span class="hljs-string">|=</span> <span class="hljs-string">n</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">;</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">1111</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br>    <span class="hljs-string">---------------------------------------</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">1111</span><br>    <br>    <span class="hljs-string">n</span> <span class="hljs-string">|=</span> <span class="hljs-string">n</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-number">8</span><span class="hljs-string">;</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">1111</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br>    <span class="hljs-string">---------------------------------------</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">1111</span><br>    <br>    <span class="hljs-string">n</span> <span class="hljs-string">|=</span> <span class="hljs-string">n</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-number">16</span><span class="hljs-string">;</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">1111</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br>    <span class="hljs-string">---------------------------------------</span><br>    <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">1111</span><br>    <br><span class="hljs-string">此时n为15，return</span> <span class="hljs-number">15</span><span class="hljs-string">+1=16</span>    <br></code></pre></td></tr></table></figure><h3 id="集合容量为什么要设置成二的n次幂"><a href="#集合容量为什么要设置成二的n次幂" class="headerlink" title="集合容量为什么要设置成二的n次幂"></a>集合容量为什么要设置成二的n次幂</h3><p>要回答这个问题，我们需要先看看哈希表中一个重要的方法：<strong>static int indexFor(int h, int length)<strong>，该方法会根据插入元素的哈希值</strong>决定该元素应该被放在桶中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>        <span class="hljs-comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br>        <span class="hljs-comment">// 将传入的哈希值与其长度-1进行按位与操作，并返回其结果</span><br>        <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道，哈希表的致命缺点是发生<strong>哈希碰撞</strong>，也就是<strong>多个哈希值相同的元素被放置到了同一个桶中</strong></p><p>想要尽量避免发生哈希碰撞，分别分到不同的桶中，<strong>h &amp; (length-1)</strong> 就是这样一个操作，<strong>根据元素的哈希值和哈希表的长度-1来按位与</strong>，并且与运算的速度快，效率高</p><p>当哈希表的大小为2的幂时，我们拿16来举例，它的二进制表示是 <strong>10000</strong> ， 让其<strong>长度-1</strong>后就是 <strong>1111</strong>，全部都是1</p><p>我们知道，当<strong>一个二进制数与全为1的数进行按位与时，其结果就是该数本身并且小于等于桶的最大数量</strong>。这样一来，只要数不同，那么他们按位与下来的值也就不同了，所以我们需要哈希表的容量为2的幂</p><p><strong>总结</strong>：为了之后进行<strong>按位与</strong>操作，加快计算效率</p><p><strong>为什么使用位运算，而不是直接取模？</strong></p><p><strong>位运算(&amp;)效率要比代替取模运算(%)高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</strong></p><h3 id="为什么Map桶中节点个数超过8才转为红黑树"><a href="#为什么Map桶中节点个数超过8才转为红黑树" class="headerlink" title="为什么Map桶中节点个数超过8才转为红黑树"></a>为什么Map桶中节点个数超过8才转为红黑树</h3><p>当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是随便决定的，而是根据概率统计决定的。</p><p>因为树节点的大小大约是普通节点的两倍，理想情况下，节点分布概率遵循泊松分布。当为8时的概率已经很小了</p><h3 id="当链表的值小于几会从红黑树转回链表"><a href="#当链表的值小于几会从红黑树转回链表" class="headerlink" title="当链表的值小于几会从红黑树转回链表"></a>当链表的值小于几会从红黑树转回链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当桶(bucket)上的结点数小于这个值时树转链表</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><h3 id="JDK-1-8中对hash算法和寻址算法是如何优化的？"><a href="#JDK-1-8中对hash算法和寻址算法是如何优化的？" class="headerlink" title="JDK 1.8中对hash算法和寻址算法是如何优化的？"></a>JDK 1.8中对hash算法和寻址算法是如何优化的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK 1.8以后的HashMap的一段源码</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-keyword">return</span> (key==<span class="hljs-keyword">null</span>)?<span class="hljs-number">0</span>:(h=key.hashCode())^(h&gt;&gt;&gt;<span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>比如说，有一个key的hash值</p><p>1111 1111 1111 1111 1111 1010 0111 1100</p><p>先右移16位，得到</p><p>0000 0000 0000 0000 1111 1111 1111 1111 </p><p>将两个数据进行异或运算（即，让原始数据的高16位和低16位进行异或运算），得到</p><p>1111 1111 1111 1111 0000 0101 1000 0011</p><p>再转换成int值，返回</p><p><strong>为什么要这样做呢，和寻址算法有关，希望运算后低16位中，保留了低16位和高16位的特征</strong>，降低hash冲突的概率</p><h3 id="寻址算法优化"><a href="#寻址算法优化" class="headerlink" title="寻址算法优化"></a>寻址算法优化</h3><p>(n-1) &amp; hash -&gt; 算出数组里的一个位置</p><ul><li>因为**(n-1) &amp; hash**的效果是和将hash对n的取模，效果是一样的，但是运算性能比取模要好很多</li></ul><p>1111 1111 1111 1111 1111 1010 0111 1100（没有经过优化的hash值）</p><p>0000 0000 0000 0000 0000 0000 0000 0111（n-1，即16-1=15）</p><p>二者进行与运算</p><p>0000 0000 0000 0000 0000 0000 0000 0100</p><p>直接这样运算，高16位的运算是可以忽略的，核心在于低16位运算，hash值的高16位没有参与运算</p><p>假设有两个hash值</p><p>1111 1111 1111 1111 1111 1010 0111 1100 -&gt;高低16位进行异或，1111 1111 1111 1111 0000 0101 1000 0011    </p><p>1111 1111 1111 1110 1111 1010 0111 1100 -&gt;高低16位进行异或，1111 1111 1111 1110 0000 0101 1000 0010</p><p>这样优化后算出来的低16位，保留了低16位和高16位的特征</p><p>1111 1111 1111 1111 0000 0101 1000 0011（经过优化和二进制运算后的新的hash值）</p><p>0000 0000 0000 0000 0000 0000 0000 0111（n-1，即16-1=15）</p><p>二者进行与运算</p><p>0000 0000 0000 0000 0000 0000 0000 0011</p><p>直接这样运算，高16位的运算是可以忽略的，核心在于低16位运算，hash值的高16位没有参与运算</p><h3 id="扩容算法优化"><a href="#扩容算法优化" class="headerlink" title="扩容算法优化"></a>扩容算法优化</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 </p><p>HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n-1)&amp;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到”<strong>原位置+旧容量</strong>“这个位置。</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/4.62.png"></p><p>正是因为这样巧妙的rehash方式，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，在resize的过程中保证了rehash之后每个桶上的节点数一定小于等于原来桶上的节点数，保证了rehash之后不会出现更严重的hash冲突，均匀的把之前的冲突的节点分散到新的桶中了。</p><h3 id="JDK1-8，多线程下HashMap不安全的问题"><a href="#JDK1-8，多线程下HashMap不安全的问题" class="headerlink" title="JDK1.8，多线程下HashMap不安全的问题"></a>JDK1.8，多线程下HashMap不安全的问题</h3><ul><li>多个线程在同一个hash桶中添加元素时，可能出现数据丢失</li><li>size计算时，使用的++size不是原子操作</li></ul><h3 id="JDK1-7，多线程下HashMap不安全的问题"><a href="#JDK1-7，多线程下HashMap不安全的问题" class="headerlink" title="JDK1.7，多线程下HashMap不安全的问题"></a>JDK1.7，多线程下HashMap不安全的问题</h3><ul><li>扩容的时候、链表的元素发生倒置。在多线程进行扩容的时候、就会导致循环链表</li></ul><p>假设一个HashMap已经到了Resize的临界点。此时有两个线程A和B，在同一时刻对HashMap进行Put操作</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727115128959.png" alt="image-20210727115128959"></p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727115210752.png" alt="image-20210727115210752"></p><p>此时达到Resize条件，两个线程各自进行Rezie的第一步，也就是扩容</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727115300441.png" alt="image-20210727115300441"></p><p>这时候，两个线程都走到了ReHash的步骤。让我们回顾一下ReHash的代码：</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727115355309.png" alt="image-20210727115355309"></p><p>假如此时线程B遍历到Entry3对象，刚执行完红框里的这行代码，线程就被挂起。对于线程B来说：</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727115544544.png" alt="image-20210727115544544"></p><p>这时候线程A畅通无阻地进行着Rehash，当ReHash完成后，结果如下（图中的e和next，代表线程B的两个引用）：</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727115625349.png" alt="image-20210727115625349"></p><p>直到这一步，看起来没什么毛病。接下来线程B恢复，继续执行属于它自己的ReHash。线程B刚才的状态是：</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727115716859.png" alt="image-20210727115716859"></p><p>当执行到上面这一行时，显然 i = 3，因为刚才线程A对于Entry3的hash结果也是3。</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727115812289.png" alt="image-20210727115812289"></p><p>我们继续执行到这两行，Entry3放入了线程B的数组下标为3的位置，并且e指向了Entry2。此时e和next的指向如下：</p><p>e = Entry2</p><p>next = Entry2</p><p>整体情况如图所示：</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727115855718.png" alt="image-20210727115855718"></p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727120153222.png" alt="image-20210727120153222"></p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727120221388.png" alt="image-20210727120221388"></p><p>接下来执行下面的三行，用头插法把Entry2插入到了线程B的数组的头结点：</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727120308129.png" alt="image-20210727120308129"></p><p>整体情况如图所示：</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727120348292.png" alt="image-20210727120348292"></p><p>第三次循环开始，又执行到红框的代码：</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727120435948.png" alt="image-20210727120435948"></p><p>e = Entry3</p><p>next = Entry3.next = null</p><p>最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727120500276.png" alt="image-20210727120500276"></p><p>newTable[i] = Entry2</p><p>e = Entry3</p><p>Entry2.next = Entry3</p><p>Entry3.next = Entry2</p><p>链表出现了环形！</p><p>整体情况如图所示：</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210727120552282.png" alt="image-20210727120552282"></p><p>此时，问题还没有直接产生。当调用Get查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！</p><hr><h1 id="五、ConcurrentHashMap"><a href="#五、ConcurrentHashMap" class="headerlink" title="五、ConcurrentHashMap"></a>五、ConcurrentHashMap</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><h2 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>Java 7 中 ConcurrentHashMap 的存储结构如图，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦<strong>初始化就不能改变</strong>，默认 Segment 的个数是 16 个，也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。</p><ul><li>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的</li><li>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且<strong>不是懒惰初始化</strong></li></ul><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/5.1.png"></p><p>在 jdk 1.7 中，ConcurrentHashMap 是由 Segment 数据结构和 HashEntry 数组结构构成，采取分段锁来保证安全性。Segment 是 ReentrantLock 重入锁，在 ConcurrentHashMap 中扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，Segment 的结构和 HashMap 类似，是一个数组和链表结构。</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210413101541141.png" alt="image-20210413101541141"></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>通过 ConcurrentHashMap 的无参构造探寻 ConcurrentHashMap 的初始化流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a new, empty map with a default initial capacity (16),</span><br><span class="hljs-comment"> * load factor (0.75) and concurrencyLevel (16).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);<br>&#125;<br></code></pre></td></tr></table></figure><p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 默认初始化容量</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 默认负载因子</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 默认并发级别</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="hljs-number">16</span>;<br></code></pre></td></tr></table></figure><p>接着看下这个有参构造函数的内部实现逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity,<span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">int</span> concurrencyLevel)</span> </span>&#123;<br>    <span class="hljs-comment">// 参数校验</span><br>    <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span><br>    <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)<br>        concurrencyLevel = MAX_SEGMENTS;<br>    <span class="hljs-comment">// Find power-of-two sizes best matching arguments</span><br>    <span class="hljs-comment">// 2的多少次方</span><br>    <span class="hljs-keyword">int</span> sshift = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> ssize = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span><br>    <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;<br>        ++sshift;<br>        ssize &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 记录段偏移量,默认是 32 - 4 = 28</span><br>    <span class="hljs-keyword">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;<br>    <span class="hljs-comment">// 记录段掩码,默认是 15 即 0000 0000 0000 1111</span><br>    <span class="hljs-keyword">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 设置容量</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span><br>    <span class="hljs-keyword">int</span> c = initialCapacity / ssize;<br>    <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)<br>        ++c;<br>    <span class="hljs-keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;<br>    <span class="hljs-comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span><br>    <span class="hljs-keyword">while</span> (cap &lt; c)<br>        cap &lt;&lt;= <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// create segments and segments[0]</span><br>    <span class="hljs-comment">// 创建 Segment 数组，设置 segments[0]</span><br>    Segment&lt;K,V&gt; s0 = <span class="hljs-keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="hljs-keyword">int</span>)(cap * loadFactor),<br>                         (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> HashEntry[cap]);<br>    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Segment[ssize];<br>    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="hljs-comment">// ordered write of segments[0]</span><br>    <span class="hljs-keyword">this</span>.segments = ss;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。</p><ol><li>必要参数校验。</li><li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无惨构造<strong>默认值是 16.</strong></li><li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li><li>记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li><li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15.</li><li><strong>初始化 segments[0]<strong>，</strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75=1.5</strong>，插入第二个值时才会进行扩容。</li></ol><hr><h3 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Maps the specified key to the specified value in this table.</span><br><span class="hljs-comment"> * Neither the key nor the value can be null.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span><br><span class="hljs-comment"> * with a key that is equal to the original key.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key key with which the specified value is to be associated</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value value to be associated with the specified key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><br><span class="hljs-comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified key or value is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    Segment&lt;K,V&gt; s;<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">int</span> hash = hash(key);<br>    <span class="hljs-comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span><br>    <span class="hljs-comment">// 其实也就是把高4位与segmentMask（1111）做与运算,计算出 segment 下标</span><br>    <span class="hljs-keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<br>    <span class="hljs-comment">// 获得 segment 对象, 判断是否为 null, 是则创建该 segment</span><br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="hljs-comment">// nonvolatile; recheck</span><br>         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-keyword">null</span>) <span class="hljs-comment">//  in ensureSegment</span><br>        <span class="hljs-comment">// 这时不能确定是否真的为 null, 因为其它线程也发现该 segment 为 null,</span><br><span class="hljs-comment">// 因此在 ensureSegment 里用 cas 方式保证该 segment 安全性</span><br>        s = ensureSegment(j);<br>    <span class="hljs-comment">// 进入 segment 的put 流程</span><br>    <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the segment for the given index, creating it and</span><br><span class="hljs-comment"> * recording in segment table (via CAS) if not already present.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k the index</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the segment</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Segment&lt;K,V&gt; <span class="hljs-title">ensureSegment</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="hljs-keyword">this</span>.segments;<br>    <span class="hljs-keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="hljs-comment">// raw offset</span><br>    Segment&lt;K,V&gt; seg;<br>    <span class="hljs-comment">// 判断 u 位置的 Segment 是否为null</span><br>    <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="hljs-keyword">null</span>) &#123;<br>        Segment&lt;K,V&gt; proto = ss[<span class="hljs-number">0</span>]; <span class="hljs-comment">// use segment 0 as prototype</span><br>        <span class="hljs-comment">// 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span><br>        <span class="hljs-keyword">int</span> cap = proto.table.length;<br>        <span class="hljs-comment">// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span><br>        <span class="hljs-keyword">float</span> lf = proto.loadFactor;<br>        <span class="hljs-comment">// 计算扩容阀值</span><br>        <span class="hljs-keyword">int</span> threshold = (<span class="hljs-keyword">int</span>)(cap * lf);<br>        <span class="hljs-comment">// 创建一个 cap 容量的 HashEntry 数组</span><br>        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> HashEntry[cap];<br>        <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// recheck</span><br>            <span class="hljs-comment">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span><br>            Segment&lt;K,V&gt; s = <span class="hljs-keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);<br>            <span class="hljs-comment">// 自旋检查 u 位置的 Segment 是否为null</span><br>            <span class="hljs-keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                   == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 使用CAS 赋值，只会成功一次</span><br>                <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="hljs-keyword">null</span>, seg = s))<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> seg;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的源码分析了 ConcurrentHashMap 在 put 一个数据时的处理流程，下面梳理下具体流程。</p><ol><li><p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p></li><li><p>如果指定位置的 Segment 为空，则初始化这个 Segment.</p><p><strong>初始化 Segment 流程：</strong></p><ol><li>检查计算得到的位置的 Segment 是否为null.</li><li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li><li>再次检查计算得到的指定位置的 Segment 是否为null.</li><li>使用创建的 HashEntry 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li></ol></li><li><p>Segment.put 插入 key,value 值。</p></li></ol><p>上面探究了获取 Segment 段和初始化 Segment 段的操作。最后一行的 Segment 的 put 方法还没有查看，继续分析。</p><p>segment 继承了可重入锁（ReentrantLock）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, <span class="hljs-keyword">int</span> hash, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span><br>    <span class="hljs-comment">// 如果是多核 cpu 最多 tryLock 64 次, 进入 lock 流程,在尝试期间, 还可以顺便看该节点在链表中有没有, 如果没有顺便创建出来</span><br>    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="hljs-keyword">null</span> : scanAndLockForPut(key, hash, value);<br>    <br>    <span class="hljs-comment">// 执行到这里 segment 已经被成功加锁, 可以安全执行</span><br>    V oldValue;<br>    <span class="hljs-keyword">try</span> &#123;<br>        HashEntry&lt;K,V&gt;[] tab = table;<br>        <span class="hljs-comment">// 计算要put的数据位置</span><br>        <span class="hljs-keyword">int</span> index = (tab.length - <span class="hljs-number">1</span>) &amp; hash;<br>        <span class="hljs-comment">// CAS 获取 index 坐标的值</span><br>        HashEntry&lt;K,V&gt; first = entryAt(tab, index);<br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span><br>                K k;<br>                <span class="hljs-keyword">if</span> ((k = e.key) == key ||<br>                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;<br>                    oldValue = e.value;<br>                    <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;<br>                        e.value = value;<br>                        ++modCount;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                e = e.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span><br>                <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>                    node.setNext(first);<br>                <span class="hljs-keyword">else</span><br>                    node = <span class="hljs-keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);<br>                <span class="hljs-keyword">int</span> c = count + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span><br>                <span class="hljs-keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)<br>                    rehash(node);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span><br>                    setEntryAt(tab, index, node);<br>                ++modCount;<br>                count = c;<br>                oldValue = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li><p>tryLock() 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p></li><li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p><p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p><ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接头插法插入。</li></ol><p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p><ol><li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li><li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接链表头插法插入。</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p></li></ol><p>这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> HashEntry&lt;K,V&gt; <span class="hljs-title">scanAndLockForPut</span><span class="hljs-params">(K key, <span class="hljs-keyword">int</span> hash, V value)</span> </span>&#123;<br>    HashEntry&lt;K,V&gt; first = entryForHash(<span class="hljs-keyword">this</span>, hash);<br>    HashEntry&lt;K,V&gt; e = first;<br>    HashEntry&lt;K,V&gt; node = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> retries = -<span class="hljs-number">1</span>; <span class="hljs-comment">// negative while locating node</span><br>    <span class="hljs-comment">// 自旋获取锁</span><br>    <span class="hljs-keyword">while</span> (!tryLock()) &#123;<br>        HashEntry&lt;K,V&gt; f; <span class="hljs-comment">// to recheck first below</span><br>        <span class="hljs-keyword">if</span> (retries &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// speculatively create node</span><br>                    node = <span class="hljs-keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>);<br>                retries = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.equals(e.key))<br>                retries = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                e = e.next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;<br>            <span class="hljs-comment">// 自旋达到指定次数后，阻塞等到只到获取到锁</span><br>            lock();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((retries &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp;<br>                 (f = entryForHash(<span class="hljs-keyword">this</span>, hash)) != first) &#123;<br>            e = first = f; <span class="hljs-comment">// re-traverse if entry changed</span><br>            retries = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容 rehash"></a>扩容 rehash</h3><p>rehash发生在 put 中，因为此时已经获得了锁，因此 rehash 时不需要考虑线程安全</p><p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rehash</span><span class="hljs-params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;<br>    HashEntry&lt;K,V&gt;[] oldTable = table;<br>    <span class="hljs-comment">// 老容量</span><br>    <span class="hljs-keyword">int</span> oldCapacity = oldTable.length;<br>    <span class="hljs-comment">// 新容量，扩大两倍</span><br>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 新的扩容阀值 </span><br>    threshold = (<span class="hljs-keyword">int</span>)(newCapacity * loadFactor);<br>    <span class="hljs-comment">// 创建新的数组</span><br>    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="hljs-keyword">new</span> HashEntry[newCapacity];<br>    <span class="hljs-comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span><br>    <span class="hljs-keyword">int</span> sizeMask = newCapacity - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; oldCapacity ; i++) &#123;<br>        <span class="hljs-comment">// 遍历老数组</span><br>        HashEntry&lt;K,V&gt; e = oldTable[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            HashEntry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-comment">// 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span><br>            <span class="hljs-keyword">int</span> idx = e.hash &amp; sizeMask;<br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)   <span class="hljs-comment">//  Single node on list</span><br>                <span class="hljs-comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span><br>                newTable[idx] = e;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Reuse consecutive sequence at same slot</span><br>                <span class="hljs-comment">// 如果是链表了</span><br>                HashEntry&lt;K,V&gt; lastRun = e;<br>                <span class="hljs-keyword">int</span> lastIdx = idx;<br>                <span class="hljs-comment">// 新的位置只可能是不便或者是老的位置+老的容量。</span><br>                <span class="hljs-comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span><br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="hljs-keyword">null</span>; last = last.next) &#123;<br>                    <span class="hljs-keyword">int</span> k = last.hash &amp; sizeMask;<br>                    <span class="hljs-keyword">if</span> (k != lastIdx) &#123;<br>                        lastIdx = k;<br>                        lastRun = last;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span><br>                newTable[lastIdx] = lastRun;<br>                <span class="hljs-comment">// Clone remaining nodes</span><br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;<br>                    <span class="hljs-comment">// 遍历剩余元素，头插法到指定 k 位置。</span><br>                    V v = p.value;<br>                    <span class="hljs-keyword">int</span> h = p.hash;<br>                    <span class="hljs-keyword">int</span> k = h &amp; sizeMask;<br>                    HashEntry&lt;K,V&gt; n = newTable[k];<br>                    newTable[k] = <span class="hljs-keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 头插法插入新的节点</span><br>    <span class="hljs-keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="hljs-comment">// add the new node</span><br>    node.setNext(newTable[nodeIndex]);<br>    newTable[nodeIndex] = node;<br>    <span class="hljs-comment">// 替换为新的 HashEntry table</span><br>    table = newTable;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最后的两个 for 循环，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计。</p><h3 id="get方法-1"><a href="#get方法-1" class="headerlink" title="get方法"></a>get方法</h3><p>get方法并未加锁，用了UNSAFE方法保证了可见性，get 方法只需要两步即可。</p><ol><li>计算得到 key 的存放位置。</li><li>遍历指定位置查找相同 key 的 value 值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Segment&lt;K,V&gt; s; <span class="hljs-comment">// manually integrate access methods to reduce overhead</span><br>    HashEntry&lt;K,V&gt;[] tab;<br>    <span class="hljs-keyword">int</span> h = hash(key);<br>    <span class="hljs-keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;<br>    <span class="hljs-comment">// 计算得到 key 的存放位置</span><br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="hljs-keyword">null</span> &amp;&amp;<br>        (tab = s.table) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile<br>                 (tab, ((<span class="hljs-keyword">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);<br>             e != <span class="hljs-keyword">null</span>; e = e.next) &#123;<br>            <span class="hljs-comment">// 如果是链表，遍历查找到相同 key 的 value。</span><br>            K k;<br>            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))<br>                <span class="hljs-keyword">return</span> e.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h3><ul><li>计算元素个数前，先不加锁计算两次，如果前后两次结果如一样，认为个数正确返回</li><li>如果不一样，进行重试，重试次数超过 3，将所有 segment 锁住，重新计算个数返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// Try a few times to get accurate count. On failure due to</span><br><span class="hljs-comment">// continuous async changes in table, resort to locking.</span><br><span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="hljs-keyword">this</span>.segments;<br><span class="hljs-keyword">int</span> size;<br><span class="hljs-keyword">boolean</span> overflow; <span class="hljs-comment">// true if size overflows 32 bits</span><br><span class="hljs-keyword">long</span> sum; <span class="hljs-comment">// sum of modCounts</span><br><span class="hljs-keyword">long</span> last = <span class="hljs-number">0L</span>; <span class="hljs-comment">// previous sum</span><br><span class="hljs-keyword">int</span> retries = -<span class="hljs-number">1</span>; <span class="hljs-comment">// first iteration isn&#x27;t retry</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;<br><span class="hljs-comment">// 超过重试次数, 需要创建所有 segment 并加锁</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)<br>ensureSegment(j).lock(); <span class="hljs-comment">// force creation</span><br>&#125;<br>sum = <span class="hljs-number">0L</span>;<br>size = <span class="hljs-number">0</span>;<br>overflow = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j) &#123;<br>Segment&lt;K,V&gt; seg = segmentAt(segments, j);<br><span class="hljs-keyword">if</span> (seg != <span class="hljs-keyword">null</span>) &#123;<br>sum += seg.modCount;<br><span class="hljs-keyword">int</span> c = seg.count;<br><span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span> || (size += c) &lt; <span class="hljs-number">0</span>)<br>overflow = <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (sum == last)<br><span class="hljs-keyword">break</span>;<br>last = sum;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)<br>segmentAt(segments, j).unlock();<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> overflow ? Integer.MAX_VALUE : size;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h2><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p>Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/5.2.png"></p><h3 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认为 0</span><br><span class="hljs-comment">// 当初始化时, 为 -1</span><br><span class="hljs-comment">// 当扩容时, 为 -(1 + 扩容线程数)</span><br><span class="hljs-comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> sizeCtl;<br><br><span class="hljs-comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br><span class="hljs-keyword">final</span> K key;<br><span class="hljs-keyword">volatile</span> V val;<br><span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br>&#125;<br><br><span class="hljs-comment">// hash 表</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">// 扩容时的 新 hash 表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<br><br><span class="hljs-comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span><br><span class="hljs-comment">//(其他线程来进行访问次bin时，发现头结点是ForwardingNode，就去扩容后的容器中去查找了)</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardingNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;<br><br><span class="hljs-comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReservationNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;<br><br><span class="hljs-comment">// 作为 treebin 的头节点, 存储 root 和 first</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeBin</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;<br><br><span class="hljs-comment">// 作为 treebin 的节点, 存储 parent, left, right</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取 Node[] 中第 i 个 Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"><span class="hljs-comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">boolean</span> <span class="hljs-title">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span><br><span class="hljs-function"><span class="hljs-comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i, Node&lt;K,V&gt; v)</span></span><br></code></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">int</span> concurrencyLevel)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0.0f</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br><span class="hljs-keyword">if</span> (initialCapacity &lt; concurrencyLevel) <span class="hljs-comment">// Use at least as many bins</span><br>initialCapacity = concurrencyLevel; <span class="hljs-comment">// as estimated threads</span><br><span class="hljs-keyword">long</span> size = (<span class="hljs-keyword">long</span>)(<span class="hljs-number">1.0</span> + (<span class="hljs-keyword">long</span>)initialCapacity / loadFactor);<br><span class="hljs-comment">// tableSizeFor 仍然是保证计算的大小是 2^n, 即 16,32,64 ...</span><br><span class="hljs-keyword">int</span> cap = (size &gt;= (<span class="hljs-keyword">long</span>)MAXIMUM_CAPACITY) ?<br>MAXIMUM_CAPACITY : tableSizeFor((<span class="hljs-keyword">int</span>)size);<br><span class="hljs-keyword">this</span>.sizeCtl = cap;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建</p></blockquote><h3 id="初始化-initTable"><a href="#初始化-initTable" class="headerlink" title="初始化 initTable"></a>初始化 initTable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initializes table, using the size recorded in sizeCtl.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 让出 CPU 使用权</span><br>            Thread.yield(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-comment">// 尝试将 sizeCtl 设置为 -1（表示初始化 table）</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">int</span> n = (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>从源码中可以发现 ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化</li><li>-N 说明有N-1个线程正在进行扩容</li><li>如果 table 没有初始化，表示 table 初始化大小</li><li>如果 table已经初始化，表示 table 容量</li></ol><h3 id="put方法-2"><a href="#put方法-2" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-comment">/** Implementation for put and putIfAbsent */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;<br>    <span class="hljs-comment">// key 和 value 不能为空</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-comment">// 其中 spread 方法会综合高位低位, 具有更好的 hash 性。并且确保返回结果是正数</span><br>    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());<br>    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        <span class="hljs-comment">// f 是目标位置元素</span><br>        <span class="hljs-comment">// fh 是后面存放目标位置的元素 hash 值</span><br>        <span class="hljs-comment">// i 是链表在数组中的下标</span><br>        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;<br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span><br>            tab = initTable();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))<br>                <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-comment">// 如果其他线程正在扩容，帮忙扩容，MOVED = -1</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            V oldVal = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">// 使用 synchronized 加锁到节点</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">// 说明是链表</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-comment">// 循环加入新的或者覆盖节点</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-keyword">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        <span class="hljs-comment">// 红黑树</span><br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != <span class="hljs-keyword">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            <span class="hljs-comment">// 释放链表头节点的锁</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    <span class="hljs-comment">// 如果链表长度 &gt;= 树化阈值(8), 看数组长度是否&gt;=64，确定扩容数组还是，将链表转为红黑树</span><br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 增加 size 计数</span><br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>如果数量大于等于 <code>TREEIFY_THRESHOLD</code> 且数组长度大于等于64则要转换为红黑树。</li></ol><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3ajE3NjQ3NTkwNzgx,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><h3 id="get方法-2"><a href="#get方法-2" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-keyword">int</span> n, eh; K ek;<br>    <span class="hljs-comment">// key 所在的 hash 位置，spread 方法能确保返回结果是正数</span><br>    <span class="hljs-keyword">int</span> h = spread(key.hashCode());<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 如果指定位置元素存在，头结点hash值相同</span><br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-comment">// key hash 值相等，key值相同，直接返回元素 value</span><br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span><br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-keyword">null</span> ? p.val : <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 是链表，遍历查找</span><br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结一下 get 过程：</p><ol><li>根据 hash 值计算位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li><li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li><li>如果是链表，遍历查找之。</li></ol><p>get操作的高效之处在于整个get过程都不需要加锁，除非读到空的值才会加锁重读。原因就是将使用的共享变量定义成 <code>volatile</code> 类型。</p><h3 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// check 是之前 binCount 的个数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCount</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">int</span> check)</span> </span>&#123;<br>CounterCell[] as; <span class="hljs-keyword">long</span> b, s;<br><span class="hljs-keyword">if</span> (<br><span class="hljs-comment">// 已经有了 counterCells, 向 cell 累加</span><br>(as = counterCells) != <span class="hljs-keyword">null</span> ||<br><span class="hljs-comment">// 还没有, 向 baseCount 累加</span><br>!U.compareAndSwapLong(<span class="hljs-keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)<br>) &#123;<br>CounterCell a; <span class="hljs-keyword">long</span> v; <span class="hljs-keyword">int</span> m;<br><span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">if</span> (<br><span class="hljs-comment">// 还没有 counterCells</span><br>as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br><span class="hljs-comment">// 还没有 cell</span><br>(a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||<br><span class="hljs-comment">// cell cas 增加计数失败</span><br>!(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))<br>) &#123;<br><span class="hljs-comment">// 创建累加单元数组和cell, 累加重试</span><br>fullAddCount(x, uncontended);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 获取元素个数</span><br>s = sumCount();<br>&#125;<br><span class="hljs-keyword">if</span>(check &gt;= <span class="hljs-number">0</span>) &#123;<br>Node&lt;K,V&gt;[] tab, nt; <span class="hljs-keyword">int</span> n, sc;<br><span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="hljs-keyword">null</span> &amp;&amp;<br>(n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br><span class="hljs-keyword">int</span> rs = resizeStamp(n);<br><span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-keyword">null</span> ||<br>transferIndex &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// newtable 已经创建了，帮忙扩容</span><br><span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>transfer(tab, nt);<br>&#125;<br><span class="hljs-comment">// 需要扩容，这时 newtable 未创建</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,(rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>    transfer(tab, <span class="hljs-keyword">null</span>);<br>s = sumCount();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>size 计算实际发生在 put，remove 改变集合元素的操作之中</p><ul><li>没有竞争发生，向 baseCount 累加计数</li><li>有竞争发生，新建 counterCells，向其中的一个 cell 累加计数<ul><li>counterCells 初始有两个 cell</li><li>如果计数竞争比较激烈，会创建新的 cell 来累加计数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">long</span> n = sumCount();<br><span class="hljs-keyword">return</span> ((n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0</span> :(n &gt; (<span class="hljs-keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :(<span class="hljs-keyword">int</span>)n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sumCount</span><span class="hljs-params">()</span> </span>&#123;<br>CounterCell[] as = counterCells; CounterCell a;<br><span class="hljs-comment">// 将 baseCount 计数与所有 cell 计数累加</span><br><span class="hljs-keyword">long</span> sum = baseCount;<br><span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br><span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br>sum += a.value;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Java7 中 ConcruuentHashMap 使用的<strong>分段锁</strong>，也就是<strong>每一个 Segment 上同时只有一个线程可以操作</strong>，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p><ul><li>Java8 中的 ConcruuentHashMap 使用的 **Synchronized 锁加 CAS **的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。<ul><li>初始化，使用 cas 来保证并发安全，懒惰初始化 table</li><li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程会用 synchronized 锁住链表头</li><li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部</li><li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新table 进行搜索</li><li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中</li><li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加即可</li></ul></li></ul><hr><h1 id="六、LinkedBlockingQueue"><a href="#六、LinkedBlockingQueue" class="headerlink" title="六、LinkedBlockingQueue"></a>六、LinkedBlockingQueue</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><h3 id="基本的入队出队"><a href="#基本的入队出队" class="headerlink" title="基本的入队出队"></a>基本的入队出队</h3><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedBlockingDeque</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingDeque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>            E item;<br>            <br>            Node&lt;E&gt; prev;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">* 下列三种情况之一</span><br><span class="hljs-comment">* - 真正的后继节点</span><br><span class="hljs-comment">* - 自己, 发生在出队时</span><br><span class="hljs-comment">* - null, 表示是没有后继节点, 是最后了</span><br><span class="hljs-comment">*/</span><br>            Node&lt;E&gt; next;<br><br>        Node(E x) &#123;<br>            item = x;<br>        &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>初始化链表 <code>last = head = new Node&lt;E&gt;(null);</code> Dummy 节点用来占位，item 为 null</li></ul><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/6.1.png"></p><ul><li>当一个节点入队<code> last = last.next = node;</code></li></ul><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/6.2.png"></p><ul><li>再来一个节点入队 <code>last = last.next = node;</code></li></ul><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/6.3.png"></p><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&lt;E&gt; h = head;<br>Node&lt;E&gt; first = h.next;<br>h.next = h; <span class="hljs-comment">// help GC</span><br>head = first;<br>E x = first.item;<br>first.item = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">return</span> x;<br></code></pre></td></tr></table></figure><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/6.4.png"></p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/6.5.png"></p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/6.6.png"></p><h2 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h2><p>LinkedBlockingQueue的优点在于<strong>用了两把锁和 dummy 节点</strong></p><ul><li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li><li> 用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul><p><strong>线程安全性</strong></p><ul><li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是head 节点的线程安全。两把锁保证了入队和出队没有竞争。</li><li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li><li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于 put(阻塞) offer(非阻塞)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">// 用户 take(阻塞) poll(非阻塞)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">new</span> ReentrantLock();<br></code></pre></td></tr></table></figure><h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="put方法-3"><a href="#put方法-3" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br><span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;<br>Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;E&gt;(e);<br><span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;<br><span class="hljs-comment">// count 用来维护元素计数</span><br><span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;<br>putLock.lockInterruptibly();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 满了等待</span><br><span class="hljs-keyword">while</span> (count.get() == capacity) &#123;<br><span class="hljs-comment">// 倒过来读就好: 等待 notFull</span><br>notFull.await();<br>&#125;<br><span class="hljs-comment">// 有空位, 入队且计数加一</span><br>enqueue(node);<br>c = count.getAndIncrement();<br><span class="hljs-comment">// 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程</span><br><span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)<br>notFull.signal();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>putLock.unlock();<br>&#125;<br><span class="hljs-comment">// 如果队列中有一个元素, 叫醒 take 线程</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争</span><br>signalNotEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>E x;<br><span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;<br><span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;<br>takeLock.lockInterruptibly();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;<br>notEmpty.await();<br>&#125;<br>x = dequeue();<br>c = count.getAndDecrement();<br><span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)<br>notEmpty.signal();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>takeLock.unlock();<br>&#125;<br><span class="hljs-comment">// 如果队列中只有一个空位时, 叫醒 put 线程</span><br><span class="hljs-comment">// 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c &lt; capacity</span><br><span class="hljs-keyword">if</span> (c == capacity)<br><span class="hljs-comment">// 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争</span><br>signalNotFull();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由 put 唤醒 put 是为了避免信号不足，只有一个空位时，才叫醒 put 线程</p></blockquote><hr><h1 id="七、ArrayBlockingQueue"><a href="#七、ArrayBlockingQueue" class="headerlink" title="七、ArrayBlockingQueue"></a>七、ArrayBlockingQueue</h1><p>LinkedBlockingQueue 与 ArrayBlockingQueue 的区别</p><ul><li>Linked 支持有界，Array 强制有界</li><li>Linked 实现是链表，Array 实现是数组</li><li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li><li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li><li>Linked 两把锁，Array 一把锁</li></ul><hr><h1 id="八、ConcurrentLinkedQueue"><a href="#八、ConcurrentLinkedQueue" class="headerlink" title="八、ConcurrentLinkedQueue"></a>八、ConcurrentLinkedQueue</h1><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是</p><ul><li>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li><li>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争</li><li>只是这【锁】使用了 cas 来实现</li></ul><hr><h1 id="九、CopyOnWriteArrayList"><a href="#九、CopyOnWriteArrayList" class="headerlink" title="九、CopyOnWriteArrayList"></a>九、CopyOnWriteArrayList</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><hr><h1 id="十、LinkedHashMap"><a href="#十、LinkedHashMap" class="headerlink" title="十、LinkedHashMap"></a>十、LinkedHashMap</h1><h2 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h2><p>HashMap是无序的，也就是说，迭代HashMap所得到的元素顺序并不是它们最初放置到HashMap的顺序。HashMap的这一缺点往往会造成诸多不便，因为在有些场景中，我们确需要用到一个可以保持插入顺序的Map。庆幸的是，JDK为我们解决了这个问题，它为HashMap提供了一个子类 —— LinkedHashMap。虽然LinkedHashMap增加了时间和空间上的开销，但是它通过维护一个额外的<strong>双向链表</strong>保证了迭代顺序。特别地，该迭代顺序可以是插入顺序，也可以是访问顺序。因此，根据链表中元素的顺序可以将LinkedHashMap分为：保持插入顺序的LinkedHashMap 和 保持访问顺序的LinkedHashMap，其中LinkedHashMap的默认实现是按插入顺序排序的。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>本质上，HashMap和双向链表合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表双向链表的HashMap。在LinkedHashMapMap中，所有put进来的Entry都保存在哈希表中，但由于它又额外定义了一个以head为头结点的双向链表，因此对于每次put进来Entry，除了将其保存到哈希表中对应的位置上之外，还会将其插入到双向链表的尾部。<br><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210622154349632.png" alt="image-20210622154349632"></p><p>其中，HashMap与LinkedHashMap的Entry结构示意图如下图所示：</p><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210622154644550.png" alt="image-20210622154644550"></p><blockquote><p>由于LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。比如，LinkedHashMap也最多只允许一条Entry的键为Null(多条会覆盖)，但允许多条Entry的值为Null。此外，LinkedHashMap 也是 Map 的一个非同步的实现。此外，LinkedHashMap还可以用来实现LRU (Least recently used, 最近最少使用)算法</p></blockquote><h2 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="在JDK中的定义"><a href="#在JDK中的定义" class="headerlink" title="在JDK中的定义"></a>在JDK中的定义</h3><h4 id="类结构定义"><a href="#类结构定义" class="headerlink" title="类结构定义"></a>类结构定义</h4><p>LinkedHashMap继承于HashMap，其在JDK中的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="成员变量定义"><a href="#成员变量定义" class="headerlink" title="成员变量定义"></a>成员变量定义</h4><p>与HashMap相比，LinkedHashMap增加了两个属性用于保证迭代顺序，分别是 双向链表头结点header 和 标志位accessOrder (值为true时，表示按照访问顺序迭代；值为false时，表示按照插入顺序迭代)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The head of the doubly linked list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Entry&lt;K,V&gt; header;  <span class="hljs-comment">// 双向链表的表头元素</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="hljs-comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> accessOrder;  <span class="hljs-comment">//true表示按照访问顺序迭代，false时表示按照插入顺序 </span><br></code></pre></td></tr></table></figure><h4 id="成员方法定义"><a href="#成员方法定义" class="headerlink" title="成员方法定义"></a>成员方法定义</h4><p>LinkedHashMap中并增加没有额外方法。也就是说，LinkedHashMap与HashMap在操作上大致相同，只是在实现细节上略有不同罢了。</p><h4 id="基本元素-Entry"><a href="#基本元素-Entry" class="headerlink" title="基本元素 Entry"></a>基本元素 Entry</h4><p>LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了Entry。LinkedHashMap中的Entry增加了两个指针 before 和 after，它们分别用于维护双向链接列表。特别需要注意的是，next用于维护HashMap各个桶中Entry的连接顺序，before、after用于维护Entry插入的先后顺序的，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// These fields comprise the doubly linked list used for iteration.</span><br>    Entry&lt;K,V&gt; before, after;<br><br>    Entry(<span class="hljs-keyword">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, value, next);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/12/28/Java/Java%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81/image-20210622154644550.png" alt="image-20210622154644550"></p><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><p>LinkedHashMap 一共提供了五个构造函数，它们都是在HashMap的构造函数的基础上实现的，分别如下：</p><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap()"></a>LinkedHashMap()</h4><p>该构造函数意在构造一个具有 默认初始容量 (16)和默认负载因子(0.75)的空 LinkedHashMap，是 Java Collection Framework 规范推荐提供的，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span><br><span class="hljs-comment"> * with the default initial capacity (16) and load factor (0.75).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>();  <span class="hljs-comment">// 调用HashMap对应的构造函数</span><br>    accessOrder = <span class="hljs-keyword">false</span>;           <span class="hljs-comment">// 迭代顺序的默认值</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="LinkedHashMap-int-initialCapacity-float-loadFactor"><a href="#LinkedHashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="LinkedHashMap(int initialCapacity, float loadFactor)"></a>LinkedHashMap(int initialCapacity, float loadFactor)</h4><p>该构造函数意在构造一个指定初始容量和指定负载因子的空 LinkedHashMap，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span><br><span class="hljs-comment">  * with the specified initial capacity and load factor.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span>  initialCapacity the initial capacity</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span>  loadFactor      the load factor</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span><br><span class="hljs-comment">  *         or the load factor is nonpositive</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>     <span class="hljs-keyword">super</span>(initialCapacity, loadFactor);      <span class="hljs-comment">// 调用HashMap对应的构造函数</span><br>     accessOrder = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 迭代顺序的默认值</span><br> &#125;<br></code></pre></td></tr></table></figure><h4 id="LinkedHashMap-int-initialCapacity"><a href="#LinkedHashMap-int-initialCapacity" class="headerlink" title="LinkedHashMap(int initialCapacity)"></a>LinkedHashMap(int initialCapacity)</h4><p>该构造函数意在构造一个指定初始容量和默认负载因子 (0.75)的空 LinkedHashMap，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span><br><span class="hljs-comment"> * with the specified initial capacity and a default load factor (0.75).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  initialCapacity the initial capacity</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(initialCapacity);  <span class="hljs-comment">// 调用HashMap对应的构造函数</span><br>    accessOrder = <span class="hljs-keyword">false</span>;     <span class="hljs-comment">// 迭代顺序的默认值</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="LinkedHashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#LinkedHashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m)</h4><p>该构造函数意在构造一个与指定 Map 具有相同映射的 LinkedHashMap，其 初始容量不小于 16 (具体依赖于指定Map的大小)，负载因子是 0.75，是 Java Collection Framework 规范推荐提供的，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs an insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with</span><br><span class="hljs-comment">     * the same mappings as the specified map.  The &lt;tt&gt;LinkedHashMap&lt;/tt&gt;</span><br><span class="hljs-comment">     * instance is created with a default load factor (0.75) and an initial</span><br><span class="hljs-comment">     * capacity sufficient to hold the mappings in the specified map.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  m the map whose mappings are to be placed in this map</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException if the specified map is null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(m);       <span class="hljs-comment">// 调用HashMap对应的构造函数</span><br>        accessOrder = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 迭代顺序的默认值</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="LinkedHashMap-int-initialCapacity-float-loadFactor-boolean-accessOrder"><a href="#LinkedHashMap-int-initialCapacity-float-loadFactor-boolean-accessOrder" class="headerlink" title="LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)"></a>LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)</h4><p>该构造函数意在构造一个指定初始容量和指定负载因子的具有指定迭代顺序的LinkedHashMap，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the</span><br><span class="hljs-comment">     * specified initial capacity, load factor and ordering mode.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  initialCapacity the initial capacity</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  loadFactor      the load factor</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for</span><br><span class="hljs-comment">     *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span><br><span class="hljs-comment">     *         or the load factor is nonpositive</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity,<span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">boolean</span> accessOrder)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(initialCapacity, loadFactor);   <span class="hljs-comment">// 调用HashMap对应的构造函数</span><br>        <span class="hljs-keyword">this</span>.accessOrder = accessOrder;    <span class="hljs-comment">// 迭代顺序的默认值</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="init-方法"><a href="#init-方法" class="headerlink" title="init 方法"></a>init 方法</h3><p>从上面的五种构造函数我们可以看出，无论采用何种方式创建LinkedHashMap，其都会调用HashMap相应的构造函数。事实上，不管调用HashMap的哪个构造函数，HashMap的构造函数都会在最后调用一个init()方法进行初始化，只不过这个方法在HashMap中是一个空实现，而在LinkedHashMap中重写了它用于初始化它所维护的双向链表。例如，HashMap的参数为空的构造函数以及init方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span><br><span class="hljs-comment">     * (16) and the default load factor (0.75).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>        threshold = (<span class="hljs-keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);<br>        table = <span class="hljs-keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];<br>        init();<br>    &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Initialization hook for subclasses. This method is called</span><br><span class="hljs-comment">     * in all constructors and pseudo-constructors (clone, readObject)</span><br><span class="hljs-comment">     * after HashMap has been initialized but before any entries have</span><br><span class="hljs-comment">     * been inserted.  (In the absence of this method, readObject would</span><br><span class="hljs-comment">     * require explicit knowledge of subclasses.)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在LinkedHashMap中，它重写了init方法以便初始化双向列表，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Called by superclass constructors and pseudoconstructors (clone,</span><br><span class="hljs-comment">    * readObject) before any entries are inserted into the map.  Initializes</span><br><span class="hljs-comment">    * the chain.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>       header = <span class="hljs-keyword">new</span> Entry&lt;K,V&gt;(-<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>       header.before = header.after = header;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>因此，在创建LinkedHashMap的同时就会不知不觉地对双向链表进行初始化。</p><h3 id="put-key-vlaue-方法"><a href="#put-key-vlaue-方法" class="headerlink" title="put(key, vlaue)方法"></a>put(key, vlaue)方法</h3><p>LinkedHashMap没有对 put(key,vlaue) 方法进行任何直接的修改，完全继承了HashMap的 put(Key,Value) 方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Associates the specified value with the specified key in this map.</span><br><span class="hljs-comment">    * If the map previously contained a mapping for the key, the old</span><br><span class="hljs-comment">    * value is replaced.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> key key with which the specified value is to be associated</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> value value to be associated with the specified key</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> the previous value associated with key, or null if there was no mapping for key.</span><br><span class="hljs-comment">    *  Note that a null return can also indicate that the map previously associated null with key.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br><br>       <span class="hljs-comment">//当key为null时，调用putForNullKey方法，并将该键值对保存到table的第一个位置 </span><br>       <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)<br>           <span class="hljs-keyword">return</span> putForNullKey(value); <br><br>       <span class="hljs-comment">//根据key的hashCode计算hash值</span><br>       <span class="hljs-keyword">int</span> hash = hash(key.hashCode());           <br><br>       <span class="hljs-comment">//计算该键值对在数组中的存储位置（哪个桶）</span><br>       <span class="hljs-keyword">int</span> i = indexFor(hash, table.length);              <br><br>       <span class="hljs-comment">//在table的第i个桶上进行迭代，寻找 key 保存的位置</span><br>       <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;      <br>           Object k;<br>           <span class="hljs-comment">//判断该条链上是否存在hash值相同且key值相等的映射，若存在，则直接覆盖 value，并返回旧value</span><br>           <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<br>               V oldValue = e.value;<br>               e.value = value;<br>               e.recordAccess(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// LinkedHashMap重写了Entry中的recordAccess方法--- (1)    </span><br>               <span class="hljs-keyword">return</span> oldValue;    <span class="hljs-comment">// 返回旧值</span><br>           &#125;<br>       &#125;<br><br>       modCount++; <span class="hljs-comment">//修改次数增加1，快速失败机制</span><br><br>       <span class="hljs-comment">//原Map中无该映射，将该添加至该链的链头</span><br>       addEntry(hash, key, value, i);  <span class="hljs-comment">// LinkedHashMap重写了HashMap中的createEntry方法 ---- (2)    </span><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>上述源码反映了LinkedHashMap与HashMap保存数据的过程。特别地，在LinkedHashMap中，它对addEntry方法和Entry的recordAccess方法进行了重写。下面我们对比地看一下LinkedHashMap 和HashMap的addEntry方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This override alters behavior of superclass put method. It causes newly</span><br><span class="hljs-comment"> * allocated entry to get inserted at the end of the linked list and</span><br><span class="hljs-comment"> * removes the eldest entry if appropriate.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * LinkedHashMap中的addEntry方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;   <br><br>    <span class="hljs-comment">//创建新的Entry，并插入到LinkedHashMap中  </span><br>    createEntry(hash, key, value, bucketIndex);  <span class="hljs-comment">// 重写了HashMap中的createEntry方法</span><br><br>    <span class="hljs-comment">//双向链表的第一个有效节点（header后的那个节点）为最近最少使用的节点，这是用来支持LRU算法的</span><br>    Entry&lt;K,V&gt; eldest = header.after;  <br>    <span class="hljs-comment">//如果有必要，则删除掉该近期最少使用的节点，  </span><br>    <span class="hljs-comment">//这要看对removeEldestEntry的覆写,由于默认为false，因此默认是不做任何处理的。  </span><br>    <span class="hljs-keyword">if</span> (removeEldestEntry(eldest)) &#123;  <br>        removeEntryForKey(eldest.key);  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">//扩容到原来的2倍  </span><br>        <span class="hljs-keyword">if</span> (size &gt;= threshold)  <br>            resize(<span class="hljs-number">2</span> * table.length);  <br>    &#125;  <br>&#125; <br><br>-------------------------------我是分割线------------------------------------<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Adds a new entry with the specified key, value and hash code to</span><br><span class="hljs-comment"> * the specified bucket.  It is the responsibility of this</span><br><span class="hljs-comment"> * method to resize the table if appropriate.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Subclass overrides this to alter the behavior of put method.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * HashMap中的addEntry方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;<br>    <span class="hljs-comment">//获取bucketIndex处的Entry</span><br>    Entry&lt;K,V&gt; e = table[bucketIndex];<br><br>    <span class="hljs-comment">//将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry </span><br>    table[bucketIndex] = <span class="hljs-keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);<br><br>    <span class="hljs-comment">//若HashMap中元素的个数超过极限了，则容量扩大两倍</span><br>    <span class="hljs-keyword">if</span> (size++ &gt;= threshold)<br>        resize(<span class="hljs-number">2</span> * table.length);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于LinkedHashMap本身维护了插入的先后顺序，因此其可以用来做缓存，14~19行的操作就是用来支持LRU算法的，这里暂时不用去关心它。此外，在LinkedHashMap的addEntry方法中，它重写了HashMap中的createEntry方法，我们接着看一下createEntry方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123; <br>    <span class="hljs-comment">// 向哈希表中插入Entry，这点与HashMap中相同 </span><br>    <span class="hljs-comment">//创建新的Entry并将其链入到数组对应桶的链表的头结点处， </span><br>    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];  <br>    Entry&lt;K,V&gt; e = <span class="hljs-keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, old);  <br>    table[bucketIndex] = e;     <br><br>    <span class="hljs-comment">//在每次向哈希表插入Entry的同时，都会将其插入到双向链表的尾部，  </span><br>    <span class="hljs-comment">//这样就按照Entry插入LinkedHashMap的先后顺序来迭代元素(LinkedHashMap根据双向链表重写了迭代器)</span><br>    <span class="hljs-comment">//同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，也符合LRU算法的实现  </span><br>    e.addBefore(header);  <br>    size++;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>由以上源码我们可以知道，在LinkedHashMap中向哈希表中插入新Entry的同时，还会通过Entry的addBefore方法将其链入到双向链表中。其中，addBefore方法本质上是一个双向链表的插入操作，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在双向链表中，将当前的Entry插入到existingEntry(header)的前面  </span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBefore</span><span class="hljs-params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;  <br>    after  = existingEntry;  <br>    before = existingEntry.before;  <br>    before.after = <span class="hljs-keyword">this</span>;  <br>    after.before = <span class="hljs-keyword">this</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>到此为止，我们分析了在LinkedHashMap中put一条键值对的完整过程。总的来说，相比HashMap而言，LinkedHashMap在向哈希表添加一个键值对的同时，也会将其链入到它所维护的双向链表中，以便设定迭代顺序。</p><h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><p>在HashMap中，我们知道随着HashMap中元素的数量越来越多，发生碰撞的概率将越来越大，所产生的子链长度就会越来越长，这样势必会影响HashMap的存取速度。为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理，该临界点就是HashMap中元素的数量在数值上等于threshold（table数组长度*加载因子）。但是，不得不说，扩容是一个非常耗时的过程，因为它需要重新计算这些元素在新table数组中的位置并进行复制处理。所以，如果我们能够提前预知HashMap 中元素的个数，那么在构造HashMap时预设元素的个数能够有效的提高HashMap的性能。<br>　　<br>同样的问题也存在于LinkedHashMap中，因为LinkedHashMap本来就是一个HashMap，只是它还将所有Entry节点链入到了一个双向链表中。LinkedHashMap完全继承了HashMap的resize()方法，只是对它所调用的transfer方法进行了重写。我们先看resize()方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rehashes the contents of this map into a new array with a</span><br><span class="hljs-comment"> * larger capacity.  This method is called automatically when the</span><br><span class="hljs-comment"> * number of keys in this map reaches its threshold.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If current capacity is MAXIMUM_CAPACITY, this method does not</span><br><span class="hljs-comment"> * resize the map, but sets threshold to Integer.MAX_VALUE.</span><br><span class="hljs-comment"> * This has the effect of preventing future calls.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span><br><span class="hljs-comment"> *        must be greater than current capacity unless current</span><br><span class="hljs-comment"> *        capacity is MAXIMUM_CAPACITY (in which case value</span><br><span class="hljs-comment"> *        is irrelevant).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newCapacity)</span> </span>&#123;<br>    Entry[] oldTable = table;<br>    <span class="hljs-keyword">int</span> oldCapacity = oldTable.length;<br><br>    <span class="hljs-comment">// 若 oldCapacity 已达到最大值，直接将 threshold 设为 Integer.MAX_VALUE</span><br>    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <br>        threshold = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">return</span>;             <span class="hljs-comment">// 直接返回</span><br>    &#125;<br><br>    <span class="hljs-comment">// 否则，创建一个更大的数组</span><br>    Entry[] newTable = <span class="hljs-keyword">new</span> Entry[newCapacity];<br><br>    <span class="hljs-comment">//将每条Entry重新哈希到新的数组中</span><br>    transfer(newTable);  <span class="hljs-comment">//LinkedHashMap对它所调用的transfer方法进行了重写</span><br><br>    table = newTable;<br>    threshold = (<span class="hljs-keyword">int</span>)(newCapacity * loadFactor);  <span class="hljs-comment">// 重新设定 threshold</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从上面代码中我们可以看出，<strong>Map扩容操作的核心在于重哈希</strong>。所谓重哈希是指重新计算原HashMap中的元素在新table数组中的位置并进行复制处理的过程。鉴于性能和LinkedHashMap自身特点的考量，LinkedHashMap对重哈希过程(transfer方法)进行了重写，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Transfers all entries to new table array.  This method is called</span><br><span class="hljs-comment"> * by superclass resize.  It is overridden for performance, as it is</span><br><span class="hljs-comment"> * faster to iterate using our linked list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(HashMap.Entry[] newTable)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> newCapacity = newTable.length;<br>    <span class="hljs-comment">// 与HashMap相比，借助于双向链表的特点进行重哈希使得代码更加简洁</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = header.after; e != header; e = e.after) &#123;<br>        <span class="hljs-keyword">int</span> index = indexFor(e.hash, newCapacity);   <span class="hljs-comment">// 计算每个Entry所在的桶</span><br>        <span class="hljs-comment">// 将其链入桶中的链表</span><br>        e.next = newTable[index];<br>        newTable[index] = e;   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上述源码所示，LinkedHashMap借助于自身维护的双向链表轻松地实现了重哈希操作。</p><h3 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h3><p>相对于LinkedHashMap的存储而言，读取就显得比较简单了。LinkedHashMap中重写了HashMap中的get方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the value to which the specified key is mapped,</span><br><span class="hljs-comment">     * or &#123;<span class="hljs-doctag">@code</span> null&#125; if this map contains no mapping for the key.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> k&#125; to a value &#123;<span class="hljs-doctag">@code</span> v&#125; such that &#123;<span class="hljs-doctag">@code</span> (key==null ? k==null :</span><br><span class="hljs-comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="hljs-doctag">@code</span> v&#125;; otherwise</span><br><span class="hljs-comment">     * it returns &#123;<span class="hljs-doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;A return value of &#123;<span class="hljs-doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span><br><span class="hljs-comment">     * indicate that the map contains no mapping for the key; it&#x27;s also</span><br><span class="hljs-comment">     * possible that the map explicitly maps the key to &#123;<span class="hljs-doctag">@code</span> null&#125;.</span><br><span class="hljs-comment">     * The &#123;<span class="hljs-doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span><br><span class="hljs-comment">     * distinguish these two cases.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-comment">// 根据key获取对应的Entry，若没有这样的Entry，则返回null</span><br>        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key); <br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)      <span class="hljs-comment">// 若不存在这样的Entry，直接返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        e.recordAccess(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> e.value;<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the entry associated with the specified key in the</span><br><span class="hljs-comment">     * HashMap.  Returns null if the HashMap contains no mapping</span><br><span class="hljs-comment">     * for the key.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * HashMap 中的方法</span><br><span class="hljs-comment">     *     </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title">getEntry</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> hash = (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : hash(key);<br>        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];<br>             e != <span class="hljs-keyword">null</span>;<br>             e = e.next) &#123;<br>            Object k;<br>            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-keyword">return</span> e;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在LinkedHashMap的get方法中，通过HashMap中的getEntry方法获取Entry对象。注意这里的recordAccess方法，如果链表中元素的排序规则是按照插入的先后顺序排序的话，该方法什么也不做；如果链表中元素的排序规则是按照访问的先后顺序排序的话，则将e移到链表的末尾处，笔者会在后文专门阐述这个问题。</p><p>另外，同样地，调用LinkedHashMap的get(Object key)方法后，若返回值是 NULL，则也存在如下两种可能：</p><ul><li>该 key 对应的值就是 null;</li><li>HashMap 中不存在该 key。</li></ul><blockquote><p>LinkedHashMap 存取小结</p><p>LinkedHashMap 的存取过程基本与HashMap基本类似，只是在细节实现上稍有不同，这是由LinkedHashMap本身的特性所决定的，因为它要额外维护一个双向链表用于保持迭代顺序。在put操作上，虽然LinkedHashMap完全继承了HashMap的put操作，但是在细节上还是做了一定的调整，比如，在LinkedHashMap中向哈希表中插入新Entry的同时，还会通过Entry的addBefore方法将其链入到双向链表中。在扩容操作上，虽然LinkedHashMap完全继承了HashMap的resize操作，但是鉴于性能和LinkedHashMap自身特点的考量，LinkedHashMap对其中的重哈希过程(transfer方法)进行了重写。在读取操作上，LinkedHashMap中重写了HashMap中的get方法，通过HashMap中的getEntry方法获取Entry对象。在此基础上，进一步获取指定键对应的值。</p></blockquote><h2 id="LinkedHashMap-与-LRU-Least-recently-used，最近最少使用-算法"><a href="#LinkedHashMap-与-LRU-Least-recently-used，最近最少使用-算法" class="headerlink" title="LinkedHashMap 与 LRU(Least recently used，最近最少使用)算法"></a>LinkedHashMap 与 LRU(Least recently used，最近最少使用)算法</h2><p>LinkedHashMap区别于HashMap最大的一个不同点是，前者是有序的，而后者是无序的。为此，LinkedHashMap增加了两个属性用于保证顺序，分别是双向链表头结点header和标志位accessOrder。我们知道，header是LinkedHashMap所维护的双向链表的头结点，而accessOrder用于决定具体的迭代顺序。实际上，accessOrder标志位的作用可不像我们描述的这样简单，我们接下来仔细分析一波~</p><p>我们知道，当accessOrder标志位为true时，表示双向链表中的元素按照访问的先后顺序排列，可以看到，虽然Entry插入链表的顺序依然是按照其put到LinkedHashMap中的顺序，但put和get方法均有调用recordAccess方法（put方法在key相同时会调用）。recordAccess方法判断accessOrder是否为true，如果是true，则将当前访问的Entry（put进来的Entry或get出来的Entry）移到双向链表的尾部（key不相同时，put新Entry时，会调用addEntry，它会调用createEntry，该方法同样将新插入的元素放入到双向链表的尾部，既符合插入的先后顺序，又符合访问的先后顺序，因为这时该Entry也被访问了）；当标志位accessOrder的值为false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序，即每次put到LinkedHashMap中的Entry都放在双向链表的尾部，这样遍历双向链表时，Entry的输出顺序便和插入的顺序一致，这也是默认的双向链表的存储顺序。因此，当标志位accessOrder的值为false时，虽然也会调用recordAccess方法，但不做任何操作。</p><p>注意到我们在前面介绍的LinkedHashMap的五种构造方法，前四个构造方法都将accessOrder设为false，说明<strong>默认是按照插入顺序排序的</strong>；而第五个构造方法可以自定义传入的accessOrder的值，因此可以指定双向循环链表中元素的排序规则。特别地，当我们要用LinkedHashMap实现LRU算法时，就需要调用该构造方法并将accessOrder置为true。</p><h3 id="put操作与标志位accessOrder"><a href="#put操作与标志位accessOrder" class="headerlink" title="put操作与标志位accessOrder"></a>put操作与标志位accessOrder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">/ 将key/value添加到LinkedHashMap中      <br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;      <br>    <span class="hljs-comment">// 若key为null，则将该键值对添加到table[0]中。      </span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)      <br>        <span class="hljs-keyword">return</span> putForNullKey(value);      <br>    <span class="hljs-comment">// 若key不为null，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。      </span><br>    <span class="hljs-keyword">int</span> hash = hash(key.hashCode());      <br>    <span class="hljs-keyword">int</span> i = indexFor(hash, table.length);      <br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;      <br>        Object k;      <br>        <span class="hljs-comment">// 若key对已经存在，则用新的value取代旧的value     </span><br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;      <br>            V oldValue = e.value;      <br>            e.value = value;      <br>            e.recordAccess(<span class="hljs-keyword">this</span>);      <br>            <span class="hljs-keyword">return</span> oldValue;      <br>        &#125;      <br>    &#125;      <br><br>    <span class="hljs-comment">// 若key不存在，则将key/value键值对添加到table中      </span><br>    modCount++;    <br>    <span class="hljs-comment">//将key/value键值对添加到table[i]处    </span><br>    addEntry(hash, key, value, i);      <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      <br>&#125; <br></code></pre></td></tr></table></figure><p>从上述源码我们可以看到，当要put进来的Entry的key在哈希表中已经在存在时，会调用Entry的recordAccess方法；当该key不存在时，则会调用addEntry方法将新的Entry插入到对应桶的单链表的头部。我们先来看recordAccess方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* This method is invoked by the superclass whenever the value</span><br><span class="hljs-comment">* of a pre-existing entry is read by Map.get or modified by Map.set.</span><br><span class="hljs-comment">* If the enclosing Map is access-ordered, it moves the entry</span><br><span class="hljs-comment">* to the end of the list; otherwise, it does nothing.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recordAccess</span><span class="hljs-params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;  <br>    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;  <br>    <span class="hljs-comment">//如果链表中元素按照访问顺序排序，则将当前访问的Entry移到双向循环链表的尾部，  </span><br>    <span class="hljs-comment">//如果是按照插入的先后顺序排序，则不做任何事情。  </span><br>    <span class="hljs-keyword">if</span> (lm.accessOrder) &#123;  <br>        lm.modCount++;  <br>        <span class="hljs-comment">//移除当前访问的Entry  </span><br>        remove();  <br>        <span class="hljs-comment">//将当前访问的Entry插入到链表的尾部  </span><br>        addBefore(lm.header);  <br>      &#125;  <br>  &#125; <br></code></pre></td></tr></table></figure><p>LinkedHashMap重写了HashMap中的recordAccess方法（HashMap中该方法为空），当调用父类的put方法时，在发现key已经存在时，会调用该方法；当调用自己的get方法时，也会调用到该方法。该方法提供了LRU算法的实现，它将最近使用的Entry放到双向循环链表的尾部。也就是说，当accessOrder为true时，get方法和put方法都会调用recordAccess方法使得最近使用的Entry移到双向链表的末尾；当accessOrder为默认值false时，从源码中可以看出recordAccess方法什么也不会做。我们反过头来，再看一下addEntry方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * This override alters behavior of superclass put method. It causes newly</span><br><span class="hljs-comment">  * allocated entry to get inserted at the end of the linked list and</span><br><span class="hljs-comment">  * removes the eldest entry if appropriate.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * LinkedHashMap中的addEntry方法</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;   <br><br>     <span class="hljs-comment">//创建新的Entry，并插入到LinkedHashMap中  </span><br>     createEntry(hash, key, value, bucketIndex);  <span class="hljs-comment">// 重写了HashMap中的createEntry方法</span><br><br>     <span class="hljs-comment">//双向链表的第一个有效节点（header后的那个节点）为最近最少使用的节点，这是用来支持LRU算法的</span><br>     Entry&lt;K,V&gt; eldest = header.after;  <br>     <span class="hljs-comment">//如果有必要，则删除掉该近期最少使用的节点，  </span><br>     <span class="hljs-comment">//这要看对removeEldestEntry的覆写,由于默认为false，因此默认是不做任何处理的。  </span><br>     <span class="hljs-keyword">if</span> (removeEldestEntry(eldest)) &#123;  <br>         removeEntryForKey(eldest.key);  <br>     &#125; <span class="hljs-keyword">else</span> &#123;  <br>         <span class="hljs-comment">//扩容到原来的2倍  </span><br>         <span class="hljs-keyword">if</span> (size &gt;= threshold)  <br>             resize(<span class="hljs-number">2</span> * table.length);  <br>     &#125;  <br> &#125; <br><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123; <br>     <span class="hljs-comment">// 向哈希表中插入Entry，这点与HashMap中相同 </span><br>     <span class="hljs-comment">//创建新的Entry并将其链入到数组对应桶的链表的头结点处， </span><br>     HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];  <br>     Entry&lt;K,V&gt; e = <span class="hljs-keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, old);  <br>     table[bucketIndex] = e;     <br><br>     <span class="hljs-comment">//在每次向哈希表插入Entry的同时，都会将其插入到双向链表的尾部，  </span><br>     <span class="hljs-comment">//这样就按照Entry插入LinkedHashMap的先后顺序来迭代元素(LinkedHashMap根据双向链表重写了迭代器)</span><br>     <span class="hljs-comment">//同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，也符合LRU算法的实现  </span><br>     e.addBefore(header);  <br>     size++;  <br> &#125;<br></code></pre></td></tr></table></figure><p>同样是将新的Entry链入到table中对应桶中的单链表中，但可以在createEntry方法中看出，同时也会把新put进来的Entry插入到了双向链表的尾部。从插入顺序的层面来说，新的Entry插入到双向链表的尾部可以实现按照插入的先后顺序来迭代Entry，而从访问顺序的层面来说，新put进来的Entry又是最近访问的Entry，也应该将其放在双向链表的尾部。在上面的addEntry方法中还调用了removeEldestEntry方法，该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map should remove its eldest entry.</span><br><span class="hljs-comment">     * This method is invoked by &lt;tt&gt;put&lt;/tt&gt; and &lt;tt&gt;putAll&lt;/tt&gt; after</span><br><span class="hljs-comment">     * inserting a new entry into the map.  It provides the implementor</span><br><span class="hljs-comment">     * with the opportunity to remove the eldest entry each time a new one</span><br><span class="hljs-comment">     * is added.  This is useful if the map represents a cache: it allows</span><br><span class="hljs-comment">     * the map to reduce memory consumption by deleting stale entries.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;Sample use: this override will allow the map to grow up to 100</span><br><span class="hljs-comment">     * entries and then delete the eldest entry each time a new entry is</span><br><span class="hljs-comment">     * added, maintaining a steady state of 100 entries.</span><br><span class="hljs-comment">     * &lt;pre&gt;</span><br><span class="hljs-comment">     *     private static final int MAX_ENTRIES = 100;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *     protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span><br><span class="hljs-comment">     *        return size() &gt; MAX_ENTRIES;</span><br><span class="hljs-comment">     *     &#125;</span><br><span class="hljs-comment">     * &lt;/pre&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;This method typically does not modify the map in any way,</span><br><span class="hljs-comment">     * instead allowing the map to modify itself as directed by its</span><br><span class="hljs-comment">     * return value.  It &lt;i&gt;is&lt;/i&gt; permitted for this method to modify</span><br><span class="hljs-comment">     * the map directly, but if it does so, it &lt;i&gt;must&lt;/i&gt; return</span><br><span class="hljs-comment">     * &lt;tt&gt;false&lt;/tt&gt; (indicating that the map should not attempt any</span><br><span class="hljs-comment">     * further modification).  The effects of returning &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="hljs-comment">     * after modifying the map from within this method are unspecified.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;This implementation merely returns &lt;tt&gt;false&lt;/tt&gt; (so that this</span><br><span class="hljs-comment">     * map acts like a normal map - the eldest element is never removed).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>    eldest The least recently inserted entry in the map, or if</span><br><span class="hljs-comment">     *           this is an access-ordered map, the least recently accessed</span><br><span class="hljs-comment">     *           entry.  This is the entry that will be removed it this</span><br><span class="hljs-comment">     *           method returns &lt;tt&gt;true&lt;/tt&gt;.  If the map was empty prior</span><br><span class="hljs-comment">     *           to the &lt;tt&gt;put&lt;/tt&gt; or &lt;tt&gt;putAll&lt;/tt&gt; invocation resulting</span><br><span class="hljs-comment">     *           in this invocation, this will be the entry that was just</span><br><span class="hljs-comment">     *           inserted; in other words, if the map contains a single</span><br><span class="hljs-comment">     *           entry, the eldest entry is also the newest.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>   &lt;tt&gt;true&lt;/tt&gt; if the eldest entry should be removed</span><br><span class="hljs-comment">     *           from the map; &lt;tt&gt;false&lt;/tt&gt; if it should be retained.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法是用来被重写的，一般地，如果用LinkedHashmap实现LRU算法，就要重写该方法。比如可以将该方法覆写为如果设定的内存已满，则返回true，这样当再次向LinkedHashMap中putEntry时，在调用的addEntry方法中便会将近期最少使用的节点删除掉（header后的那个节点）。</p><h3 id="get操作与标志位accessOrder"><a href="#get操作与标志位accessOrder" class="headerlink" title="get操作与标志位accessOrder"></a>get操作与标志位accessOrder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Returns the value to which the specified key is mapped,</span><br><span class="hljs-comment">    * or &#123;<span class="hljs-doctag">@code</span> null&#125; if this map contains no mapping for the key.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt;More formally, if this map contains a mapping from a key</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@code</span> k&#125; to a value &#123;<span class="hljs-doctag">@code</span> v&#125; such that &#123;<span class="hljs-doctag">@code</span> (key==null ? k==null :</span><br><span class="hljs-comment">    * key.equals(k))&#125;, then this method returns &#123;<span class="hljs-doctag">@code</span> v&#125;; otherwise</span><br><span class="hljs-comment">    * it returns &#123;<span class="hljs-doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt;A return value of &#123;<span class="hljs-doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span><br><span class="hljs-comment">    * indicate that the map contains no mapping for the key; it&#x27;s also</span><br><span class="hljs-comment">    * possible that the map explicitly maps the key to &#123;<span class="hljs-doctag">@code</span> null&#125;.</span><br><span class="hljs-comment">    * The &#123;<span class="hljs-doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span><br><span class="hljs-comment">    * distinguish these two cases.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>       <span class="hljs-comment">// 根据key获取对应的Entry，若没有这样的Entry，则返回null</span><br>       Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key); <br>       <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)      <span class="hljs-comment">// 若不存在这样的Entry，直接返回</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>       e.recordAccess(<span class="hljs-keyword">this</span>);<br>       <span class="hljs-keyword">return</span> e.value;<br>   &#125;<br></code></pre></td></tr></table></figure><p>在LinkedHashMap中进行读取操作时，一样也会调用recordAccess方法。    </p><blockquote><p><strong>使用LinkedHashMap实现LRU的必要前提是将accessOrder标志位设为true以便开启按访问顺序排序的模式。</strong>我们可以看到，无论是put方法还是get方法，都会导致目标Entry成为最近访问的Entry，因此就把该Entry加入到了双向链表的末尾：get方法通过调用recordAccess方法来实现；put方法在覆盖已有key的情况下，也是通过调用recordAccess方法来实现，在插入新的Entry时，则是通过createEntry中的addBefore方法来实现。这样，我们便把最近使用的Entry放入到了双向链表的后面。多次操作后，双向链表前面的Entry便是最近没有使用的，这样当节点个数满的时候，删除最前面的Entry(head后面的那个Entry)即可，因为它就是最近最少使用的Entry。</p></blockquote><h2 id="使用LinkedHashMap实现LRU算法"><a href="#使用LinkedHashMap实现LRU算法" class="headerlink" title="使用LinkedHashMap实现LRU算法"></a>使用LinkedHashMap实现LRU算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(capacity, <span class="hljs-number">0.75F</span>, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getOrDefault(key, -<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.put(key, value);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size() &gt; capacity; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LinkedHashMap-有序性原理分析"><a href="#LinkedHashMap-有序性原理分析" class="headerlink" title="LinkedHashMap 有序性原理分析"></a>LinkedHashMap 有序性原理分析</h2><p>如前文所述，LinkedHashMap 增加了双向链表头结点header 和 标志位accessOrder两个属性用于保证迭代顺序。但是要想真正实现其有序性，还差临门一脚，那就是重写HashMap 的迭代器，其源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashIterator</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    Entry&lt;K,V&gt; nextEntry    = header.after;<br>    Entry&lt;K,V&gt; lastReturned = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The modCount value that the iterator believes that the backing</span><br><span class="hljs-comment">     * List should have.  If this expectation is violated, the iterator</span><br><span class="hljs-comment">     * has detected concurrent modification.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">int</span> expectedModCount = modCount;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-comment">// 根据双向列表判断 </span><br>            <span class="hljs-keyword">return</span> nextEntry != header;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lastReturned == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br><br>            LinkedHashMap.<span class="hljs-keyword">this</span>.remove(lastReturned.key);<br>            lastReturned = <span class="hljs-keyword">null</span>;<br>            expectedModCount = modCount;<br>    &#125;<br><br>    <span class="hljs-function">Entry&lt;K,V&gt; <span class="hljs-title">nextEntry</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 迭代输出双向链表各节点</span><br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>            <span class="hljs-keyword">if</span> (nextEntry == header)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br><br>            Entry&lt;K,V&gt; e = lastReturned = nextEntry;<br>            nextEntry = e.after;<br>            <span class="hljs-keyword">return</span> e;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Key 迭代器，KeySet</span><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashIterator</span>&lt;<span class="hljs-title">K</span>&gt; </span>&#123;   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> nextEntry().getKey(); &#125;<br>&#125;<br><br><span class="hljs-comment">// Value 迭代器，Values(Collection)</span><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashIterator</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> nextEntry().value; &#125;<br>&#125;<br><br><span class="hljs-comment">// Entry 迭代器，EntrySet</span><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EntryIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashIterator</span>&lt;<span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> Map.<span class="hljs-function">Entry&lt;K,V&gt; <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> nextEntry(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中我们可以知道，<strong>LinkedHashMap重写了HashMap 的迭代器，它使用其维护的双向链表进行迭代输出。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java NIO</title>
    <link href="/2020/11/20/Java/JavaNIO/JavaNIO/"/>
    <url>/2020/11/20/Java/JavaNIO/JavaNIO/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Java NIO（java non-blocking IO）是从Java 1.4版本开始引入的一个新的IO API，<strong>可以替代标准的Java IO API</strong>。</p><p>NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持<strong>面向缓冲区的、基于通道的IO操作</strong>。</p><ul><li>BIO 以<strong>流</strong>的方式处理数据</li></ul><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/1.1.png"></p><ul><li>而NIO 以<strong>块</strong>的方式处理数据，块I/O 的效率比流I/O 高很多。另外，NIO 是<strong>非阻塞式</strong>的，使用它可以提供非阻塞式的高伸缩性网络。</li></ul><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/1.2.png"></p><p>NIO 主要有三大核心部分：<strong>Channel(通道)，Buffer(缓冲区), Selector(选择器)<strong>。传统的BIO基于字节流和字符流进行操作，而NIO基于</strong>Channel</strong>(通道)<strong>Buffer</strong>(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<strong>Selector</strong>(选择区)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</p><blockquote><p><strong>通道负责传输，缓冲区负责存储</strong></p></blockquote><h1 id="二、缓冲区"><a href="#二、缓冲区" class="headerlink" title="二、缓冲区"></a>二、缓冲区</h1><h2 id="2-1-缓冲区类型"><a href="#2-1-缓冲区类型" class="headerlink" title="2.1 缓冲区类型"></a>2.1 缓冲区类型</h2><p>缓冲区Buffer就像是一个顶层父类，像一个数组，可以保存多个相同类型的数据，它是一个抽象类。根据数据类型不同(<strong>boolean 除外</strong>) ，有以下Buffer 常用子类</p><ul><li>ByteBuffer，存储字节数据到缓冲区</li><li>CharBuffer，存储字符数据到缓冲区</li><li>ShortBuffer，存储短整型数据到缓冲区</li><li>IntBuffer，存储整数数据到缓冲区</li><li>LongBuffer，存储长整型数据到缓冲区</li><li>FloatBuffer，存储小数到缓冲区</li><li>DoubleBuffer，存储小数到缓冲区</li></ul><p><strong>他们的继承关系如下</strong></p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/2.1.png"></p><h2 id="2-2-核心属性"><a href="#2-2-核心属性" class="headerlink" title="2.2 核心属性"></a>2.2 核心属性</h2><p>缓冲区的父类Buffer中有几个核心属性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mark = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br></code></pre></td></tr></table></figure><ul><li>capacity：缓冲区的<strong>容量</strong>。通过构造函数赋予，一旦设置，无法更改，缓冲区容量不能为负</li><li>limit：缓冲区的<strong>界限</strong>。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li><li>position：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li><li>mark：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><h2 id="2-3-常用方法"><a href="#2-3-常用方法" class="headerlink" title="2.3 常用方法"></a>2.3 常用方法</h2><p>ByteBuffer 类（二进制数据），该类的主要方法如下：</p><h3 id="allocate-方法"><a href="#allocate-方法" class="headerlink" title="allocate()方法"></a>allocate()方法</h3><ul><li><p>public static ByteBuffer allocate(int capacity); 设置缓冲区的初始容量</p><ul><li>通过<strong>allocate方法</strong>可以获取一个对应缓冲区的对象，它是缓冲区类的一个静态方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取一个容量大小为1024字节的字节缓冲区</span><br>ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h3><ul><li><p>public abstract ByteBuffer put(byte[] b); 存储字节数据到缓冲区</p><ul><li><p>put()方法可以将一个数据放入到缓冲区中</p></li><li><p>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值</p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/2.2.png"></p></li></ul></li></ul><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h3><ul><li><p>public abstract byte[] get(); 从缓冲区获得字节数据</p><ul><li><p>get()方法会读取缓冲区中的一个值</p></li><li><p>进行该操作后，position会+1，如果超过了limit则会抛出异常</p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/2.3.png"></p></li></ul></li></ul><h3 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h3><ul><li><p>public final Buffer flip(); 翻转缓冲区，重置位置到初始位置</p><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/2.4.png"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取一个容量大小为1024字节的字节缓冲区</span><br>ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br></code></pre></td></tr></table></figure><blockquote><p>flip()：反转此缓冲区。首先对当前位置设置限制，然后将该位置设置为零。如果已定义了标记，则丢弃该标记</p></blockquote><h3 id="array-方法"><a href="#array-方法" class="headerlink" title="array()方法"></a>array()方法</h3><ul><li>public final byte[] array(); 把缓冲区数据转换成字节数组<ul><li>它是缓冲区类的一个静态方法</li></ul></li></ul><h3 id="wrap-方法"><a href="#wrap-方法" class="headerlink" title="wrap()方法"></a>wrap()方法</h3><ul><li>public static ByteBuffer wrap(byte[] array); 把一个现成的数组放到缓冲区中使用<ul><li>它是缓冲区类的一个静态方法</li></ul></li></ul><h3 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h3><ul><li>该方法<strong>只能在读模式下使用</strong></li><li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li></ul><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/2.5.png"></p><h3 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a>clean()方法</h3><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/2.6.png"></p><h3 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h3><ul><li>mark()方法会将postion的值保存到mark属性中</li><li>reset()方法会将position的值改为mark中保存的值</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>System.out.println(<span class="hljs-string">&quot;放入前参数&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());<br>System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());<br>System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());<br>System.out.println();<br><br>System.out.println(<span class="hljs-string">&quot;------put()------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;放入3个数据&quot;</span>);<br><span class="hljs-keyword">byte</span> bt = <span class="hljs-number">1</span>;<br>byteBuffer.put(bt);<br>byteBuffer.put(bt);<br>byteBuffer.put(bt);<br><br>System.out.println(<span class="hljs-string">&quot;放入后参数&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());<br>System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());<br>System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());<br>System.out.println();<br><br>System.out.println(<span class="hljs-string">&quot;------flip()-get()------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;读取一个数据&quot;</span>);<br><span class="hljs-comment">// 切换模式</span><br>byteBuffer.flip();<br>byteBuffer.get();<br><br>System.out.println(<span class="hljs-string">&quot;读取后参数&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());<br>System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());<br>System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());<br>System.out.println();<br><br>System.out.println(<span class="hljs-string">&quot;------rewind()------&quot;</span>);<br>byteBuffer.rewind();<br>System.out.println(<span class="hljs-string">&quot;恢复后参数&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());<br>System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());<br>System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());<br>System.out.println();<br><br>System.out.println(<span class="hljs-string">&quot;------clear()------&quot;</span>);<br><span class="hljs-comment">// 清空缓冲区，这里只是恢复了各个属性的值，但是缓冲区里的数据依然存在</span><br><span class="hljs-comment">// 但是下次写入的时候会覆盖缓冲区中之前的数据</span><br>byteBuffer.clear();<br>System.out.println(<span class="hljs-string">&quot;清空后参数&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());<br>System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());<br>System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());<br>System.out.println();<br>System.out.println(<span class="hljs-string">&quot;清空后获得数据&quot;</span>);<br>System.out.println(byteBuffer.get());<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">放入前参数<br>position <span class="hljs-number">0</span><br>limit <span class="hljs-number">1024</span><br>capacity <span class="hljs-number">1024</span><br><br>------put()------<br>放入<span class="hljs-number">3</span>个数据<br>放入后参数<br>position <span class="hljs-number">3</span><br>limit <span class="hljs-number">1024</span><br>capacity <span class="hljs-number">1024</span><br><br>------flip()-get()------<br>读取一个数据<br>读取后参数<br>position <span class="hljs-number">1</span><br>limit <span class="hljs-number">3</span><br>capacity <span class="hljs-number">1024</span><br><br>------rewind()------<br>恢复后参数<br>position <span class="hljs-number">0</span><br>limit <span class="hljs-number">3</span><br>capacity <span class="hljs-number">1024</span><br><br>------clear()------<br>清空后参数<br>position <span class="hljs-number">0</span><br>limit <span class="hljs-number">1024</span><br>capacity <span class="hljs-number">1024</span><br><br>清空后获得数据<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="2-4-非直接缓冲区和直接缓冲区"><a href="#2-4-非直接缓冲区和直接缓冲区" class="headerlink" title="2.4 非直接缓冲区和直接缓冲区"></a>2.4 非直接缓冲区和直接缓冲区</h2><h3 id="非直接缓冲区"><a href="#非直接缓冲区" class="headerlink" title="非直接缓冲区"></a>非直接缓冲区</h3><p>通过<strong>allocate()<strong>方法获取的缓冲区都是非直接缓冲区。这些缓冲区是建立在JVM</strong>堆内存</strong>之中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br><br>    <span class="hljs-comment">// 在堆内存中开辟空间</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeapByteBuffer(capacity, capacity);<br>&#125;<br><br>HeapByteBuffer(<span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> lim) &#123;        <span class="hljs-comment">// package-private</span><br>    <span class="hljs-comment">// new byte[cap] 创建数组，在堆内存中开辟空间</span><br>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, lim, cap, <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[cap], <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    hb = new byte[cap];</span><br><span class="hljs-comment">    offset = 0;</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/2.7.png"></p><p>通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。<strong>都需要经过JVM和操作系统</strong>，数据在两个地址空间中传输时，会<strong>copy</strong>一份保存在对方的空间中。所以费直接缓冲区的读取效率较低</p><h3 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h3><p><strong>只有ByteBuffer可以获得直接缓冲区</strong>，通过allocateDirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在<strong>物理内存</strong>之中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);<br>&#125;<br><br>DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;                   <span class="hljs-comment">// package-private</span><br>...<br>    <span class="hljs-comment">// 申请物理内存</span><br><span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/2.8.png"></p><p>直接缓冲区通过在操作系统和JVM之间创建<strong>物理内存映射文件</strong>加快缓冲区数据读/写入物理磁盘的速度。放到物理内存映射文件中的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入到物理内存中</p><h1 id="三、通道"><a href="#三、通道" class="headerlink" title="三、通道"></a>三、通道</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>Channel由java.nio.channels 包定义的。Channel 表示<strong>IO 源与目标打开的连接</strong>。Channel 类似于传统的“流”。只不过<strong>Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互</strong></p><p>BIO 中的stream是<strong>单向</strong>的，例如FileInputStream 对象只能进行读取数据的操作，而NIO中的通道(Channel)是<strong>双向</strong>的，既可以用来进行读操作，也可以用来进行写操作。</p><h2 id="3-2-图解"><a href="#3-2-图解" class="headerlink" title="3.2 图解"></a>3.2 图解</h2><p>应用程序进行读写操作调用函数时，<strong>底层调用的操作系统提供给用户的读写API</strong>，调用这些API时会生成对应的指令，CPU则会执行这些指令。在计算机刚出现的那段时间，<strong>所有读写请求的指令都有CPU去执行</strong>，过多的读写请求会导致CPU无法去执行其他命令，从而CPU的利用率降低</p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/3.1.png"></p><p>后来，<strong>DMA</strong>(Direct Memory Access，直接存储器访问)出现了。当IO请求传到计算机底层时，<strong>DMA会向CPU请求，让DMA去处理这些IO操作</strong>，从而可以让CPU去执行其他指令。DMA处理IO操作时，会请求获取总线的使用权。<strong>当IO请求过多时，会导致大量总线用于处理IO请求，从而降低效率</strong></p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/3.2.png"></p><p>于是便有了<strong>Channel(通道)<strong>，Channel相当于一个</strong>专门用于IO操作的独立处理器</strong>，它具有独立处理IO请求的能力，当有IO请求时，它会自行处理这些IO请求</p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/3.3.png"></p><h2 id="3-3-Java-Channel"><a href="#3-3-Java-Channel" class="headerlink" title="3.3 Java Channel"></a>3.3 Java Channel</h2><h3 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h3><p>常用的Channel 类有：<strong>FileChannel</strong>、<strong>DatagramChannel</strong>、<strong>ServerSocketChannel <strong>和</strong>SocketChannel</strong>。FileChannel 用于本地文件的数据读写，DatagramChannel 用于UDP 的数据读写，ServerSocketChannel 和SocketChannel 用于TCP 的数据读写。</p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/3.4.png"></p><h3 id="获得通道的方法"><a href="#获得通道的方法" class="headerlink" title="获得通道的方法"></a>获得通道的方法</h3><p>获取通道的一种方式是对支持通道的<strong>对象调用getChannel() 方法</strong>。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 本地通道</span><br>      FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;&quot;</span>);<br>      FileChannel channel1 = fileInputStream.getChannel();<br><br>      FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;&quot;</span>);<br>      FileChannel channel2 = fileOutputStream.getChannel();<br>   <br>      <span class="hljs-comment">// 网络通道</span><br>      Socket socket = <span class="hljs-keyword">new</span> Socket();<br>      SocketChannel channel3 = socket.getChannel();<br>      <br>      ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>      ServerSocketChannel channel4 = serverSocket.getChannel();<br><br>      DatagramSocket datagramSocket = <span class="hljs-keyword">new</span> DatagramSocket();<br>      DatagramChannel channel5 = datagramSocket.getChannel();<br>       <br>      <span class="hljs-comment">// 最后要关闭通道</span><br>       <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>也可以通过通道的静态方法open()来获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>   FileChannel open = FileChannel.open(Paths.get(<span class="hljs-string">&quot;&quot;</span>));<br>   <br>   SocketChannel open1 = SocketChannel.open();<br>   <br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getChannel-非直接缓冲区"><a href="#getChannel-非直接缓冲区" class="headerlink" title="getChannel()+非直接缓冲区"></a>getChannel()+非直接缓冲区</h3><ul><li>getChannel()获得通道</li><li>allocate()获得<strong>非直接缓冲区</strong></li></ul><p>通过非直接缓冲区读写数据，需要通过通道来传输缓冲区里的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      FileInputStream is = <span class="hljs-keyword">null</span>;<br>      FileOutputStream os = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-comment">// 获得通道</span><br>      FileChannel inChannel = <span class="hljs-keyword">null</span>;<br>      FileChannel outChannel = <span class="hljs-keyword">null</span>;<br>       <br>      <span class="hljs-comment">// 利用 try-catch-finally 保证关闭</span><br>      <span class="hljs-keyword">try</span> &#123;<br>         is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\temp\\1.txt&quot;</span>);<br>         os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\temp\\2.txt&quot;</span>);<br><br>         <span class="hljs-comment">// 获得通道</span><br>         inChannel = is.getChannel();<br>         outChannel = os.getChannel();<br><br>         <span class="hljs-comment">// 获得缓冲区，用于在通道中传输数据</span><br>         ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>         <span class="hljs-comment">// 循环将字节数据放入到buffer中，然后写入磁盘中</span><br>         <span class="hljs-keyword">while</span> (inChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 切换模式</span><br>            byteBuffer.flip();<br>            outChannel.write(byteBuffer);<br>            byteBuffer.clear();<br>         &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>         e.printStackTrace();<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         <span class="hljs-keyword">if</span> (inChannel != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               inChannel.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>               e.printStackTrace();<br>            &#125;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (outChannel != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               outChannel.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>               e.printStackTrace();<br>            &#125;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               is.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>               e.printStackTrace();<br>            &#125;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (os != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               os.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>               e.printStackTrace();<br>            &#125;<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="open-直接缓冲区"><a href="#open-直接缓冲区" class="headerlink" title="open()+直接缓冲区"></a>open()+直接缓冲区</h3><ul><li>通过open获得通道</li><li>通过FileChannel.map()获取直接缓冲区</li></ul><p>使用直接缓冲区时，无需通过通道来传输数据，直接将数据放在缓冲区内即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 通过open()方法来获得通道</span><br>      FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;E:\\temp\\1.txt&quot;</span>), StandardOpenOption.READ);<br><br>      <span class="hljs-comment">// outChannel需要为 READ WRITE CREATE模式</span><br>      <span class="hljs-comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span><br>      <span class="hljs-comment">// CREATE是因为要创建新的文件</span><br>      FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;E:\\temp\\3.txt&quot;</span>), <br>                                                StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);<br><br>      <span class="hljs-comment">// 获得直接缓冲区</span><br>      MappedByteBuffer inMapBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, inChannel.size());<br>      MappedByteBuffer outMapBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, inChannel.size());<br><br>      <span class="hljs-comment">// 字节数组</span><br>      <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inMapBuf.limit()];<br><br>      <span class="hljs-comment">// 因为是直接缓冲区，可以直接将数据放入到内存映射文件，无需通过通道传输</span><br>      inMapBuf.get(bytes);<br>      outMapBuf.put(bytes);<br><br>      <span class="hljs-comment">// 关闭缓冲区，这里没有用try-catch-finally</span><br>      inChannel.close();<br>      outChannel.close();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>直接缓冲区的读写速度虽然很快，但是会占用很多很多内存空间。如果文件过大，会使得系统整体运行速度变慢</p></blockquote><h2 id="3-4-分散和聚集"><a href="#3-4-分散和聚集" class="headerlink" title="3.4 分散和聚集"></a>3.4 分散和聚集</h2><h3 id="分散读取"><a href="#分散读取" class="headerlink" title="分散读取"></a>分散读取</h3><p>分散读取（Scattering Reads）是指<strong>从Channel 中读取的数据“分散”到多个Buffer 中</strong></p><p><strong>注意</strong>：按照缓冲区的<strong>顺序</strong>，从Channel 中读取的数据依次将 Buffer 填满</p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/3.5.png"></p><h3 id="聚集写入"><a href="#聚集写入" class="headerlink" title="聚集写入"></a>聚集写入</h3><p>聚集写入（Gathering Writes）是指将<strong>多个Buffer 中的数据“聚集”到Channel</strong></p><p>按照缓冲区的<strong>顺序</strong>，写入position 和limit 之间的数据到Channel</p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/3.6.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      FileInputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\temp\\1.zip&quot;</span>);<br>      FileOutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\temp\\2.zip&quot;</span>);<br><br>      FileChannel inChannel = is.getChannel();<br>      FileChannel outChannel = os.getChannel();<br><br>      <span class="hljs-comment">// 获得多个缓冲区，并且放入到缓冲区数组中</span><br>      ByteBuffer byteBuffer1 = ByteBuffer.allocate(<span class="hljs-number">50</span>);<br>      ByteBuffer byteBuffer2 = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>      ByteBuffer[] byteBuffers = &#123;byteBuffer1, byteBuffer2&#125;;<br><br>      <span class="hljs-comment">// 分散读取</span><br>      inChannel.read(byteBuffers);<br>      <br>      byteBuffer1.flip();<br>      byteBuffer2.flip();<br>      <br>      <span class="hljs-comment">// 聚集写入</span><br>      outChannel.write(byteBuffers);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、网络IO"><a href="#四、网络IO" class="headerlink" title="四、网络IO"></a>四、网络IO</h1><p>前面在进行文件IO 时用到的<strong>FileChannel并不支持非阻塞操作</strong>，学习NIO 主要就是进行<strong>网络IO</strong>，Java NIO中的<strong>网络通道是非阻塞IO</strong>的实现，<strong>基于事件驱动</strong>，非常适用于服务器需要维持大量连接，但是数据交换量不大的情况，例如一些即时通信的服务等等….</p><h2 id="4-1-阻塞式网络通信"><a href="#4-1-阻塞式网络通信" class="headerlink" title="4.1 阻塞式网络通信"></a>4.1 阻塞式网络通信</h2><p>传统的IO 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，<strong>该线程被阻塞</strong>，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务</p><p>因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以<strong>服务器端必须为每个客户端都提供一个独立的线程进行处理</strong>，当服务器端需要处理大量客户端时，<strong>性能急剧下降</strong></p><p>也就是说，服务器在等待IO准备就绪的期间，<strong>线程处于阻塞状态</strong>，若为单线程，等待期间CPU未执行任何任务，效率降低。所以需要开启多个线程，当某些线程因为等待IO准备就绪时，CPU可以去执行其他线程中的任务。但是线程的创建、切换与销毁的开销也是不小的。当大量的任务到来时，服务器性能也急剧下降。</p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/4.1.png"></p><p>例如，TCP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    TCP接收数据的步骤</span><br><span class="hljs-comment">        1:创建服务器端的Socket对象(ServerSocket)</span><br><span class="hljs-comment">        2:获取输入流，读数据，并把数据显示在控制台</span><br><span class="hljs-comment">        3:释放资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//创建服务器端的Socket对象(ServerSocket)</span><br>        <span class="hljs-comment">//ServerSocket(int port) 创建绑定到指定端口的服务器套接字</span><br>        ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">10000</span>);<br><br>        <span class="hljs-comment">//Socket accept() 侦听要连接到此套接字并接受它</span><br>        Socket s = ss.accept();<br><br>        <span class="hljs-comment">//获取输入流，读数据，并把数据显示在控制台</span><br>        InputStream is = s.getInputStream();<br>        <span class="hljs-keyword">byte</span>[] bys = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> len = is.read(bys);<br>        String data = <span class="hljs-keyword">new</span> String(bys,<span class="hljs-number">0</span>,len);<br>        System.out.println(<span class="hljs-string">&quot;数据是：&quot;</span> + data);<br><br>        <span class="hljs-comment">//释放资源</span><br>        s.close();<br>        ss.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    TCP发送数据的步骤</span><br><span class="hljs-comment">        1:创建客户端的Socket对象(Socket)</span><br><span class="hljs-comment">        2:获取输出流，写数据</span><br><span class="hljs-comment">        3:释放资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//创建客户端的Socket对象(Socket)</span><br>        <span class="hljs-comment">//Socket(InetAddress address, int port) 创建流套接字并将其连接到指定IP地址的指定端口号</span><br><span class="hljs-comment">//        Socket s = new Socket(InetAddress.getByName(&quot;10.18.25.203&quot;),10000);</span><br>        <span class="hljs-comment">//Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号</span><br>        Socket s = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;10.18.25.203&quot;</span>,<span class="hljs-number">10000</span>);<br><br>        <span class="hljs-comment">//获取输出流，写数据</span><br>        <span class="hljs-comment">//OutputStream getOutputStream() 返回此套接字的输出流</span><br>        OutputStream os = s.getOutputStream();<br>        os.write(<span class="hljs-string">&quot;hello,tcp,我来了&quot;</span>.getBytes());<br><br>        <span class="hljs-comment">//释放资源</span><br>        s.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-非阻塞式网络通信"><a href="#4-2-非阻塞式网络通信" class="headerlink" title="4.2 非阻塞式网络通信"></a>4.2 非阻塞式网络通信</h2><p>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，<strong>若没有数据可用时，该线程可以进行其他任务</strong>。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以<strong>单独的线程可以管理多个输入和输出通道</strong></p><p>因此，NIO 可以让服务器端<strong>使用一个或有限几个线程来同时处理连接到服务器端的所有客户端</strong></p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/4.2.png"></p><p>例如，聊天室</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Selector selector;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//1.获取ServerSocketChannel对象</span><br>        ServerSocketChannel serverChannel = ServerSocketChannel.open();<br><br>        <span class="hljs-comment">//2.获取一个Selector</span><br>        selector = Selector.open();<br><br>        <span class="hljs-comment">//3.绑定端口号</span><br>        serverChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">9999</span>));<br><br>        <span class="hljs-comment">//4.设置非阻塞模式</span><br>        serverChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-comment">//5.将serverSocketChannel注册到selector</span><br>        serverChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-comment">//6.进行监听</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-comment">//6.1监听端口，如果没有客户端连接，就继续监听</span><br>            <span class="hljs-keyword">if</span> (selector.select(<span class="hljs-number">2000</span>)==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//System.out.println(&quot;服务端：没有客户端，我可以干别的，体现非阻塞式&quot;);</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//6.2有客户端就绪，服务端得到SelectionKey，判断通道里的事件</span><br>            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span> (keyIterator.hasNext())&#123;<br>                SelectionKey key = keyIterator.next();<br><br>                <span class="hljs-comment">//客户端可以连接了</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable())&#123;<br>                    SocketChannel socketChannel = serverChannel.accept();<br>                    socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>                    socketChannel.register(selector,SelectionKey.OP_READ);<br>                    System.out.println(socketChannel.getRemoteAddress().toString()+<span class="hljs-string">&quot;上线了&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-comment">//客户端数据可以读取了</span><br>                <span class="hljs-keyword">if</span> (key.isReadable())&#123;<br>                    readMsg(key);<br>                &#125;<br><br>                <span class="hljs-comment">//6.3手动从集合中移除当前key防止重复处理</span><br>                keyIterator.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//读取客户端发来的信息，并进行广播</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readMsg</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SocketChannel channel = (SocketChannel)key.channel();<br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-keyword">if</span> (channel.read(buffer)&gt;<span class="hljs-number">0</span>)&#123;<br>            String msg = <span class="hljs-keyword">new</span> String(buffer.array());<br>            printInfo(msg);<br>            <span class="hljs-comment">//发广播</span><br>            broadcast(channel,msg);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//给所有客户端发广播</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">broadcast</span><span class="hljs-params">(SocketChannel channel, String msg)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器发送广播了&quot;</span>);<br>        <span class="hljs-keyword">for</span> (SelectionKey key :selector.keys()) &#123;<br>            Channel targetChannel = key.channel();<br>            <span class="hljs-keyword">if</span> (targetChannel <span class="hljs-keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel!=channel)&#123;<br>                SocketChannel sc = (SocketChannel)targetChannel;<br>                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());<br>                sc.write(buffer);<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">(String msg)</span></span>&#123;<br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;[&quot;</span>+sdf.format(<span class="hljs-keyword">new</span> Date())+<span class="hljs-string">&quot;]-&gt;&quot;</span>+msg);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatClient</span> </span>&#123;<br>    <span class="hljs-comment">//服务器地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String HOST =<span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-comment">//服务器端口</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">9999</span>;<br>    <span class="hljs-comment">//通道</span><br>    <span class="hljs-keyword">private</span> SocketChannel socketChannel;<br>    <span class="hljs-comment">//聊天用户名</span><br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChatClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        <span class="hljs-keyword">this</span>.socketChannel = SocketChannel.open();<br>        <span class="hljs-keyword">this</span>.socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>        SocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(HOST, PORT);<br>        <span class="hljs-comment">//this.socketChannel.bind(address);</span><br><br>        <span class="hljs-comment">//4.连接到服务端,连不上就一直尝试</span><br>        <span class="hljs-keyword">if</span> (!socketChannel.connect(address))&#123;<br>            <span class="hljs-keyword">while</span> (!socketChannel.finishConnect())&#123;<br>                System.out.println(<span class="hljs-string">&quot;客户端：没有服务端，我可以干别的，体现非阻塞式&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.userName = socketChannel.getLocalAddress().toString();<br>        System.out.println(<span class="hljs-string">&quot;==========&quot;</span>+userName+<span class="hljs-string">&quot;，已经就位==========&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//向服务器发数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (msg.equalsIgnoreCase(<span class="hljs-string">&quot;bye&quot;</span>))&#123;<br>         socketChannel.close();<br>         <span class="hljs-keyword">return</span>;<br>        &#125;<br>        msg = userName+<span class="hljs-string">&quot;说&quot;</span>+msg;<br>        ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());<br>        socketChannel.write(buffer);<br>    &#125;<br><br>    <span class="hljs-comment">//从服务器接收数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMsg</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-keyword">int</span> size = socketChannel.read(buffer);<br>        <span class="hljs-keyword">if</span> (size&gt;<span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(buffer.array()));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试程序</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestChatClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ChatClient chatClient = <span class="hljs-keyword">new</span> ChatClient();<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    chatClient.receiveMsg();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        Scanner scanner=<span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNextLine())&#123;<br>            String msg=scanner.nextLine();<br>            chatClient.sendMsg(msg);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/4.3.png"></p><h1 id="五、选择器"><a href="#五、选择器" class="headerlink" title="五、选择器"></a>五、选择器</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Selector(选择器)，<strong>能够检测多个注册的通道上是否有事件发生</strong>，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。</p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/4.4.png"></p><p>Selector(选择器)是<strong>SelectableChannle</strong> 对象的多路复用器，Selector 可以同时监控多个SelectableChannel 的IO 状况，也就是说，利用Selector 可使一个单独的线程管理多个Channel。<strong>Selector 是非阻塞IO 的核心</strong></p><p><img src="/2020/11/20/Java/JavaNIO/JavaNIO/4.5.png"></p><h2 id="5-2-Selector常用方法"><a href="#5-2-Selector常用方法" class="headerlink" title="5.2 Selector常用方法"></a>5.2 Selector常用方法</h2><ul><li>public static Selector open()，得到一个选择器对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个选择器</span><br>Selector selector = Selector.open();<br></code></pre></td></tr></table></figure><ul><li><p>public int select(long timeout)，监控所有注册的通道，当其中有IO 操作可以进行时，将对应的SelectionKey 加入到内部集合中并返回，参数用来设置超时时间</p></li><li><p>public Set<SelectionKey> selectedKeys()，从内部集合中得到所有的SelectionKey</SelectionKey></p></li></ul><h2 id="5-3-SelectionKey"><a href="#5-3-SelectionKey" class="headerlink" title="5.3 SelectionKey"></a>5.3 SelectionKey</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>SelectionKey表示SelectableChannel 和Selector 之间的注册关系（一共四种）</strong>。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作</p><ul><li>int OP_ACCEPT：有新的网络连接可以accept，值为16</li><li>int OP_CONNECT：代表连接已经建立，值为8</li><li>int OP_READ：代表读操作，值为1</li><li>int OP_WRITE：代表写操作，值为4</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>public abstract Selector selector()，得到与之关联的Selector 对象</li><li>public abstract SelectableChannel channel()，得到与之关联的通道</li><li>public final Object attachment()，得到与之关联的共享数据</li><li>public abstract SelectionKey interestOps(int ops)，设置或改变监听事件</li><li>public final boolean isAcceptable()，是否可以accept</li><li>public final boolean isReadable()，是否可以读</li><li>public final boolean isWritable()，是否可以写</li></ul><h2 id="5-4-ServerSocketChannel"><a href="#5-4-ServerSocketChannel" class="headerlink" title="5.4 ServerSocketChannel"></a>5.4 ServerSocketChannel</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>ServerSocketChannel，用来在服务器端监听新的客户端Socket 连接</strong></p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>public static ServerSocketChannel open()，得到一个ServerSocketChannel 通道</li><li>public final ServerSocketChannel bind(SocketAddress local)，设置服务器端端口号</li><li>public final SelectableChannel configureBlocking(boolean block)，设置阻塞或非阻塞模式，取值false 表示采用非阻塞模式</li><li>public SocketChannel accept()，接受一个连接，返回代表这个连接的通道对象</li><li>public final SelectionKey register(Selector sel, int ops)，注册一个选择器并设置监听事件，ops：监听事件类型。ops有4个值可以选择，为<strong>SelectionKey</strong>的静态属性</li></ul><h2 id="5-5-SocketChannel"><a href="#5-5-SocketChannel" class="headerlink" title="5.5 SocketChannel"></a>5.5 SocketChannel</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>SocketChannel，网络IO 通道，具体负责进行读写操作。NIO 总是把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区</strong></p><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>public static SocketChannel open()，得到一个SocketChannel 通道</li><li>public final SelectableChannel configureBlocking(boolean block)，设置阻塞或非阻塞模式，取值false 表示采用非阻塞模式</li><li>public boolean connect(SocketAddress remote)，连接服务器</li><li>public boolean finishConnect()，如果上面的方法连接失败，接下来就要通过该方法完成连接操作</li><li>public int write(ByteBuffer src)，往通道里写数据</li><li>public int read(ByteBuffer dst)，从通道里读数据</li><li>public final SelectionKey register(Selector sel, int ops, Object att)，注册一个选择器并设置监听事件，最后一个参数可以设置共享数据</li><li>public final void close()，关闭通道</li></ul><h1 id="六、IO对比"><a href="#六、IO对比" class="headerlink" title="六、IO对比"></a>六、IO对比</h1><p>IO 的方式通常分为几种：<strong>同步阻塞</strong>的BIO、<strong>同步非阻塞</strong>的NIO、<strong>异步非阻塞</strong>的AIO。</p><ul><li>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。</li><li>NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。</li><li>AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS 参与并发操作，编程比较复杂，JDK7 开始支持。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JavaNIO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RediS设计与实现</title>
    <link href="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis中的数据结构与对象"><a href="#一、Redis中的数据结构与对象" class="headerlink" title="一、Redis中的数据结构与对象"></a>一、Redis中的数据结构与对象</h1><h2 id="1-1-简单动态字符串"><a href="#1-1-简单动态字符串" class="headerlink" title="1.1 简单动态字符串"></a>1.1 简单动态字符串</h2><p>Redis没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（Simple Dynamic String，SDS）的抽象类型，并将<strong>SDS用作Redis的默认字符串表示</strong></p><p>在Redis数据库中，包含字符串值的键值对在底层都是由SDS实现的，如：SET msg “hello redis”，其键和值是两个SDS</p><h3 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h3><p>SDS称为简单动态字符串（Simple Dynamic String），每个sds.h/sdshdr结构表示一个SDS值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>    <span class="hljs-comment">//记录buf数组中已使用字节的数量</span><br>    <span class="hljs-comment">//等于SDS所保存字符串的长度</span><br>    <span class="hljs-keyword">int</span> len;<br>    <br>    <span class="hljs-comment">//记录buf数组中未使用字节的数量</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">free</span>;<br>    <br>    <span class="hljs-comment">//字节数组，用于保存字符串</span><br>    <span class="hljs-keyword">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果将一个值为“Redis”的字符串放入SDS中，它的状态如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.1.png"></p><ul><li><p>buf相当于C中的字符串，<strong>一般被称为字节数组</strong>，为一个char类型的数组</p></li><li><p>len记录了buf的长度（未记录最后一个’\0’字符）（这个空字符不计算在SDS的len属性里，并未空字符分配额外的1字节空间，空字符对于SDS使用者是完全透明的）</p><ul><li>该值使得<strong>获取字符串的长度的时间复杂度降为了O(1)</strong></li><li>设置和更新SDS长度的工作是由SDS的API在执行时自动完成的</li></ul></li><li><p>free中保存了额外申请的空间</p><ul><li><p>通过未使用空间，SDS实现了空间预分配和惰性空间释放的两种优化策略</p></li><li><p>在进行字符串拼接时（空间预分配）</p><ul><li>如果空间充足，会直接使用之前额外申请的空间</li><li>如果空间不足（free &lt; 拼接字符串的长度）会申请额外的空间。若所需的空间<strong>小于1M</strong>，会额外申请和len值相同的空间（如申请13个字节，则free也为13，算上空字符的1字节，共计13+13+1=27字节）。若所需空间<strong>大于等于1M</strong>，则额外申请1M的空间（如申请13MB，则free也为1MB，算上空字符的1字节，共计13MB+1MB+1byte）</li></ul></li><li><p>在进行字符串裁剪时（惰性空间释放）</p><ul><li>多出来的空间会被记录在free中，方便再次使用</li></ul></li></ul></li></ul><h3 id="SDS与C语言字符串的差别"><a href="#SDS与C语言字符串的差别" class="headerlink" title="SDS与C语言字符串的差别"></a>SDS与C语言字符串的差别</h3><table><thead><tr><th>C语言字符串</th><th>SDS</th><th>解释</th></tr></thead><tbody><tr><td>获取长度的时间复杂度为O(n)</td><td>获取长度的时间复杂度为O(1)</td><td>SDS中len属性保存了字符串的长度</td></tr><tr><td>修改字符串n次<strong>必定</strong>执行n次内存分配</td><td>修改字符串<strong>最多</strong>执行n次内存分配</td><td>SDS会分配额外的空间，额外空间大小由free记录</td></tr><tr><td>只能保存文本数据</td><td>可以保存文本数据或者二进制数据</td><td>SDS使用buf来保存一系列二进制数据，不会因为‘\0’分隔字符串，而使用len判断字符串是否结束</td></tr><tr><td>可以使用&lt;string.h&gt;库中所有的函数</td><td>可以使用&lt;string.h&gt;中部分函数</td><td>SDS中的buf相当于字符串</td></tr></tbody></table><hr><h2 id="1-2-链表（Redis-3-2以后已经不再使用）"><a href="#1-2-链表（Redis-3-2以后已经不再使用）" class="headerlink" title="1.2 链表（Redis 3.2以后已经不再使用）"></a>1.2 链表（Redis 3.2以后已经不再使用）</h2><p>由于C语言并没有内置链表数据结构，由于Redis构建了自己的链表实现</p><p>链表在Redis中的应用非常广泛，如<strong>列表键</strong>（list）的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，或者列表中包含的元素的都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现</p><h3 id="Redis中的链表"><a href="#Redis中的链表" class="headerlink" title="Redis中的链表"></a>Redis中的链表</h3><p>每个<strong>链表节点</strong>使用一个adlist.h/listNode结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    <span class="hljs-comment">// 保存前驱节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span><br>    <span class="hljs-comment">// 保存后继节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-comment">// 保存值</span><br>    <span class="hljs-keyword">void</span> *value;<br>&#125; listNode;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.2.png"></p><p>Redis中将节点放在了list中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br>    <span class="hljs-comment">// 头结点</span><br>    listNode *head;<br>    <span class="hljs-comment">// 尾节点</span><br>    listNode *tail;<br>    <span class="hljs-comment">// 链表长度</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;<br>    <span class="hljs-comment">// 节点复制函数</span><br>    <span class="hljs-keyword">void</span> *(*dup)(<span class="hljs-keyword">void</span> *ptr);<br>    <span class="hljs-comment">// 节点释放函数</span><br>    <span class="hljs-keyword">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-keyword">void</span> *ptr);<br>    <span class="hljs-comment">// 匹配函数</span><br>    <span class="hljs-keyword">int</span> (*match)(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">void</span> *key);<br>&#125; <span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure><p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len</p><p>dup、free和match成员则是用于实现多态链表所需的类型特定函数</p><ul><li>dup函数用于复制链表节点所保存的</li><li>free函数用于释放链表节点所保存的值</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.3.png"></p><h3 id="Redis中链表的特性"><a href="#Redis中链表的特性" class="headerlink" title="Redis中链表的特性"></a>Redis中链表的特性</h3><ul><li><strong>双向链表</strong>，能够很方便地获取一个节点的前驱节点或后继节点</li><li><strong>带头尾指针</strong>，list中的head与tail分别保存了链表的头结点和尾节点</li><li><strong>获取长度方便</strong>，list中的len属性使得获取链表长度的时间复杂度变为了O(1)</li><li><strong>多态</strong>，链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值</li></ul><hr><h2 id="1-3-字典"><a href="#1-3-字典" class="headerlink" title="1.3 字典"></a>1.3 字典</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>字典，又称为符号表、关联数组或映射，是一种用于保存键值对的抽象数据结构</p><p>在字典中，一个键（key）可以和一个值（value）进行关联</p><p>Redis中数据库就是使用字典作为底层实现的。字典还是哈希键（<strong>hash</strong>）的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符长时，Redis就会使用字典作为哈希键的底层实现。</p><h3 id="Redis中字典的实现"><a href="#Redis中字典的实现" class="headerlink" title="Redis中字典的实现"></a>Redis中字典的实现</h3><p>Redis的字典使用<strong>哈希表</strong>作为底层实现，一个哈希表里面可以有<strong>多个</strong>哈希表节点，而每个哈希表节点就保存了字典中的<strong>一个</strong>键值对</p><h4 id="哈希节点"><a href="#哈希节点" class="headerlink" title="哈希节点"></a>哈希节点</h4><p>Redis中哈希节点的实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <span class="hljs-comment">// 键</span><br>    <span class="hljs-keyword">void</span> *key;<br>    <span class="hljs-comment">// 值</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-keyword">void</span> *val;<br>        <span class="hljs-keyword">uint64_t</span> u64;<br>        <span class="hljs-keyword">int64_t</span> s64;<br>    &#125; v;<br>    <span class="hljs-comment">// 指向下一个哈希节点，形成链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><ul><li>key保存了键值对中键的值</li><li>v保存了键值对中值的值，其中值可以为指针类型，uint64_t、int64_t和double</li><li>next用于解决哈希冲突，使用拉链法</li></ul><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis中的哈希表实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>    <span class="hljs-comment">// 哈希表数组</span><br>    <span class="hljs-comment">// 类似于Java中HashMap的</span><br>    <span class="hljs-comment">//transient Node&lt;K,V&gt;[] table;</span><br>    dictEntry **table;<br>    <br>    <span class="hljs-comment">// 哈希表大小</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size;<br>    <br>    <span class="hljs-comment">// 哈希表掩码，大小为size-1，用于计算索引值</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> sizemask;<br>    <br>    <span class="hljs-comment">// 哈希表中已有的节点数</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> used;<br>&#125; dictht;<br></code></pre></td></tr></table></figure><ul><li>table为一个dictEntry类型的数组<ul><li>每个dictEntry中保存了一个键值对</li></ul></li><li>size记录了哈希表的大小</li><li>sizemask为size-1，用于哈希计算，决定一个键应该被放到哪个桶中</li><li>used记录了哈希表目前已有节点（<strong>键值对</strong>）的数量</li></ul><p>下图展示了，通过next指针将索引值相同的键k1和k0连接在一起</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.4.png"></p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis中的字典实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>    <span class="hljs-comment">//类型特定的函数</span><br>    dictType *type;<br>    <span class="hljs-comment">//私有数据</span><br>    <span class="hljs-keyword">void</span> *privdata;<br>    <span class="hljs-comment">//哈希表</span><br>    dictht ht[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//rehash索引</span><br>    <span class="hljs-comment">//当rehas不在进行时，值为-1</span><br>    <span class="hljs-keyword">int</span> rehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span><br>&#125; dict;<br></code></pre></td></tr></table></figure><ul><li>type属性是一个指向<strong>dictType</strong>结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数</li><li>而privdata属性则保存了需要传给那些类型特定函数的可选参数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictType</span> &#123;</span><br>    <span class="hljs-comment">// 计算哈希值的函数</span><br>    <span class="hljs-keyword">uint64_t</span> (*hashFunction)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key);<br>    <br>    <span class="hljs-comment">// 复制键的函数</span><br>    <span class="hljs-keyword">void</span> *(*keyDup)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key);<br>    <br>    <span class="hljs-comment">// 复制值的函数</span><br>    <span class="hljs-keyword">void</span> *(*valDup)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj);<br>    <br>    <span class="hljs-comment">// 对比键的函数</span><br>    <span class="hljs-keyword">int</span> (*keyCompare)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key2);<br>    <br>    <span class="hljs-comment">// 销毁键的函数</span><br>    <span class="hljs-keyword">void</span> (*keyDestructor)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">void</span> *key);<br>    <br>   <span class="hljs-comment">// 销毁值的函数</span><br>    <span class="hljs-keyword">void</span> (*valDestructor)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">void</span> *obj);<br>&#125; dictType;<br></code></pre></td></tr></table></figure><ul><li>ht属性为包含了两个ditht元素的数组<ul><li>一般情况下，只是用ht[0]作为哈希表，ht[1]只会在对ht[0]进行<code>rehash</code>时才会使用</li></ul></li><li>rehashidx是除了ht[1]以外，另一个与rehash有关的属性，它<strong>记录了rehash目前的进度</strong>，如果没有rehash，那么它的值为-1</li></ul><p><strong>一个普通状态下（未进行rehash）的字典如下图所示</strong></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.5.png"></p><h3 id="字典中的算法"><a href="#字典中的算法" class="headerlink" title="字典中的算法"></a>字典中的算法</h3><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><blockquote><p>Redis计算哈希值和索引值的方法如下：</p><p>使用字典设置的哈希函数，计算键key的哈希值</p><p>hash = dict -&gt; type -&gt; hashFunction(key);</p><p>使用哈希表的sizemask属性和哈希值，计算出索引值</p><p>根据情况不同，ht[x]可以是ht[0]或ht[1]</p><p>index = hash &amp; dict -&gt; ht[x].sizemask</p></blockquote><p><strong>例</strong>：如果我们要将一个键值对k0和v0添加到容量为4字典里面，那么程序会先使用语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hash = dict-&gt;type-&gt;hashFunction(key0);<br></code></pre></td></tr></table></figure><p>计算出对应的hash值</p><p>假设计算的hash值为8，则再通过sizemask（值为3）来计算出索引</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">index = hash &amp; dict-&gt;ht[x].sizemask; <span class="hljs-comment">// 8 &amp; 3 = 0</span><br></code></pre></td></tr></table></figure><p>计算出key0的索引值为0，放入对应的位置上</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.6.png"></p><blockquote><p>Redis底层使用MurmurHash2算法来计算键的哈希值</p></blockquote><h4 id="哈希冲突的解决方法"><a href="#哈希冲突的解决方法" class="headerlink" title="哈希冲突的解决方法"></a>哈希冲突的解决方法</h4><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）。</p><p>Redis的哈希表使用<strong>链地址法</strong>（separate chaining）来解决键冲突（和Java 7 中的HashMap类似），每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。</p><p>程序总是将新的节点添加到链表的表头位置，排在其他已有节点的<strong>前面</strong></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.7.png"></p><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load_factor）维持在一个合理的范围之内（可以减少出现哈希冲突的几率），当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的<strong>扩展或者收缩</strong>。</p><p>扩展和收缩哈希表的工作可以通过执行<strong>rehash（重新散列）</strong>操作来完成，Redis对字典的哈希表执行rehash的步骤如下：</p><ul><li>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（dictht.used的大小）<ul><li>如果执行的是<strong>扩展操作</strong>，那么ht[1]的大小为<strong>第一个</strong>大于等于ht[0].used*2 的 2的n次方 （和Java 中的 HashMap一样，这样可以保证sizemask的值必定为11…11）</li><li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的 2的n次方<ul><li>注：Redis中的字典是有<strong>缩容</strong>操作的，而Java中的HashMap没有缩容操作</li></ul></li></ul></li><li>将保存在ht[0]中的所有键值对rehash到ht[1]上面<ul><li>rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上</li></ul></li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备<ul><li>上面有两步有点像垃圾回收算法中的<strong>标记-复制算法</strong>（FROM-TO，然后交换FROM 和 TO）</li></ul></li></ul><p><strong>例</strong></p><p>假设程序要对下图所示字典的ht[0]进行<strong>扩展操作</strong>，那么程序将执行以下步骤：</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.8.png"></p><ul><li>ht[0].used当前的值为4，4*2=8，所以程序会将ht[1]哈希表的大小设置为8。下图展示了ht[1]在分配空间之后，字典的样子</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.9.png"></p><ul><li>将ht[0]包含的四个键值对都<strong>rehash</strong>到ht[1]</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.10.png"></p><ul><li>释放ht[0]，并将ht[1]设置为ht[0]，然后为ht[1]分配一个空白哈希表，如下图所示。至此，对哈希表的扩展操作执行完毕，程序成功将哈希表的大小从原来的4改为了现在的8</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.11.png"></p><p><strong>哈希表的扩展与收缩</strong></p><p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作</p><ul><li>服务器目前<strong>没有在执行</strong>BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1</li><li>服务器目前<strong>正在执行</strong>BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5</li></ul><blockquote><p>负载因子的计算：</p><p>load_factory = ht[0].used/ht[0].size</p></blockquote><p>根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而<strong>尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存</strong>。</p><p>另一方面，<strong>当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作</strong>。</p><h4 id="渐进rehash"><a href="#渐进rehash" class="headerlink" title="渐进rehash"></a>渐进rehash</h4><p>扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，<strong>这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。</strong>这样做主要因为在数据量较大时，如果一次性，集中式地完成，庞大的计算量可能会导致服务器在一段时间内停止服务。</p><p><strong>详细步骤</strong></p><ul><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始<ul><li>索引计数器rehashidx类似程序计数器PC，用于保存进行rehash的进度（rehash到哪个索引了）</li></ul></li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一（指向下一个索引）</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成</li></ul><p><strong>例</strong></p><ul><li>准备开始rehash</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.12.png"></p><ul><li>开始rehash，rehash索引为0的键值对</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.13.png"></p><ul><li>rehash索引为1的键值对</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.14.png"></p><ul><li>… 依次rehash</li><li>rehash完成，rehashidx再次变为-1</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.15.png"></p><p>因为在进行渐进式rehash的过程中，<strong>字典会同时使用ht[0]和ht[1]两个哈希表</strong>，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会<strong>在两个哈希表上进行</strong></p><p> 例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进行查找，诸如此类</p><p>另外，在渐进式rehash执行期间，<strong>新添加到字典的键值对一律会被保存到ht[1]里面</strong>，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表</p><hr><h2 id="1-4-跳跃表"><a href="#1-4-跳跃表" class="headerlink" title="1.4 跳跃表"></a>1.4 跳跃表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>跳跃链表是一种随机化数据结构，<strong>基于并联的链表</strong>，其效率可比拟于二叉排序树(对于大多数操作需要O(log n)平均时间)，并且对并发算法友好。</p><p>Redis使用跳跃表作为有序集合键（<strong>Zset</strong>）的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表作为有序集合键的底层实现。</p><p>基本上，跳跃列表是对<strong>有序</strong>的链表增加上附加的前进链接，增加是以随机化（抛硬币）的方式进行的，所以在列表中的查找可以快速的跳过部分列表(因此得名)。所有操作都以对数随机化的时间进行。</p><h3 id="跳跃表原理"><a href="#跳跃表原理" class="headerlink" title="跳跃表原理"></a>跳跃表原理</h3><h4 id="查询链表的时间复杂度"><a href="#查询链表的时间复杂度" class="headerlink" title="查询链表的时间复杂度"></a>查询链表的时间复杂度</h4><p>**搜索链表中的元素时，无论链表中的元素是否有序，时间复杂度都为O(n)**，如下图，搜索103需要查询9次才能找到该节点</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.16.png"></p><p>但是能够提高搜索的其他数据结构，如：二叉排序树、红黑树、B树、B+树等等的实现又过于复杂。有没有一种相对简单，同时又能提搜索效率的数据结构呢，跳跃表就是这样一种数据结构。</p><p>Redis中使用跳跃表好像就是因为一是B+树的实现过于复杂，二是Redis只涉及内存读写，所以最后选择了跳跃表。</p><h4 id="跳跃表实现——搜索"><a href="#跳跃表实现——搜索" class="headerlink" title="跳跃表实现——搜索"></a>跳跃表实现——搜索</h4><p>为了能够更快的查找元素，我们可以在该链表之上，再添加一个新链表，新链表中保存了部分旧链表中的节点，以加快搜索的速度。如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.17.png"></p><p>我们搜索元素时，从最上层的链表开始搜索。当找到某个节点大于目标值或其后继节点为空时，从该节点向下层链表搜寻，然后顺着该节点到下一层继续搜索。</p><p>比如我们要找103这个元素，则会经历：2-&gt;23-&gt;54-&gt;87-&gt;103</p><p>这样还是查找了5次，当我们再将链表的层数增高以后，查找的次数会明显降低，如下图所示。3次便找到了目标元素103</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.18.png"></p><p><strong>代码中实现的跳表结构如下图所示</strong></p><p>一个节点拥有<strong>多个指针</strong>，指向不同的节点</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.19.png"></p><h4 id="跳跃表实现——插入"><a href="#跳跃表实现——插入" class="headerlink" title="跳跃表实现——插入"></a>跳跃表实现——插入</h4><p>跳跃表的插入策略如下</p><ul><li><p>先找到合适的位置以便插入元素</p></li><li><p>找到后，将该元素插入到最底层的链表中，并且</p><p>抛掷硬币（1/2的概率）</p><ul><li>若硬币为正面，则将该元素晋升到上一层链表中，<strong>并再抛一次</strong></li><li>若硬币为反面，则插入过程结束</li></ul></li><li><p>为了避免以下情况，需要在每个链表的头部设置一个 <strong>负无穷</strong> 的元素</p></li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.20.png"></p><p>设置负无穷后，若要查找元素2，过程如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.21.png"></p><p><strong>插入图解</strong></p><ul><li>若我们要将45插入到跳跃表中</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.22.png"></p><ul><li>先找到插入位置，将45插入到合适的位置</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.23.png"></p><ul><li>抛掷硬币：<strong>为正</strong>，晋升</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.24.png"></p><ul><li>假设硬币一直为正，插入元素一路晋升，当晋升的次数超过跳跃表的层数时，<strong>需要再创建新的链表以放入晋升的插入元素。新创建的链表的头结点为负无穷</strong></li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.25.png"></p><p><strong>以上便是跳跃表的插入过程</strong></p><hr><h3 id="为什么Redis要使用跳跃表而不是用B-树"><a href="#为什么Redis要使用跳跃表而不是用B-树" class="headerlink" title="为什么Redis要使用跳跃表而不是用B+树"></a>为什么Redis要使用跳跃表而不是用B+树</h3><p>引用Redis作者 antirez 的原话</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"> There are a few reasons:<br><br><span class="hljs-number">1</span>) They are <span class="hljs-built_in">not</span> very memory intensive. It<span class="hljs-comment">&#x27;s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</span><br><br><span class="hljs-number">2</span>) A sorted <span class="hljs-keyword">set</span> <span class="hljs-built_in">is</span> often target <span class="hljs-keyword">of</span> many ZRANGE <span class="hljs-built_in">or</span> ZREVRANGE operations, that <span class="hljs-built_in">is</span>, traversing the <span class="hljs-keyword">skip</span> list <span class="hljs-keyword">as</span> a linked list. <span class="hljs-keyword">With</span> this operation the cache locality <span class="hljs-keyword">of</span> <span class="hljs-keyword">skip</span> lists <span class="hljs-built_in">is</span> at least <span class="hljs-keyword">as</span> good <span class="hljs-keyword">as</span> <span class="hljs-keyword">with</span> other kind <span class="hljs-keyword">of</span> balanced trees.<br><br><span class="hljs-number">3</span>) They are simpler <span class="hljs-keyword">to</span> implement, debug, <span class="hljs-built_in">and</span> so forth. <span class="hljs-keyword">For</span> instance thanks <span class="hljs-keyword">to</span> the <span class="hljs-keyword">skip</span> list simplicity I received a patch (already <span class="hljs-keyword">in</span> Redis master) <span class="hljs-keyword">with</span> augmented <span class="hljs-keyword">skip</span> lists implementing ZRANK <span class="hljs-keyword">in</span> O(log(N)). It required little changes <span class="hljs-keyword">to</span> the code.<br><br>翻译一下<br><br><span class="hljs-number">1</span>) 它们不需要太多的内存。这基本上取决于你。改变一个节点具有给定级别数的概率的参数，会比btree占用更少的内存。<br><br><span class="hljs-number">2</span>) 排序集通常是许多ZRANGE或ZREVRANGE操作的目标，即作为链表遍历跳跃表。使用这种操作，跳跃表的缓存局部性至少与其他类型的平衡树一样好。<br><br><span class="hljs-number">3</span>)它们更容易实现、调试等等。例如，感谢跳跃表的简单性，我收到了一个补丁(已经在Redis master)，增强跳跃表实现ZRANK在O(log(N))。它只需要对代码做一点小小的修改。<br></code></pre></td></tr></table></figure><p>MySQL使用B+树的是因为：<strong>叶子节点存储数据，非叶子节点存储索引</strong>，B+树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，<strong>充分利用了磁盘预读的功能</strong>。每次读取磁盘页时就会读取一整个节点,每个叶子节点还有指向前后节点的指针，为的是最大限度的降低磁盘的IO;因为数据在内存中读取耗费的时间是从磁盘的IO读取的百万分之一</p><p>而Redis是<strong>内存中读取数据，不涉及IO，因此使用了跳跃表</strong></p><p>既然提到了Redis是对<strong>内存操作</strong>的，那么再讨论一个问题：<strong>为什么Redis是单线程的还这么快呢</strong></p><hr><h3 id="Redis使用单线程效率依然很高的原因"><a href="#Redis使用单线程效率依然很高的原因" class="headerlink" title="Redis使用单线程效率依然很高的原因"></a>Redis使用单线程效率依然很高的原因</h3><p>假设有两个任务A和B，分别有两种方法来执行他们</p><ul><li>两个线程并发执行：先执行A一段时间，然后切换到B再执行一段时间，然后又切换回A执行… 直到A和B都执行完毕</li><li>两个线程串行执行：先执行A，A执行完了在执行B</li></ul><p>对于单核CPU来说，第二种方法的执行时间更短，效率更高。因为单核CPU下的并发操作，会导致上下文的切换，需要保存切换线程的信息，这段时间CPU无法去执行任何任务中的指令，时间白白浪费了</p><p><strong>对于I/O操作，并发执行效率更高</strong></p><p>因为I/O操作主要有以下两个过程</p><ul><li>等待I/O准备就绪</li><li>真正操作I/O资源</li></ul><p><strong>等待I/O准备就绪</strong>这个阶段，CPU是空闲的，这时便可以去执行其他任务，这样也就提高了CPU的利用率</p><p><strong>而Redis是基于内存的操作，没有I/O操作，所以单线程执行效率更高</strong></p><hr><h3 id="Redis中跳跃表的实现"><a href="#Redis中跳跃表的实现" class="headerlink" title="Redis中跳跃表的实现"></a>Redis中跳跃表的实现</h3><p>Redis只在两个地方用到了跳跃表，一个是实现<strong>有序集合</strong>键，另一个是在<strong>集群节点中</strong>用作内部数据结构</p><p>Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义。其中<strong>zskiplistNode</strong>用于表示跳跃表节点，<strong>zskiplist</strong>用于保存跳跃表节点的相关信息</p><p>Redis中的跳表结构如下</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.26.png"></p><h4 id="zskiplistNode"><a href="#zskiplistNode" class="headerlink" title="zskiplistNode"></a>zskiplistNode</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    <span class="hljs-comment">// 后退指针，指向前驱节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br>    <br>    <span class="hljs-comment">// 存储的元素的地址,就是语句中的member的地址</span><br>    robj *obj;<br>    <br>    <span class="hljs-comment">// 分值,就是语句中的score</span><br>    <span class="hljs-keyword">double</span> score;<br>    <br>    <span class="hljs-comment">// 层，每个节点有1~32个层，除头结点外（32层），其他节点的层数是随机的</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-comment">// 前进指针，每个层都保存了该节点的后继节点</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>        <br>        <span class="hljs-comment">// 跨度，用于记录该节点与forward指向的节点之间，隔了多少各节点。主要用于计算Rank</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> span;<br>    &#125; level[];<br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><p><strong>各个属性的详细解释</strong></p><ul><li><p>backward：后退指针，用于保存节点的前驱节点，<strong>每个节点只有一个backward</strong></p><ul><li>例：如果要从第四层的节点访问第三层的节点，则可以通过backward直接访问</li></ul></li><li><p>*obj：是一个指针，指向一个字符串对象，而字符串对象则保存着一个SDS值</p></li><li><p>score：double变量，用于保存score</p><ul><li><strong>注意</strong>：<strong>score和ele共同来决定一个元素在跳表中的顺序</strong>。score不同则根据score进行排序（从小到大），score相同则根据ele来进行排序</li><li><strong>跳表中score是可以相同的，而ele是肯定不同的</strong></li></ul></li><li><p>level[]：节点的层，每个节点拥有1~32个层，除头结点外（32层），其他节点的层数是随机的。<strong>注意</strong>：Redis中没有使用抛硬币的晋升策略，而是直接随机一个层数值。下图展示了层数为1,3,5的节点</p></li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.27.png"></p><ul><li>level：保存了该节点指向的下一个节点，但是不一定是紧挨着的节点。还保存了两个节点之间的跨度<ul><li>forward：<code>level[i].forward</code>，后继节点，该节点指向的下一个节点，但是不一定是紧挨着的节点</li><li>span：<code>level[i].span</code>，跨度，用于记录从该节点到forward指向的节点之间，要走多少步。主要用于计算Rank<ul><li>rank：排位，头节点开始到目标节点的跨度，由沿途的span相加获得</li></ul></li></ul></li></ul><h4 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-comment">// 头尾指针，用于保存头结点和尾节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br>    <br>    <span class="hljs-comment">// 跳跃表的长度，即除头结点以外的节点数</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> length;<br>    <br>    <span class="hljs-comment">// 最大层数，保存了节点中拥有的最大层数（不包括头结点）</span><br>    <span class="hljs-keyword">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><h4 id="遍历过程"><a href="#遍历过程" class="headerlink" title="遍历过程"></a>遍历过程</h4><p>遍历需要访问跳表中的每个节点，直接走底层的节点即可依次访问</p><h4 id="搜索过程"><a href="#搜索过程" class="headerlink" title="搜索过程"></a>搜索过程</h4><p>如我们要访问该跳表中score = 2.0的节点</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.28.png"></p><p>从高层依次向下层遍历</p><ul><li>头结点的L6~L32的 forward 都为空，从L5开始访问</li><li>头结点L5的 forward 的指向的node3的score为3.0，小于2.0，返回头结点</li><li>从头结点L4 的 forward 指向的node1开始访问，节点的score = 1.0，继续向下执行</li><li>从node1的 L4 开始访问，为node3，返回node1</li><li>从node1的L3开始访问，为node3，返回node1</li><li>从node1的L2开始访问，为node2，score = 2.0，即为所要的节点</li></ul><h4 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h4><p>插入节点时，需要找到节点的插入位置。并给节点的各个属性赋值。插入后判断是否需要拓展上层。</p><hr><h2 id="1-5-整数集合"><a href="#1-5-整数集合" class="headerlink" title="1.5 整数集合"></a>1.5 整数集合</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>整数集合（inset）是Redis用于保存整数值的集合抽象数据结构，他可以保存类型为int16_t、int32_t、int64_t的整数值，并保证集合中不会出现重复元素</p><p>整数集合（intset）是集合键（<strong>set</strong>）的底层实现之一，<strong>当一个集合只包含整数值元素，并且这个集合的元素数量不多时</strong>，Redis就会使用整数集合作为集合键的底层实现</p><h3 id="Redis中整数集合的实现"><a href="#Redis中整数集合的实现" class="headerlink" title="Redis中整数集合的实现"></a>Redis中整数集合的实现</h3><p>每个intset.h/intset结构表示一个整数集合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span>&#123;</span><br><br><span class="hljs-comment">//编码方式</span><br><span class="hljs-keyword">uint32_t</span> encoding;<br><span class="hljs-comment">//集合包含的元素数量</span><br>    <span class="hljs-keyword">uint32_t</span> length;<br>    <span class="hljs-comment">//包含元素的数组</span><br>    <span class="hljs-keyword">int8_t</span> contents[];<br>&#125; intset;<br></code></pre></td></tr></table></figure><ul><li><p><strong>contents数组是整数集合的底层实现</strong>：整数集合的每个元素都是contents数组的一个数组项，各个项在数组中按值的大小<strong>从小到大有序排列</strong>，并且数组中<strong>不包含重复项</strong>，<strong>数组类型由encoding决定，与int8_t无关</strong></p><ul><li>如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值</li><li>如果encoding属性的值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值</li><li>如果encoding属性的值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值</li></ul></li><li><p>length属性记录了整数集合包含的元素数量，即contents数组的长度</p></li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.29.png"></p><blockquote><p>该整数集合中有5个元素，contents的类型为int16_t</p></blockquote><hr><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>每当我们要将一个新元素添加到整数集合里面，并且<strong>新元素的类型比整数集合现有所有元素的类型都要长时</strong>，整数集合需要先进行<strong>升级</strong>（upgrade），然后才能将新元素添加到整数集合里面</p><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><ul><li><p>根据新元素的类型，<strong>扩展</strong>整数集合底层数组的空间大小，并为新元素<strong>分配空间</strong></p></li><li><p>将底层数组(contents[])现有的所有元素都<strong>转换</strong>成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的<strong>有序性质不变</strong></p></li><li><p>将新元素添加到底层数组里面</p><ul><li><p>因为新元素的长度大于数组中所有其他元素的长度，所以</p><p>该元素要么是最小的，要么是最大的</p><ul><li>若为最小值，放在数组开头</li><li>若为最大值，放在数组末尾</li></ul></li></ul></li></ul><p><strong>图解</strong></p><ul><li><p>假设现在有一个INTSET_ENC_INT16编码的整数集合，<strong>集合中包含三个int16_t类型的元素</strong></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.30.png"></p></li></ul><blockquote><p>因为contents中的元素都是16位的，3个数组共占用空间48位，如下</p></blockquote><p>​    <img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.31.png"></p><ul><li><p>这时，需要将65535添加到整数集合里面，因为int16_t能够表示的范围为(-32768~32767)，无法容纳该数字，所以<strong>需要升级</strong>。升级过程如下</p><ol><li>扩展content的分配的内存空间，由3x16 扩展为 3x32</li></ol><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.32.png"></p><ol start="2"><li>将数组中的元素<strong>类型改为int32_t</strong>，并放入扩展后的contents中。最后添加新插入的元素。</li></ol></li></ul><p> <img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.33.png"></p><pre><code>3. 改变intset中，encoding和length的值    - encoding由INTSET_ENC_INT16改为INTSET_ENC_INT32    - lentg由3改为4</code></pre><ul><li>插入完成后，intset的结构如下</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.34.png"></p><h3 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h3><ul><li><strong>自适应</strong>：会根据contents中的元素位数选择最合适的类型，来进行内存的分配</li><li><strong>节约内存</strong>：基于自适应，不会为一个位数较少的整数分配较大的空间</li></ul><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p><strong>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态</strong></p><hr><h2 id="1-6-压缩列表"><a href="#1-6-压缩列表" class="headerlink" title="1.6 压缩列表"></a>1.6 压缩列表</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>压缩列表（ziplist）是列表键(<strong>list</strong>)和哈希键(<strong>hash</strong>)的底层实现之一</p><ul><li>当<strong>一个列表键（list）只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串</strong>，那么Redis就会使用压缩列表来做列表键的底层实现<ul><li>注意：这一点没有验证出来。根据书上的例子，底层使用的是quicklist</li></ul></li><li>当<strong>一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串</strong>，那么Redis就会使用压缩列表来做哈希键的底层实现</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.35.png"></p><h3 id="压缩列表的组成"><a href="#压缩列表的组成" class="headerlink" title="压缩列表的组成"></a>压缩列表的组成</h3><p>压缩列表是Redis为了<strong>节约内存</strong>而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存<strong>一个字节数组</strong>或者<strong>一个整数值</strong>。具体组成如下</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.36.png"></p><h4 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h4><ul><li>zlbytes：表示压缩列表占用的内存（单位：字节），在对压缩列表进行重分配或计算zlend位置时使用</li><li>zltail：压缩列表其实指针到尾节点的偏移量<ul><li>如果我们有一个指向压缩列表起始地址的指针p，通过p+zltail就能直接访问压缩列表的最后一个节点</li></ul></li><li>zllen：压缩列表中的<strong>节点数</strong></li><li>entry：压缩列表中的节点</li><li>zlend：用于标记压缩列表末端</li></ul><h3 id="压缩列表中的节点的组成"><a href="#压缩列表中的节点的组成" class="headerlink" title="压缩列表中的节点的组成"></a>压缩列表中的节点的组成</h3><p>每个压缩列表节点可以保存一个字节数组或者整数值</p><p>每个压缩列表节点都由<strong>previous_entry_length、encoding、content</strong>三个部分组成，如下图</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.37.png"></p><h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的previous_entry_length属性以<strong>字节为单位，记录了压缩列表中前一个节点的长度</strong>，其值长度为1个字节<strong>或者</strong>5个字节</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节<ul><li>前一节点的长度就保存在这一个字节里面</li></ul></li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节<ul><li>其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度</li></ul></li></ul><p>若前一个节点的长度为5个字节，那么压缩列表的previous_entry_length属性为0x05（1个字节保存长度）</p><p>若前一个节点的长度为10086(0x2766)，那么压缩列表中previous_entry_length属性为0xFE00002766（后4个字节保存长度）</p><p>通过previous_entry_length属性，可以方便地访问当前节点的前一个节点</p><h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>节点的encoding属性记录了<strong>节点的content属性所保存数据的类型以及长度</strong></p><h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>节点的content属性负责保存节点的值，<strong>节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定</strong></p><h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 <code>250</code> 字节到 <code>253</code> 字节之间的节点 <code>e1</code> 至 <code>eN</code></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.38.png"></p><p>因为 <code>e1</code> 至 <code>eN</code> 的所有节点的长度都小于 <code>254</code> 字节， 所以记录这些节点的长度只需要 <code>1</code> 字节长的 <code>previous_entry_length</code> 属性， 换句话说，<code>e1</code> 至 <code>eN</code> 的所有节点的 <code>previous_entry_length</code> 属性都是 <code>1</code> 字节长的。</p><p>这时， 如果我们将一个长度大于等于 <code>254</code> 字节的新节点 <code>new</code> 设置为压缩列表的表头节点， 那么 <code>new</code> 将成为 <code>e1</code> 的前置节点， 如图下图所示。</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.39.png"></p><p>因为 <code>e1</code> 的 <code>previous_entry_length</code> 属性仅长 <code>1</code> 字节， 它没办法保存新节点 <code>new</code> 的长度， 所以程序将对压缩列表执行空间重分配操作， 并将<code>e1</code> 节点的 <code>previous_entry_length</code> 属性从原来的 <code>1</code> 字节长扩展为 <code>5</code> 字节长。</p><p>现在， 麻烦的事情来了 —— <code>e1</code> 原本的长度介于 <code>250</code> 字节至 <code>253</code> 字节之间， 在为 <code>previous_entry_length</code> 属性新增四个字节的空间之后， <code>e1</code>的长度就变成了介于 <code>254</code> 字节至 <code>257</code> 字节之间， 而这种长度使用 <code>1</code> 字节长的 <code>previous_entry_length</code> 属性是没办法保存的。</p><p>因此， 为了让 <code>e2</code> 的 <code>previous_entry_length</code> 属性可以记录下 <code>e1</code> 的长度， 程序需要再次对压缩列表执行空间重分配操作， 并将 <code>e2</code> 节点的<code>previous_entry_length</code> 属性从原来的 <code>1</code> 字节长扩展为 <code>5</code> 字节长。</p><p>正如扩展 <code>e1</code> 引发了对 <code>e2</code> 的扩展一样， 扩展 <code>e2</code> 也会引发对 <code>e3</code> 的扩展， 而扩展 <code>e3</code> 又会引发对 <code>e4</code> 的扩展……为了让每个节点的<code>previous_entry_length</code> 属性都符合压缩列表对节点的要求， 程序需要不断地对压缩列表执行空间重分配操作， 直到 <code>eN</code> 为止。</p><p>Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.40.png"></p><blockquote><p>除了添加新节点可能会引发连锁更新之外， 删除节点也可能会引发连锁更新。</p></blockquote><p>因为连锁更新在最坏情况下需要对压缩列表执行 <code>N</code> 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N^2)。</p><p>要注意的是， 尽管连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的：</p><ul><li>首先， 压缩列表里要恰好有多个连续的、长度介于 <code>250</code> 字节至 <code>253</code> 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；</li><li>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；</li></ul><p>因为以上原因， <code>ziplistPush</code> 等命令的平均复杂度仅为 O(N)， 在实际中， 我们可以放心地使用这些函数， 而不必担心连锁更新会影响压缩列表的性能。</p><hr><h2 id="1-7-快表"><a href="#1-7-快表" class="headerlink" title="1.7 快表"></a>1.7 快表</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>quicklist是Redis 3.2中新引入的数据结构，<strong>能够在时间效率和空间效率间实现较好的折中</strong>。Redis中对quciklist的注释为A doubly linked list of ziplists。顾名思义，quicklist是一个<strong>双向链表</strong>，链表中的每个节点是一个ziplist结构。quicklist可以看成是用双向链表将若干小型的ziplist连接到一起组成的一种数据结构。当ziplist节点个数过多，quicklist退化为双向链表，一个极端的情况就是每个ziplist节点只包含一个entry，即只有一个元素。当ziplist元素个数过少时，quicklist可退化为ziplist，一种极端的情况就是quicklist中只有一个ziplist节点</p><h3 id="快表的结构"><a href="#快表的结构" class="headerlink" title="快表的结构"></a>快表的结构</h3><p>quicklist是由quicklist node组成的双向链表，quicklist node中又由ziplist充当节点。quicklist的存储结构如图</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.41.png"></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210728103430722.png" alt="image-20210728103430722"></p><h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span> &#123;</span><br>    quicklistNode *head;<br>    quicklistNode *tail;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> count;        <span class="hljs-comment">/* total count of all entries in all ziplists */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;          <span class="hljs-comment">/* number of quicklistNodes */</span><br>    <span class="hljs-keyword">int</span> fill : QL_FILL_BITS;              <span class="hljs-comment">/* fill factor for individual nodes */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> compress : QL_COMP_BITS; <span class="hljs-comment">/* depth of end nodes not to compress;0=off */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> bookmark_count: QL_BM_BITS;<br>    quicklistBookmark bookmarks[];<br>&#125; quicklist;<br></code></pre></td></tr></table></figure><p><strong>head和tail</strong></p><ul><li>head和tail分别指向快表的首位节点</li></ul><p><strong>count</strong></p><ul><li>count为quicklist中元素总数</li></ul><p><strong>len</strong></p><ul><li>len为quicklist Node（节点）个数</li></ul><p><strong>fill</strong></p><ul><li>fill用来指明每个quicklistNode中ziplist长度</li></ul><hr><h4 id="quicklistNode"><a href="#quicklistNode" class="headerlink" title="quicklistNode"></a>quicklistNode</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">prev</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *zl;   <span class="hljs-comment">/* 指向压缩列表的指针 */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> sz;             <span class="hljs-comment">/* ziplist size in bytes */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count : <span class="hljs-number">16</span>;     <span class="hljs-comment">/* count of items in ziplist */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> encoding : <span class="hljs-number">2</span>;   <span class="hljs-comment">/* RAW==1 or LZF==2 */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> container : <span class="hljs-number">2</span>;  <span class="hljs-comment">/* NONE==1 or ZIPLIST==2 */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> recompress : <span class="hljs-number">1</span>; <span class="hljs-comment">/* was this node previous compressed? */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> attempted_compress : <span class="hljs-number">1</span>; <span class="hljs-comment">/* node can&#x27;t compress; too small */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> extra : <span class="hljs-number">10</span>; <span class="hljs-comment">/* more bits to steal for future usage */</span><br>&#125; quicklistNode;<br></code></pre></td></tr></table></figure><p><strong>prev和next</strong></p><ul><li>因为quicklist为双向链表，所以有prev和next指针，分别指向前驱节点和后继节点</li></ul><p><strong>zl</strong></p><ul><li>zl指向该节点对应的<strong>ziplist结构</strong></li></ul><p><strong>encoding</strong></p><ul><li>encoding代表采用的编码方式<ul><li>1代表是原生的ziplist（未进行再次压缩）</li><li>2代表使用LZF进行压缩</li></ul></li></ul><p><strong>container</strong></p><ul><li>container为quicklistNode节点zl指向的容器类型<ul><li>1代表none</li><li>2代表使用ziplist存储数据</li></ul></li></ul><p><strong>recompress</strong></p><ul><li>recompress代表这个节点之前是否是压缩节点，若是，则在使用压缩节点前先进行解压缩，使用后需要重新压缩，此外为1，代表是压缩节点</li></ul><p><strong>attempted_compress</strong></p><ul><li>attempted_compress测试时使用</li></ul><p><strong>extra</strong></p><ul><li>extra为预留</li></ul><hr><h4 id="quickLZF"><a href="#quickLZF" class="headerlink" title="quickLZF"></a>quickLZF</h4><p><strong>quicklist允许ziplist进行再次压缩</strong>。当我们对ziplist利用LZF算法进行压缩时，quicklistNode节点指向的结构为<strong>quicklistLZF</strong>。其中sz表示compressed所占字节大小，quicklistLZF结构如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistLZF</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> sz; <span class="hljs-comment">/* LZF size in bytes*/</span><br>    <span class="hljs-keyword">char</span> compressed[];<br>&#125; quicklistLZF;<br></code></pre></td></tr></table></figure><hr><h4 id="quicklistEntry"><a href="#quicklistEntry" class="headerlink" title="quicklistEntry"></a>quicklistEntry</h4><p>当我们使用quicklistNode中<strong>ziplist中的一个节点</strong>时，Redis提供了quicklistEntry结构以便于使用，该结构如下</p><p>可以理解为其为<strong>ziplist中的一个节点</strong>，只不过记录了更详细的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistEntry</span> &#123;</span><br>    <span class="hljs-comment">// 指向当前元素所在的quicklist</span><br>    <span class="hljs-keyword">const</span> quicklist *quicklist;<br>    <br>    <span class="hljs-comment">// 指向当前元素所在的quicklistNode结构</span><br>    quicklistNode *node;<br>    <br>    <span class="hljs-comment">// 指向当前元素所在的ziplist</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *zi;<br>    <br>    <span class="hljs-comment">// 指向该节点的字符串内容</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *value;<br>    <br>    <span class="hljs-comment">// 该节点的整型值</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> longval;<br>    <br>    <span class="hljs-comment">// 该节点的大小</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> sz;<br>    <br>    <span class="hljs-comment">// 该节点相对于整个ziplist的偏移量，即该节点是ziplist第多少个entry</span><br>    <span class="hljs-keyword">int</span> offset;<br>&#125; quicklistEntry;<br></code></pre></td></tr></table></figure><h3 id="快表的操作"><a href="#快表的操作" class="headerlink" title="快表的操作"></a>快表的操作</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化是构建quicklist结构的第一步，由quicklistCreate函数完成，该函数的主要功能就是初始化quicklist结构。初始化后的quicklist如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.42.png"></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入操作有</p><ul><li>插入quicklist node</li><li>插入ziplist中的节点</li></ul><p>插入时可以选择头插和尾插，对应list的lpush和rpush，底层调用的是quicklistPushHead与quicklistPushTail方法</p><ul><li>quicklistPushHead的<strong>基本思路</strong>是：查看quicklist原有的head节点是否可以插入，如果可以就直接利用ziplist的接口进行插入，否则新建quicklistNode节点进行插入。函数的入参为待插入的quicklist，需要插入的数据value及其大小sz；函数返回值代表是否新建了head节点，0代表没有新建，1代表新建了head</li></ul><p>当quicklist中只有一个节点时，其结构如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.43.png"></p><p>具体的插入（zlentry）情况如下</p><ul><li>当前插入位置所在的quicklistNode仍然<strong>可以继续插入</strong>，此时可以直接插入</li><li>当前插入位置所在的quicklistNode不能继续插入，此时可以分为如下几种情况<ul><li>需要向当前quicklistNode第一个元素（entry1）前面插入元素，当前ziplist所在的quicklistNode的<strong>前一个</strong>quicklistNode可以插入，则将数据插入到前一个quicklistNode。如果<strong>前一个quicklistNode不能插入</strong>（不包含前一个节点为空的情况），则<strong>新建</strong>一个quicklistNode插入到当前quicklistNode<strong>前面</strong></li><li>需要向当前quicklistNode的最后一个元素（entryN）后面插入元素，当前ziplist所在的quicklistNode的<strong>后一个</strong>quicklistNode可以插入，则直接将数据插入到后一个quicklistNode。如果<strong>后一个quicklistNode不能插入</strong>（不包含为后一个节点为空的情况），则<strong>新建</strong>一个quicklistNode插入到当前quicklistNode的<strong>后面</strong></li><li><strong>不满足前面2个条件的所有其他种情况</strong>，将当前所在的quicklistNode以当前待插入位置为基准，拆分成左右两个quicklistNode，之后将需要插入的数据插入到其中一个拆分出来的quicklistNode中</li></ul></li></ul><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>quicklist查找元素主要是针对index，即通过元素在链表中的下标查找对应元素。基本思路是，<strong>首先找到index对应的数据所在的quicklistNode节点，之后调用ziplist的接口函数ziplistGet得到index对应的数据</strong>。简而言之就是：定位quicklistNode，再在quicklistNode中的ziplist中寻找目标节点</p><hr><h2 id="1-8-对象"><a href="#1-8-对象" class="headerlink" title="1.8 对象"></a>1.8 对象</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>Redis<strong>并没有直接使用</strong>简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含<strong>字符串对象、列表对象、哈希对象、集合对象和有序集合对象</strong>这五种类型的对象</p><h4 id="使用对象的好处"><a href="#使用对象的好处" class="headerlink" title="使用对象的好处"></a>使用对象的好处</h4><ul><li>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令</li><li>我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而<strong>优化对象在不同场景下的使用效率</strong></li></ul><h4 id="对象的回收"><a href="#对象的回收" class="headerlink" title="对象的回收"></a>对象的回收</h4><ul><li><p>Redis的对象系统还实现了基于<strong>引用计数</strong>技术的内存回收机制</p></li><li><p>Redis还<strong>通过引用计数技术实现了对象共享机制</strong>，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存</p></li></ul><hr><h3 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h3><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们<strong>至少会创建两个对象</strong>，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象），如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set hello &quot;hello world&quot;<br></code></pre></td></tr></table></figure><p>其中键值对的<strong>键</strong>是一个包含了字符串值”hello”的对象，而键值对的<strong>值</strong>则是一个包含了字符串值”hello world”的对象</p><p>Redis中的每个对象都由一个<strong>redisObject</strong>结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-comment">// 类型(对象类型)</span><br>    <span class="hljs-keyword">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 编码(对象底层使用的数据结构)</span><br>    <span class="hljs-keyword">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 指向底层数据结构的指针</span><br>    <span class="hljs-keyword">void</span> *ptr;<br>    <br>    ....<br>        <br>&#125; robj;<br></code></pre></td></tr></table></figure><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>对象的type属性记录了对象的类型，这个属性的值可以是下标所示的值</p><table><thead><tr><th>类型常量</th><th>对象名称</th></tr></thead><tbody><tr><td>REDIS_STRING</td><td>字符串对象</td></tr><tr><td>REDIS_LIST</td><td>列表对象</td></tr><tr><td>REDIS_HASH</td><td>哈希对象</td></tr><tr><td>REDIS_SET</td><td>集合对象</td></tr><tr><td>REDIS_ZSET</td><td>有序集合对象</td></tr></tbody></table><p>对于Redis数据库保存的键值对来说，<strong>键总是一个字符串对象</strong>，而值<strong>则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种</strong>，因此</p><ul><li>当我们称呼一个数据库键为<strong>字符串</strong>键时，我们指的是“这个数据库键所对应的<strong>值为字符串对象</strong></li><li>当我们称呼一个键为<strong>列表键</strong>时，我们指的是这个数据库键所对应的值为<strong>列表对象</strong></li></ul><p>TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，<strong>命令返回的结果为数据库键对应的值对象的类型</strong>，而不是键对象的类型，如</p><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定</p><p><strong>encoding属性记录了对象所使用的编码</strong>，也即是说这个对象使用了什么数据结构作为对象的底层实现</p><table><thead><tr><th>编码常量</th><th>编码所对应的底层数据结构</th></tr></thead><tbody><tr><td>OBJ_ENCODING_INT</td><td>long类型的整数</td></tr><tr><td>OBJ_ENCODING_EMBSTR</td><td>embstr编码的简单动态字符串</td></tr><tr><td>OBJ_ENCODING_RAW</td><td>简单动态字符串</td></tr><tr><td>OBJ_ENCODING_HT</td><td>字典</td></tr><tr><td>OBJ_ENCODING_LINKEDLIST</td><td>双向链表</td></tr><tr><td>OBJ_ENCODING_ZIPLIST</td><td>压缩列表</td></tr><tr><td>OBJ_ENCODING_INTSET</td><td>整数集合</td></tr><tr><td>OBJ_ENCODING_SKIPLIST</td><td>跳跃表</td></tr><tr><td>OBJ_ENCODING_QUICKLIST</td><td>快表</td></tr><tr><td>OBJ_ENCODING_ZIPMAP</td><td>压缩哈希表</td></tr><tr><td>OBJ_ENCODING_STREAM</td><td>消息流（用于消息队列）</td></tr></tbody></table><p>每种类型的对象都<strong>至少使用了两种</strong>不同的编码，可以通过下方命令来查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">OBJECT ENCODING key<br></code></pre></td></tr></table></figure><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.44.png"></p><p><strong>使用不同编码带来的好处</strong></p><p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，<strong>极大地提升了Redis的灵活性和效率</strong>，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率</p><hr><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象的编码可以是<strong>int、raw或者embstr</strong></p><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><p>如果一个字符串对象保存的是<strong>整数值</strong>，并且这个整数值<strong>可以用long类型来表示</strong>，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.45.png"></p><h4 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h4><p>如果字符串对象保存的是一个<strong>字符串值</strong>，并且这个字符串值的<strong>长度大于32字节</strong>，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.46.png"></p><h4 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h4><p>embstr编码是专门用于保存<strong>短字符串</strong>的一种优化编码方式。这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而<strong>embstr编码则通过调用一次内存分配函数来分配一块连续的空间</strong>，空间中依次包含redisObject和sdshdr两个结构</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.47.png"></p><p>简单来说，raw和embstr都是用来保存字符串的。字符串长度较短时使用embstr，较长时使用raw</p><ul><li>raw的redisObject和sdshdr是分别分配空间的，通过redisObject的ptr指针联系起来</li><li>embstr的redisObject和sdshdr则是一起分配空间的，在内存中是一段连续的区域</li></ul><p><strong>测试三种字符串对象如下</strong></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.48.png"></p><h4 id="浮点数的编码"><a href="#浮点数的编码" class="headerlink" title="浮点数的编码"></a>浮点数的编码</h4><p>浮点数在Redis中使用embstr或者raw进行编码</p><h4 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象（<strong>int/embstr -&gt; raw</strong>）</p><h5 id="int转raw"><a href="#int转raw" class="headerlink" title="int转raw"></a>int转raw</h5><p>编码为int的字符串，在<strong>进行append操作后</strong>，编码会转换为raw</p><blockquote><p>原理：</p><p>因为append命令只能对字符串值执行，所以程序会先将之前保存的整数值转换为字符串值，再执行追加操作</p></blockquote><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.49.png"></p><h5 id="embstr转raw"><a href="#embstr转raw" class="headerlink" title="embstr转raw"></a>embstr转raw</h5><p>编码为embstr的字符串，<strong>进行append操作后</strong>，编码会转换为raw</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.50.png"></p><blockquote><p>原理：</p><p>因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序，所以embstr编码的字符串实际上是只读的。</p><p>当需要对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，再执行操作</p></blockquote><hr><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码是quicklist，此处《Redis设计与实现》第二版中，写的是ziplist或linkedlist，与Redis3.2版本不同</p><hr><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是<strong>ziplist</strong>或者<strong>hashtable</strong></p><h4 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h4><p><strong>ziplist编码</strong>的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了<strong>键</strong>的压缩列表节点推入到压缩列表表尾，然后再将保存了<strong>值</strong>的压缩列表节点推入到压缩列表表尾，因此</p><ul><li>保存了同一键值对的两个节点总是紧挨在一起，保存<strong>键的节点在前</strong>，保存<strong>值的节点在后</strong></li><li><strong>先</strong>添加到哈希对象中的键值对会被放在压缩列表的<strong>表头</strong>方向，而<strong>后</strong>来添加到哈希对象中的键值对会被放在压缩列表的<strong>表尾</strong>方向</li></ul><p>如果我们依次向哈希表中添加一下元素，那么哈希对象中的压缩列表结构如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.51.png"></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.52.png"></p><h4 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h4><p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存</p><ul><li>字典的每个键都是一个<strong>字符串对象</strong>，对象中保存了键值对的键</li><li>字典的每个值都是一个<strong>字符串对象</strong>，对象中保存了键值对的值</li></ul><p>如果前面manKey键创建的不是ziplist编码的哈希对象，而是<strong>hashtable编码</strong>的哈希对象，结构则如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.53.png"></p><h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>当哈希对象可以<strong>同时满足</strong>以下两个条件时，哈希对象使用<strong>ziplist编码</strong></p><ul><li>希对象保存的所有键值对的<strong>键和值的字符串长度都小于64字节</strong></li><li>哈希对象保存的键值对<strong>数量小于512个</strong></li></ul><p>不能满足这两个条件的哈希对象需要使用hashtable编码</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.54.png"></p><hr><h3 id="集合-set-对象"><a href="#集合-set-对象" class="headerlink" title="集合(set)对象"></a>集合(set)对象</h3><p>集合对象的编码可以是<strong>intset</strong>或者<strong>hashtable</strong></p><h4 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h4><p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有<strong>整数值</strong>元素都被保存在整数集合里面</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.55.png"></p><p>其结构如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.56.png"></p><h4 id="hashtable-1"><a href="#hashtable-1" class="headerlink" title="hashtable"></a>hashtable</h4><p>hashtable编码的集合对象使用字典作为底层实现，字典的每个<strong>键都是一个字符串对象</strong>，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.57.png"></p><p>其结构如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.58.png"></p><h4 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h4><p>当集合对象可以<strong>同时满足</strong>以下两个条件时，对象使用intset编码</p><ul><li>集合对象保存的<strong>所有元素都是整数值</strong></li><li>集合对象保存的元素数量不超过512个</li></ul><p>不能满足这两个条件的集合对象需要使用hashtable编码</p><hr><h3 id="有序-sorted-set-集合"><a href="#有序-sorted-set-集合" class="headerlink" title="有序(sorted_set)集合"></a>有序(sorted_set)集合</h3><p>有序集合的编码可以是ziplist或者skiplist</p><h4 id="ziplist-1"><a href="#ziplist-1" class="headerlink" title="ziplist"></a>ziplist</h4><p>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素<strong>使用两个紧挨在一起的压缩列表节点来保存</strong>，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.59.png"></p><p>其结构如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.60.png"></p><h4 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h4><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个跳跃表和一个字典</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span> &#123;</span><br>    <span class="hljs-comment">// 跳跃表</span><br>    zskiplist *zsl;<br>    <br>    <span class="hljs-comment">// 字典</span><br>    dict *dict<br>&#125; zset;<br></code></pre></td></tr></table></figure><p>其结构如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.61.png"></p><p><strong>字典和跳表中的数据</strong></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.62.png"></p><p><strong>注意</strong>：上图在字典和跳跃表中重复展示了各个元素的成员和分值，但在实际中，<strong>字典和跳跃表会共享元素的成员和分值</strong>，所以并不会造成任何数据重复，也不会因此而浪费任何内存</p><p>zset结构中的zsl跳跃表按分值(score)<strong>从小到大保存了所有集合元素</strong>，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值</p><p>其结构如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.63.png"></p><p>除此之外，zset结构中的<strong>dict字典为有序集合创建了一个从成员到分值的映射</strong>，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，<strong>程序可以用O（1）复杂度查找给定成员的分值</strong>，ZSCORE命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性</p><p><strong>为何sorted_set同时使用字典和跳表来作为底层的数据结构</strong></p><ul><li><p><strong>字典</strong>可以保证查询效率为O(1)，但是对于范围查询就无能为力了</p></li><li><p><strong>跳表</strong>可以保证数据是有序的，范围查询效率较高，但是单个查询效率较低</p></li></ul><hr><h3 id="Redis-类型检查与命令多态"><a href="#Redis-类型检查与命令多态" class="headerlink" title="Redis 类型检查与命令多态"></a>Redis 类型检查与命令多态</h3><p>Redis 中用于操作键的命令基本上可以分为两种类型。</p><p>一种命令可以对任何类型的键执行， 比如 DEL 命令、 EXPIRE 命令、 RENAME 命令、 TYPE 命令、 OBJECT 命令， 等等。</p><p>而另一种命令只能对特定类型的键执行， 比如：</p><ul><li>SET 、 GET 、 APPEND 、 STRLEN 等命令只能对字符串键执行；</li><li>HDEL 、 HSET 、 HGET 、 HLEN 等命令只能对哈希键执行；</li><li>RPUSH 、 LPOP 、 LINSERT 、 LLEN 等命令只能对列表键执行；</li><li>SADD 、 SPOP 、 SINTER 、 SCARD 等命令只能对集合键执行；</li><li>ZADD 、 ZCARD 、 ZRANK 、 ZSCORE 等命令只能对有序集合键执行；</li></ul><h4 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h4><p>在执行一个类型特定的命令之前， Redis 会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令。</p><p>类型特定命令所进行的类型检查是通过 <code>redisObject</code> 结构的 <code>type</code> 属性来实现的：</p><ul><li>在执行一个类型特定命令之前， 服务器会先检查输入数据库键的值对象是否为执行命令所需的类型， 如果是的话， 服务器就对键执行指定的命令；</li><li>否则， 服务器将拒绝执行命令， 并向客户端返回一个类型错误。</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.64.png"></p><h4 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h4><p>Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外， 还会根据值对象的编码方式， 选择正确的命令实现代码来执行命令。</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.65.png"></p><hr><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个<strong>引用计数</strong>（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p><p>每个对象的引用计数信息由redisObject结构的<strong>refcount</strong>属性记录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">unsigned</span> lru:LRU_BITS; <br>    <br>    <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-keyword">int</span> refcount;<br>    <span class="hljs-keyword">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p>对象的引用计数信息会随着对象的使用状态而不断变化</p><ul><li>在创建一个新对象时，引用计数的值会被初始化为1</li><li>当对象被一个新程序使用时，它的引用计数值会被增一</li><li>当对象不再被一个程序使用时，它的引用计数值会被减一</li><li>当对象的引用计数值变为0时，对象所占用的内存会被释放</li></ul><hr><h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>除了用于实现引用计数内存回收机制外，对象的<strong>引用计数属性还带有对象共享的作用</strong>。</p><p>创建一个键为A，值为100的字符串对象，用过使用OBJECT REFCOUNT命令查看键A的值对象的引用计数是2。这时再创建一个键为B，值为100的字符串对象后，再次查看共享对象的引用计数值，变成了3</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.66.png"></p><p>原因：共有三个程序共享这个值对象，服务器程序，键A，键B</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.67.png"></p><p>另外， 这些共享对象不单单只有字符串键可以使用， 那些在数据结构中嵌套了字符串对象的对象（<code>linkedlist</code> 编码的列表对象、 <code>hashtable</code> 编码的哈希对象、 <code>hashtable</code> 编码的集合对象、以及 <code>zset</code> 编码的有序集合对象）都可以使用这些共享对象。</p><p>但Redis<strong>不共享包含字符串的对象，只对包含整数值的字符串对象进行共享。</strong></p><blockquote><p>为什么 Redis 不共享包含字符串的对象？</p><p>当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</p><ul><li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 <img src="https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f521a2227eb.png" alt="O(1)"> ；</li><li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 <img src="https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f521a314bb1.png" alt="O(N)"> ；</li><li>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 <img src="https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f521a3ee960.png" alt="O(N^2)"> 。</li></ul></blockquote><p>注意：目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 <code>0</code> 到 <code>9999</code> 的所有整数值， 当服务器需要用到值为 <code>0</code>到 <code>9999</code> 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。如下图<code>999999</code>并没有被共享</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.68.png"></p><hr><h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><p>除了 <code>type</code> 、 <code>encoding</code> 、 <code>ptr</code> 和 <code>refcount</code> 四个属性之外， <code>redisObject</code> 结构包含的最后一个属性为 <code>lru</code> 属性， 该属性记录了对象最后一次被命令程序访问的时间</p><p><code>OBJECT IDLETIME</code> 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 <code>lru</code> 时间计算得出的：</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.69.png"></p><blockquote><p>注意</p><p>OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 <code>lru</code> 属性。</p></blockquote><p>除了可以被 OBJECT IDLETIME 命令打印出来之外， 键的空转时长还有另外一项作用： 如果服务器打开了 <code>maxmemory</code> 选项， 并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ， 那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p><hr><h1 id="二、单机数据库的实现"><a href="#二、单机数据库的实现" class="headerlink" title="二、单机数据库的实现"></a>二、单机数据库的实现</h1><h2 id="2-1-数据库"><a href="#2-1-数据库" class="headerlink" title="2.1 数据库"></a>2.1 数据库</h2><h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>Redis服务器将所有数据库都保存在服务器状态redisServer结构的<strong>db数组</strong>中，db数组的每个项都是一个redisDb结构，每个redisDb结构代表一个数据库。在初始化服务器时，程序会根据服务器状态的<strong>dbnum属性来决定应该创建多少个数据库</strong>，默认为16个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span><br>...<br>    <br>    <span class="hljs-comment">// 数据库</span><br>    redisDb *db;<br>     <br>    <span class="hljs-comment">// 数据库的数量</span><br>    <span class="hljs-keyword">int</span> dbnum;                      <span class="hljs-comment">/* Total number of configured DBs */</span><br><br>    ...    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br>    <span class="hljs-comment">// 数据库键空间</span><br>    dict *dict;                 <span class="hljs-comment">/* The keyspace for this DB */</span><br>    <span class="hljs-comment">// 过期字典</span><br>    dict *expires;              <span class="hljs-comment">/* Timeout of keys with a timeout set */</span><br>    dict *blocking_keys;        <span class="hljs-comment">/* Keys with clients waiting for data (BLPOP)*/</span><br>    dict *ready_keys;           <span class="hljs-comment">/* Blocked keys that received a PUSH */</span><br>    dict *watched_keys;         <span class="hljs-comment">/* WATCHED keys for MULTI/EXEC CAS */</span><br>    <span class="hljs-keyword">int</span> id;                     <span class="hljs-comment">/* Database ID */</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> avg_ttl;          <span class="hljs-comment">/* Average TTL, just for stats */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> expires_cursor; <span class="hljs-comment">/* Cursor of the active expire cycle. */</span><br>    <span class="hljs-built_in">list</span> *defrag_later;         <span class="hljs-comment">/* List of key names to attempt to defrag one by one, gradually. */</span><br>&#125; redisDb;<br></code></pre></td></tr></table></figure><p>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过使用<code>select 数据库序号</code>来切换目标数据库。</p><p>在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisClient</span> &#123;</span><br>...<br>    <br>    <span class="hljs-comment">// 记录客户端正在使用的数据库</span><br>    redisDb *db;<br>    <br>    ...<br>&#125; redisClient;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.1.png"></p><hr><h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><p>Redis 是一个键值对（key-value pair）数据库服务器， 服务器中的每个数据库都由一个 <code>redis.h/redisDb</code> 结构表示， 其中， <code>redisDb</code> 结构的<code>dict</code> 字典保存了数据库中的所有键值对， 这个字典称为键空间（key space）</p><p><strong>键空间和用户所见的数据库是直接对应的</strong>：</p><ul><li>键空间的键也就是数据库的键， 每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值， 每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象在内的任意一种 Redis 对象。</li></ul><p>如果我们在空白的数据库中执行以下命令</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.2.png"></p><p>那么在这些命令执行之后，数据库的键空间的结构如下</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.3.png"></p><ul><li>添加一个新键值对到数据库， 实际上就是将一个新键值对添加到键空间字典里面， 其中键为字符串对象， 而值则为任意一种类型的 Redis 对象。</li><li>删除数据库中的一个键， 实际上就是在键空间里面删除键所对应的键值对对象。</li><li>对一个数据库键进行更新， 实际上就是对键空间里面键所对应的值对象进行更新， 根据值对象的类型不同， 更新的具体方法也会有所不同。</li><li>对一个数据库键进行取值， 实际上就是在键空间中取出键所对应的值对象， 根据值对象的类型不同， 具体的取值方法也会有所不同。</li></ul><hr><h3 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h3><p>通过<strong>EXPIRE</strong>命令或者<strong>PEXPIRE</strong>命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键</p><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><p>Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）</p><ul><li>EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl秒</li><li>PEXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl毫秒</li><li>EXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳</li><li>PEXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳</li></ul><p>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令<strong>都是使用PEXPIREAT命令来实现的</strong></p><ul><li>无论客户端执行的是以上四个命令中的哪一个，经过转换之后，<strong>最终的执行效果都和执行PEXPIREAT命令一样</strong></li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.4.png"></p><blockquote><p><strong>TTL</strong>命令和<strong>PTTL</strong>命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间</p></blockquote><h4 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h4><p>redisDb结构的<strong>expires</strong>字典保存了数据库中所有键的过期时间，这个字典称为<strong>过期字典</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br>    ...<br>        <br>    <span class="hljs-comment">// 过期字典，用于存放有过期时间的对象</span><br>    dict *expires;              <span class="hljs-comment">/* Timeout of keys with a timeout set */</span><br>   <br>    ...<br>        <br>&#125; redisDb;<br></code></pre></td></tr></table></figure><ul><li>过期字典的<strong>键</strong>是一个指针，这个指针<strong>指向键空间中的某个键对象</strong>（也即是某个数据库键）</li><li>过期字典的<strong>值</strong>是一个long long类型的整数，这个整数<strong>保存了键所指向的数据库键的过期时间</strong>——一个毫秒精度的UNIX时间戳</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.5.png"></p><blockquote><p>这里为了展示方便，出现了两次alphabet对象和book对象。在实际中，键空间的键和过期字典的键都指向同一个键对象，不会出现重复对象。</p></blockquote><h4 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h4><p>TTL命令以<strong>秒</strong>为单位返回键的剩余生存时间，而PTTL命令则以<strong>毫秒</strong>为单位返回键的剩余生存时间。这两个命令都是<strong>通过计算键的过期时间和当前时间之间的差来实现的</strong></p><h4 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h4><p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期</p><ul><li>检查给定键是否存在于过期字典<ul><li>如果存在，那么取得键的过期时间</li></ul></li><li>检查当前UNIX时间戳是否大于键的过期时间<ul><li>是的话，那么键已经过期</li><li>不是的话，键未过期</li></ul></li></ul><hr><h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，<strong>立即执行对键的删除操作</strong></p><p><strong>优点</strong></p><ul><li>定时删除策略对内存是最友好的<ul><li>通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存</li></ul></li></ul><p><strong>缺点</strong></p><ul><li>对CPU时间是最不友好的<ul><li>在过期键比较多的情况下，<strong>删除过期键这一行为可能会占用相当一部分CPU时间</strong>，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响</li></ul></li><li>创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——<strong>并不能高效地处理大量时间事件</strong></li></ul><hr><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>放任键过期不管，但是每次从键空间中<strong>获取键时</strong>，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键</p><p><strong>优点</strong></p><ul><li>惰性删除策略对CPU时间来说是最友好的<ul><li>程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作<strong>只会在非做不可的情况下进行</strong>，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间</li></ul></li></ul><p><strong>缺点</strong></p><ul><li>它对内存是最不友好的<ul><li>如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放</li></ul></li></ul><hr><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>定期删除是一种较为综合的删除策略，能够兼顾CPU与内存</p><ul><li>定期删除策略<strong>每隔一段时间执行一次删除过期键操作</strong>，并通过限制删除操作执行的时长和频率来<strong>减少删除操作对CPU时间的影响</strong></li><li>通过定期删除过期键，定期删除策略<strong>有效地减少了</strong>因为过期键而带来的<strong>内存浪费</strong></li><li>要删除多少过期键，以及要检查多少个数据库，则由算法决定</li></ul><hr><h3 id="Redis中的删除策略"><a href="#Redis中的删除策略" class="headerlink" title="Redis中的删除策略"></a>Redis中的删除策略</h3><p>Redis服务器实际使用的是<strong>惰性删除</strong>和<strong>定期删除</strong>两种策略</p><h4 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h4><p>过期键的惰性删除策略由<strong>expireIfNeeded</strong>函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查</p><ul><li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除</li><li>如果输入键未过期，那么expireIfNeeded函数不做动作</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.6.png"></p><h4 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h4><p>过期键的定期删除策略由<strong>activeExpireCycle</strong>函数实现，每当Redis的服务器周期性操作serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，<strong>分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键</strong></p><p>activeExpireCycle函数的工作模式可以总结如下</p><ul><li>函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键</li><li>全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键</li><li>随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作</li></ul><hr><h3 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h3><h4 id="RDB生成"><a href="#RDB生成" class="headerlink" title="RDB生成"></a>RDB生成</h4><p>在执行<code>save</code>或<code>bgsave</code>命令时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中</p><h4 id="RDB文件载入"><a href="#RDB文件载入" class="headerlink" title="RDB文件载入"></a>RDB文件载入</h4><p>启动Redis服务器时，如果服务器开启了RDB功能，那么服务器会对RDB文件进行载入</p><ul><li>如果服务器以<strong>主服务器模式</strong>运行，在载入RDB文件过程中会对键进行检查，过期的键不会载入到数据库中</li><li>如果服务器以<strong>从服务器模式</strong>运行，文件中保存的所有键，无论是否过期都会被载入到数据库中。之后进行主从服务器同步时候，从服务器数据库会被清空</li></ul><h4 id="AOF生成"><a href="#AOF生成" class="headerlink" title="AOF生成"></a>AOF生成</h4><p>当服务器以AOF持久化模式运行时，如果数据库中某个键过期，但还未被惰性删除或定期删除，则AOF文件不会产生变化。当过期的键被惰性删除或定期删除后，程序会向AOF文件追加一条<code>DEL</code>命令，显式的记录该键已被删除</p><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>在进行AOF重写时，已过期的键不会被保存到重写后的AOF文件中</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>当服务器运行在复制模式时，从服务器的过期键删除动作<strong>由主服务器控制</strong></p><ul><li>主服务器在删除一个过期键之后，会显式的向所有从服务器发送DEL命令，告知从服务器删除这个键</li><li>从服务器在执行客户端发送的命令时，<strong>即使碰到过期的键也不会删除</strong>，而是继续像处理未过期的键一样来处理过期的键（即，在从服务器上查询过期的键，仍然可以查到）</li><li>从服务器只有接收到主服务器发送的<code>DEL</code>命令之后，才会删除过期的键</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.7.png"></p><hr><h2 id="2-2-RDB持久化"><a href="#2-2-RDB持久化" class="headerlink" title="2.2 RDB持久化"></a>2.2 RDB持久化</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>Redis提供了RDB（Redis DataBase）持久化功能</strong>，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失</p><h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><p>有两个Redis命令可以用于生成RDB文件，一个是<strong>save</strong>，另一个是<strong>bgsave</strong></p><ul><li>save命令会<strong>阻塞Redis服务器进程</strong>，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</li><li>bgsave命令会<strong>派生出一个子进程</strong>，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求</li></ul><h4 id="save命令执行时的服务器状态"><a href="#save命令执行时的服务器状态" class="headerlink" title="save命令执行时的服务器状态"></a>save命令执行时的服务器状态</h4><p>当save命令执行时，Redis服务器会被阻塞，所以当save命令正在执行时，客户端发送的所有命令请求都会被拒绝</p><p>只有在服务器执行完save命令、重新开始接受命令请求之后，客户端发送的命令才会被处理</p><h4 id="bgsave命令执行时的服务器状态"><a href="#bgsave命令执行时的服务器状态" class="headerlink" title="bgsave命令执行时的服务器状态"></a>bgsave命令执行时的服务器状态</h4><p>因为bgsave命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是，<strong>在bgsave命令执行期间</strong>，服务器处理save、bgsave、bgrewriteaof三个命令的方式会和平时有所不同</p><ul><li>在bgsave命令执行期间，客户端发送的save命令会被服务器拒绝，服务器禁止save命令和bgsave命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，<strong>防止产生竞争条件</strong></li><li>在bgsave命令执行期间，客户端发送的bgsave命令会被服务器拒绝，因为同时执行两个bgsave命令也<strong>会产生竞争条件</strong></li><li>bgwriteaof和bgsave两个命令不能同时执行<ul><li>如果bgsave命令正在执行，那么客户端发送的bgwriteaof命令会被延迟到bgsave命令执行完毕之后执行</li><li>如果bgwriteaof命令正在执行，那么客户端发送的bgsave命令<strong>会被服务器拒绝</strong></li><li>bgwriteaof和bgsave两个命令的实际工作都由子进程执行，这两个操作并没有冲突的地方，不能同时执行是从性能的角度考虑，防止短时间IO过高影响性能</li></ul></li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.7.1.png"></p><h4 id="RDB文件载入时的服务器状态"><a href="#RDB文件载入时的服务器状态" class="headerlink" title="RDB文件载入时的服务器状态"></a>RDB文件载入时的服务器状态</h4><p>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止</p><p>因为AOF文件的更新频率通常比RDB文件的更新频率更高，所以：</p><ul><li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.8.png"></p><hr><h3 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h3><p>用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行bgsave命令，如果我们向服务器提供以下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">save 900 1<br>save 300 10<br>save 60 10000<br></code></pre></td></tr></table></figure><blockquote><p>900秒内修改1次数据，则保存</p><p>300秒内修改10次数据，则保存</p><p>60秒内修改10000次数据，则保存</p></blockquote><h4 id="saveparams数组"><a href="#saveparams数组" class="headerlink" title="saveparams数组"></a><strong>saveparams数组</strong></h4><p>服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的<strong>saveparams</strong>属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span><br>    ...<br>    <span class="hljs-comment">// 保存save配置参数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">saveparam</span> *<span class="hljs-title">saveparams</span>;</span><br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件。saveparam的结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">saveparam</span> &#123;</span><br>  <span class="hljs-comment">// 设定的秒数</span><br>    <span class="hljs-keyword">time_t</span> seconds;<br>    <span class="hljs-comment">// 规定时间内的修改次数</span><br>    <span class="hljs-keyword">int</span> changes;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.9.png"></p><h4 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h4><p>除了saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性</p><ul><li>dirty计数器记录距离上一次成功执行save命令或者bgsave命令之后，服务器对数据库状态（服务器中的所有数据库）<strong>进行了多少次修改</strong>（包括写入、删除、更新等操作）</li><li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行save命令或者bgsave命令的<strong>时间</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span><br>    ...<br>    <span class="hljs-comment">// 上次save到现在Redis中数据修改的次数</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dirty;                <span class="hljs-comment">/* Changes to DB from the last save */</span><br>    <br>    <span class="hljs-comment">// 上一次成功save到现在所经过的时间</span><br>    <span class="hljs-keyword">time_t</span> lastsave;                <span class="hljs-comment">/* Unix time of last successful save */</span><br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新。命令修改了多少次数据库，dirty计数器的值就增加多少</p><h4 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h4><p>Redis的服务器周期性操作函数<strong>serverCron</strong>默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是<strong>检查save选项所设置的保存条件是否已经满足</strong>，如果满足的话，就执行bgsave命令</p><hr><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p>一个完整 RDB 文件所包含如下的各个部分：</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.10.png"></p><p>其中，全大写单词标示常量， 用全小写单词标示变量和数据。</p><ul><li><p>RDB 文件的最开头是 <code>REDIS</code> 部分， 这个部分的长度为 <code>5</code> 字节， 保存着 <code>&quot;REDIS&quot;</code> 五个字符。 通过这五个字符， 程序可以在载入文件时， 快速检查所载入的文件是否 RDB 文件。</p></li><li><p><code>db_version</code> 长度为 <code>4</code> 字节， 它的值是一个字符串表示的整数， 这个整数记录了 RDB 文件的版本号， 比如 <code>&quot;0006&quot;</code> 就代表 RDB 文件的版本为第六版。 </p></li><li><p><code>databases</code> 部分包含着零个或任意多个数据库， 以及各个数据库中的键值对数据：</p><ul><li>如果服务器的数据库状态为空（所有数据库都是空的）， 那么这个部分也为空， 长度为 <code>0</code> 字节。</li><li>如果服务器的数据库状态为非空（有至少一个数据库非空）， 那么这个部分也为非空， 根据数据库所保存键值对的数量、类型和内容不同， 这个部分的长度也会有所不同。</li></ul></li><li><p><code>EOF</code> 常量的长度为 <code>1</code> 字节， 这个常量标志着 RDB 文件正文内容的结束， 当读入程序遇到这个值的时候， 它知道所有数据库的所有键值对都已经载入完毕了。</p></li><li><p><code>check_sum</code> 是一个 <code>8</code> 字节长的无符号整数， 保存着一个校验和， 这个校验和是程序通过对 <code>REDIS</code> 、 <code>db_version</code> 、 <code>databases</code> 、 <code>EOF</code> 四个部分的内容进行计算得出的。 服务器在载入 RDB 文件时， 会将载入数据所计算出的校验和与 <code>check_sum</code> 所记录的校验和进行对比， 以此来检查 RDB 文件是否有出错或者损坏的情况出现。</p></li></ul><hr><h2 id="2-3-AOF持久化"><a href="#2-3-AOF持久化" class="headerlink" title="2.3 AOF持久化"></a>2.3 AOF持久化</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>除了RDB持久化功能之外，Redis还提供了<strong>AOF（Append Only File）</strong>持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，<strong>AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的</strong>，如图下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.11.png"></p><hr><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>AOF持久化功能的实现可以分为<strong>命令追加</strong>（append）、<strong>文件写入</strong>、<strong>文件同步</strong>（sync）三个步骤</p><h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式<strong>将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span><br>    ...<br>    <span class="hljs-comment">// 缓冲区，本质上是一个动态字符串</span><br>  sds aof_buf;      <span class="hljs-comment">/* AOF buffer, written before entering the event loop */</span><br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>步骤解析</strong></p><p>如果客户端向服务器发送以下命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">set</span> key value<br></code></pre></td></tr></table></figure><p>那么服务器在执行这个SET命令之后，会将以下<strong>协议内容追加到aof_buf缓冲区的末尾</strong></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.12.png"></p><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>Redis的服务器进程就是一个事件循环（loop），这个循环中的<strong>文件事件</strong>负责接收客户端的命令请求，以及向客户端发送命令回复，而<strong>时间事件</strong>则负责执行像serverCron函数这样需要定时运行的函数</p><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器<strong>每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数</strong>，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面</p><p><code>flushAppendOnlyFile</code>函数的行为由服务器配置的appendfsyc选项的值来决定。如下：</p><table><thead><tr><th align="left"><code>appendfsyc</code>选项的值</th><th><code>flushAppendOnlyFile</code>函数的行为</th></tr></thead><tbody><tr><td align="left">always</td><td>将aof_buf缓冲区中的所有内容写入并同步到AOF文件</td></tr><tr><td align="left">everysec（默认项）</td><td>将aof_buf缓冲区中的所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过一秒钟，那么再次对AOF文件进行同步，并且这个同步操作是由一个线程专门负责执行的</td></tr><tr><td align="left">no</td><td>将aof_buf缓冲区中的所有内容写入到AOF文件中，但不对AOF文件进行同步，何时同步由操作系统决定</td></tr></tbody></table><p><strong>文件的写入和同步</strong></p><p>为了提高文件的写入效率，在现代操作系统中，当用户调用<code>write</code>函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。</p><p>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。</p><p>为此，系统提供了<code>fsync</code>和<code>fdatasync</code>两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p><hr><h4 id="AOF持久化的效率和安全性"><a href="#AOF持久化的效率和安全性" class="headerlink" title="AOF持久化的效率和安全性"></a>AOF持久化的效率和安全性</h4><p>服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。</p><ul><li>当appendfsync的值为<strong>always</strong>时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但<strong>从安全性来说，always是最安全的</strong>，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据。</li><li>当appendfsync的值为<strong>everysec</strong>时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。从效率上来讲，everysec模式足够快，并且就算<strong>出现故障停机，数据库也只丢失一秒钟的命令数据</strong>。</li><li>当appendfsync的值为<strong>no</strong>时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。因为处在no模式下的flushAppendOnlyFile调用无须执行同步操作，所以<strong>该模式下的AOF文件写入速度总是最快的</strong>，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以<strong>该模式的单次同步时间通常是三种模式中最长的</strong>。</li></ul><hr><h3 id="文件的载入与数据还原"><a href="#文件的载入与数据还原" class="headerlink" title="文件的载入与数据还原"></a>文件的载入与数据还原</h3><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以<strong>服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态</strong></p><h4 id="还原步骤"><a href="#还原步骤" class="headerlink" title="还原步骤"></a>还原步骤</h4><ul><li>创建一个<strong>不带网络连接</strong>的伪客户端（fake client）<ul><li>因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样</li></ul></li><li>从AOF文件中分析并读取出一条写命令</li><li>使用伪客户端执行被读出的写命令</li><li>一直执行上面两步，直到AOF文件中的所有写命令都被处理完毕为止</li></ul><p>以上过程的流程图如下：</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.13.png"></p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><h4 id="为什么需要重写"><a href="#为什么需要重写" class="headerlink" title="为什么需要重写"></a>为什么需要重写</h4><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，<strong>所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多</strong>，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多</p><h4 id="重写的实现"><a href="#重写的实现" class="headerlink" title="重写的实现"></a>重写的实现</h4><p>重写过程伪代码如下</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.14.png"></p><p>因为aof_rewrite函数生成的新AOF文件只包含还原当前数据库状态所必须的命令，所以<strong>新AOF文件不会浪费任何硬盘空间</strong></p><h4 id="后台重写（bgrewriteaof）"><a href="#后台重写（bgrewriteaof）" class="headerlink" title="后台重写（bgrewriteaof）"></a>后台重写（bgrewriteaof）</h4><p>为了避免出现AOF重写出现服务器无法处理请求的情况，所以Redis决定<strong>将AOF重写程序放到子进程里执行</strong>，这样做可以有以下两个目的</p><ul><li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性</li></ul><p>不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而<strong>新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致</strong>（有点像CMS垃圾回收期，在并发清理期间产生的垃圾，没法在本次GC中得到回收）</p><p>为了解决这种数据不一致问题，Redis服务器设置了一个<strong>AOF重写缓冲区</strong>（保存了子进程在重写过程中，主进程执行的操作），这个缓冲区在服务器创建子进程之后开始使用，<strong>当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区</strong>，如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.15.png"></p><p>在子进程执行AOF重写期间，<strong>服务器进程需要执行以下三个工作</strong></p><ul><li>执行客户端发来的命令</li><li>将执行后的写命令追加到<strong>AOF缓冲区</strong></li><li>将执行后的写命令追加到<strong>AOF重写缓冲区</strong></li></ul><p>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作</p><ul><li>将<strong>AOF重写缓冲区</strong>中的所有内容写入到新AOF文件中，<strong>这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致</strong></li><li>对新的AOF文件进行改名，<strong>原子地（atomic）覆盖现有的AOF文件</strong>，完成新旧两个AOF文件的替换</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.16.png"></p><hr><h2 id="2-4-事件"><a href="#2-4-事件" class="headerlink" title="2.4 事件"></a>2.4 事件</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>redis服务器是一个事件驱动程序，服务器需要处理以下两类事件</p><ul><li>文件事件（file event）<ul><li>Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作</li></ul></li><li>时间事件（time event）<ul><li>Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象</li></ul></li></ul><hr><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为<strong>文件事件处理器</strong>（file event handler)：</p><ul><li><p>文件事件处理器使用<strong>I/O多路复用</strong>（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p></li><li><p>当被监听的套接字准备好执行连接应答（accept)、读取（read)、写入（write)、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p></li></ul><blockquote><p>虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p></blockquote><h4 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h4><p>文件事件处理器由<strong>套接字</strong>、<strong>I/O多路复用程序</strong>、<strong>文件事件分派器</strong>(dispatcher)、<strong>事件处理器</strong>四个部分组成。</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.17.png"></p><ul><li><p><strong>文件事件是对套接字操作的抽象</strong>，每当一个套接字准备好执行连接应答 (accept)、读取、写入、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p></li><li><p><strong>I/O多路复用程序负责监听多个套接字</strong>，并向文件事件分派器传送那些产生了事件的套接字。尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially)、同步 (synchronously)、每次一个套接字的方式向文件事件分派器传送套接字。</p></li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.18.png"></p><ul><li><p><strong>文件事件分派器接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器</strong>。</p></li><li><p>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。</p></li></ul><h4 id="文件事件的处理器分类"><a href="#文件事件的处理器分类" class="headerlink" title="文件事件的处理器分类"></a>文件事件的处理器分类</h4><p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求。</p><ul><li><p>为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联<strong>连接应答处理器</strong>。</p></li><li><p>为了接收客户端传来的命令请求，服务器要为客户端套接字关联<strong>命令请求处理器</strong>。</p></li><li><p>为了向客户端返回命令的执行结果，服务器要为客户端套接字关联<strong>命令回复处理器</strong>。</p></li><li><p>当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的<strong>复制处理器</strong>。</p></li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.19.png"></p><hr><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><h4 id="时间时间分类"><a href="#时间时间分类" class="headerlink" title="时间时间分类"></a>时间时间分类</h4><p>Redis的时间事件分为两类：</p><ul><li><p><strong>定时事件</strong></p><ul><li>让一段程序在指定的时间之后执行一次。比如说。让程序X在当前时间的30毫秒之后执行一次。</li></ul></li><li><p><strong>周期性事件</strong></p><ul><li>让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</li></ul></li></ul><h4 id="时间事件构成"><a href="#时间事件构成" class="headerlink" title="时间事件构成"></a>时间事件构成</h4><p>一个时间事件主要由三个属性组成：</p><ul><li><p>id：服务器为时间事件创建的<strong>全局唯一ID</strong>（标识号）。<strong>ID号按从小到大的顺序递增</strong>，新事件的ID号比旧事件的ID号要大。</p></li><li><p>when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。</p></li><li><p>timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</p></li></ul><p><strong>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值</strong>：</p><ul><li>如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为<strong>定时事件</strong><ul><li><strong>该事件在达到一次之后就会被删除，之后不再到达。</strong></li></ul></li><li>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为<strong>周期性事件</strong>：<ul><li>当一个时间事件到达之后，<strong>服务器会根据事件处理器返回的值，对时间事件的when属性进行更新</strong>，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。</li></ul></li></ul><h4 id="时间事件实现"><a href="#时间事件实现" class="headerlink" title="时间事件实现"></a>时间事件实现</h4><p>服务器将所有时间事件都放在一个<strong>无序链表</strong>中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p><blockquote><p>因为新的时间事件总是插入到链表的表头，所以时间事件按ID逆序排序在无序链表中排列</p></blockquote><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.20.png"></p><blockquote><p>注意，我们说保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序。</p><p>正因为链表没有按when属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理。</p></blockquote><hr><h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等。<br>事件的调度和执行由ae.c/aeProcessEvents函数负责，以下是该函数的伪代码表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">def <span class="hljs-title">aeProcessEvents</span><span class="hljs-params">()</span>:</span><br><span class="hljs-function"></span><br><span class="hljs-function"># 获取到达时间离当前时间最接近的时间事件</span><br><span class="hljs-function">time_event</span>=aeSearchNearestTimer()<br>        <br># 计算最接近的时间事件距离到达还有多少毫秒<br>    remaind_ms=time_event.when - unix_ts_now()<br>        <br># 如果事件已到达，那么remaind_ms的值可能为负数，将它设定为<span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> remaind_ms&lt;<span class="hljs-number">0</span>:<br>        remaind_ms=<span class="hljs-number">0</span><br>            <br>#根据remaind_ms的值，创建timeval结构<br>    timeval=create_timeval_with_ms(remaind_ms)<br>            <br># 阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定<br># 如果remaind_ms的值为<span class="hljs-number">0</span>，那么aeApiPoll调用之后马上返回，不阻塞aeApiPo11（timeva1）<br>    #处理所有已产生的文件事件<br>processFileEvents（）<br>#处理所有已到达的时间事件<br>processTimeEvents（）<br></code></pre></td></tr></table></figure><hr><h1 id="三、多机数据库的实现"><a href="#三、多机数据库的实现" class="headerlink" title="三、多机数据库的实现"></a>三、多机数据库的实现</h1><h2 id="3-1、复制"><a href="#3-1、复制" class="headerlink" title="3.1、复制"></a>3.1、复制</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>在Redis中，用户可以通过执行<code>SLAVEOF</code>命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，被复制的服务器称为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.1.png"></p><p>假设现在有两个Redis服务器，地址分别为127.0.0.1:6379和127.0.0.1:1111，如果我们向服务器127.0.0.1:1111发送以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">slaveof 127.0.0.1 1111<br></code></pre></td></tr></table></figure><p>那么服务器127.0.0.1:1111将成为127.0.0.1:6379的从服务器，而服务器127.0.0.1:6379则会成为127.0.0.1:1111的主服务器</p><p>进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“<strong>数据库状态一致</strong>”，或者简称“一致”</p><hr><h3 id="主从复制实现（旧版，2-8版之前）"><a href="#主从复制实现（旧版，2-8版之前）" class="headerlink" title="主从复制实现（旧版，2.8版之前）"></a>主从复制实现（旧版，2.8版之前）</h3><p>Redis的复制功能分为<strong>同步</strong>（sync）和<strong>命令传播</strong>（command propagate）两个操作：</p><ul><li>同步操作用于<strong>将从服务器的数据库状态更新至主服务器当前所处的数据库状态</strong></li><li>命令传播操作则用于在<strong>主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态</strong></li></ul><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器<strong>首先需要执行同步操作</strong>，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态</p><p>从服务器对主服务器的同步操作需要通过向主服务器发送<strong>SYNC</strong>命令来完成，SYNC命令的执行步骤如下</p><ul><li>从服务器向主服务器发送SYNC命令</li><li>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，<strong>并使用一个缓冲区记录从现在开始执行的所有写命令</strong></li><li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，<strong>从服务器将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态</strong></li><li>主服务器将记录在<strong>缓冲区里面的所有写命令发送给从服务器</strong>，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.2.png"></p><p><strong>一个主从同步的例子如下：</strong></p><table><thead><tr><th align="left">时间</th><th align="left">主服务器</th><th align="left">从服务器</th></tr></thead><tbody><tr><td align="left">T0</td><td align="left">服务器启动</td><td align="left">服务器启动</td></tr><tr><td align="left">T1</td><td align="left">执行SET k1 v1</td><td align="left"></td></tr><tr><td align="left">T2</td><td align="left">执行SET k2 v2</td><td align="left"></td></tr><tr><td align="left">T3</td><td align="left">执行SET k2 v2</td><td align="left"></td></tr><tr><td align="left">T4</td><td align="left"></td><td align="left">向主服务器发送SYNC命令</td></tr><tr><td align="left">T5</td><td align="left">接收到从服务器发来的SYNC命令，执行BGSAVE命令，创建包含键k1、k2、k3的RDB文件，并使用缓冲区记录接下来执行的所有写命令</td><td align="left"></td></tr><tr><td align="left">T6</td><td align="left">执行SET k4 v4，并将这个命令记录到缓冲区里面</td><td align="left"></td></tr><tr><td align="left">T7</td><td align="left">执行SET k5 v5，并将这个命令记录到缓冲区里面</td><td align="left"></td></tr><tr><td align="left">T8</td><td align="left">BGSAVE命令执行完毕，向从服务器发送RDB文件</td><td align="left"></td></tr><tr><td align="left">T9</td><td align="left"></td><td align="left">接收并载入主服务器发来的RDB文件，获得k1、k2、k3三个键</td></tr><tr><td align="left">T10</td><td align="left">向从服务器发送缓冲区中保存的写命令SET k4 v4和SET k5 v5</td><td align="left"></td></tr><tr><td align="left">T11</td><td align="left"></td><td align="left">接收并执行主服务器发来的两个SET命令，得到k4和k5两个键</td></tr><tr><td align="left">T12</td><td align="left">同步完成，现在主从服务器两者的数据库都包含了键k1、k2、k3、k4、k5</td><td align="left">同步完成，现在主从服务器两者的数据库都包含了键k1、k2、k3、k4、k5</td></tr></tbody></table><p><strong>虽然SYNC指令可以完成主从复制，但是该指令执行是十分消耗资源的！</strong></p><p>每次执行SYNC命令，主从服务器需要执行以下动作</p><ul><li>主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源</li><li>主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响</li><li>接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。因为SYNC命令是一个如此耗费资源的操作</li></ul><p><strong>所以Redis有必要保证在真正有需要时才执行SYNC命令</strong></p><h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，<strong>每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致</strong></p><p>例如下面这种情况</p><p>假设一个主服务器和一个从服务器刚刚完成同步操作，它们的数据库都保存了相同的五个键k1至k5，如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.3.png"></p><p>这时，<strong>客户端向主服务器发送命令DEL k3</strong>，那么主服务器在执行完这个DEL命令之后，主从服务器的数据库将出现不一致，如下图所示</p><ul><li>主服务器的数据库已经不再包含键k3，但这个键却仍然包含在从服务器的数据库里面</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.4.png"></p><p>为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行<strong>命令传播</strong>操作</p><ul><li><strong>主服务器会将自己执行的写命令</strong>，也即是造成主从服务器不一致的那条写命令，<strong>发送给从服务器执行</strong>，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态</li></ul><p>在上面的例子中，<strong>主服务器因为执行了命令DEL k3而导致主从服务器不一致</strong>，所以主服务器将向从服务器发送相同的命令DEL k3。当从服务器执行完这个命令之后，主从服务器将再次回到一致状态，现在主从服务器两者的数据库都不再包含键k3了，如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.5.png"></p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>在Redis中，从服务器对主服务器的复制可以分为以下两种情况</p><ul><li>初次复制<ul><li>从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同</li></ul></li><li>断线后重复制<ul><li>处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并<strong>继续复制主服务器</strong></li></ul></li></ul><p>对于初次复制来说，旧版复制功能能够很好地完成任务，但<strong>对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低</strong></p><p><strong>例如下面这种断线重连情况</strong></p><table><thead><tr><th>时间</th><th>主服务器</th><th>从服务器</th></tr></thead><tbody><tr><td>T1</td><td>主从服务器完成同步</td><td>主从服务器完成同步</td></tr><tr><td>T2</td><td>执行命令并传播SET key1 val1</td><td>接收主服务器传来的命令并执行SET key1 set1</td></tr><tr><td>T3</td><td>执行命令并传播SET key2 val2</td><td>接收主服务器传来的命令并执行SET key2 set2</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>T1111</td><td>执行命令并传播SET key1111 val1111</td><td>接收主服务器传来的命令并执行SET key1111 set1111</td></tr><tr><td>T1112</td><td><strong>主从服务器断开连接</strong></td><td><strong>主从服务器断开连接</strong></td></tr><tr><td>T1113</td><td>执行命令并传播SET key1112 val1112</td><td>断线中，尝试重连</td></tr><tr><td>T1114</td><td>执行命令并传播SET key1113 val1113</td><td>断线中，尝试重连</td></tr><tr><td>T1115</td><td><strong>主从服务器重新建立连接</strong></td><td><strong>主从服务器重新建立连接</strong></td></tr><tr><td>T1116</td><td></td><td>发送SYNC指令</td></tr><tr><td>T1117</td><td>接收SYNC指令，先进行BGSAVE生成RDB文件，<strong>此文件中包含了key1~key1113</strong>。生成后将RDB文件发送给从服务器，并将此期间执行的操作记录在缓冲区中</td><td></td></tr><tr><td>T1118</td><td></td><td>接收到RDB文件，进行恢复</td></tr><tr><td>T1119</td><td>主从服务器再次完成同步</td><td>主从服务器再次完成同步</td></tr></tbody></table><p>主从服务器断开连接后，在T1115秒再次建立连接。但<strong>因为这时主从服务器的状态已经不再一致，所以从服务器将向主服务器发送SYNC命令</strong>，而<strong>主服务器会将包含键key1至键key1113的RDB文件发送给从服务器</strong>，从服务器通过接收和载入这个RDB文件来将自己的数据库更新至主服务器数据库当前所处的状态</p><p>虽然再次发送SYNC命令可以让主从服务器重新回到一致状态，但<strong>传送RDB文件这一步实际上并不是非做不可的</strong></p><ul><li>主从服务器在时间T0至时间T1110中一直处于一致状态，<strong>这两个服务器保存的数据大部分都是相同的</strong></li><li>从服务器想要将自己更新至主服务器当前所处的状态，真正需要的是主从服务器连接中断期间，主服务器新添加的key1112、key1113这两个键的数据</li><li>但旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键k1至键k1112的RDB文件，但<strong>实际上RDB文件包含的键k1至键k1111的数据对于从服务器来说都是不必要的</strong>。并且如上面所说，SYNC操作是非常消耗资源的一种操作，所以要尽量避免不必要的同步操作</li></ul><hr><h3 id="主从复制实现（新版，2-8版之后）"><a href="#主从复制实现（新版，2-8版之后）" class="headerlink" title="主从复制实现（新版，2.8版之后）"></a>主从复制实现（新版，2.8版之后）</h3><p>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用<strong>PSYNC</strong>命令代替SYNC命令来执行复制时的同步操作</p><p>PSYNC命令具有<strong>完整重同步</strong>（full resynchronization）和<strong>部分重同步</strong>（partialresynchronization）两种模式</p><ul><li>完整重同步用于处理初次复制情况<ul><li>完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步</li></ul></li><li>部分重同步则用于处理断线后重复制情况<ul><li>当从服务器在断线后重新连接主服务器时，如果条件允许，<strong>主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器</strong>，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li></ul></li></ul><p>如上面所提到的情况，在新版的主从复制中的流程如下</p><table><thead><tr><th>时间</th><th>主服务器</th><th>从服务器</th></tr></thead><tbody><tr><td>T1</td><td>主从服务器完成同步</td><td>主从服务器完成同步</td></tr><tr><td>T2</td><td>执行命令并传播SET key1 val1</td><td>接收主服务器传来的命令并执行SET key1 set1</td></tr><tr><td>T3</td><td>执行命令并传播SET key2 val2</td><td>接收主服务器传来的命令并执行SET key2 set2</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>T1111</td><td>执行命令并传播SET key1111 val1111</td><td>接收主服务器传来的命令并执行SET key1111 set1111</td></tr><tr><td>T1112</td><td><strong>主从服务器断开连接</strong></td><td><strong>主从服务器断开连接</strong></td></tr><tr><td>T1113</td><td>执行命令并传播SET key1112 val1112</td><td>断线中，尝试重连</td></tr><tr><td>T1114</td><td>执行命令并传播SET key1113 val1113</td><td>断线中，尝试重连</td></tr><tr><td>T1115</td><td><strong>主从服务器重新建立连接</strong></td><td><strong>主从服务器重新建立连接</strong></td></tr><tr><td>T1116</td><td></td><td><strong>发送PSYNC指令</strong></td></tr><tr><td>T1117</td><td>向从服务器返回+CONTINUE回复，表示执行部分重同步</td><td></td></tr><tr><td>T1118</td><td></td><td>接收+CONTINUE回复，准备部分重同步</td></tr><tr><td>T1119</td><td>向从服务器发送SET key1112 val1112和SET key1113 val1113两条指令</td><td></td></tr><tr><td>T1120</td><td></td><td>接收发送过来的两条SET指令，并执行</td></tr><tr><td>T1121</td><td>主从服务器再次完成同步</td><td>主从服务器再次完成同步</td></tr></tbody></table><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.6.png"></p><h4 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h4><p>部分重同步功能由以下三个部分构成</p><ul><li>主服务器的<strong>复制偏移量</strong>（replication offset）和从服务器的<strong>复制偏移量</strong></li><li>主服务器的<strong>复制积压缓冲区</strong>（replication backlog）</li><li>服务器的运行ID（run ID）</li></ul><h5 id="1、复制偏移量"><a href="#1、复制偏移量" class="headerlink" title="1、复制偏移量"></a>1、复制偏移量</h5><p>执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量</p><ul><li><strong>主服务器</strong>每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li><li><strong>从服务器</strong>每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li></ul><p>例如下图，主从服务器拥有相同的偏移量</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.7.png"></p><p>如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119，如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.8.png"></p><p>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态</p><ul><li>如果主从服务器处于<strong>一致状态</strong>，那么主从服务器两者的<strong>偏移量总是相同的</strong></li><li>相反，如果主从服务器两者的<strong>偏移量并不相同</strong>，那么说明主从服务器并<strong>未处于一致状态</strong></li></ul><p>如果在主服务器要向从服务器传播长度为33字节的数据之前，从<strong>服务器A断线了</strong>，那么主服务器传播的数据将只有从服务器B和从服务器C能收到，在这之后，主服务器、从服务器B和从服务器C三个服务器的复制偏移量都将更新为10119，而断线的从服务器A的复制偏移量仍然停留在10086，这说明从服务器A与主服务器并不一致，如下图</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.9.png"></p><p>假设从服务器A在断线之后就立即重新连接主服务器，并且成功，那么接下来，从服务器将向主服务器发送PSYNC命令，报告从服务器A当前的复制偏移量为10086，那么这时，主服务器应该对从服务器执行完整重同步还是部分重同步呢？如果执行部分重同步的话，主服务器又如何补偿从服务器A在断线期间丢失的那部分数据呢？以上问题的答案都和<strong>复制积压缓冲区</strong>有关</p><h5 id="2、复制积压缓冲区"><a href="#2、复制积压缓冲区" class="headerlink" title="2、复制积压缓冲区"></a>2、复制积压缓冲区</h5><p>复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。当主服务器进行命令传播时，<strong>它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面</strong>，如下图</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.10.png"></p><p>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且<strong>复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量</strong>，如下</p><table><thead><tr><th>偏移量</th><th>…</th><th>10087</th><th>10088</th><th>10089</th><th>10090</th><th>10091</th><th>10092</th><th>10093</th><th>…</th></tr></thead><tbody><tr><td><strong>字节值</strong></td><td>…</td><td>‘a’</td><td>‘b’</td><td>‘c’</td><td>‘d’</td><td>‘e’</td><td>‘\n’</td><td>‘f’</td><td>…</td></tr></tbody></table><p>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作</p><ul><li>如果offset偏移量之后的<strong>数据</strong>（也即是偏移量offset+1开始的数据）<strong>仍然存在于复制积压缓冲区里面</strong>，那么主服务器将对从服务器执行部分重同步操作</li><li>相反，如果offset偏移量之后的<strong>数据已经不存在于复制积压缓冲区</strong>，那么主服务器将对从服务器执行<strong>完整重同步</strong>操作</li></ul><p>像上面的例子，从服务器A断线重连，向主服务器发送PSYNC指令后，主服务器接受从服务器的偏移量后，检查复制积压缓冲区中是否有偏移量之后的数据。如果有，就将这部分数据发送给从服务，如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.11.png"></p><h5 id="3、服务器运行ID"><a href="#3、服务器运行ID" class="headerlink" title="3、服务器运行ID"></a>3、服务器运行ID</h5><p>除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID（run ID）</p><ul><li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID</li><li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如<code>53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3</code></li></ul><p>可以通过<code>info server</code>指令查看</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.12.png"></p><p>当从服务器对主服务器进行初次复制时，<strong>主服务器会将自己的运行ID传送给从服务器</strong>，而从服务器则会将这个运行ID保存起来</p><p>当从服务器<strong>断线并重新连</strong>上一个主服务器时，<strong>从服务器将向当前连接的主服务器发送之前保存的运行ID</strong>，这主要是用于验证从服务器当前所连的主服务器是否为断线前所连的那个主服务器</p><ul><li>如果从服务器保存的运行ID和当前连接的主服务器的运行<strong>ID相同</strong>，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行<strong>部分重同步</strong>操作</li><li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行<strong>ID并不相同</strong>，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行<strong>完整重同步</strong>操作</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从服务器与主服务器建立连接后，<strong>主服务器会将自己的id发送给从服务器</strong>，从服务器会保存主服务器的id</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.13.png"></p><p>因为是第一次连接，所以会进行<strong>完整重同步</strong>，从服务器发送SYNC指令，主服务器执行BGSAVE，并将RDB文件发送给从服务。发送后再将缓冲区中的数据发送给从服务器</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.14.png"></p><p>完全重同步后，主从服务器的偏移量相同，此后开始<strong>命令传播</strong>过程</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.15.png"></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.16.png"></p><p>命令传播过程中，<strong>从服务器A与主服务器断开连接了</strong>，但是主服务器依然在执行客户端发来的指令，依然进行着命令传播</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.17.png"></p><p>从服务器A尝试重连主服务器，某个时刻成功连上了。但是<strong>它需要确定连上的主服务器是不是之前的主服务器</strong></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.18.png"></p><p>确认是之前的主服务器后，开始<strong>部分复制</strong>操作，至复制完成</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.19.png"></p><h4 id="PSYNC命令"><a href="#PSYNC命令" class="headerlink" title="PSYNC命令"></a>PSYNC命令</h4><p>PSYNC命令的调用方法有两种，主服务器通过<strong>PSYNC所带的参数</strong>来判断具体执行哪种重同步操作</p><ul><li>如果<strong>从服务器以前没有复制过任何主服务器</strong>，或者之前执行过<code>SLAVEOF no one</code>命令，那么从服务器在开始一次新的复制时将向主服务器发送<code>PSYNC ? -1</code>命令，主动请求主服务器进行<strong>完整重同步</strong>（因为这时不可能执行部分重同步）</li><li>如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送<code>PSYNC ＜runid＞ ＜offset＞</code>命令<ul><li>其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作</li></ul></li></ul><p>根据情况，接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种</p><ul><li>如果主服务器返回<code>+FULLRESYNC ＜runid＞ ＜offset＞</code>回复，那么表示主服务器将与从服务器执行<strong>完整重同步</strong>操作<ul><li>其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，<strong>从服务器会将这个值作为自己的初始化偏移量</strong></li></ul></li><li>如果主服务器返回<code>+CONTINUE</code>回复，那么表示主服务器将与从服务器执行<strong>部分重同步</strong>操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了</li><li>如果主服务器返回<code>-ERR</code>回复，那么表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作</li></ul><p><strong>流程图如下</strong></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.20.png"></p><h3 id="复制步骤"><a href="#复制步骤" class="headerlink" title="复制步骤"></a>复制步骤</h3><h4 id="1-设置主服务器的地址和端口"><a href="#1-设置主服务器的地址和端口" class="headerlink" title="1. 设置主服务器的地址和端口"></a>1. 设置主服务器的地址和端口</h4><p>当客户端向从服务器发送以下命令时：<br><code>127.0.0.1:12345&gt;SLAVEOF 127.0.0.1:6379 OK</code><br>从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口6379保存到服务器状态的masterhost属性和masterport属性里面</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.21.png"></p><h4 id="2-建立套接字连接"><a href="#2-建立套接字连接" class="headerlink" title="2. 建立套接字连接"></a>2. 建立套接字连接</h4><p>在<code>SLAVEOF</code>命令执行之后，从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.22.png"></p><h4 id="3-发送PING命令"><a href="#3-发送PING命令" class="headerlink" title="3. 发送PING命令"></a>3. 发送PING命令</h4><p>从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送一个<code>PING</code>命令</p><p>这个PING命令有两个作用：</p><ul><li>虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信，通过发送PING命令可以检查套接字的读写状态是否正常。</li><li>因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以检查主服务器能否正常处理命令请求。</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.23.png"></p><h4 id="4-身份验证"><a href="#4-身份验证" class="headerlink" title="4. 身份验证"></a>4. 身份验证</h4><p>从服务器在收到主服务器返回的“PONG”回复之后，下一步要做的就是决定是否进行身份验证：</p><ul><li>如果从服务器设置了<code>masterauth</code>选项，那么进行身份验证。</li><li>如果从服务器没有设置<code>masterauth</code>选项，那么不进行身份验证。<ul><li>在需要进行身份验证的情况下，从服务器将向主服务器发送一条<code>AUTH</code>命令，命令的参数为从服务器masterauth选项的值。</li></ul></li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.24.png"></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.25.png"></p><h4 id="5-发送端口信息"><a href="#5-发送端口信息" class="headerlink" title="5. 发送端口信息"></a>5. 发送端口信息</h4><p>在身份验证步骤之后，从服务器将执行<code>REPLCONF listening-port &lt;port-number&gt;</code>命令，向主服务器发送从服务器的监听端口号。</p><p>主服务器在接收到这个命令之后，会将端口号记录在从服务器对应的客户端状态<code>slave_listening_port</code>属性中</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.26.png"></p><h4 id="6-同步"><a href="#6-同步" class="headerlink" title="6. 同步"></a>6. 同步</h4><p>在这一步，从服务器将向主服务器发送<code>PSYNC</code>命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。<br><strong>在同步操作执行之前，只有从服务器是主服务器的客户端，但是在执行同步操作之后，主服务器也会成为从服务器的客户端：</strong></p><ul><li><p>如果<code>PSYVC</code>命令执行的是完整重同步操作，那么主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行</p></li><li><p>如果<code>PSYNC</code>命令执行的是部分重同步操作，那么主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令。</p></li></ul><p>因此，<strong>在同步操作执行之后，主从服务器双方都是对方的客户端</strong>，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复。<br>正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命令传播操作的基础</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.27.png"></p><h4 id="7-命令传播"><a href="#7-命令传播" class="headerlink" title="7. 命令传播"></a>7. 命令传播</h4><p>当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。<br>以上就是Redis2.8或以上版本的复制功能的实现步骤。</p><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令，以确保主从服务器连接正常</p><p><code>REPLCONE ACK &lt;replication_offset&gt;</code></p><p>其中replication_offset是<strong>从服务器当前的复制偏移量</strong></p><p>发送REPLCONF ACK命令对于主从服务器有<strong>三个作用</strong></p><ul><li>检测主从服务器的网络连接状态</li><li>辅助实现min-slaves选项</li><li>检测命令丢失</li></ul><h4 id="检测主从服务器的网络连接状态"><a href="#检测主从服务器的网络连接状态" class="headerlink" title="检测主从服务器的网络连接状态"></a>检测主从服务器的网络连接状态</h4><p>主从服务器可以通过发送和接收REPLCONF ACK命令来检查两者之间的网络连接是否正常</p><p>如果主服务器<strong>超过一秒钟</strong>没有收到从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了</p><ul><li>通过向主服务器发送<code>INFO replication</code>命令，在列出的从服务器列表的<strong>lag</strong>一栏中，可以看到相应从服务器最后一次向主服务器发送<code>REPLCONF ACK</code>命令距离现在过了多少秒</li></ul><p>在一般情况下，<strong>lag的值应该在0秒或者1秒之间跳动</strong>，如果超过1秒的话，那么说明主从服务器之间的连接出现了故障</p><h4 id="辅助实现min-slaves配置选项"><a href="#辅助实现min-slaves配置选项" class="headerlink" title="辅助实现min-slaves配置选项"></a>辅助实现min-slaves配置选项</h4><p>Redis的<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>两个选项可以防止主服务器在不安全的情况下执行写命令</p><p>比如下面的参数设置</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>那么在从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，<strong>主服务器将拒绝执行写命令</strong>，这里的延迟值就是上面提到的INFOreplication命令的lag值</p><h4 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h4><p>如果因为网络故障，<strong>主服务器传播给从服务器的写命令在半路丢失</strong>，那么当从服务器向主服务器发送<code>REPLCONF ACK</code>命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器</p><hr><h2 id="3-2、哨兵"><a href="#3-2、哨兵" class="headerlink" title="3.2、哨兵"></a>3.2、哨兵</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>Sentinel（哨岗、哨兵）是Redis的高可用性（high availability）解决方案</p><ul><li>由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求</li></ul><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.28.png"></p><p>其中<strong>sever1为主服务器</strong>，剩下的为从服务器</p><p>假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4<strong>对主服务器的复制操作将被中止</strong>，并且Sentinel系统会察觉到server1已下线，如下图（下线的服务器用虚线表示）</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.29.png"></p><p>当server1的下线时长超过用户设定的下线时长上限时，Sentinel系统就会对server1执行<strong>故障转移操作</strong>，具体操作如下</p><ul><li>Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的<strong>从服务器升级为新的主服务器</strong></li><li>Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始<strong>复制新的主服务器</strong>时，故障转移操作执行完毕</li><li>Sentinel还会<strong>继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器</strong></li></ul><p>若server1下线，Sentinel系统选择新的主服务器的过程如下</p><p>线，如下图（下线的服务器用虚线表示）</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.30.png"></p><p>如果此期间server1重新上线了，那么<strong>它会降级成为从服务器</strong></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.31.png"></p><h3 id="2-启动与初始化"><a href="#2-启动与初始化" class="headerlink" title="2. 启动与初始化"></a>2. 启动与初始化</h3><p>当一个Sentinel启动时，它需要执行以下步骤</p><ul><li>初始化服务器</li><li>将普通Redis服务器使用的代码<strong>替换成Sentinel专用代码</strong></li><li>初始化Sentinel状态</li><li>根据给定的配置文件，初始化Sentinel的监视主服务器列表</li><li>创建连向主服务器的网络连接</li></ul><h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><p>Sentinel<strong>本质上只是一个运行在特殊模式下的Redis服务器</strong>，所以启动Sentinel的第一步，就是初始化一个普通的Redis服务器。不过，因为Sentinel执行的工作和普通Redis服务器执行的工作不同，所以Sentinel的初始化过程和普通Redis服务器的初始化过程<strong>并不完全相同</strong></p><p>例如：普通服务器在初始化时会通过载入RDB文件或者AOF文件来还原数据库状态，但是因为<strong>Sentinel并不使用数据库</strong>，所以初始化Sentinel时就不会载入RDB文件或者AOF文件</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.32.png"></p><h4 id="使用Sentinel专用代码"><a href="#使用Sentinel专用代码" class="headerlink" title="使用Sentinel专用代码"></a>使用Sentinel专用代码</h4><p>启动Sentinel的第二个步骤就是将一部分普通Redis服务器使用的代码<strong>替换成Sentinel专用代码</strong>。。比如说，普通Redis服务器使用<code>redis.h/REDIS_SERVERPORT</code>常量的值作为服务器端口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> REDIS_SERVERPORT 6379</span><br></code></pre></td></tr></table></figure><p>而Sentinel则使用<code>sentinel.c/REDIS_SENTINEL_PORT</code>常量的值作为服务器端口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> REDIS_SENTINEL_PORT 6379</span><br></code></pre></td></tr></table></figure><p>普通Redis 服务器使用<code>redis.c/redisCommandTable</code>作为服务器的命令表，而Sentinel则使用sentinel.c/sentinelcmds作为服务器的命令表。</p><p>sentinelcmds命令表也解释了为什么在Sentinel模式下，Redis服务器不能执行诸如<code>SET</code>、<code>DBSIZE</code>、<code>EVAL</code>等等这些命令，因为服务器根本没有在命令表中载入这些命令。<code>PING</code>、<code>SENTINEL</code>、<code>INFO</code>、<code>SUBSCRIBE</code>、<code>UNSUBSCRIBE</code>、<code>PSUBSCRIBE</code>和<code>PUNSUBSCRIBE</code>这七个命令就是客户端可以对Sentinel执行的全部命令了。</p><h4 id="初始化Sentinel状态"><a href="#初始化Sentinel状态" class="headerlink" title="初始化Sentinel状态"></a>初始化Sentinel状态</h4><p>在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个<strong>sentinelState结构</strong>（后面简称“Sentinel状态”），这个结构保存了服务器中所有和Sentinel功能有关的状态（服务器的一般状态仍然由redisServer结构保存）。其代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sentinelState</span> &#123;</span><br>    <span class="hljs-keyword">char</span> myid[CONFIG_RUN_ID_SIZE+<span class="hljs-number">1</span>]; <span class="hljs-comment">/* This sentinel ID. */</span><br>    <span class="hljs-comment">// 当前纪元，用于故障转移</span><br>    <span class="hljs-keyword">uint64_t</span> current_epoch;         <span class="hljs-comment">/* Current epoch. */</span><br>    <br>    <span class="hljs-comment">// 保存了被该哨兵监视的主服务器（多个）</span><br>    <span class="hljs-comment">// 使用字典，键是主服务器的名字，值是指向主服务器的指针</span><br>    dict *masters;      <span class="hljs-comment">/* Dictionary of master sentinelRedisInstances.</span><br><span class="hljs-comment">                           Key is the instance name, value is the</span><br><span class="hljs-comment">                           sentinelRedisInstance structure pointer. */</span><br>    <span class="hljs-keyword">int</span> tilt;           <span class="hljs-comment">/* Are we in TILT mode? */</span><br>    <span class="hljs-keyword">int</span> running_scripts;    <span class="hljs-comment">/* Number of scripts in execution right now. */</span><br>    <span class="hljs-keyword">mstime_t</span> tilt_start_time;       <span class="hljs-comment">/* When TITL started. */</span><br>    <span class="hljs-keyword">mstime_t</span> previous_time;         <span class="hljs-comment">/* Last time we ran the time handler. */</span><br>    <span class="hljs-built_in">list</span> *scripts_queue;            <span class="hljs-comment">/* Queue of user scripts to execute. */</span><br>    <span class="hljs-keyword">char</span> *announce_ip;  <span class="hljs-comment">/* IP addr that is gossiped to other sentinels if</span><br><span class="hljs-comment">                           not NULL. */</span><br>    <span class="hljs-keyword">int</span> announce_port;  <span class="hljs-comment">/* Port that is gossiped to other sentinels if</span><br><span class="hljs-comment">                           non zero. */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> simfailure_flags; <span class="hljs-comment">/* Failures simulation. */</span><br>    <span class="hljs-keyword">int</span> deny_scripts_reconfig; <span class="hljs-comment">/* Allow SENTINEL SET ... to change script</span><br><span class="hljs-comment">                                  paths at runtime? */</span><br>    <span class="hljs-keyword">char</span> *sentinel_auth_pass;    <span class="hljs-comment">/* Password to use for AUTH against other sentinel */</span><br>    <span class="hljs-keyword">char</span> *sentinel_auth_user;    <span class="hljs-comment">/* Username for ACLs AUTH against other sentinel. */</span><br>&#125; sentinel;<br></code></pre></td></tr></table></figure><h4 id="初始化Sentinel状态的masters属性"><a href="#初始化Sentinel状态的masters属性" class="headerlink" title="初始化Sentinel状态的masters属性"></a>初始化Sentinel状态的masters属性</h4><p>Sentinel状态中的<strong>masters字典</strong>记录了所有被Sentinel监视的主服务器的相关信息，其中</p><ul><li>字典的键是被监视主服务器的名字</li><li>字典的值是指向被监视的主服务器的指针</li></ul><p>每个sentinelRedisInstance结构（后面简称“<strong>实例结构</strong>”）代表一个<strong>被Sentinel监视的Redis服务器实例</strong>（instance），这个实例可以是主服务器、从服务器，或者另外一个Sentinel</p><p><strong>sentinelRedisInstance结构的代码如下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sentinelRedisInstance</span> &#123;</span><br>    <span class="hljs-keyword">int</span> flags;      <span class="hljs-comment">/* See SRI_... defines */</span><br>    <br>    <span class="hljs-comment">// 实例的名字</span><br>    <span class="hljs-keyword">char</span> *name;     <span class="hljs-comment">/* Master name from the point of view of this sentinel. */</span><br>    <br>    <span class="hljs-comment">// 实例的运行时id</span><br>    <span class="hljs-keyword">char</span> *runid;    <span class="hljs-comment">/* Run ID of this instance, or unique ID if is a Sentinel.*/</span><br>    <span class="hljs-keyword">uint64_t</span> config_epoch;  <span class="hljs-comment">/* Configuration epoch. */</span><br>    <br>    <span class="hljs-comment">// 实例的运行时地址。通过该变量来寻找主服务器</span><br>    sentinelAddr *addr; <span class="hljs-comment">/* Master host. */</span><br>    <br>    ...<br>        <br>    <span class="hljs-comment">// 从服务器的字典</span><br>    dict *slaves;       <span class="hljs-comment">/* Slaves for this master instance. */</span><br><br>    <span class="hljs-comment">// 其他哨兵的字典</span><br>    dict *sentinels;    <span class="hljs-comment">/* Other sentinels monitoring the same master. */</span> <br>&#125; sentinelRedisInstance;<br></code></pre></td></tr></table></figure><p>其中的addr为一个sentinelAddr类型的指针，sentinelAddr的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sentinelAddr</span> &#123;</span><br>    <span class="hljs-comment">// 实例的ip</span><br>    <span class="hljs-keyword">char</span> *ip;<br>    <span class="hljs-comment">// 实例的端口号</span><br>    <span class="hljs-keyword">int</span> port;<br>&#125; sentinelAddr;<br></code></pre></td></tr></table></figure><p>若让哨兵分别监视两个主服务器的实例master1和master2，那么他们的结构如下图所示</p><p>两个主服务器的实例</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.33.png"></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.34.png"></p><p>Sentinel状态以及masters<strong>字典</strong></p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.35.png"></p><h4 id="创建连向主服务器的网络连接"><a href="#创建连向主服务器的网络连接" class="headerlink" title="创建连向主服务器的网络连接"></a>创建连向主服务器的网络连接</h4><p>对于每个被Sentinel监视的主服务器来说，Sentinel会创建<strong>两个</strong>连向主服务器的异步网络连接</p><ul><li>一个是<strong>命令连接</strong>，这个连接专门用于向主服务器发送命令，并接收命令回复</li><li>一个是<strong>订阅连接</strong>，这个连接专门用于订阅主服务器的<strong>sentinel</strong>:hello频道</li></ul><p><strong>为什么有两个连接？</strong></p><p>一方面，在Redis目前的发布与订阅功能中，被发送的信息都不会保存在Redis服务器里面，如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。因此，为了不丢失<strong>sentinel</strong>:hello频道的任何信息，Sentinel必须专门用一个订阅连接来接收该频道的信息</p><p>另一方面，除了订阅频道之外，Sentinel还必须向主服务器发送命令，以此来与主服务器进行通信，所以Sentinel还必须向主服务器创建命令连接</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.36.png"></p><hr><h3 id="3-获取主服务器信息"><a href="#3-获取主服务器信息" class="headerlink" title="3. 获取主服务器信息"></a>3. 获取主服务器信息</h3><p>Sentinel默认会以每十秒一次的频率，通过命令连接<strong>向被监视的主服务器发送INFO命令</strong>，并通过分析INFO命令的<strong>回复</strong>来获取主服务器的当前信息</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.37.png"></p><p>通过分析<strong>主服务器返回的INFO命令回复</strong>，Sentinel可以获取以下两方面的信息</p><ul><li>一方面是关于主服务器本身的信息，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色</li><li>另一方面是关于主服务器属下所有从服务器的信息，每个<strong>从服务器都由一个”slave”字符串开头的行记录</strong>，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器</li></ul><p>Sentinel在分析INFO命令中包含的<strong>从服务器</strong>信息时，会检查从服务器对应的实例结构是否已经存在于slaves字典</p><ul><li>如果从服务器对应的实例结构已经存在，那么Sentinel对从服务器的实例结构进行更新</li><li>如果从服务器对应的实例结构不存在，那么说明这个从服务器是新发现的从服务器，Sentinel会在slaves字典中为这个从服务器新创建一个实例结构</li></ul><hr><h3 id="4-获取从服务器信息"><a href="#4-获取从服务器信息" class="headerlink" title="4. 获取从服务器信息"></a>4. 获取从服务器信息</h3><p>当Sentinel发现主服务器有<strong>新的从服务器</strong>出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的<strong>命令连接和订阅连接</strong></p><p>举个例子，对于下图所示的主从服务器关系来说</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.38.png"></p><p>Sentinel将对slave0、slave1和slave2<strong>三个从服务器分别创建命令连接和订阅连接</strong>，如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.39.png"></p><hr><h3 id="5-向主服务器和从服务器发送信息"><a href="#5-向主服务器和从服务器发送信息" class="headerlink" title="5. 向主服务器和从服务器发送信息"></a>5. 向主服务器和从服务器发送信息</h3><p>在默认情况下，Sentinel会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：</p><p><code>PUBLISH_sentinel_:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</code><br>这条命令向服务器的<code>_sentinel_:hello</code>频道发送了一条信息，信息的内容由多个参数组成：</p><ul><li>其中以s_开头的参数记录的是Sentinel本身的信息。</li><li>以m_开头的参数记录的则是主服务器的信息。如果Sentinel正在监视的是主服务器，那么这些参数记录的就是主服务器的信息；如果Sentinel正在监视的是从服务器，那么这些参数记录的就是从服务器正在复制的主服务器的信息。</li></ul><hr><h3 id="6-接收主从服务器的频道信息"><a href="#6-接收主从服务器的频道信息" class="headerlink" title="6. 接收主从服务器的频道信息"></a>6. 接收主从服务器的频道信息</h3><p>当Sentinel与一个主服务器或者从服务器建立起<strong>订阅连接</strong>之后，Sentinel就会通过订阅连接，向服务器发送<code>SUBSCRIBE _sentinel_:hello</code>命令</p><p>Sentinel对<strong>sentinel</strong>:hello频道的订阅会一直持续到Sentinel与服务器的连接断开为止</p><p>这也就是说，对于每个与Sentinel连接的服务器，Sentinel既通过<strong>命令连接</strong>向服务器的<strong>sentinel</strong>:hello频道发送信息，又通过<strong>订阅连接</strong>从服务器的<strong>sentinel</strong>:hello频道接收信息</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.40.png"></p><p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到，这些信息会被用于<strong>更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知</strong></p><p>举个例子，假设现在有sentinel1、sentinel2、sentinel3<strong>三个Sentinel</strong>在监视同一个服务器，那么当sentinel1向服务器的<strong>sentinel</strong>:hello频道发送一条信息时，<strong>所有</strong>订阅了<strong>sentinel</strong>:hello频道的Sentinel（包括sentinel1自己在内）都会收到这条信息，如图下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.41.png"></p><h4 id="更新sentinels字典"><a href="#更新sentinels字典" class="headerlink" title="更新sentinels字典"></a>更新sentinels字典</h4><p>Sentinel为主服务器创建的实例结构中的sentinels字典保存了除Sentinel本身之外，还保存了<strong>所有同样监视这个主服务器的其他Sentinel的资料</strong></p><ul><li>键是其中一个Sentinel的名字，格式为ip:port</li><li>值则是键所对应Sentinel的实例结构</li></ul><p>当一个Sentinel接收到其他Sentinel发来的信息时（我们称呼发送信息的Sentinel为<strong>源Sentinel</strong>，接收信息的Sentinel为<strong>目标Sentinel</strong>），目标Sentinel会从信息中分析并提取出以下<strong>两方面参数</strong></p><ul><li>与Sentinel有关的参数<ul><li>源Sentinel的IP地址、端口号、运行ID和配置纪元</li></ul></li><li>与主服务器有关的参数<ul><li>源Sentinel正在监视的主服务器的名字、IP地址、端口号和配置纪元</li></ul></li></ul><p>根据信息中提取出的主服务器参数，目标Sentinel会在自己的Sentinel状态的masters字典中查找相应的主服务器实例结构，然后根据提取出的Sentinel参数，检查主服务器实例结构的sentinels字典中，源Sentinel的实例结构是否存在</p><p>因为一个Sentinel可以通过分析接收到的频道信息来获知其他Sentinel的存在，并通过发送频道信息来让其他Sentinel知道自己的存在，所以用户在使用Sentinel的时候并不需要提供各个Sentinel的地址信息，<strong>监视同一个主服务器的多个Sentinel可以自动发现对方</strong></p><h4 id="创建Sentinel之间的命令连接"><a href="#创建Sentinel之间的命令连接" class="headerlink" title="创建Sentinel之间的命令连接"></a>创建Sentinel之间的命令连接</h4><p>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，还<strong>会创建一个连向新Sentinel的命令连接，而新Sentinel也同样会创建连向这个Sentinel的命令连接</strong>（互相连接）。<strong>这是为了能够让多个哨兵中保存的主从服务器信息一致</strong>。最终监视同一主服务器的多个Sentinel将形成相互连接的网络，如下图所示</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.42.png"></p><blockquote><p>注意：Sentinel之间不会创建订阅连接</p></blockquote><hr><h3 id="7-检测主观下线状态"><a href="#7-检测主观下线状态" class="headerlink" title="7. 检测主观下线状态"></a>7. 检测主观下线状态</h3><p>在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送<code>PING</code>命令，并通过实例返回的PING命令回复来判断实例是否在线</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.43.png"></p><p>实例对PING命令的<strong>回复</strong>可以分为以下两种情况</p><ul><li>有效回复<ul><li>实例返回+PONG、-LOADING、-MASTERDOWN三种回复的其中一种</li></ul></li><li>无效回复<ul><li>实例返回除+PONG、-LOADING、-MASTERDOWN三种回复<strong>之外</strong>的其他回复，或者在指定时限内没有返回任何回复</li></ul></li></ul><p>Sentinel配置文件中的down-after-milliseconds选项指定了Sentinel判断实例进入主观下线所需的时间长度：如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打开SRI_S_DOWN标识，以此来表示这个实例已经<strong>进入主观下线状态</strong></p><blockquote><p>注意：多个Sentinel设置的主观下线时长可能不同</p></blockquote><hr><h3 id="8-检查客观下线状态"><a href="#8-检查客观下线状态" class="headerlink" title="8. 检查客观下线状态"></a>8. 检查客观下线状态</h3><p>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，<strong>它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态</strong>（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作</p><p><img src="/2020/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/3.44.png"></p><blockquote><p>注意：多个Sentinel设置的客观下线条件可能不同</p></blockquote><hr><h3 id="9-选举领头Sentinel"><a href="#9-选举领头Sentinel" class="headerlink" title="9. 选举领头Sentinel"></a>9. 选举领头Sentinel</h3><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，<strong>选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作</strong></p><p>选举规则如下</p><ul><li>所有在线的Sentinel都有被选为领头Sentinel的资格，换句话说，监视同一个主服务器的多个在线Sentinel中的任意一个都有可能成为领头Sentinel</li><li>每次进行领头Sentinel<strong>选举之后</strong>，不论选举是否成功，所有Sentinel的配置纪元（configuration epoch）的值都会自增一次。配置纪元实际上就是一个计数器，并没有什么特别的</li><li>在一个配置纪元里面，<strong>所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会</strong>，并且局部领头一旦设置，在这个配置纪元里面就不能再更改</li><li>每个<strong>发现主服务器进入客观下线</strong>的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel</li><li>当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送SENTINEL is-master-down-by-addr命令，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel</li><li>Sentinel设置局部领头Sentinel的规则是<strong>先到先得</strong><ul><li>最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝</li></ul></li><li>目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，将向源Sentinel返回一条命令回复，回复中的leader_runid参数和leader_epoch参数分别记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元</li><li>源Sentinel在接收到目标Sentinel返回的命令回复之后，会检查回复中leader_epoch参数的值和自己的配置纪元是否相同，如果相同的话，那么源Sentinel继续取出回复中的leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标Sentinel将源Sentinel设置成了局部领头Sentinel</li><li>如果有<strong>某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel</strong>，那么这个Sentinel成为领头Sentinel<ul><li>举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成为领头Sentinel</li></ul></li><li>因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，所以在一个配置纪元里面，只会出现一个领头Sentinel</li><li>如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后<strong>再次进行选举，直到选出领头Sentinel为止</strong></li></ul><hr><h3 id="10-故障转移"><a href="#10-故障转移" class="headerlink" title="10. 故障转移"></a>10. 故障转移</h3><p>在选举产生出领头Sentinel之后，<strong>领头Sentinel将对已下线的主服务器执行故障转移操作</strong>，该操作包含以下三个步骤</p><ul><li>在已下线主服务器<strong>属下</strong>的所有从服务器里面，<strong>挑选出一个从服务器，并将其转换为主服务器</strong></li><li>让已下线主服务器属下的所有从服务器改为复制新的主服务器</li><li>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器</li></ul><h4 id="选出新的主服务器"><a href="#选出新的主服务器" class="headerlink" title="选出新的主服务器"></a>选出新的主服务器</h4><p>故障转移操作第一步要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送SLAVEOF no one命令（断开与主服务器的连接），<strong>将这个从服务器转换为主服务器</strong></p><p>领头Sentinel筛选新主服务器的规则如下</p><ul><li><strong>删除列表中所有处于下线或者断线状态的从服务器</strong>，这可以保证列表中剩余的从服务器都是正常在线的</li><li><strong>删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器</strong>，这可以保证列表中剩余的从服务器都是最近成功进行过通信的</li><li>删除所有与已下线主服务器连接断开超过down-after-milliseconds*10毫秒的从服务器</li></ul><p>之后，领头Sentinel将根据从服务器的<strong>优先级</strong>，对列表中剩余的从服务器进行排序，并选出其中优先级最高的从服务器</p><h4 id="修改从服务器的复制目标"><a href="#修改从服务器的复制目标" class="headerlink" title="修改从服务器的复制目标"></a>修改从服务器的复制目标</h4><p>当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的<strong>所有从服务器去复制新的主服务器</strong>，这一动作可以通过向从服务器发送<strong>SLAVEOF</strong>命令来实现</p><h4 id="将旧的主服务器变为从服务器"><a href="#将旧的主服务器变为从服务器" class="headerlink" title="将旧的主服务器变为从服务器"></a>将旧的主服务器变为从服务器</h4><p>因为旧的主服务器已经下线，所以这种设置是保存在server1对应的实例结构里面的，当<strong>server1重新上线</strong>时，Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL进阶</title>
    <link href="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/"/>
    <url>/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Mysql逻辑架构"><a href="#一、Mysql逻辑架构" class="headerlink" title="一、Mysql逻辑架构"></a>一、Mysql逻辑架构</h1><h2 id="1-1-整体架构"><a href="#1-1-整体架构" class="headerlink" title="1.1 整体架构"></a>1.1 整体架构</h2><p>MySQL架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/1.1.png"></p><h3 id="1-1-1-连接层"><a href="#1-1-1-连接层" class="headerlink" title="1.1.1 连接层"></a>1.1.1 连接层</h3><p>最上层是一些客户端和连接服务，包括socket通信和大多数基于客服端/服务端工具实现的类似于tcp/ip的通信，主要完成一些类似于连接处理、授权认证及相关安全的方案，在该层上引入了线程池的概念，为通过认证安全接入的客服端提供线程，同样在该层上可以实现基于SSL的安全的连接，服务器也会为安全接入的每个客户端验证它所具有的操作权限</p><h3 id="1-1-2-服务层"><a href="#1-1-2-服务层" class="headerlink" title="1.1.2 服务层"></a>1.1.2 服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析以及优化部分内置函数的执行，所有跨存储引擎的功能也在这一层实现，如过程、函数等，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询的顺序是否利用索引，最后生成相应的执行操作</p><table><thead><tr><th>Management Serveices &amp; Utilities</th><th>系统管理和控制工具</th></tr></thead><tbody><tr><td>SQL Interface</td><td>SQL 接口。接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface</td></tr><tr><td>Parser</td><td>解析器。 SQL 命令传递到解析器的时候会被解析器验证和解析</td></tr><tr><td>Optimizer</td><td>查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有 where 条件时，优化器来决定先投影还是先过滤。</td></tr><tr><td>Cache 和 Buffer</td><td>查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存， 权限缓存等（查询缓存默认关闭）</td></tr></tbody></table><h3 id="1-1-3-引擎层"><a href="#1-1-3-引擎层" class="headerlink" title="1.1.3 引擎层"></a>1.1.3 引擎层</h3><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信，不同的存储引擎具有功能不同</p><table><thead><tr><th>对比项</th><th>MylSAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁（不适合高并发）</td><td>行锁（适合高并发操作）</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引，还缓存真实数据。对内存要求较高</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能</td><td>事务</td></tr><tr><td>默认安装</td><td>是</td><td>是</td></tr></tbody></table><ul><li>InnoDB的数据文件本身就是主索引文件。而MyISAM的主索引和数据是分开的。</li></ul><h3 id="1-1-4-存储层"><a href="#1-1-4-存储层" class="headerlink" title="1.1.4 存储层"></a>1.1.4 存储层</h3><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互</p><h2 id="1-2-查询流程"><a href="#1-2-查询流程" class="headerlink" title="1.2 查询流程"></a>1.2 查询流程</h2><p>mysql 的查询流程大致是：<br>    mysql 客户端通过协议与mysql 服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果，否则进行语句解析,也就是说，在解析查询之前，服务器会先访问查询缓存(query cache)——它存储SELECT 语句以及相应的查询结果集。如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。<br>    语法解析器和预处理：首先mysql 通过关键字将SQL 语句进行解析，并生成一颗对应的“解析树”。mysql 解析器将使用mysql 语法规则验证和解析查询；预处理器则根据一些mysql 规则进一步检查解析数是否合法。查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。。<br>    然后，mysql 默认使用的BTREE 索引，并且一个大致方向是:无论怎么折腾sql，至少在目前来说，mysql 最多只用到表中的一个索引。</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20210416095931829.png" alt="image-20210416095931829"></p><h2 id="1-3-SQL执行顺序"><a href="#1-3-SQL执行顺序" class="headerlink" title="1.3 SQL执行顺序"></a>1.3 SQL执行顺序</h2><h3 id="手写的顺序"><a href="#手写的顺序" class="headerlink" title="手写的顺序"></a>手写的顺序</h3><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/1.2.png"></p><h3 id="动态调整后执行顺序"><a href="#动态调整后执行顺序" class="headerlink" title="动态调整后执行顺序"></a>动态调整后执行顺序</h3><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/1.3.png"></p><p>整体顺序如下：</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/1.4.png"></p><h1 id="二、连接查询"><a href="#二、连接查询" class="headerlink" title="二、连接查询"></a>二、连接查询</h1><h2 id="2-1-概览"><a href="#2-1-概览" class="headerlink" title="2.1 概览"></a>2.1 概览</h2><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/2.1.png"></p><blockquote><p>最下面两种语句MySQL中不适用，改为分别左右查询之后进行union操作</p></blockquote><h2 id="2-2-实际操作"><a href="#2-2-实际操作" class="headerlink" title="2.2 实际操作"></a>2.2 实际操作</h2><h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t_dept` (<br>`id` INT(11) NOT NULL AUTO_INCREMENT, `deptName` VARCHAR(30) DEFAULT NULL, `address` VARCHAR(40) DEFAULT NULL, PRIMARY KEY (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br>CREATE TABLE `t_emp` (<br>`id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT NULL, `age` INT(3) DEFAULT NULL, `deptId` INT(11) DEFAULT NULL, empno INT NOT NULL, PRIMARY KEY (`id`), KEY `idx_dept_id` (`deptId`)<br>#CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;华山&#x27;,&#x27;华山&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;丐帮&#x27;,&#x27;洛阳&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;峨眉&#x27;,&#x27;峨眉山&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;武当&#x27;,&#x27;武当山&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;明教&#x27;,&#x27;光明顶&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;少林&#x27;,&#x27;少林寺&#x27;);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;风清扬&#x27;,90,1,100001);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;岳不群&#x27;,50,1,100002);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;令狐冲&#x27;,24,1,100003);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;洪七公&#x27;,70,2,100004);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;乔峰&#x27;,35,2,100005);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;灭绝师太&#x27;,70,3,100006);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;周芷若&#x27;,20,3,100007);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;张三丰&#x27;,100,4,100008);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;张无忌&#x27;,25,5,100009);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;韦小宝&#x27;,18,NULL,100010);<br></code></pre></td></tr></table></figure><h3 id="JOIN查询"><a href="#JOIN查询" class="headerlink" title="JOIN查询"></a>JOIN查询</h3><h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_dept, t_emp;<br></code></pre></td></tr></table></figure><p>t_dept共10条记录，t_emp共6条记录。两表共同查询后共60条记录</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/2.2.png"></p><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/2.3.png"></p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/2.4.png"></p><h4 id="左外连接取左表的独有部分（即，查询没有门派的人）"><a href="#左外连接取左表的独有部分（即，查询没有门派的人）" class="headerlink" title="左外连接取左表的独有部分（即，查询没有门派的人）"></a>左外连接<strong>取左表的独有部分</strong>（即，查询没有门派的人）</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/2.5.png"></p><h4 id="右外连接取右表的独有部分（即，查询没有人的门派）"><a href="#右外连接取右表的独有部分（即，查询没有人的门派）" class="headerlink" title="右外连接取右表的独有部分（即，查询没有人的门派）"></a>右外连接<strong>取右表的独有部分</strong>（即，查询没有人的门派）</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/2.6.png"></p><blockquote><p>注意：判断字段是否为NULL时，<strong>不能使用’=’</strong></p><p>因为<code>= NULL</code>的结果不会报错，但是<strong>结果永远为false</strong>。所以必须使用<code>IS NULL</code>来进行判空</p></blockquote><h4 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h4><blockquote><p>MySQL不支持全外连接，要查询两个表的全集，需要合并两个查询结果，所以要使用 <strong>UNION</strong> 关键字</p></blockquote><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/2.7.png"></p><h4 id="查询两表独有"><a href="#查询两表独有" class="headerlink" title="查询两表独有"></a>查询两表独有</h4><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/2.8.png"></p><h1 id="三、索引优化"><a href="#三、索引优化" class="headerlink" title="三、索引优化"></a>三、索引优化</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ul><li><p>MySQL 官方对索引的定义为：<strong>索引（Index）是帮助 MySQL 高效获取数据的数据结构</strong>。</p></li><li><p>索引的本质： <strong>索引是数据结构</strong>。可以简单理解为：<strong>排好序的快速查找数据结构</strong></p></li><li><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：</p></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/3.1.png"></p><ul><li>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用 二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录</li><li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</li></ul><h2 id="3-2-索引的数据结构"><a href="#3-2-索引的数据结构" class="headerlink" title="3.2 索引的数据结构"></a>3.2 索引的数据结构</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/3.2.png"></p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p><ul><li>模拟查找关键字29的过程：<ol><li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29</li></ol></li></ul><h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+Tree 索引"></a>B+Tree 索引</h3><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，<strong>InnoDB存储引擎就是用B+Tree实现其索引结构</strong>。</p><p>B-Tree每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在<strong>同一层的叶子节点</strong>上，而<strong>非叶子节点上只存储key值信息</strong>，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p>B+Tree相对于B-Tree有几点不同：</p><ol><li>非叶子节点只存储键值信息。</li><li>所有叶子节点之间都有一个链指针。</li><li>数据记录都存放在叶子节点中。</li></ol><p>由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/3.3.png"></p><p>通常在B+Tree上有两个头指针，<strong>一个指向根节点，另一个指向关键字最小的叶子节点</strong>，而且所有叶子节点（即数据节点）之间是一种<strong>链式环结构</strong>。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><p><strong>为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><ul><li>B+树的磁盘读写代价更低<ul><li>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了</li></ul></li><li>B+树的查询效率更加稳定<ul><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</li></ul></li></ul><h4 id="聚簇索引（聚集索引）"><a href="#聚簇索引（聚集索引）" class="headerlink" title="聚簇索引（聚集索引）"></a>聚簇索引（聚集索引）</h4><p>聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是<strong>整张表的行记录数据</strong>，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。</p><p>Innodb通过<strong>主键</strong>聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>优点<ul><li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul></li><li>缺点<ul><li>插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong></li></ul></li><li><strong>更新主键的代价很高</strong>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/3.4.png"></p><p><strong>与一般的B+树不同的是：叶子节点间的指针是双向的</strong></p><h4 id="辅助索引（非聚簇索引）"><a href="#辅助索引（非聚簇索引）" class="headerlink" title="辅助索引（非聚簇索引）"></a>辅助索引（非聚簇索引）</h4><p>在<strong>聚簇索引之上创建的索引称之为辅助索引</strong>，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。</p><p>Innodb辅助索引的叶子节点并<strong>不包含行记录的全部数据</strong>，叶子节点除了包含键值外，还包含了<strong>相应行数据的聚簇索引键</strong>。</p><p>辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在innodb中有时也称辅助索引为二级索引。</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/3.5.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/3.6.png"></p><p>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。</p><p><strong>回表查询</strong>：先根据非聚簇索引定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p><h2 id="3-3-索引的优缺点"><a href="#3-3-索引的优缺点" class="headerlink" title="3.3 索引的优缺点"></a>3.3 索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>提高数据检索的效率</strong>，降低数据库的IO成本</li><li>通过索引列对数据进行排序，<strong>降低数据排序的成本</strong>，降低了CPU的消耗</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>虽然索引大大提高了查询速度，同时却<strong>会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<strong>索引列也是要占用空间的</strong></li></ul><h2 id="3-4-索引的分类"><a href="#3-4-索引的分类" class="headerlink" title="3.4 索引的分类"></a>3.4 索引的分类</h2><h3 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h3><ul><li><p>定义：即一个索引只包含单个列，一个表可以有多个单列索引</p></li><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--和表一起创建<br>CREATE TABLE customer (<br>id INT(10) UNSIGNED AUTO_INCREMENT,<br>customer_no VARCHAR(200),<br>customer_name VARCHAR(200), <br>PRIMARY KEY(id), <br>KEY (customer_name) --单值索引<br>);<br><br>--单独创建单值索引<br>CREATE INDEX idx_customer_name ON customer(customer_name);<br></code></pre></td></tr></table></figure></li></ul><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul><li><p>定义：索引列的值必须唯一，但允许有空值</p></li><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--和表一起创建<br>CREATE TABLE customer (<br>id INT(10) UNSIGNED AUTO_INCREMENT,<br>customer_no VARCHAR(200),<br>customer_name VARCHAR(200), <br>PRIMARY KEY(id), <br>KEY (customer_name), --单值索引<br>UNIQUE (customer_no) --唯一索引<br>);<br><br>--单独创建唯一索引<br>CREATE UNIQUE INDEX idx_customer_no ON customer(customer_no);<br></code></pre></td></tr></table></figure></li></ul><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><ul><li><p>定义：设定为主键后数据库会<strong>自动建立索引</strong>，innodb为聚簇索引</p></li><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--和表一起创建<br>CREATE TABLE customer (<br>id INT(10) UNSIGNED AUTO_INCREMENT,<br>customer_no VARCHAR(200),<br>customer_name VARCHAR(200), <br>PRIMARY KEY(id) --主键索引<br>);<br><br>--单独创建主键索引<br>ALTER TABLE customer ADD PRIMARY KEY customer(customer_no);<br><br>--删除主键索引<br>ALTER TABLE customer DROP PRIMARY KEY;<br><br>--修改建主键索引<br>必须先删除掉(drop)原索引，再新建(add)索引<br></code></pre></td></tr></table></figure></li></ul><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><ul><li><p>定义：即一个索引包含多个列</p></li><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--和表一起创建<br>CREATE TABLE customer (<br>id INT(10) UNSIGNED AUTO_INCREMENT,<br>customer_no VARCHAR(200),<br>customer_name VARCHAR(200), <br>PRIMARY KEY(id), <br>KEY (customer_name), --单值索引<br>UNIQUE (customer_no), --唯一索引<br>KEY (customer_no,customer_name) --复合索引<br>);<br><br>--单独创建复合索引<br>CREATE INDEX idx_no_name ON customer(customer_no,customer_name);<br></code></pre></td></tr></table></figure></li></ul><p>从本质上来说，复合索引还是一棵B+树，不同的是复合索引的键值数量不是1，而是大于等于2，参考下图。另外，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，所以使用联合索引时遵循最左前缀集合。</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20210415162109613.png" alt="image-20210415162109613"></p><h2 id="3-5-索引的基本语法"><a href="#3-5-索引的基本语法" class="headerlink" title="3.5 索引的基本语法"></a>3.5 索引的基本语法</h2><ul><li><p>创建</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] <span class="hljs-keyword">INDEX</span> [indexName] <span class="hljs-keyword">ON</span> <span class="hljs-built_in">table_name</span>(<span class="hljs-keyword">column</span>);<br></code></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> [indexName] <span class="hljs-keyword">ON</span> <span class="hljs-built_in">table_name</span>;<br></code></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW INDEX FROM table_name;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-6-索引的使用场景"><a href="#3-6-索引的使用场景" class="headerlink" title="3.6 索引的使用场景"></a>3.6 索引的使用场景</h2><h3 id="适合索引的场景"><a href="#适合索引的场景" class="headerlink" title="适合索引的场景"></a>适合索引的场景</h3><ul><li>主键自动建立唯一索引</li><li>频繁作为<strong>查询条件</strong>的字段应该创建索引</li><li>查询中与其它表关联的字段，<strong>外键关系</strong>建立索引</li><li>单键/组合索引的选择问题，<strong>组合索引性价比更高</strong></li><li>查询中<strong>排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中<strong>统计</strong>或者<strong>分组</strong>字段</li></ul><h3 id="不适合索引的场景"><a href="#不适合索引的场景" class="headerlink" title="不适合索引的场景"></a>不适合索引的场景</h3><ul><li>表<strong>记录太少</strong>（有无索引差别不大）</li><li>经常<strong>增删改</strong>的表或者字段</li><li>Where 条件里用不到的字段不创建索引</li><li><strong>过滤性不好</strong>的不适合建索引（重复性较高，比如国籍、性别之类的字段）</li></ul><h2 id="3-7-索引重建"><a href="#3-7-索引重建" class="headerlink" title="3.7 索引重建"></a>3.7 索引重建</h2><h3 id="需要重建索引的时机"><a href="#需要重建索引的时机" class="headerlink" title="需要重建索引的时机"></a>需要重建索引的时机</h3><ol><li>表上频繁发生update,delete操作；</li><li>表上发生了alter table ..move操作（move操作导致了rowid变化）。</li></ol><h3 id="判断索引是否应该重建"><a href="#判断索引是否应该重建" class="headerlink" title="判断索引是否应该重建"></a>判断索引是否应该重建</h3><ol><li><p>一般看索引是否倾斜的严重，是否浪费了空间，对索引进行结构分析：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">analyze index index_name validate structure;<br></code></pre></td></tr></table></figure></li><li><p>在相同的session中查询index_stats表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> height,DEL_LF_ROWS<span class="hljs-operator">/</span>LF_ROWS <span class="hljs-keyword">from</span> index_stats;<br></code></pre></td></tr></table></figure><p>当查询的height&gt;=4（索引的深度，即从根到叶节点的高度）或DEL_LF_ROWS/LF_ROWS&gt;0.2的情况下，就应该考虑重建该索引。</p></li></ol><h3 id="重建索引的方式"><a href="#重建索引的方式" class="headerlink" title="重建索引的方式"></a>重建索引的方式</h3><ul><li><p>drop原索引，然后再创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> index index_name;<br><span class="hljs-keyword">create</span> index index_name <span class="hljs-keyword">on</span> table_name (index_column);<br></code></pre></td></tr></table></figure><p>这种方式相当耗时，一般不建议使用。</p></li><li><p>直接重建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> index indexname rebuild;<br><span class="hljs-keyword">alter</span> index indexname rebuild online;<br></code></pre></td></tr></table></figure><p>此方法较快，建议使用。</p></li></ul><p>rebuild是快速重建索引的一种有效的办法，因为它是一种<strong>使用现有索引项来重建新索引</strong>的方法。如果重建索引时有其他用户在对这个表操作，尽量使用带online参数来最大限度的减少索引重建时将会出现的任何加锁问题。由于新旧索引在建立时同时存在，因此，使用这种重建方法需要有额外的磁盘空间可供临时使用，当索引建完后把老索引删除，如果没有成功，也不会影响原来的索引。利用这种办法可以用来将一个索引移到新的表空间。</p><h3 id="rebuild重建索引的过程"><a href="#rebuild重建索引的过程" class="headerlink" title="rebuild重建索引的过程"></a>rebuild重建索引的过程</h3><ol><li>Rebuild以index fast full scan或table full scan方式（采用那种方式取决于cost）读取原索引中的数据来构建一个新的索引，重建过程中有排序操作，rebuild online执行表扫描获取数据，重建过程中有排序的操作；</li><li>Rebuild会阻塞DML操作，rebuild online不会阻塞DML操作；</li><li>rebuild online时系统会产生一个SYS_JOURNAL_xxx的IOT类型的系统临时日志表，所有rebuild online时索引的变化都记录在这个表中，<strong>当新的索引创建完成后，把这个表的记录维护到新的索引中去，然后drop掉旧的索引</strong>，rebuild online就完成了。</li></ol><h3 id="重建索引过程中的注意事项"><a href="#重建索引过程中的注意事项" class="headerlink" title="重建索引过程中的注意事项"></a>重建索引过程中的注意事项</h3><ol><li>执行rebuild操作时，需要检查表空间是否足够；</li><li>虽然说rebuild online操作允许DML操作，但还是建议在业务不繁忙时间段进行；</li><li>Rebuild操作会产生大量Redo Log；</li></ol><h2 id="3-8-MySQL的Hash索引和B树索引有什么区别"><a href="#3-8-MySQL的Hash索引和B树索引有什么区别" class="headerlink" title="3.8 MySQL的Hash索引和B树索引有什么区别"></a>3.8 MySQL的Hash索引和B树索引有什么区别</h2><p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树，对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。它们有以下的不同：</p><ul><li>hash索引进行等值查询更快(一般情况下)，但是却<strong>无法进行范围查询</strong>。因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</li><li>hash索引<strong>不支持使用索引进行排序</strong>，原理同上。</li><li>hash索引<strong>不支持模糊查询</strong>以及多列索引的最左前缀匹配，原理也是因为hash函数的不可预测。</li><li>hash索引任何时候都<strong>避免不了回表查询数据</strong>，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</li><li>hash索引虽然在等值查询上较快，但是<strong>不稳定，性能不可预测</strong>，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li></ul><p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p><h1 id="四、Explain-性能分析"><a href="#四、Explain-性能分析" class="headerlink" title="四、Explain 性能分析"></a>四、Explain 性能分析</h1><h2 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h2><p>使用 <strong>EXPLAIN</strong> 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理SQL 语句。<strong>分析</strong>查询语句或是表结构的<strong>性能瓶颈</strong></p><h2 id="4-2-用法"><a href="#4-2-用法" class="headerlink" title="4.2 用法"></a>4.2 用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--EXPLAIN + SQL语句，如：<br>EXPLAIN SELECT * FROM `Device`;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.1.png"></p><h2 id="4-3-表头字段介绍"><a href="#4-3-表头字段介绍" class="headerlink" title="4.3 表头字段介绍"></a>4.3 表头字段介绍</h2><h3 id="建表语句-1"><a href="#建表语句-1" class="headerlink" title="建表语句"></a>建表语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE t1(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));<br>CREATE TABLE t2(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));<br>CREATE TABLE t3(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));<br>CREATE TABLE t4(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));<br>INSERT INTO t1(content) VALUES(CONCAT(&#x27;t1_&#x27;,FLOOR(1+RAND()*1000)));<br>INSERT INTO t2(content) VALUES(CONCAT(&#x27;t2_&#x27;,FLOOR(1+RAND()*1000)));<br>INSERT INTO t3(content) VALUES(CONCAT(&#x27;t3_&#x27;,FLOOR(1+RAND()*1000)));<br>INSERT INTO t4(content) VALUES(CONCAT(&#x27;t4_&#x27;,FLOOR(1+RAND()*1000)));<br></code></pre></td></tr></table></figure><hr><h3 id="id：表的读取顺序"><a href="#id：表的读取顺序" class="headerlink" title="id：表的读取顺序"></a>id：表的读取顺序</h3><p>id是select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p><ul><li><p><strong>id相同</strong>：执行顺序为 <strong>从上至下执行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.id = t3.id;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.2.png"></p><blockquote><p>查询时，表的加载<strong>顺序为t1, t2, t3</strong></p></blockquote><ul><li><strong>id不同</strong>：执行顺序为 <strong>id大的先执行</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT t2.id FROM t2 WHERE t2.id = <br>(SELECT t1.id FROM t1 WHERE t1.id = (SELECT t3.id FROM t3));<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.3.png"></p><blockquote><p>查询时，表的加载<strong>顺序为t3, t1, t2</strong></p></blockquote><ul><li><strong>id相同又不同</strong>： 执行顺序为<ul><li>id不同时，值较大的先执行</li><li>id相同时，从上至下执行</li></ul></li></ul><p><strong>总结</strong></p><p>id 号每个号码，表示一趟独立的查询。一个sql 的查询趟数越少越好。</p><hr><h3 id="select-type：查询操作类型"><a href="#select-type：查询操作类型" class="headerlink" title="select_type：查询操作类型"></a>select_type：查询操作类型</h3><p>select_type代表<strong>查询的类型</strong>，主要是用于区别<strong>普通查询、联合查询、子查询等</strong>的复杂查询</p><table><thead><tr><th>select_type 属性</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的 select 查询,查询中<strong>不包含子查询或者 UNION</strong></td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子部分，<strong>最外层</strong>查询则被标记为 Primary</td></tr><tr><td>DERIVED</td><td>在 FROM 列表中包含的子查询被标记为 DERIVED(衍生)， MySQL 会递归执行这些子查询, 把结果放在临时表里</td></tr><tr><td>SUBQUERY</td><td>在SELECT或WHERE列表中包含了<strong>子查询</strong></td></tr><tr><td>DEPEDENT SUBQUERY</td><td>在SELECT或WHERE列表中包含了子查询,<strong>子查询基于外层</strong></td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td><strong>无法使用缓存</strong>的子查询</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表<strong>获取结果</strong>的SELECT</td></tr></tbody></table><ul><li><p>SUBQUERY 和 DEPEDENT SUBQUERY</p></li><li><p>都是 WHERE 后面的条件，SUBQUERY 是单个值（=），DEPEDENT SUBQUERY 是一组值（IN）</p></li><li><p>UNCACHEABLE SUBQUERY</p><ul><li><p>当使用了**@@来引用系统变量**的时候，不会使用缓存</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.4.png"></p></li></ul></li><li><p>UNION 和 UNION RESULT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t1 a LEFT JOIN  t2 b ON a.id = b.id WHERE b.id IS NULL<br>UNION<br>SELECT * FROM t2 a RIGHT JOIN  t3 b ON a.id = b.id WHERE a.id IS NULL;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.5.png"></p></li></ul><hr><h3 id="table：表的来源"><a href="#table：表的来源" class="headerlink" title="table：表的来源"></a>table：表的来源</h3><p>table表示这个数据是基于哪张表的</p><hr><h3 id="type：访问类型"><a href="#type：访问类型" class="headerlink" title="type：访问类型"></a>type：访问类型</h3><p>type 是查询的访问类型。<strong>是较为重要的一个指标</strong>，结果值从最好到最坏依次是：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">all</span><br><br><span class="hljs-comment">--常见的顺序为</span><br><span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><p>一般来说，得保证查询<strong>至少达到 range 级别</strong>，最好能达到 ref</p><table><thead><tr><th>类型名</th><th>含义</th></tr></thead><tbody><tr><td>SYSTEM</td><td>表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也<strong>可以忽略不计</strong></td></tr><tr><td>CONST</td><td>表示<strong>通过索引一次就找到了</strong>,const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量</td></tr><tr><td>EQ_REF</td><td>唯一性索引扫描，对于每个索引键，<strong>表中只有一条记录与之匹配</strong>。常见于主键或唯一索引扫描</td></tr><tr><td>REF</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。<strong>本质上也是一种索引访问</strong>，它返回所有匹配某个单独值的行， 然而，它<strong>可能会找到多个符合条件的行</strong>，所以他应该属于查找和扫描的混合体</td></tr><tr><td>RANGE</td><td>只检索给定<strong>范围</strong>的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在 where 语句中出现 了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而 结束语另一点，不用扫描全部索引</td></tr><tr><td>INDEX</td><td>出现index是sql使用了索引但是<strong>没用通过索引进行过滤</strong>，一般是使用了<strong>覆盖索引</strong>或者是利用索引进行了<strong>排序分组</strong></td></tr><tr><td>ALL</td><td>Full Table Scan，将遍历全表以找到匹配的行</td></tr></tbody></table><ul><li><strong>CONST</strong></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.6.png"></p><ul><li><strong>EQ_REF</strong></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.7.png"></p><ul><li><strong>REF</strong></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.8.png"></p><ul><li><strong>range</strong></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.9.png"></p><ul><li><strong>index</strong></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.10.png"></p><ul><li><strong>all</strong></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.11.png"></p><hr><h3 id="possible-key：可能用到的索引"><a href="#possible-key：可能用到的索引" class="headerlink" title="possible_key：可能用到的索引"></a>possible_key：可能用到的索引</h3><p>显示<strong>可能</strong>应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但<strong>不一定被查询实际使用</strong></p><hr><h3 id="key：实际使用的索引"><a href="#key：实际使用的索引" class="headerlink" title="key：实际使用的索引"></a>key：实际使用的索引</h3><p><strong>实际使用的索引</strong>。如果为NULL，则没有使用索引</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>当查找的字段与建立的索引的匹配（查询的字段都是索引，但不需要全是索引）时，会发生覆盖索引。MySQL推测使用的索引为NULL，而实际上会使用索引</p><p>有以下两种解释</p><ul><li>select的数据列<strong>只用从索引中就能够取得</strong>，不必从数据表中读取，换句话说<strong>查询列要被所使用的索引覆盖</strong></li><li>索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引</li></ul><p>注意：要使用覆盖索引，则<strong>只取出需要的列</strong>（被令为索引），<strong>不要</strong>使用 SELECT *</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.12.png"></p><hr><h3 id="key-len：索引使用字节数"><a href="#key-len：索引使用字节数" class="headerlink" title="key_len：索引使用字节数"></a>key_len：索引使用字节数</h3><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 key_len 字段能够帮你检查是否充分的利用上了索引</p><blockquote><p>ken_len 越长，说明索引使用的越充分</p></blockquote><hr><h3 id="ref：显示被使用的索引的具体信息"><a href="#ref：显示被使用的索引的具体信息" class="headerlink" title="ref：显示被使用的索引的具体信息"></a>ref：显示被使用的索引的具体信息</h3><p>ref显示索引的哪一列被使用了，如果可能的话，可以是一个常数。哪些列或常量被用于查找索引列上的值</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.13.png"></p><hr><h3 id="rows：被查询的行数"><a href="#rows：被查询的行数" class="headerlink" title="rows：被查询的行数"></a>rows：被查询的行数</h3><p>rows 列显示 MySQL 认为它执行查询时必须检查的行数。<strong>越少越好！</strong></p><hr><h3 id="Extra：额外重要信息"><a href="#Extra：额外重要信息" class="headerlink" title="Extra：额外重要信息"></a>Extra：额外重要信息</h3><p>其他的额外<strong>重要</strong>的信息</p><ul><li><strong>Using filesort</strong>：使用外部索引排序（未使用用户创建的索引）<ul><li>说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引 完成的排序操作称为“文件排序”</li><li>出现 Using filesort <strong>说明SQL语句设计的不好</strong>，<strong>没有按照创建的索引进行排序</strong>，或者<strong>未按照索引指定的顺序进行排序</strong></li></ul></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.14.png"></p><ul><li><strong>Using temporary</strong><ul><li>使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。<strong>常见于排序 order by 和分组查询 group by</strong></li><li>出现 Using temporary <strong>说明SQL语句设计的非常不好</strong>，可能是因为没有按照顺序使用复合索引</li></ul></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.15.png"></p><blockquote><p>如果创建了<strong>复合索引</strong>，一定要<strong>按照复合索引的顺序来使用</strong>（包括查找，排序），否则会使得性能大幅下降</p></blockquote><ul><li><strong>Using index</strong><ul><li>Using index 代表表示相应的 select 操作中使用了<strong>覆盖索引</strong>(Covering Index)，避免访问了表的数据行，<strong>比较高效</strong></li><li>如果同时出现 using where，表明<strong>索引被用来执行索引键值的查找</strong></li><li>如果没有同时出现 using where，表明<strong>索引只是用来读取数据</strong>而非利用索引执行查找。</li></ul></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/4.16.png"></p><ul><li>Using where<ul><li>表明使用了 where 过滤</li></ul></li><li>Using join buffer<ul><li>使用了连接缓存</li></ul></li><li>impossible where<ul><li>where 子句的值总是 false，不能用来获取任何元组</li></ul></li><li>select tables optimized away<ul><li>在没有 GROUP BY 子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*)操 作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li></ul></li></ul><h1 id="五、单表查询优化"><a href="#五、单表查询优化" class="headerlink" title="五、单表查询优化"></a>五、单表查询优化</h1><blockquote><p>使用第二章建的表</p></blockquote><h2 id="全值匹配我最爱"><a href="#全值匹配我最爱" class="headerlink" title="全值匹配我最爱"></a>全值匹配我最爱</h2><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#建立符合索引（age, deptId, name）<br>CREATE INDEX idx_emp_ade ON t_emp(age, deptId, NAME);<br><br>#查找<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90;<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1;<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1 AND name = &#x27;风清扬&#x27;;<br><br>#和上一条SQL语句中WHERE后字段的顺序不同，但是不影响查询结果<br>EXPLAIN SELECT empno FROM t_emp WHERE deptId = 1 AND name = &#x27;风清扬&#x27; AND age = 90;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/5.1.png"></p><p>可以看到，<strong>复合索引都被用到了，并且SQL中查询字段的顺序，跟使用索引中字段的顺序，没有关系</strong>。优化器会在不影响 SQL 执行结果的前提下，自动地优化</p><p><strong>结论：全值匹配我最爱指的是，查询的字段按照顺序在索引中都可以匹配到</strong></p><h2 id="最佳左前缀法则"><a href="#最佳左前缀法则" class="headerlink" title="最佳左前缀法则"></a>最佳左前缀法则</h2><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询，未按照最佳左前缀法则<br>EXPLAIN SELECT empno FROM t_emp WHERE name = &#x27;风清扬&#x27;;<br><br>#查询，部分按照最佳左前缀法则（age字段和复合索引匹配，但name没有）<br>EXPLAIN SELECT empno FROM t_emp WHERE  age = 90 AND name = &#x27;风清扬&#x27;;<br><br>#查询，完全按照最佳左前缀法则<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1;<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1 AND name = &#x27;风清扬&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/5.2.png"></p><p>可以看到，查询<strong>字段与索引字段顺序的不同会导致，索引无法充分使用，甚至索引失效</strong></p><p><strong>原因</strong>：使用复合索引，需要<strong>遵循最佳左前缀法则</strong>，即如果索引了多列，要遵守最左前缀法则。指的是查询从索引的<strong>最左前列开始并且不跳过索引中的列</strong></p><p><strong>结论：过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong></p><h2 id="索引列上不计算"><a href="#索引列上不计算" class="headerlink" title="索引列上不计算"></a>索引列上不计算</h2><p>不在索引列上做任何操作（计算、函数、(自动 or 手动)类型转换），<strong>可能会导致索引失效而转向全表扫描</strong></p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#直接查询<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND NAME = &#x27;风清扬&#x27;;<br><br>#使用MySQL函数查询<br>EXPLAIN SELECT empno FROM t_emp WHERE LEFT(age,2) = 90 AND name = &#x27;风清扬&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/5.3.png"></p><p>可以看出，当age字段使用了left函数以后，<strong>导致索引完全失效</strong></p><p><strong>结论：等号左边无计算</strong></p><h2 id="范围之后全失效"><a href="#范围之后全失效" class="headerlink" title="范围之后全失效"></a>范围之后全失效</h2><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#范围查询<br>EXPLAIN SELECT empno FROM t_emp WHERE age &gt; 50 AND deptId = 1 AND name = &#x27;风清扬&#x27;;<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 50 AND deptId &gt; 1 AND NAME = &#x27;风清扬&#x27;;<br><br>#未使用范围查询<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 50 AND deptId = 1 AND name = &#x27;风清扬&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/5.4.png"></p><p>可以看出，当对age字段使用范围查询后，使得范围后面的索引失效了</p><p><strong>建议：</strong>将可能做范围查询的字段的索引顺序<strong>放在最后</strong></p><p><strong>结论：使用范围查询后，如果范围内的记录过多，会导致索引失效</strong>，因为从自定义索引映射到主键索引需要耗费太多的时间，反而不如全表扫描来得快</p><h2 id="覆盖索引多使用"><a href="#覆盖索引多使用" class="headerlink" title="覆盖索引多使用"></a>覆盖索引多使用</h2><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询索引字段<br>EXPLAIN SELECT content FROM t2;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/5.5.png"></p><p><strong>结论：使用覆盖索引（Using index）会提高检索效率</strong></p><h2 id="使用不等会失效"><a href="#使用不等会失效" class="headerlink" title="使用不等会失效"></a>使用不等会失效</h2><p>在使用<strong>不等于(!= 或者&lt;&gt;)时</strong>，有时会无法使用索引会导致全表扫描</p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#SQL语句中有不等于<br>EXPLAIN SELECT * FROM t_emp WHERE age != 90;<br>EXPLAIN SELECT * FROM t_emp WHERE age &lt;&gt; 90;<br><br>#SQL语句中没有不等于<br>EXPLAIN SELECT * FROM t_emp WHERE age = 90;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/5.6.png"></p><p><strong>结论：尽量不要使用不等于</strong></p><h2 id="使用NULL值要小心"><a href="#使用NULL值要小心" class="headerlink" title="使用NULL值要小心"></a>使用NULL值要小心</h2><p>在使用<code>IS NULL</code>或者<code>IS NOT NULL</code>时，可能会导致索引失效，但是如果<strong>允许字段为空</strong>，则</p><ul><li>IS NULL 不会导致索引失效</li><li>IS NOT NULL 会导致索引失效</li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/5.7.png"></p><h2 id="模糊查询加右边"><a href="#模糊查询加右边" class="headerlink" title="模糊查询加右边"></a>模糊查询加右边</h2><p>要使用模糊查询时，<strong>百分号最好加在右边，而且进行模糊查询的字段必须是单值索引</strong></p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建单值索引<br>CREATE INDEX idx_emp_name ON t_emp(NAME);<br><br>#进行模糊查询<br>EXPLAIN SELECT * FROM t_emp WHERE name LIKE &#x27;%风&#x27;;<br>EXPLAIN SELECT * FROM t_emp WHERE name LIKE &#x27;风%&#x27;;<br>EXPLAIN SELECT * FROM t_emp WHERE name LIKE &#x27;%风%&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/5.8.png"></p><p><strong>结论：对索引进行模糊查询时，最好在右边加百分号。必须在左边或左右加百分号时，需要用到覆盖索引来提升查询效率</strong></p><p>可以加入冗余列（MySQL5.7之后加入了虚拟列，使用虚拟列更合适，思路相同），比如 mobile_reverse，内部存储为 mobile 的倒叙文本，如 mobile为17312345678，那么 mobile_reverse 存储 87654321371，为 mobile_reverse 列建立索引，查询中使用语句 mobile_reverse like reverse(’%5678’) 即可。</p><p>reverse 是 MySQL 中的反转函数，这条语句相当于 mobile_reverse like ‘8765%’ ，这种语句是可以使用索引的。</p><h2 id="字符串加单引号"><a href="#字符串加单引号" class="headerlink" title="字符串加单引号"></a>字符串加单引号</h2><p>当字段为字符串时，查询时必须带上单引号。否则<strong>会发生自动的类型转换</strong>，从而发生全表扫描</p><h2 id="尽量不用or查询"><a href="#尽量不用or查询" class="headerlink" title="尽量不用or查询"></a>尽量不用or查询</h2><p>如果使用or，可能导致索引失效。所以要减少or的使用，可以<strong>使用 union all 或者 union 来替代：</strong></p><p><strong>查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引</strong>时，查询中才使用索引。否则，查询将不使用索引。</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/5.9.png"></p><h2 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h2><p>全值匹配我最爱，最左前缀要遵守</p><p>带头大哥不能死，中间兄弟不能断</p><p>索引列上少计算，范围之后全失效</p><p>LIKE 百分写最右，覆盖索引不写*</p><p>不等空值还有 OR，索引影响要注意</p><p>VARCHAR 引号不可丢，SQL 优化有诀窍</p><hr><h1 id="六、关联查询优化"><a href="#六、关联查询优化" class="headerlink" title="六、关联查询优化"></a>六、关联查询优化</h1><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#删除存储过程<br>DROP PROCEDURE insert_deviceCondition ;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#新建存储过程<br><br>#将结尾符号改成$$<br>DELIMITER $$<br>CREATE PROCEDURE creat_class_book()<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>CREATE TABLE IF NOT EXISTS `class` (<br>`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, `card` INT(10) UNSIGNED NOT NULL, PRIMARY KEY (`id`)<br>);<br>CREATE TABLE IF NOT EXISTS `book` (<br>`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, `card` INT(10) UNSIGNED NOT NULL, PRIMARY KEY (`bookid`)<br>);<br><br># 把autocommit 设置成0<br>SET autocommit = 0;<br>REPEAT<br>SET i = i + 1;<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>UNTIL i = 20<br>END REPEAT;<br>COMMIT;<br>END$$<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#执行存储过程<br>DELIMITER ;<br>CALL creat_class_book();<br></code></pre></td></tr></table></figure><h2 id="6-1-LEFT-JOIN优化"><a href="#6-1-LEFT-JOIN优化" class="headerlink" title="6.1 LEFT JOIN优化"></a>6.1 LEFT JOIN优化</h2><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#--未建立索引时的左外连接查询<br>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;<br><br>#左表（class）建立索引<br>CREATE INDEX idx_class_card ON class(card);<br><br>#再次执行查询<br>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;<br><br>#去掉左表索引<br>DROP INDEX idx_class_card ON class;<br><br>#右表建立索引<br>CREATE INDEX idx_book_card ON book(card);<br><br>#再次执行查询<br>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/6.1.png"></p><p><strong>结论</strong></p><ul><li>在优化关联查询时，只有在<strong>被驱动表上建立索引才有效</strong></li><li>left join 时，左侧的为驱动表，<strong>右侧为被驱动表</strong></li></ul><h2 id="6-2-INNER-JOIN优化"><a href="#6-2-INNER-JOIN优化" class="headerlink" title="6.2 INNER JOIN优化"></a>6.2 INNER JOIN优化</h2><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询操作，目前索引在book表的card上，class表和book表的位置不会改变查询结果<br>EXPLAIN SELECT * FROM class INNER JOIN book ON class.card = book.card;<br>EXPLAIN SELECT * FROM book INNER JOIN class ON book.card = class.card;<br><br>#删除book表中的几条记录<br>DELETE FROM book WHERE bookid&lt;10;<br><br>#再次查询<br>EXPLAIN SELECT * FROM class INNER JOIN book ON class.card = book.card;<br><br>#删除book表card字段索引，给class表的card字段添加索引<br>DROP INDEX idx_book_card ON book;<br>CREATE INDEX idx_class_card ON class(card);<br><br>#再次查询<br>EXPLAIN SELECT * FROM class INNER JOIN book ON class.card = book.card;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/6.2.png"></p><p><strong>结论</strong>：inner join 时，<strong>mysql 会把小结果集的表选为驱动表</strong>（小表驱动大表）</p><p><strong>所以最好把索引建立在大表（数据较多的表）上</strong></p><h2 id="6-3-RIGHT-JOIN优化"><a href="#6-3-RIGHT-JOIN优化" class="headerlink" title="6.3 RIGHT JOIN优化"></a>6.3 RIGHT JOIN优化</h2><p>优化类型和LEFT JOIN类似，只不过<strong>被驱动表变成了左表</strong></p><h1 id="七、子查询优化"><a href="#七、子查询优化" class="headerlink" title="七、子查询优化"></a>七、子查询优化</h1><ul><li><strong>结论</strong>： 在范围判断时，<strong>尽量不要使用not in 和not exists</strong>，使用left join on xxx is null 代替。</li></ul><p>NOT IN、NOT EXISTS导致索引失效</p><h1 id="八、排序分组优化"><a href="#八、排序分组优化" class="headerlink" title="八、排序分组优化"></a>八、排序分组优化</h1><p>在查询中难免会对查询结果进行排序操作。进行排序操作时要<strong>避免出现 Using filesort</strong>，应使用索引给排序带来的方便</p><p><strong>索引信息</strong></p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/8.1.png"></p><h2 id="8-1-ORDER-BY-优化"><a href="#8-1-ORDER-BY-优化" class="headerlink" title="8.1 ORDER BY 优化"></a>8.1 ORDER BY 优化</h2><p>以下查询都是在<strong>索引覆盖</strong>的条件下进行的</p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#不满足索引覆盖时进行排序查询<br>EXPLAIN SELECT empno FROM t_emp  WHERE age &gt; 50 ORDER BY age, deptId;<br><br>#按照复合索引顺序进行排序<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age;<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age, deptId;<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age, deptId, name;<br><br>#不按照复合索引顺序进行排序（无 age 字段），发生Using filesort<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY deptId, name;<br><br>#不按照复合索引顺序进行排序（索引顺序打乱），发生Using filesort<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY deptId, name, age;<br><br>#排序时部分(age)升序，部分(deptId)降序，发生Using filesort<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age ASC, deptId DESC;<br><br>#排序时都为降序<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age DESC, deptId DESC;<br><br>#排序时，在前面的字段为常量时（非范围）<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age = 50 ORDER BY deptId, name;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/8.2.png"></p><p><strong>结论</strong>：</p><p>要想在排序时使用索引，避免 Using filesort，首先需要发生<strong>索引覆盖</strong>，其次</p><ul><li>ORDER BY 后面字段的顺序要和复合索引的<strong>顺序完全一致</strong></li><li>ORDER BY 后面的索引必须按照顺序出现，<strong>排在后面的可以不出现</strong></li><li>要进行升序或者降序时，<strong>字段的排序顺序必须一致</strong>。不能一部分升序，一部分降序，可以都升序或者都降序</li><li>如果复合索引前面的<strong>字段作为常量</strong>出现在过滤条件中，<strong>排序字段可以为紧跟其后的字段</strong></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/8.3.png"></p><h2 id="8-2-MySQL的排序算法"><a href="#8-2-MySQL的排序算法" class="headerlink" title="8.2 MySQL的排序算法"></a>8.2 MySQL的排序算法</h2><p>当发生 Using filesort 时，MySQL会根据自己的算法对查询结果进行排序</p><ul><li>双路排序<ul><li>MySQL 4.1 之前是使用双路排序,字面意思就是<strong>两次扫描磁盘</strong>，最终得到数据，读取<strong>行指针和 order by 列</strong>，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段</li><li>简单来说，<strong>取一批数据，要对磁盘进行了两次扫描</strong>，众所周知，I\O 是很耗时的，所以在 mysql4.1 之后，出现了第二种改进的算法，就是单路排序</li></ul></li><li>单路排序<ul><li>从磁盘读取查询需要的<strong>所有列</strong>，按照 order by 列<strong>在 buffer 对它们进行排序</strong>，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO,但是它会使用更多的空间， 因为它把每一行都保存在内存中了</li><li><strong>存在的问题</strong>：在 sort_buffer 中，方法 B 比方法 A 要多占用很多空间，因为方法 B 是把所有字段都取出, 所以有可能<strong>取出的数据的总大小超出了 sort_buffer 的容量</strong>，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 tmp 文件，多 路合并），排完再取取 sort_buffer 容量大小，再排……从而多次 I/O。也就是<strong>本来想省一次 I/O 操作，反而导致了大量的 I/O 操作，反而得不偿失</strong></li></ul></li><li>优化Using filesort<ul><li>增大 sort_butter_size 参数的设置<ul><li>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对<strong>每个进程的 1M-8M 之间调整</strong></li></ul></li><li>增大 max_length_for_sort_data 参数的设置<ul><li>mysql 使用单路排序的前提是<strong>排序的字段大小要小于 max_length_for_sort_data</strong></li><li>提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大， 明显症状是高的磁盘 I/O 活动和低的处理器使用率。（1024-8192 之间调整）</li></ul></li><li>减少 select 后面的查询的字段<ul><li>查询的字段减少了，缓冲里就能容纳更多的内容了，<strong>间接增大了sort_buffer_size</strong></li></ul></li></ul></li></ul><h2 id="8-3-GROUP-BY-优化"><a href="#8-3-GROUP-BY-优化" class="headerlink" title="8.3 GROUP BY 优化"></a>8.3 GROUP BY 优化</h2><p>优化方式和 ORDER BY 类似，参考ORDER BY 的优化方式即可</p><h3 id="WHERE和HAVING的区别"><a href="#WHERE和HAVING的区别" class="headerlink" title="WHERE和HAVING的区别"></a>WHERE和HAVING的区别</h3><ul><li><p>WHERE是一个约束声明，使用WHERE约束来自数据库的数据，WHERE是在结果返回之前起作用的，WHERE中不能使用聚合函数。</p></li><li><p>HAVING是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在HAVING中可以使用聚合函数。另一方面，HAVING子句中不能使用除了分组字段和聚合函数之外的其他字段。</p></li></ul><p>从性能的角度来说，HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。</p><h2 id="8-4-Limit-分页优化"><a href="#8-4-Limit-分页优化" class="headerlink" title="8.4 Limit 分页优化"></a>8.4 Limit 分页优化</h2><p>在偏移量非常大的时候，例如 <code>LIMIT 10000,20</code> 这样的查询，这时MySQL需要查询10020条记录然后只返回最后20条，前面的10000条记录都将被抛弃，这样的代价是非常高的。如果所有的页面被访问的频率都相同，那么这样的查询平均需要访问半个表的数据。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。</p><p>例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> film_id,description <span class="hljs-keyword">FROM</span> sakila.film <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> title LIMIT <span class="hljs-number">50</span>,<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><ul><li>优化此类分页查询的一个最简单的办法就是尽可能地使用<strong>索引覆盖</strong>扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候，这样做的效率会提升非常大。考虑下面的查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> film.film_id,film.description <br><span class="hljs-keyword">FROM</span> sakila.film<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<br>    <span class="hljs-keyword">SELECT</span> film_id <span class="hljs-keyword">FROM</span> sakila.film <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> title LIMIT <span class="hljs-number">50</span>,<span class="hljs-number">5</span><br>) <span class="hljs-keyword">AS</span> lim <span class="hljs-keyword">USING</span>(film_id);<br></code></pre></td></tr></table></figure><ul><li>有时候也可以将LIMIT查询转换为已知位置的查询，让MySQL通过范围扫描获得对应的结果。例如，如果在一个位置列上有索引，并且预先计算出了边界值，上面的查询就可以改写为：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> film_id,description <span class="hljs-keyword">FROM</span> skila.film<br><span class="hljs-keyword">WHERE</span> position <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">54</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> position;<br></code></pre></td></tr></table></figure><ul><li>LIMIT和OFFSET的问题，其实是OFFSET的问题，它会导致MySQL扫描大量不需要的行然后再抛弃掉。如果可以使用书签记录上次取数的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET。</li></ul><h1 id="九、截取查询分析"><a href="#九、截取查询分析" class="headerlink" title="九、截取查询分析"></a>九、截取查询分析</h1><h2 id="9-1-慢日志查询"><a href="#9-1-慢日志查询" class="headerlink" title="9.1 慢日志查询"></a>9.1 慢日志查询</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>MySQL的慢查询日志是MySQL提供的一种日志记录，<strong>它用来记录在MySQL中响应时间超过阈值的语句</strong>，具体指运行时间超过<strong>long_query_time</strong>值的SQL，则会被记录到慢查询日志中</li><li>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为 10，意思是运行10秒以上的语句</li><li>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>默认情况下，MySQL 数据库没有开启慢查询日志，需要我们<strong>手动</strong>来设置这个参数</p><p>如果不是调优需要的话，<strong>一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。 慢查询日志支持将日志记录写入文件</p><table><thead><tr><th>SQL 语句</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>SHOW VARIABLES LIKE ‘’%slow_query_log%’</td><td>查看慢查询日志是否开启</td><td>默认情况下 slow_query_log 的值为 OFF</td></tr><tr><td>set global slow_query_log=1</td><td>开启慢查询日志</td><td></td></tr><tr><td>SHOW VARIABLES LIKE ‘long_query_time%’</td><td>查看慢查询设定阈值</td><td>单位：秒</td></tr><tr><td>set long_query_time=1</td><td>设定慢查询阈值</td><td>单位：秒</td></tr></tbody></table><p>如永久生效需要修改配置文件my.cnf 中[mysqld]下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[mysqld]<br>slow_query_log=1<br>slow_query_log_file=/var/lib/mysql/atguigu-slow.log<br>long_query_time=3<br>log_output=FILE<br></code></pre></td></tr></table></figure><p>运行查询时间长的 sql，<strong>可以打开慢查询日志查看</strong></p><h2 id="9-2-SHOW-PROFILE分析"><a href="#9-2-SHOW-PROFILE分析" class="headerlink" title="9.2 SHOW PROFILE分析"></a>9.2 SHOW PROFILE分析</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>在MySQL数据库中，可以通过配置profiling参数来启用SQL剖析。该参数可以在全局和session级别来设置。对于全局级别则作用于整个MySQL实例，而session级别紧影响当前session。该参数开启后，后续<strong>执行的SQL语句都将记录其资源开销，诸如IO，上下文切换，CPU，Memory</strong>等等</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>默认情况下，MySQL 数据库没有开启PROFILE，需要我们<strong>手动</strong>来设置这个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查看profile状态<br>SHOW VARIABLES LIKE &#x27;profiling&#x27;;<br><br>#开启profile<br>set profiling = 1;<br><br>#运行要分析的SQL之后<br><br>#查看记录<br>SHOW PROFILES;<br><br>#诊断SQL<br>SHOW PROFILE CPU，BLOG IO FOR QUERT 190 #数字对应QUERYID<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/9.1.png"></p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/9.2.png"></p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/9.3.png"></p><h3 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">type</span>:  <br>    <span class="hljs-keyword">ALL</span>                <span class="hljs-comment">--显示所有的开销信息  </span><br>  | <span class="hljs-keyword">BLOCK</span> IO           <span class="hljs-comment">--显示块IO相关开销  </span><br>  | <span class="hljs-keyword">CONTEXT</span> SWITCHES   <span class="hljs-comment">--上下文切换相关开销  </span><br>  | CPU                <span class="hljs-comment">--显示CPU相关开销信息  </span><br>  | IPC                <span class="hljs-comment">--显示发送和接收相关开销信息  </span><br>  | MEMORY             <span class="hljs-comment">--显示内存相关开销信息  </span><br>  | PAGE FAULTS        <span class="hljs-comment">--显示页面错误相关开销信息  </span><br>  | SOURCE             <span class="hljs-comment">--显示和Source_function，Source_file，Source_line相关的开销信息  </span><br>  | SWAPS              <span class="hljs-comment">--显示交换次数相关开销的信息 </span><br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>需要注意如下几点</p><ul><li>converting HEAP to MyISAM：查询结果太大，内存不够用往磁盘上搬了</li><li>Creating tmp table：创建临时表</li><li>Copying to temp table on disk：把内存中的临时表复制到磁盘</li></ul><h1 id="十、MySQL锁机制"><a href="#十、MySQL锁机制" class="headerlink" title="十、MySQL锁机制"></a>十、MySQL锁机制</h1><h2 id="10-1-表锁"><a href="#10-1-表锁" class="headerlink" title="10.1 表锁"></a>10.1 表锁</h2><p><strong>MylSAM引擎使用表锁，并且不支持事务</strong></p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#展示表是否加锁<br>SHOW OPEN TABLES;<br><br>#加锁 read (读锁) write (写锁)<br>LOCK TABLE table1 read(write), table2 read(write)...<br><br>#全部解锁<br>UNLOCK TABLES;<br></code></pre></td></tr></table></figure><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><ul><li>主机A给表加上<strong>表锁（读锁）</strong>以后<ul><li>主机A和其他主机都可以读取<strong>该表</strong>的信息</li><li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中所有表的信息</li><li>如果要修改被锁表的信息<ul><li>主机A如果对表进行修改，<strong>会修改失败</strong></li><li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li></ul></li></ul></li></ul><p><strong>演示</strong></p><ul><li><p>给t_dept表加锁并查询状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LOCK TABLE t_dept READ;<br><br>SHOW OPEN TABLES;<br></code></pre></td></tr></table></figure></li></ul><p><strong>读取</strong></p><ul><li><p>客户端A（加锁端）A<strong>读取其他表</strong>信息，<strong>读取失败</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp;<br></code></pre></td></tr></table></figure></li><li><p>其他客户端读取度其他表信息，读取成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/10.1.png"></p><p><strong>修改</strong></p><ul><li><p>客户端A对表中内容进行修改，<strong>修改失败</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE  t_dept SET address = &#x27;紫禁之巅&#x27; WHERE id = 1;<br></code></pre></td></tr></table></figure></li><li><p>客户端B对表中内容进行修改，进入阻塞状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM dept WHERE id = 1;<br></code></pre></td></tr></table></figure></li><li><p>客户端A解锁后，客户端B修改成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UNLOCK TABLES;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/10.2.png"></p><hr><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>主机A给表加上<strong>表锁（写锁）</strong>以后</p><ul><li>主机A可以读取该表信息，但<strong>其他主机读取时，会进入阻塞状态，直到读锁被释放</strong></li><li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中<strong>除该表以外所有表</strong>的信息</li><li>如果要修改被锁表的信息<ul><li>主机A如果对表进行修改，修改成功</li><li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li></ul></li></ul><p><strong>演示</strong></p><ul><li><p>给t_dept表加上写锁并查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LOCK TABLE t_dept WRITE;<br><br>SHOW OPEN TABLES;<br></code></pre></td></tr></table></figure></li></ul><p><strong>读取</strong></p><ul><li><p>客户端A查询该表内容，查询成功；读取其他表，读取失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_dept;<br><br>SELECT * FROM t_emp;<br></code></pre></td></tr></table></figure></li><li><p>其他客户端读取该表信息，进入阻塞状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_dept;<br></code></pre></td></tr></table></figure></li><li><p>客户端A解锁后，客户端B读取成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UNLOCK TABLES;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/10.3.png"></p><p><strong>修改</strong></p><ul><li><p>给t_dept表加上写锁<code>LOCK TABLE t_dept WRITE;</code></p></li><li><p>客户端A修改<strong>该表</strong>内容，修改成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE  t_dept SET address = &#x27;华山&#x27; WHERE id = 1;<br></code></pre></td></tr></table></figure></li><li><p>客户端A修改<strong>其他表</strong>内容，修改失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM t_emp WHERE id = 2;<br></code></pre></td></tr></table></figure></li><li><p>其他客户端修改<strong>该表</strong>内容，进入阻塞状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE  t_dept SET address = &#x27;华山333&#x27; WHERE id = 1;<br></code></pre></td></tr></table></figure></li><li><p>客户端A解锁后，客户端B修改成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UNLOCK TABLES;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/10.4.png"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>读锁不会阻塞读，只会阻塞写。但是写锁会阻塞读和写。</strong></p><h2 id="10-2-行锁"><a href="#10-2-行锁" class="headerlink" title="10.2 行锁"></a>10.2 行锁</h2><p><strong>InnoDB使用行锁，并且支持事务</strong></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>InnoDB的行锁，是通过锁住<strong>索引</strong>来实现的，如果加锁查询的时候没有使用过索引，会将整个聚簇索引都锁住，相当于<strong>表锁</strong>。根据锁定范围的不同，行锁可以使用记录锁(Record Locks)、间隙锁(Gap Locks)和临键锁(Next-Key Locks)的方式实现。</p><p>如果两个客户端<strong>对同一条记录进行修改</strong></p><ul><li>客户端A修改后，未提交（未commit），此时客户端B修改，则会阻塞</li><li>客户端A修改后，提交后，客户端B再修改，则不会阻塞</li></ul><p>如果两个客户端分别<strong>对不同的记录进行修改</strong>，则不会被阻塞</p><h3 id="修改同一条记录"><a href="#修改同一条记录" class="headerlink" title="修改同一条记录"></a>修改同一条记录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#关闭自动提交<br>SET autocommit = 0;<br><br>#客户端A、B查询id=2的记录<br>SELECT * FROM t_emp WHERE id = 2;<br><br>#客户端A进行修改操作（将年龄改为了80），但未提交<br>UPDATE t_emp SET age = 80 WHERE id = 2;<br><br>#客户端A进行查询<br>SELECT * FROM t_emp WHERE id = 2;<br><br>#客户端B进行查询<br>SELECT * FROM t_emp WHERE id = 2;<br><br>#客户端B进行修改（客户端A未提交）<br>UPDATE t_emp SET age = 90 WHERE id = 2;<br><br>#客户端A提交<br>COMMIT;<br><br>#客户端B提交<br>COMMIT;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/10.5.png"></p><h3 id="修改不同记录"><a href="#修改不同记录" class="headerlink" title="修改不同记录"></a>修改不同记录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#客户端A对id=2的年龄进行修改<br>UPDATE t_emp SET age = 90 WHERE id = 2;<br><br>#客户端B对id=3的年龄进行修改<br>UPDATE t_emp SET age = 30 WHERE id = 3;<br><br>#客户端A，B分别提交<br>COMMIT;<br>COMMIT;<br></code></pre></td></tr></table></figure><p>因为InnoDB使用行锁，<strong>对于不同行的操作，不会出现阻塞现象</strong></p><h3 id="共享锁与排它锁"><a href="#共享锁与排它锁" class="headerlink" title="共享锁与排它锁"></a>共享锁与排它锁</h3><ul><li><p>共享锁又称为读锁，简称<strong>S锁</strong>，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p></li><li><p>排他锁又称为写锁，简称<strong>X锁</strong>，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就<strong>不能再获取该行的其他锁</strong>，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p></li></ul><p>select …for update语句会对当前行加排他锁</p><p>select … lock in share mode语句会对当前行加共享锁</p><blockquote><p>加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。</p></blockquote><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20210831093214952.png" alt="image-20210831093214952"></p><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>索引失效，<strong>行锁变表锁</strong></p><p>当<strong>索引失效</strong>后，即使多个客户端操作的不是同一条记录，<strong>如果未提交，其他客户端也会进入阻塞状态</strong></p><p>所以要<strong>避免索引失效</strong></p><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>当我们用<strong>范围条件</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁</p><p>对于键值<strong>在条件范围内但并不存在的记录</strong>，叫做<strong>“间隙(GAP)<strong>” ，</strong>InnoDB也会对这个“间隙”加锁</strong>，这种锁机制就是所谓的间隙锁(Gap Locks锁)。</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。<br>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询表记录，此处没有id=2的记录<br>SELECT * FROM t_emp;<br><br>#客户端A进行范围查询，但是范围内没有id=2的记录<br>UPDATE t_emp SET deptId = 1 WHERE id&gt;1 AND id &lt; 6;<br><br>#客户端B进行插入数据，插入一条id=2的记录<br>INSERT t_emp VALUES(2, &#x27;岳不群&#x27;, 11, 2, 100002); <br><br>#客户端A提交<br>COMMIT;<br><br>#客户端B提交<br>COMMIT;<br></code></pre></td></tr></table></figure><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/10.6.png"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>可以看到表中本来<strong>没有id=2的记录</strong>，但是在客户端A进行<strong>范围修改</strong>时，客户端B对<strong>在范围内但不存在的数据进行插入时，客户端B进入了阻塞状态</strong></p><h3 id="锁住指定的一行"><a href="#锁住指定的一行" class="headerlink" title="锁住指定的一行"></a>锁住指定的一行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN;<br><br>#锁住指定的一行，如果进行更新操作就是 ... FOR UPDATE，删除操作就是 ... FOR DELETE 以此类推<br>SELECT * FROM t_emp WHERE id = 1 FOR UPDATE;<br><br>#进行修改操作<br>UPDATE t_emp SET NAME = &#x27;风车车&#x27; WHERE id = 1;<br><br>#提交<br>COMMIT;<br></code></pre></td></tr></table></figure><p>如果当某一行被锁住后，其他客户端对改行进行操作，会被<strong>阻塞</strong></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设现在有一张表t，主键是id。我们插入了4行数据，主键值分别是 1、4、7、10。接下来我们就以聚簇索引为例，具体介绍三种形式的行锁。</p><ul><li><strong>记录锁(Record Locks)</strong> 所谓记录，就是指聚簇索引中真实存放的数据，比如上面的1、4、7、10都是记录。</li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20211009101723714.png" alt="image-20211009101723714"></p><p>显然，记录锁就是直接锁定某行记录。当我们使用唯一性的索引(包括唯一索引和聚簇索引)进行等值查询且精准匹配到一条记录时，此时就会直接将这条记录锁定。例如select * from t where id =4 for update;就会将id=4的记录锁定。</p><ul><li><strong>间隙锁(Gap Locks)</strong> 间隙指的是两个记录之间逻辑上尚未填入数据的部分，比如上述的(1,4)、(4,7)等。</li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20211009101753864.png" alt="image-20211009101753864"></p><p>同理，间隙锁就是锁定某些间隙区间的。当我们使用用等值查询或者范围查询，并且没有命中任何一个record，此时就会将对应的间隙区间锁定。例如select * from t where id =3 for update;或者select * from t where id &gt; 1 and id &lt; 4 for update;就会将(1,4)区间锁定。</p><ul><li><strong>临键锁(Next-Key Locks)</strong> 临键指的是间隙加上它右边的记录组成的<strong>左开右闭</strong>区间。比如上述的(1,4]、(4,7]等。</li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20211009101819407.png" alt="image-20211009101819407"></p><p><strong>临键锁就是记录锁(Record Locks)和间隙锁(Gap Locks)的结合</strong>，即除了锁住记录本身，还要再锁住索引之间的间隙。当我们使用范围查询，并且命中了部分record记录，此时锁住的就是临键区间。注意，临键锁锁住的区间会包含最后一个record的右边的临键区间。例如select * from t where id &gt; 5 and id &lt;= 7 for update;会锁住(4,7]、(7,+∞)。mysql默认行锁类型就是临键锁(Next-Key Locks)。</p><p>当使用唯一性索引，等值查询</p><ul><li>匹配到一条记录的时候，临键锁(Next-Key Locks)会退化成记录锁；</li><li>没有匹配到任何记录的时候，退化成间隙锁。</li></ul><p><strong>间隙锁(Gap Locks)和临键锁(Next-Key Locks)都是用来解决幻读问题的，在已提交读（READ COMMITTED）隔离级别下，间隙锁(Gap Locks)和临键锁(Next-Key Locks)都会失效！</strong></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Innodb存储引擎由于实现了<strong>行级锁定</strong>，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些， 但是在整体<strong>并发</strong>处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。<br>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们<strong>使用不当的时候</strong>，可能会让Innodb的整体性能表现不仅不能比MylSAM高，甚至可能会更差。</p><h2 id="10-3-意向锁"><a href="#10-3-意向锁" class="headerlink" title="10.3 意向锁"></a>10.3 意向锁</h2><p>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p><p><strong>意向锁是表锁，多用在innoDB中，是数据库自身的行为，不需要人工干预，在事务结束后会自行解除。</strong></p><p>意向锁分为意向共享锁(IS锁)和意向排它锁(IX锁)</p><ul><li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。</li><li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。</li></ul><p>意向锁的主要作用是提升存储引擎性能，innoDB中的S锁和X锁是行锁，<strong>每当事务到来时，存储引擎需要遍历所有行的锁持有情况，性能较低</strong>，因此<strong>引入意向锁</strong>，检查行锁前先检查意向锁是否存在，如果存在则阻塞线程。</p><p>由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫以外的任何请求。故表级意向锁与行级锁的兼容性如下图所示。</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20210831095502799.png" alt="image-20210831095502799"></p><p>意向锁协议</p><ul><li>事务要获取表A某些行的S锁必须要获取表A的IS锁</li><li>事务要获取表A某些行的X锁必须要获取表A的IX锁</li></ul><h1 id="十一、复制"><a href="#十一、复制" class="headerlink" title="十一、复制"></a>十一、复制</h1><h2 id="11-1-主从复制"><a href="#11-1-主从复制" class="headerlink" title="11.1 主从复制"></a>11.1 主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改<strong>写入二进制日志</strong>（Binary log）中。</li><li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并<strong>写入从服务器的中继日志</strong>（Relay log）。</li><li><strong>SQL 线程</strong> ：负责<strong>读取中继日志</strong>，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/11.1.png"></p><p>MySQL 复制过程分成三步：</p><ul><li>master 将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events</li><li>slave 将master 的binary log events 拷贝到它的中继日志（relay log）</li><li>slave 重做中继日志中的事件，将改变应用到自己的数据库中</li></ul><blockquote><p>MySQL 复制是异步的且串行化的</p></blockquote><h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><ul><li>每个slave 只有一个master</li><li>每个slave 只能有一个唯一的服务器ID</li><li>每个master 可以有多个salve</li></ul><h2 id="11-2-读写分离"><a href="#11-2-读写分离" class="headerlink" title="11.2 读写分离"></a>11.2 读写分离</h2><p><strong>主服务器处理写操作</strong>以及实时性要求比较高的读操作，而<strong>从服务器处理读操作</strong></p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度<strong>缓解了锁的争用</strong></li><li><strong>从服务器</strong>可以使用 MyISAM，提升查询性能以及节约系统开销</li><li>增加冗余，提高可用性</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/11.2.png"></p><h1 id="十二、日志"><a href="#十二、日志" class="headerlink" title="十二、日志"></a>十二、日志</h1><h2 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h2><p><strong>日志</strong>是<code>mysql</code>数据库的重要组成部分，记录着数据库运行期间各种状态信息。<code>mysql</code>日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。作为开发，重点需要关注的是二进制日志(<code>bin log</code>)和事务日志(包括<code>redo log</code>和<code>undo log</code>)。</p><h2 id="12-2-物理日志和逻辑日志"><a href="#12-2-物理日志和逻辑日志" class="headerlink" title="12.2 物理日志和逻辑日志"></a>12.2 物理日志和逻辑日志</h2><ul><li>物理日志：通俗的讲，就是只有”我”自己可以使用，别人无法共享“我的”物理格式，私有化。</li><li>逻辑日志：可以给别的引擎使用，是所有引擎共享的。</li></ul><h2 id="12-3-日志模块-redo-log"><a href="#12-3-日志模块-redo-log" class="headerlink" title="12.3 日志模块:redo log"></a>12.3 日志模块:redo log</h2><h3 id="redo-log-产生背景"><a href="#redo-log-产生背景" class="headerlink" title="redo log 产生背景"></a>redo log 产生背景</h3><p>说<code>mysql</code>日志<code>redo log</code>，先说一个故事。从前有一家酒馆，酒馆老板常备着一个粉板，专门记着客人的赊账记录，也是他的法宝之一。如果赊账的人不多，他可以在粉板上记录下赊账的人和账目。如果赊账人多的话，由于粉板的空间大小有限，所以他又需要额外准备一本账本，专门记录所有赊账的账目。</p><p>如果有人要赊账的话，一般老板有两种做法：</p><ul><li>打开账本，找到赊账人的记录，进行追加赊账记录</li><li>先把赊账人的记录写到粉板上，待客流量少的时刻，再更新到赊账账目上</li></ul><p>如果老板使用第一种方法的话，每当有人要赊账的话，首先他需要打开厚厚的账本，一页一页查找该顾客的姓名，然后进行登记。你们想啊，如果赊账的人不多，老板找赊账人的记录轻松点，如果赊账本有好几本的话，一本一本的找，老板看的都头疼。</p><p>方案一的过程想想都头大。相比第二种方案，对老板就相对轻松点，老板只需要把赊账人的信息写在粉板上，待客流量低的时候，再更新到赊账本上。</p><p>同样，<code>mysql</code>里也有同样的问题，如果每一次数据的操作都写入磁盘中，首先磁盘先要找到对应的记录，然后再更新，整个过程io成本，查找成本比较高。所以，<code>mysql</code>为了提高性能，使用了类似老板粉板方式，先把更新数据结果存储到某个地方，待空闲时再写入磁盘中。</p><p>而<code>mysql</code>把更新结果存储的地方，就是<code>redo log</code></p><h3 id="redo-log-基本概念"><a href="#redo-log-基本概念" class="headerlink" title="redo log 基本概念"></a>redo log 基本概念</h3><p><code>redo log</code>是<code>InnoDB</code>存储引擎层的日志，又被称为<strong>重写日志</strong>，用来记录事务操作的变化，记录的是数据修改之后的值，不管事务提交是否成功，都会被记录下来。</p><p>而这种<strong>先写日志，后写磁盘</strong>的技术就是mysql里面经常提及到的<strong>WAL</strong>(<strong>Write Ahead Logging</strong>)技术。</p><p>具体的来说，就是当有一条记录需要更新的时候，<code>InnoDB</code>引擎会把记录优先更新到<code>redo log</code>（粉板）里面，并更新内存，这样更新操作就完成了。同时，<code>InnoDB</code>引擎会在空闲的时间将<code>redo log</code>中的记录存储到磁盘上。</p><p><strong>重做日志用来实现事务的持久性</strong>，即事务ACID中的D。其由两部分组成，一是内存中的<strong>重做日志缓冲</strong>（redo log buffer），其是易失的；二是<strong>重做日志文件</strong>（redo log file），其是持久的。</p><h3 id="redo-log-记录方式"><a href="#redo-log-记录方式" class="headerlink" title="redo log 记录方式"></a>redo log 记录方式</h3><p>由于<code>redo log</code>记录的是数据页的变更，而这种记录是没有必要永久保存的，因此<code>redo log</code>实现上采用来大小固定，循环写入的方式，当记录写到末尾时，又会从头开始写，如下图所示。 </p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/12.1.png"></p><p> 如图所示，<code>write pos</code>是当前记录的位置，一边写一边后移，写到4号文件末尾就回到1号文件开头。<code>check point</code>是当前要把记录写入到数据文件的位置，也是后移并且循环的。</p><p>如果和上面老板粉板场景结合起来描述的话，<code>write pos</code>就是老板在粉板上顺序写入赊账人记录位置，对于<code>mysql</code>来说，<code>write pos</code>后移；而<code>check point</code>就是老板把粉板上记录写入到赊账本上的位置，当老板写入到赊账本上后，就会把粉板上该记录擦除掉，对于<code>mysql</code>来说，<code>check point</code>后移。</p><h3 id="redo-log-使用场景"><a href="#redo-log-使用场景" class="headerlink" title="redo log 使用场景"></a>redo log 使用场景</h3><ul><li>用于系统崩溃后恢复(crash-safe)</li></ul><p>InnoDB是事务的存储引擎，它通过Force Log at Commit机制实现事务的持久性，即当事务提交（COMMIT）时，<strong>必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的COMMIT操作完成才算完成</strong>。这里的日志是指重做日志。</p><h2 id="12-4-日志模块-bin-log"><a href="#12-4-日志模块-bin-log" class="headerlink" title="12.4 日志模块:bin log"></a>12.4 日志模块:bin log</h2><h3 id="bin-log-基本概念"><a href="#bin-log-基本概念" class="headerlink" title="bin log 基本概念"></a>bin log 基本概念</h3><p><code>bin（Binary Log） log</code>是mysql数据库service层的，是所有存储引擎共享的日志模块，它用于记录数据库执行的写入性操作，也就是在事务<code>commit</code>阶段进行记录，以二进制的形式保存于磁盘中。</p><p><strong>二进制日志记录了MySQL所有修改数据库的操作，然后以二进制的形式记录在日志文件中，其中还包括每条语句所执行的时间和所消耗的资源，以及相关的事务信息。</strong></p><p><code>bin log</code>是逻辑日志，并且由mysql数据库的service层执行，也就是说使用所有的存储引擎数据库都会记录<code>bin log</code>日志。</p><p><code>bin log</code>是以追加的方式进行写入的，可以通过 <code>max_binlog_size</code> 参数设置<code>bin log</code>文件大小，当文件大小达到某个值时，会生成新的文件来保存日志。</p><h3 id="bin-log-刷盘机制"><a href="#bin-log-刷盘机制" class="headerlink" title="bin log 刷盘机制"></a>bin log 刷盘机制</h3><p>对于InnoDB引擎而言，在每次事务<code>commit</code>提交时才会记录bin log日志，此时记录仍然在内存中，那么什么时候存储到磁盘中呢？mysql通过 <code>sync_binlog</code> 参数控制bin log刷盘时机，取值范围：0～N： 0：不去强求，由系统自行判断何时写入磁盘； 1：每次事务<code>commit</code>的时候都要将bin log写入磁盘； N：每N个事务<code>commit</code>，才会将bin log写入磁盘；</p><p><code>sync_binlog</code> 参数建议设置为1，这样每次事务commit时就会把bin log写入磁盘中，这样也可以保证mysql异常重启之后bin log日志不会丢失。</p><h3 id="bin-log-使用场景"><a href="#bin-log-使用场景" class="headerlink" title="bin log 使用场景"></a>bin log 使用场景</h3><p>在实际场景中， <code>bin log</code> 的主要场景有两点，一点是主从复制，另一点是数据恢复 </p><ul><li>主从复制：在master端开启 <code>bin log</code> ，然后将 <code>bin log</code> 发送给各个slaver端，slaver端读取 <code>bin log</code> 日志，从而使得主从数据库中数据一致</li><li> 数据恢复：通过 <code>bin log</code> 获取想要恢复的时间段数据</li></ul><h2 id="12-5-日志模块-undolog"><a href="#12-5-日志模块-undolog" class="headerlink" title="12.5 日志模块:undolog"></a>12.5 日志模块:undolog</h2><h3 id="undo-log-基本概念"><a href="#undo-log-基本概念" class="headerlink" title="undo log 基本概念"></a>undo log 基本概念</h3><p><code>undo log</code> 是回滚日志，是记录每条数据的所有版本，比如 <code>update</code> 语句，那么它首先会将该条记录的数据记录到<code>undo log</code>日志中，并且将最新版本的<strong>roll_pointer指针</strong>指向上一个版本，这样就可以形成当前记录的所有版本，这也是MVCC的实现机制。</p><p><strong>实现原子性的关键</strong>，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚靠的是undo log，当事务对数据库进行修改时，InnoDB会生成对应的undo log。如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p><p>undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作。对于insert，回滚时会执行delete。对于delete，回滚时会执行insert。对于update，回滚时则会执行相反的update，把数据改回去。</p><p>在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。</p><p>redo存放在重做日志文件中，与redo不同，undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment），undo段位于共享表空间内。</p><p>每一行 undo log 可以简化为下图所示的结构</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20210828171810248.png" alt="image-20210828171810248"></p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20210828171943263.png" alt="image-20210828171943263"></p><h3 id="undo-log-使用场景"><a href="#undo-log-使用场景" class="headerlink" title="undo log 使用场景"></a>undo log 使用场景</h3><ul><li>MVCC多版本控制中使用<code>undo log</code></li></ul><h3 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>MVCC (Multi-Version Concurrency Control) 是一种基于多版本的并发控制协议，只有在InnoDB引擎下存在。MVCC是为了实现事务的隔离性，通过<strong>版本号</strong>，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。当然，这种乐观锁只在事务级别未提交锁和已提交锁时才会生效。MVCC最大的好处：<strong>读不加锁，读写不冲突</strong>。在读多写少的应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。</p><blockquote><p>注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control</p></blockquote><p>MVCC只在 <strong>READ COMMITTED</strong> 和 <strong>REPEATABLE READ</strong> 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容，因为 READ UNCOMMITTED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。</p><h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><p>InnoDB在每行数据都增加<strong>三个隐藏字段</strong>，一个唯一行号(用于无主键时)，一个记录<strong>创建的版本号</strong>，一个记录<strong>回滚的版本号</strong>。</p><ul><li><p>6字节的<strong>DB_ROW_ID</strong>字段：包含一个随着新行插入而单调递增的行ID，当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。</p></li><li><p>6字节的事务ID(<strong>DB_TRX_ID</strong>)字段：用来标识最近一次对本行记录做修改(insert|update)的事务的标识符，即最后一次修改(insert|update)本行记录的事务id。至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted，并非真正删除。</p></li><li><p>7字节的回滚指针(<strong>DB_ROLL_PTR</strong>)字段：指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。如果一行记录被更新, 则 undo log record 包含 ‘重建该行记录被更新之前内容’ 所必须的信息。</p></li></ul><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20210827221003887.png" alt="image-20210827221003887"></p><p>在多版本并发控制中，为了保证数据操作在多线程过程中，保证事务隔离的机制，降低锁竞争的压力，保证较高的并发量。在每开启一个事务时，会生成一个事务的版本号，被操作的数据会生成一条<strong>新的数据行（临时）</strong>，但是在提交前对其他事务是不可见的，对于数据的更新（包括增删改）操作成功，会将这个版本号更新到数据的行中，事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题。</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20210827221242294.png" alt="image-20210827221242294"></p><ul><li>插入数据<ul><li>InnoDB为这个新行记录当前的事务版本号。</li></ul></li><li>删除数据<ul><li> InnoDB将当前的系统版本号设置为这一行的删除ID。</li></ul></li><li>更新数据<ul><li>InnoDB会写一个这行数据的新拷贝，这个拷贝的版本为当前的系统版本号。它同时也会将这个版本号写到旧行的删除版本里。</li></ul></li><li>查询数据<ul><li>当隔离级别是REPEATABLE READ时select操作，InnoDB必须每行数据来保证它符合两个条件：<ul><li>1、InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。</li><li>2、这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。</li></ul></li><li>符合这两个条件的行可能会被当作查询结果而返回。</li></ul></li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>MySQL的默认隔离级别是Read Repeatable，就是可重复读。是通过MVCC机制来实现的</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/12.2.png"></p><p>当我们使用innodb存储引擎，会在每行数据的最后加两个隐藏列，一个保存行的创建时间，一个保存行的删除时间，但是这儿存放的不是时间，而是事务id，事务id是mysql自己维护的自增的，全局唯一。 </p><p><strong>事务id，在mysql内部是全局唯一递增的</strong></p><ul><li><p>事务id=121的事务，查询id=1的这一行的时候，一定会找到创建事务id &lt;= 当前事务id的那一行</p><p><code>select * from table where id=1</code>，就可以查到上面那一行</p></li><li><p>事务id=122的事务，将id=1的这一行给删除了，此时就会将id=1的行的删除事务id设置成122</p><ul><li><p>事务id=121的事务，再次查询id=1的那一行，能查到吗？</p><p><strong>能查到，要求创建事务id &lt;= 当前事务id，当前事务id &lt; 删除事务id</strong></p></li></ul></li><li><p>事务id=121的事务，查询id=2的那一行，查到name=李四</p></li><li><p>事务id=122的事务，将id=2的那一行的name修改成name=小李四</p><p>事务id=121的事务，查询id=2的那一行，答案是：李四，创建事务id &lt;= 当前事务id，当前事务id &lt; 删除事务id</p></li></ul><p><strong>在一个事务内查询的时候，mysql只会查询创建时间的事务id小于等于当前事务id的行，这样可以确保这个行是在当前事务中创建，或者是之前创建的；</strong></p><p>同时一个行的删除时间的事务id要么没有定义（就是没删除），要么是必当前事务id大（在事务开启之后才被删除）；满足这两个条件的数据都会被查出来。</p><p>那么如果某个事务执行期间，别的事务更新了一条数据呢？这个很关键的一个实现，其实就是在innodb中，是<strong>插入了一行记录，然后将新插入的记录的创建时间设置为新的事务的id，同时将这条记录之前的那个版本的删除时间设置为新的事务的id</strong>。</p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>这种额外的记录所带来的结果就是对于大多数查询来说根本就不需要获得一个锁。他们只是简单地以最快的速度来读取数据，确保只选择符合条件的行。这个方案的缺点在于存储引擎必须为每一行存储更多的数据，做更多的检查工作，处理更多的善后操作。<br><strong>MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下</strong>。READ UNCOMMITED不是MVCC兼容的，因为查询不能找到适合他们事务版本的行版本；它们每次都只能读到最新的版本。SERIABLABLE也不与MVCC兼容，因为读操作会锁定他们返回的每一行数据。</p><h2 id="12-6-总结"><a href="#12-6-总结" class="headerlink" title="12.6 总结"></a>12.6 总结</h2><table><thead><tr><th>类别</th><th>bin log</th><th>redo log</th><th>undo log</th></tr></thead><tbody><tr><td>存储位置</td><td>server层，所有引擎共享</td><td>InnoDB引擎独有</td><td></td></tr><tr><td>文件大小</td><td>可以通过 <code>max_binlog_size</code> 参数设置<code>bin log</code>文件大小</td><td>大小固定</td><td></td></tr><tr><td>日志名称</td><td>归档日志</td><td>重写日志</td><td>回滚日志</td></tr><tr><td>记录方式</td><td>追加写</td><td>循环写</td><td></td></tr><tr><td>适用场景</td><td>主从复制，数据恢复</td><td>崩溃恢复</td><td>MVCC多版本并发</td></tr></tbody></table><h1 id="十三、事务"><a href="#十三、事务" class="headerlink" title="十三、事务"></a>十三、事务</h1><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><ul><li>A（atomicity），原子性。原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，整个事务的执行才算成功。事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。</li><li>C（consistency），一致性。一致性指事务将数据库从一种状态转变为另一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</li><li>I（isolation），隔离性。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，这通常使用锁来实现。</li><li>D（durability） ，持久性。事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复。持久性保证的是事务系统的高可靠性，而不是高可用性。</li></ul><h2 id="MySQL的ACID特性实现原理"><a href="#MySQL的ACID特性实现原理" class="headerlink" title="MySQL的ACID特性实现原理"></a>MySQL的ACID特性实现原理</h2><h3 id="原子性实现原理"><a href="#原子性实现原理" class="headerlink" title="原子性实现原理"></a>原子性实现原理</h3><p>实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚靠的是undo log，当事务对数据库进行修改时，InnoDB会生成对应的undo log。如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p><p>undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作。对于insert，回滚时会执行delete。对于delete，回滚时会执行insert。对于update，回滚时则会执行相反的update，把数据改回去。</p><h3 id="持久性实现原理"><a href="#持久性实现原理" class="headerlink" title="持久性实现原理"></a>持久性实现原理</h3><p>InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。<strong>当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool。当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中</strong>（这一过程称为刷脏）。</p><p>Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p><p>于是，redo log被引入来解决这个问题。当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作。当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），<strong>所有修改先写入日志，再更新到Buffer Pool</strong>，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p><p>既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：</p><ul><li>刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。</li><li>刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入。而redo log中只包含真正需要写入的部分，无效IO大大减少。</li></ul><h3 id="隔离性实现原理"><a href="#隔离性实现原理" class="headerlink" title="隔离性实现原理"></a>隔离性实现原理</h3><p>隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们主要考虑最简单的读操作和写操作(加锁读等特殊读操作会特殊说明)，那么隔离性的探讨，主要可以分为两个方面。</p><p>第一方面，(一个事务)写操作对(另一个事务)写操作的影响：<strong>锁机制</strong>保证隔离性。</p><p>隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁。获得锁之后，事务便可以修改数据。该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</p><p>按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差。行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p><p>第二方面，(一个事务)写操作对(另一个事务)读操作的影响：<strong>MVCC</strong>保证隔离性。</p><p>InnoDB默认的隔离级别是RR（REPEATABLE READ），RR解决脏读、不可重复读、幻读等问题，使用的是MVCC。MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。它最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：</p><ol><li>隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log的指针等。</li><li>基于undo log的版本链：每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。</li><li>ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本。但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。</li></ol><h3 id="一致性实现原理"><a href="#一致性实现原理" class="headerlink" title="一致性实现原理"></a>一致性实现原理</h3><p>可以说，一致性是事务追求的最终目标。前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。实现一致性的措施包括：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证。</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等。</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。</li></ul><h2 id="事务的类型"><a href="#事务的类型" class="headerlink" title="事务的类型"></a>事务的类型</h2><ul><li>扁平事务：是事务类型中最简单的一种，而在实际生产环境中，这可能是使用最为频繁的事务。在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束。处于之间的操作是原子的，要么都执行，要么都回滚。</li><li>带有保存点的扁平事务：除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（savepoint）用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。</li><li>链事务：可视为保存点模式的一个变种。链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的。</li><li>嵌套事务：是一个层次结构框架。有一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换。</li><li>分布式事务：通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。对于分布式事务，同样需要满足ACID特性，要么都发生，要么都失效。</li></ul><p>对于MySQL的InnoDB存储引擎来说，它支持扁平事务、带有保存点的扁平事务、链事务、分布式事务。对于嵌套事务，MySQL数据库并不是原生的，因此对于有并行事务需求的用户来说MySQL就无能为力了，但是用户可以通过带有保存点的事务来模拟串行的嵌套事务。</p><h2 id="ReadView-机制"><a href="#ReadView-机制" class="headerlink" title="ReadView 机制"></a>ReadView 机制</h2><p>当事务在开始执行的时候，会给每个事务生成一个 ReadView。这个 ReadView 会记录 4 个非常重要的属性：</p><ol><li>creator_trx_id: 当前事务的 id;</li><li>m_ids: 当前系统中所有的活跃事务的 id，活跃事务指的是当前系统中开启了事务，但是还没有提交的事务;</li><li>min_trx_id: 当前系统中，所有活跃事务中事务 id 最小的那个事务，也就是 m_id 数组中最小的事务 id;</li><li>max_trx_id: 当前系统中事务的 id 值最大的那个事务 id 值再加 1，也就是系统中下一个要生成的事务 id。</li></ol><p>ReadView 会根据这 4 个属性，再结合 undo log 版本链，来实现 MVCC 机制，决定让一个事务能读取到哪些数据，不能读取到哪些数据。</p><p>如果用一个坐标轴来表示的话，min_trx_id 和 max_trx_id 会将这个坐标轴分成 3 个部分：</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20210828172109782.png" alt="image-20210828172109782"></p><p>当一个事务读取某条数据时，就会按照如下规则来决定当前事务能读取到什么数据：</p><ul><li><p>如果当前数据的 row_trx_id 小于 min_trx_id，那么表示这条数据是在当前事务开启之前，其他的事务就已经将该条数据修改了并提交了事务(事务的 id 值是递增的)，所以当前事务能读取到。</p></li><li><p>如果当前数据的 row_trx_id 大于等于 max_trx_id，那么表示在当前事务开启以后，过了一段时间，系统中有新的事务开启了，并且新的事务修改了这行数据的值并提交了事务，所以当前事务肯定是不能读取到的，因此这是后面的事务修改提交的数据。</p></li><li><p>如果当前数据的 row_trx_id 处于 min_trx_id 和 max_trx_id 的范围之间，又需要分两种情况：</p><ul><li>row_trx_id 在 m_ids 数组中，那么当前事务不能读取到。为什么呢?row_trx_id 在 m_ids 数组中表示的是和当前事务在同一时刻开启的事务，修改了数据的值，并提交了事务，所以不能让当前事务读取到;</li><li>row_trx_id 不在 m_ids 数组中，那么当前事务能读取到。row_trx_id 不在 m_ids 数组中表示的是在当前事务开启之前，其他事务将数据修改后就已经提交了事务，所以当前事务能读取到。</li></ul></li></ul><blockquote><p>如果 row_trx_id 等于当前事务的 id，那表示这条数据就是当前事务修改的，那当前事务肯定能读取到。</p></blockquote><h2 id="如何解决幻读问题"><a href="#如何解决幻读问题" class="headerlink" title="如何解决幻读问题"></a>如何解决幻读问题</h2><p>MySQL 已经在可重复读隔离级别下解决了幻读的问题，用的是间隙锁。MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做 Next-Key（<strong>临键锁</strong>）锁。</p><p>假设现在表中有两条记录，并且 age 字段已经添加了索引，两条记录 age 的值分别为 10 和 30。此时，在数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20210831092818152.png" alt="image-20210831092818152"></p><p>此时，在数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。如图所示，分成了3 个区间，在这3个区间是可以加间隙锁的。</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20210831092836991.png" alt="image-20210831092836991"></p><p>用下面的两个事务演示一下加锁过程。</p><p><img src="/2020/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/image-20210831092900840.png" alt="image-20210831092900840"></p><p>在事务A提交之前，事务B的插入操作只能等待，这就是间隙锁起得作用。当事务A执行<code>update user set name=&#39;风筝2号’ where age = 10;</code> 的时候，由于条件 where age = 10 ，数据库不仅在 age =10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁，从而导致事务B插入操作无法完成，只能等待事务A提交。不仅插入 age = 10 的记录需要等待事务A提交，age&lt;10、10&lt;age&lt;30 的记录页无法完成，而大于等于30的记录则不受影响，这足以解决幻读问题了。</p><p>这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 并发</title>
    <link href="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1、进程与线程"><a href="#1-1、进程与线程" class="headerlink" title="1.1、进程与线程"></a>1.1、进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云、安全卫士等）</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li></ul><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 </li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享<ul><li>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 </li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h2 id="1-2、并发与并行"><a href="#1-2、并发与并行" class="headerlink" title="1.2、并发与并行"></a>1.2、并发与并行</h2><p><strong>单核</strong>cpu下，线程实际还是<strong>串行执行</strong>的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。总结为一句话就是：<strong>微观串行，宏观并行</strong></p><p>并发是<strong>一个CPU</strong>在不同的时间去不同线程中执行指令。</p><p>并行是<strong>多个CPU</strong>同时处理不同的线程。</p><p>引用 Rob Pike 的一段描述：</p><ul><li>并发（concurrent）是同一时间<strong>应对</strong>（dealing with）多件事情的能力</li><li>并行（parallel）是同一时间<strong>动手做</strong>（doing）多件事情的能力</li></ul><h2 id="1-3、应用"><a href="#1-3、应用" class="headerlink" title="1.3、应用"></a>1.3、应用</h2><h3 id="应用之异步调用"><a href="#应用之异步调用" class="headerlink" title="应用之异步调用"></a>应用之异步调用</h3><p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><blockquote><p>同步在多线程中还有另一层意思：让多个线程步调一致</p></blockquote><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat的异步servlet也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li><li>tomcat的工作线程ui程序中，开线程进行其他操作，避免阻塞ui线程</li></ul><h3 id="应用之提高效率"><a href="#应用之提高效率" class="headerlink" title="应用之提高效率"></a>应用之提高效率</h3><h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><ul><li><p>单核cpu下，多线程<strong>不能实际提高程序运行效率</strong>，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p></li><li><p>多核cpu可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p><ul><li>有些任务，经过精心设计，将任务拆分，并行执行，可以提高程序的运行效率。但不是所有计算任务都能拆分（参考【阿姆达尔定律】）</li><li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率就没有意义</li></ul></li><li><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</p></li></ul><h2 id="1-4、查看进程线程的方法"><a href="#1-4、查看进程线程的方法" class="headerlink" title="1.4、查看进程线程的方法"></a>1.4、查看进程线程的方法</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p><ul><li><strong>tasklist</strong>查看进程</li><li><strong>taskkill</strong>杀死进程</li></ul><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p><strong>ps -fe</strong>查看所有进程<br>**ps -fT -p <PID> **查看某个进程（PID）的所有线程<br><strong>kill</strong>杀死进程<br><strong>top</strong>按大写 H 切换是否显示线程<br>**top -H -p <PID> **查看某个进程（PID）的所有线程</PID></PID></p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p><strong>jps</strong> 命令查看所有 Java 进程<br><strong>jstack <PID></PID></strong> 查看某个 Java 进程（PID）的所有线程状态<br><strong>jconsole</strong> 来查看某个 Java 进程中线程的运行情况（图形界面）</p><hr><h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="2-1、创建一个线程（非主线程）"><a href="#2-1、创建一个线程（非主线程）" class="headerlink" title="2.1、创建一个线程（非主线程）"></a>2.1、创建一个线程（非主线程）</h2><h3 id="方法一：通过继承Thread创建线程"><a href="#方法一：通过继承Thread创建线程" class="headerlink" title="方法一：通过继承Thread创建线程"></a>方法一：通过继承Thread创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread myThread = <span class="hljs-keyword">new</span> MyThread();<br>        <span class="hljs-comment">// 启动线程</span><br>        myThread.start();<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;my thread running...&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>使用继承方式的好处是，在run（）方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread（）方法；不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p><h3 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread02</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建线程任务</span><br>        Runnable r = <span class="hljs-keyword">new</span> Runnable()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;Runnable running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//将Runnable对象传给Thread</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(r);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread02</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;my runnable running...&quot;</span>);<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      MyRunnable myRunnable = <span class="hljs-keyword">new</span> MyRunnable();<br>      Thread thread = <span class="hljs-keyword">new</span> Thread(myRunnable);<br>      thread.start();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</p><h4 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h4><p><strong>当一个接口带有@FunctionalInterface注解时，是可以使用lambda来简化操作的</strong></p><p>所以方法二中的代码可以被简化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread02</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//改成lambda表达式方式如下</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt;System.out.println(<span class="hljs-string">&quot;Runnable running&quot;</span>)).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以在Runnable上使用<strong>Alt+Ente</strong>r,IDE会自动用lambda表达式替换匿名内部类</p><h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起</li><li>方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h3 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h3><p><strong>使用FutureTask(接收Callable类型参数)，可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread03</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//需要传入一个Callable对象</span><br>FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;线程执行!&quot;</span>);<br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;<br>&#125;);<br><br>Thread r1 = <span class="hljs-keyword">new</span> Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);<br>r1.start();<br><span class="hljs-comment">//获取线程中方法执行后的返回结果</span><br>System.out.println(task.get());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseFutureTask</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>      FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyCall());<br>      Thread thread = <span class="hljs-keyword">new</span> Thread(futureTask);<br>      thread.start();<br>      <span class="hljs-comment">// 获得线程运行后的返回值</span><br>      System.out.println(futureTask.get());<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<strong>继承方式的好处是方便传参</strong>，可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量（JDK1.8之后可以用不发生改变的非final变量）。<strong>不好的地方是Java不支持多继承</strong>，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</strong></p><h2 id="2-2、原理之线程运行"><a href="#2-2、原理之线程运行" class="headerlink" title="2.2、原理之线程运行"></a>2.2、原理之线程运行</h2><h3 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈） JVM 中由堆、栈、方法区所组成，其中栈内存是给线程使用的</p><ul><li>每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li><li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong></li><li>每个线程只能有一个<strong>活动栈帧</strong>，对应着当前正在执行的那个方法</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/2.1.png" alt="2.0.1"></p><h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条jvm指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch频繁发生会影响性能</li></ul><h2 id="2-3、常用方法"><a href="#2-3、常用方法" class="headerlink" title="2.3、常用方法"></a>2.3、常用方法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><table><thead><tr><th>方法名</th><th>static</th><th>功能说明</th><th>注意</th></tr></thead><tbody><tr><td>start()</td><td></td><td>启动一个新线程，在新的线程运行 run 方法中的代码</td><td>start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现IllegalThreadStateException</td></tr><tr><td>run()</td><td></td><td>新线程启动后会调用的方法</td><td>如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为</td></tr><tr><td>join()</td><td></td><td>等待线程运行结束</td><td></td></tr><tr><td>join(long n)</td><td></td><td>等待线程运行结束,最多等待 n毫秒</td><td></td></tr><tr><td>getId()</td><td></td><td>获取线程长整型的 id</td><td>id 唯一</td></tr><tr><td>getName()</td><td></td><td>获取线程名</td><td></td></tr><tr><td>setName(String)</td><td></td><td>修改线程名</td><td></td></tr><tr><td>getPriority()</td><td></td><td>获取线程优先级</td><td></td></tr><tr><td>setPriority(int)</td><td></td><td>修改线程优先级</td><td>java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率</td></tr><tr><td>getState()</td><td></td><td>获取线程状态</td><td>Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING,TIMED_WAITING, TERMINATED</td></tr><tr><td>isInterrupted()</td><td></td><td>判断是否被打断</td><td>不会清除打断标记</td></tr><tr><td>isAlive()</td><td></td><td>线程是否存活（还没有运行完毕）</td><td></td></tr><tr><td>interrupt()</td><td></td><td>打断线程</td><td>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除打断标记；如果打断的正在运行的线程，则会设置打断标记；park的线程被打断，也会设置打断标记。interrupt()<code>会使得</code>中断状态<code>为true，并调用</code>unpark</td></tr><tr><td>interrupted()</td><td>static</td><td>判断当前线程是否被打断</td><td>会清除打断标记</td></tr><tr><td>currentThread()</td><td>static</td><td>获取当前正在执行的线程</td><td></td></tr><tr><td>sleep(long n)</td><td>static</td><td>让当前执行的线程休眠n毫秒，休眠时让出 cpu的时间片给其它线程</td><td></td></tr><tr><td>yield()</td><td>static</td><td>提示线程调度器让出当前线程对CPU的使用</td><td>主要是为了测试和调试，只让出CPU，不释放锁资源</td></tr></tbody></table><h3 id="start-与-run"><a href="#start-与-run" class="headerlink" title="start() 与 run()"></a>start() 与 run()</h3><h4 id="调用-run"><a href="#调用-run" class="headerlink" title="调用 run"></a>调用 run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>log.debug(Thread.currentThread().getName());<br>FileReader.read(Constants.MP4_FULL_PATH);<br>&#125;<br>&#125;;<br>t1.run();<br>log.debug(<span class="hljs-string">&quot;do other things ...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">19</span>:<span class="hljs-number">39</span>:<span class="hljs-number">14</span> [main] c.TestStart - main<br><span class="hljs-number">19</span>:<span class="hljs-number">39</span>:<span class="hljs-number">14</span> [main] c.FileReader - read [<span class="hljs-number">1.</span>mp4] start ...<br><span class="hljs-number">19</span>:<span class="hljs-number">39</span>:<span class="hljs-number">18</span> [main] c.FileReader - read [<span class="hljs-number">1.</span>mp4] end ... cost: <span class="hljs-number">4227</span> ms<br><span class="hljs-number">19</span>:<span class="hljs-number">39</span>:<span class="hljs-number">18</span> [main] c.TestStart - <span class="hljs-keyword">do</span> other things ...<br></code></pre></td></tr></table></figure><p>结果</p><ul><li>程序仍在 main 线程运行，没有开启新的线程。<code>FileReader.read()</code>方法调用还是同步的</li></ul><h4 id="调用-start"><a href="#调用-start" class="headerlink" title="调用 start"></a>调用 start</h4><p>将上述代码的 <code>t1.run();</code>改为<code>t1.start();</code></p><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">19</span>:<span class="hljs-number">41</span>:<span class="hljs-number">30</span> [main] c.TestStart - <span class="hljs-keyword">do</span> other things ...<br><span class="hljs-number">19</span>:<span class="hljs-number">41</span>:<span class="hljs-number">30</span> [t1] c.TestStart - t1<br><span class="hljs-number">19</span>:<span class="hljs-number">41</span>:<span class="hljs-number">30</span> [t1] c.FileReader - read [<span class="hljs-number">1.</span>mp4] start ...<br><span class="hljs-number">19</span>:<span class="hljs-number">41</span>:<span class="hljs-number">35</span> [t1] c.FileReader - read [<span class="hljs-number">1.</span>mp4] end ... cost: <span class="hljs-number">4542</span> ms<br></code></pre></td></tr></table></figure><p>结果</p><ul><li>开启了新的线程t1，程序在t1线程运行，<code>FileReader.read()</code>方法调用是异步的</li></ul><h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h4><ul><li>直接调用run是在<strong>主线程中执行</strong>了run，没有启动新的线程</li><li>使用start是<strong>启动新的线程</strong>，通过新的线程间接执行 run 中的代码</li></ul><h3 id="sleep-与yield"><a href="#sleep-与yield" class="headerlink" title="sleep()与yield()"></a>sleep()与yield()</h3><h4 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep(使线程阻塞)"></a>sleep(使线程阻塞)</h4><ol><li>调用 sleep 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</li><li>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出<code>InterruptedException</code>异常</li><li>睡眠结束后的线程未必会立刻得到执行</li><li>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span><br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//休眠一分钟</span><br>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h4 id="yield（让出当前线程）"><a href="#yield（让出当前线程）" class="headerlink" title="yield（让出当前线程）"></a>yield（让出当前线程）</h4><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li><li>设置方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-comment">//设置为优先级最高</span><br></code></pre></td></tr></table></figure><h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h3><ul><li>用于等待某个线程结束。线程内调用哪个线程join()方法，就等待哪个线程结束，然后再去执行其他线程。</li></ul><blockquote><p>如：在主线程中调用ti.join()，则是主线程等待t1线程结束</p></blockquote><ul><li>有时效的 join，join(long n)，等待线程运行结束,最多等待 n毫秒。如果n毫秒内线程执行完毕，则会直接执行之后的语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread();<br><span class="hljs-comment">//等待thread线程执行结束</span><br>thread.join();<br><span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span><br>thread.join(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h3 id="interrupt-方法"><a href="#interrupt-方法" class="headerlink" title="interrupt()方法"></a>interrupt()方法</h3><p>用于打断<strong>阻塞</strong>(sleep、wait、join…)的线程。（处于阻塞状态的线程，CPU不会给其分配时间片）。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为true（即打断正常运行的线程, 不会清空打断状态）</li><li>如果是打断因sleep、wait、join方法而被阻塞的线程，会将打断标记置为false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于查看打断标记，返回值被boolean类型</span><br>t1.isInterrupted();<br></code></pre></td></tr></table></figure><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a>interrupt方法的应用——两阶段终止模式</h4><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/2.2.png"></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTerminationPattern</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>        monitor.start();<br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        monitor.stop();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;<br><br>    Thread monitor;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>        monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//开始不停的监控</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-comment">//判断当前线程是否被打断了</span><br>                    <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-comment">//终止线程执行</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//线程休眠</span><br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                        <span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span><br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于停止监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//打断线程</span><br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Thread.interrupted()：用来清除打断状态</p></blockquote><h3 id="不推荐使用的方法"><a href="#不推荐使用的方法" class="headerlink" title="不推荐使用的方法"></a>不推荐使用的方法</h3><table><thead><tr><th>方法名</th><th>static</th><th>功能说明</th></tr></thead><tbody><tr><td>stop()</td><td></td><td>停止线程运行</td></tr><tr><td>suspend()</td><td></td><td>挂起（暂停）线程运行</td></tr><tr><td>resume()</td><td></td><td>恢复线程运行</td></tr></tbody></table><blockquote><p>上述三个方法，已过时，容易破坏同步代码块，造成线程死锁</p></blockquote><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>当Java进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，Java进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将线程设置为守护线程, 默认为false</span><br>monitor.setDaemon(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><h4 id="守护线程的应用"><a href="#守护线程的应用" class="headerlink" title="守护线程的应用"></a>守护线程的应用</h4><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的Acceptor和Poller线程都是守护线程，所以 Tomcat 接收到shutdown命令后，不会等待它们处理完当前请求</li></ul><h2 id="2-4、线程的状态"><a href="#2-4、线程的状态" class="headerlink" title="2.4、线程的状态"></a>2.4、线程的状态</h2><h3 id="2-4-1-五种状态"><a href="#2-4-1-五种状态" class="headerlink" title="2.4.1 五种状态"></a>2.4.1 五种状态</h3><p>这是从<strong>操作系统</strong>层面来描述的</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/2.3.png"></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如new了Thread对象但还没有调用start方法）</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态<ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li>【阻塞状态】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h3 id="2-5-2-六种状态"><a href="#2-5-2-六种状态" class="headerlink" title="2.5.2 六种状态"></a>2.5.2 六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/2.4.png"></p><ul><li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是<strong>可运行</strong>）</li><li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。</li><li><strong>TERMINATED</strong> 当线程代码运行结束</li></ul><hr><h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="3-1、共享带来的问题"><a href="#3-1、共享带来的问题" class="headerlink" title="3.1、共享带来的问题"></a>3.1、共享带来的问题</h2><h3 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 Critical Section"></a>临界区 Critical Section</h3><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源<ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong><br>例如，下面代码中的临界区</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br><span class="hljs-function"></span>&#123;   <br>    counter++; <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br><span class="hljs-function"></span>&#123; <br>    counter--; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="竞态条件-Race-Condition"><a href="#竞态条件-Race-Condition" class="headerlink" title="竞态条件 Race Condition"></a>竞态条件 Race Condition</h3><p>多个线程在<strong>临界区</strong>内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h2 id="3-2、synchronized-解决方案"><a href="#3-2、synchronized-解决方案" class="headerlink" title="3.2、synchronized 解决方案"></a>3.2、synchronized 解决方案</h2><h3 id="解决手段"><a href="#解决手段" class="headerlink" title="解决手段"></a>解决手段</h3><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h3 id="synchronized语法"><a href="#synchronized语法" class="headerlink" title="synchronized语法"></a>synchronized语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;<br><span class="hljs-comment">//临界区</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Synchronized01</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//创建一个公共对象，作为对象锁的对象</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    counter++;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    counter--;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面向对象改进"><a href="#面向对象改进" class="headerlink" title="面向对象改进"></a>面向对象改进</h3><p>把需要保护的共享变量放入一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Synchronized02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Room room = <span class="hljs-keyword">new</span> Room();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                    room.increment();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                    room.decrement();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,room.get());<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            value++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            value--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="synchronized加在方法上"><a href="#synchronized加在方法上" class="headerlink" title="synchronized加在方法上"></a>synchronized加在方法上</h3><h4 id="加在成员方法上"><a href="#加在成员方法上" class="headerlink" title="加在成员方法上"></a>加在成员方法上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-comment">//在方法上加上synchronized关键字</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="加在静态方法上"><a href="#加在静态方法上" class="headerlink" title="加在静态方法上"></a>加在静态方法上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-comment">//在静态方法上加上synchronized关键字</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(Demo.class) &#123;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>synchronized可以修饰静态方法，但不能修饰静态代码块。</p><p>当修饰静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁。</p></li></ul><h2 id="3-3、变量的线程安全分析"><a href="#3-3、变量的线程安全分析" class="headerlink" title="3.3、变量的线程安全分析"></a>3.3、变量的线程安全分析</h2><h3 id="成员变量和静态变量线程安全性"><a href="#成员变量和静态变量线程安全性" class="headerlink" title="成员变量和静态变量线程安全性"></a>成员变量和静态变量线程安全性</h3><p>成员变量和静态变量是否线程安全？</p><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h3 id="局部变量线程安全性"><a href="#局部变量线程安全性" class="headerlink" title="局部变量线程安全性"></a>局部变量线程安全性</h3><p>局部变量是否线程安全？</p><ul><li>局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</li></ul><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>i++;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.1.png"></p><ul><li>但局部变量引用的对象则未必 （要看该对象是否被共享且被执行了读写操作）<ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离（return）方法的作用范围，需要考虑线程安全</li></ul></li></ul><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafe</span> </span>&#123;<br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br><span class="hljs-comment">// &#123; 临界区, 会产生竞态条件</span><br>method2();<br>method3();<br>        <span class="hljs-comment">// &#125; 临界区</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>list.remove(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THREAD_NUMBER = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LOOP_NUMBER = <span class="hljs-number">200</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ThreadUnsafe test = <span class="hljs-keyword">new</span> ThreadUnsafe();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>test.method1(LOOP_NUMBER);<br>&#125;, <span class="hljs-string">&quot;Thread&quot;</span> + i).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中一种情况是，如果线程2还未add，线程1remove就会报错：</p><p><code>Exception in thread &quot;Thread1&quot; java.lang.IndexOutOfBoundsException: Index: 0, Size: 0</code></p><blockquote><p>因为会出现指令重排，在同一个线程中有可能method3先于method2执行</p></blockquote><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.2.png"></p><p>将 list 修改为局部变量，就不会有上述问题了</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>method2(list);<br>method3(list);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>list.remove(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：<br>list 是局部变量，每个线程调用时会创建其不同实例，没有共享<br>而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象<br>method3 的参数分析与 method2 相同</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.3.png"></p><p>如果把 method2 和 method3 的方法修改为 public 会不会线程安全问题？</p><ul><li>情况1：有其它线程调用 method2 和 method3<ul><li>不会，因为其他线程调用时，传入的list对象，与其他线程不是同一个</li></ul></li><li>情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadSafe</span></span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>list.remove(<span class="hljs-number">0</span>);<br>&#125;).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>会，因为有新的线程，和原来的线程，共享了同一个list对象</li></ul><blockquote><p>可以用private，final修饰，加强线程安全性</p></blockquote><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuﬀer</li><li>Random</li><li>Vector （List的线程安全实现类）</li><li>Hashtable （Hash的线程安全实现类）</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p><ul><li>它们的每个方法是原子的（都被加上了synchronized）</li><li>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</li></ul><p>组合后，线程不安全。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Hashtable table = <span class="hljs-keyword">new</span> Hashtable();<br><span class="hljs-comment">// 线程1，线程2</span><br><span class="hljs-keyword">if</span>( table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-keyword">null</span>) &#123;<br>table.put(<span class="hljs-string">&quot;key&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagramparticipant t1 as 线程1participant t2 as 线程2participant tablet1 -&gt;&gt; table : get(&quot;key&quot;) == nullt2 -&gt;&gt; table : get(&quot;key&quot;) == nullt2 -&gt;&gt; table : put(&quot;key&quot;,v2)t1 -&gt;&gt; table : put(&quot;key&quot;,v1)</code></pre><h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其<strong>内部的状态不可以改变</strong>，因此它们的方法都是线程安全的</p><p>String 有 replace，substring 等方法可以”改变值“，这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><span class="hljs-comment">// 是否安全？</span><br>Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();  <span class="hljs-comment">//不安全</span><br><span class="hljs-comment">// 是否安全？</span><br>String S1 = <span class="hljs-string">&quot;...&quot;</span>;<span class="hljs-comment">//安全</span><br><span class="hljs-comment">// 是否安全？</span><br><span class="hljs-keyword">final</span> String S2 = <span class="hljs-string">&quot;...&quot;</span>;<span class="hljs-comment">//安全</span><br><span class="hljs-comment">// 是否安全？</span><br>Date D1 = <span class="hljs-keyword">new</span> Date();<span class="hljs-comment">//不安全</span><br><span class="hljs-comment">// 是否安全？</span><br><span class="hljs-keyword">final</span> Date D2 = <span class="hljs-keyword">new</span> Date();<span class="hljs-comment">//不安全，D2引用地址不会变，但是地址存的内容(如Date的属性)可能发生改变</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用上述变量</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><span class="hljs-comment">// 是否安全？ </span><br><span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl(); <span class="hljs-comment">//不安全，Servlet是单例的，UserServiceImpl有成员变量。多个线程会共享MyServlet</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>userService.update(...);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-comment">// 记录调用次数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// ...</span><br>count++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br><span class="hljs-comment">// 是否安全？</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">0L</span>; <span class="hljs-comment">// spring默认是单例的，这个MyAspect类会被共享，不安全。改成多例也不行，进入前置通知和后置通知时可能是不同的对象</span><br><span class="hljs-meta">@Before(&quot;execution(* *(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>start = System.nanoTime();<br>&#125;<br><span class="hljs-meta">@After(&quot;execution(* *(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">long</span> end = System.nanoTime();<br>System.out.println(<span class="hljs-string">&quot;cost time:&quot;</span> + (end-start));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以换成环绕通知，把成员变量变成局部变量</p></blockquote><p>例4：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><span class="hljs-comment">// 是否安全</span><br><span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl(); <span class="hljs-comment">// 线程安全，UserServiceImpl中有成员变量但是私有，外界无法修改</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>userService.update(...);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-comment">// 是否安全</span><br><span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<span class="hljs-comment">// 线程安全，userDaoImpl中没有共享的成员变量</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>userDao.update();<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br><span class="hljs-comment">// 是否安全 </span><br><span class="hljs-keyword">try</span> (Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>))&#123;<span class="hljs-comment">// 线程安全，Connection是局部变量，没有用到成员变量</span><br><span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例5：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><span class="hljs-comment">// 是否安全</span><br><span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>userService.update(...);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-comment">// 是否安全</span><br><span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>userDao.update();<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><span class="hljs-comment">// 是否安全</span><br><span class="hljs-keyword">private</span> Connection conn = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 线程不安全，Connection是成员变量，</span><br>    <span class="hljs-comment">//Myservlet是单例被个线程共享，UserDaoImpl以及成员变量Connection也是线程共享</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// ...</span><br>conn.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例6：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><span class="hljs-comment">// 是否安全</span><br><span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>userService.update(...);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl(); <span class="hljs-comment">// 线程安全，虽然Connection是成员变量</span><br>         <span class="hljs-comment">//，但是每次调用UserServiceImpl时都会创建新的Connection互不干扰</span><br>userDao.update();<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><span class="hljs-comment">// 是否安全</span><br><span class="hljs-keyword">private</span> Connection = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// ...</span><br>conn.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例7：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 是否安全</span><br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="hljs-comment">//线程不安全，虽然sdf是局部变量。但是子类可能启动一个新的线程并发</span><br>           <span class="hljs-comment">//访问，导致不安全的发生，造成泄漏</span><br>foo(sdf);<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title">foo</span><span class="hljs-params">(SimpleDateFormat sdf)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Test().bar();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为<strong>外星方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(SimpleDateFormat sdf)</span> </span>&#123;<br>String dateStr = <span class="hljs-string">&quot;1999-10-11 00:00:00&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>sdf.parse(dateStr);<br>&#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer i = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>List&lt;Thread&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">5000</span>; k++) &#123;<br><span class="hljs-keyword">synchronized</span> (i) &#123;<br>i++;<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-string">&quot;&quot;</span> + j);<br>list.add(thread);<br>&#125;<br>list.stream().forEach(t -&gt; t.start());<br>list.stream().forEach(t -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>t.join();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;);<br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4、Monitor"><a href="#3-4、Monitor" class="headerlink" title="3.4、Monitor"></a>3.4、Monitor</h2><h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>以 32 位虚拟机为例</p><h4 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-params">|--------------------------------------------------------------|</span><br><span class="hljs-params">| Object Header (64 bits)                    |</span><br><span class="hljs-params">|------------------------------------|</span>-------------------------<span class="hljs-params">|</span><br><span class="hljs-params">|</span> Mark Word (<span class="hljs-number">32</span> bits)  <span class="hljs-params">| Klass Word (32 bits)   |</span><br><span class="hljs-params">|------------------------------------|</span>-------------------------<span class="hljs-params">|</span><br></code></pre></td></tr></table></figure><h4 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">|---------------------------------------------------------------------------------|<br>| <span class="hljs-function">Object <span class="hljs-title">Header</span> <span class="hljs-params">(<span class="hljs-number">96</span> bits)</span>   |</span><br><span class="hljs-function">|--------------------------------|-----------------------|------------------------|</span><br><span class="hljs-function">| Mark <span class="hljs-title">Word</span><span class="hljs-params">(32bits)</span>  | Klass <span class="hljs-title">Word</span><span class="hljs-params">(32bits)</span>    | array <span class="hljs-title">length</span><span class="hljs-params">(32bits)</span>   |</span><br><span class="hljs-function">|--------------------------------|-----------------------|------------------------|</span><br></code></pre></td></tr></table></figure><p>其中 Mark Word 结构为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">|-------------------------------------------------------|--------------------|<br>| <span class="hljs-function">Mark <span class="hljs-title">Word</span> <span class="hljs-params">(<span class="hljs-number">32</span> bits)</span> | State |</span><br><span class="hljs-function">|-------------------------------------------------------|--------------------|</span><br><span class="hljs-function">| hashcode:25  | age:4 | biased_lock:0| 01 | Normal  |</span><br><span class="hljs-function">|-------------------------------------------------------|--------------------|</span><br><span class="hljs-function">| thread:23 | epoch:2 | age:4 | biased_lock:1 | 01 | Biased |</span><br><span class="hljs-function">|-------------------------------------------------------|--------------------|</span><br><span class="hljs-function">| ptr_to_lock_record:30 | 00| Lightweight Locked |</span><br><span class="hljs-function">|-------------------------------------------------------|--------------------|</span><br><span class="hljs-function">| ptr_to_heavyweight_monitor:30 | 10    | Heavyweight Locked |</span><br><span class="hljs-function">|-------------------------------------------------------|--------------------|</span><br><span class="hljs-function">| | 11| Marked <span class="hljs-keyword">for</span> GC   |</span><br><span class="hljs-function">|-------------------------------------------------------|--------------------|</span><br></code></pre></td></tr></table></figure><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用synchronized给对象上锁（<strong>重量级</strong>）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针。</p><p>原本对象头中的hashcode、age、biased_lock等信息会被复制到对应的Monitor对象中保存。解锁时，再复制回对象头</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.4.png"></p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.5.png"></p><ul><li><p>刚开始 Monitor 中 Owner 为 null</p></li><li><p>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。</p><p>（obj对象和Monitor对象，是一对一的）</p><ul><li>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。（Monitor中只能有一个 Owner）</li><li>如果已经绑定，则会去查询该Monitor是否已经有了Owner<ul><li>如果没有，则Owner与将当前线程绑定</li><li>如果有，则放入EntryList（阻塞队列），进入阻塞状态(blocked)</li></ul></li></ul></li><li><p>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></p></li><li><p><strong>注意</strong>：</p><ul><li>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</li><li>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</li></ul></li></ul><h3 id="字节码角度分析"><a href="#字节码角度分析" class="headerlink" title="字节码角度分析"></a>字节码角度分析</h3><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>counter++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的字节码为    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>descriptor: ([Ljava/lang/String;)V<br>flags: ACC_PUBLIC, ACC_STATIC<br>Code:<br>stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br><span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// &lt;- lock引用 （synchronized开始）</span><br><span class="hljs-number">3</span>: dup<br><span class="hljs-number">4</span>: astore_1 <span class="hljs-comment">// lock引用 -&gt; slot 1 (解锁时使用)</span><br><span class="hljs-number">5</span>: monitorenter <span class="hljs-comment">// 将 lock对象 MarkWord 置为 Monitor 指针</span><br><span class="hljs-number">6</span>: getstatic #<span class="hljs-number">3</span> <span class="hljs-comment">// &lt;- i</span><br><span class="hljs-number">9</span>: iconst_1 <span class="hljs-comment">// 准备常数 1</span><br><span class="hljs-number">10</span>: iadd <span class="hljs-comment">// +1</span><br><span class="hljs-number">11</span>: putstatic #<span class="hljs-number">3</span> <span class="hljs-comment">// -&gt; i</span><br><span class="hljs-number">14</span>: aload_1 <span class="hljs-comment">// &lt;- lock引用</span><br><span class="hljs-number">15</span>: monitorexit <span class="hljs-comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span><br><span class="hljs-number">16</span>: goto <span class="hljs-number">24</span><br><span class="hljs-number">19</span>: astore_2 <span class="hljs-comment">// e -&gt; slot 2 (发生异常，将异常对象存储)</span><br><span class="hljs-number">20</span>: aload_1 <span class="hljs-comment">// &lt;- lock引用</span><br><span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span><br><span class="hljs-number">22</span>: aload_2 <span class="hljs-comment">// &lt;- slot 2 (e)</span><br><span class="hljs-number">23</span>: athrow <span class="hljs-comment">// throw e</span><br><span class="hljs-number">24</span>: <span class="hljs-keyword">return</span><br>Exception table:<br>from to target type<br>  <span class="hljs-number">6</span>  <span class="hljs-number">16</span>  <span class="hljs-number">19</span>    any<br>  <span class="hljs-number">19</span> <span class="hljs-number">22</span>  <span class="hljs-number">19</span>     any<br>LineNumberTable:<br>line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>line <span class="hljs-number">9</span>: <span class="hljs-number">6</span><br>line <span class="hljs-number">10</span>: <span class="hljs-number">14</span><br>line <span class="hljs-number">11</span>: <span class="hljs-number">24</span><br>LocalVariableTable:<br>Start Length Slot Name     Signature<br>  <span class="hljs-number">0</span>     <span class="hljs-number">25</span>    <span class="hljs-number">0</span>   args [Ljava/lang/String;<br>StackMapTable: number_of_entries = <span class="hljs-number">2</span><br>frame_type = <span class="hljs-number">255</span> <span class="hljs-comment">/* full_frame */</span><br>offset_delta = <span class="hljs-number">19</span><br>locals = [ <span class="hljs-class"><span class="hljs-keyword">class</span> &quot;[<span class="hljs-title">Ljava</span>/<span class="hljs-title">lang</span>/<span class="hljs-title">String</span></span>;<span class="hljs-string">&quot;, class java/lang/Object ]</span><br><span class="hljs-string">stack = [ class java/lang/Throwable ]</span><br><span class="hljs-string">frame_type = 250 /* chop */</span><br><span class="hljs-string"> offset_delta = 4</span><br></code></pre></td></tr></table></figure><blockquote><p>在同步代码块内，发生了异常也会正常解锁</p><p>方法级别的 synchronized 不会在字节码指令中有所体现</p></blockquote><h2 id="3-5、Synchronized原理进阶"><a href="#3-5、Synchronized原理进阶" class="headerlink" title="3.5、Synchronized原理进阶"></a>3.5、Synchronized原理进阶</h2><h3 id="3-5-1-轻量级锁"><a href="#3-5-1-轻量级锁" class="headerlink" title="3.5.1 轻量级锁"></a>3.5.1 轻量级锁</h3><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。即用于优化Monitor这类的重量级锁。</p><p>轻量级锁对使用者是透明的，即语法<strong>仍然是synchronized</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 A</span><br>method2();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 B</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个<strong>锁记录</strong>对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）<ul><li>注意，此时对象mark word，最后是<strong>01，代表没有加锁</strong></li></ul></li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.6.png"></p><ul><li>让锁记录中的Object reference指向锁对象（Object），并尝试用<strong>cas</strong>去替换Object中的mark word，将此mark word放入lock record中保存</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.7.png"></p><ul><li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁<ul><li>注意，此时对象mark word，最后是<strong>00，代表轻量级锁状态</strong></li></ul></li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.8.png"></p><ul><li><p>如果 cas 失败，有两种情况</p><ul><li><p>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入<strong>锁膨胀</strong>过程</p></li><li><p>如果是自己执行了 synchronized <strong>锁重入</strong>，那么再添加一条 Lock Record 作为重入的计数</p></li></ul></li></ul><h3 id="3-5-2-锁重入"><a href="#3-5-2-锁重入" class="headerlink" title="3.5.2 锁重入"></a>3.5.2 锁重入</h3><ul><li>如果是自己执行了 synchronized <strong>锁重入</strong>，那么再添加一条 Lock Record 作为重入的计数（Object已经被自己线程锁住，可以正常使用）</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.9.png"></p><ul><li><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p></li><li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas <strong>将 Mark Word 的值恢复给对象头</strong></p><ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，<strong>进入重量级锁解锁流程</strong></li></ul></li></ul><h3 id="3-5-3-锁膨胀"><a href="#3-5-3-锁膨胀" class="headerlink" title="3.5.3 锁膨胀"></a>3.5.3 锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行<strong>锁膨胀</strong>，<strong>将轻量级锁变为重量级锁</strong>。</p><ul><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.10.png"></p><ul><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul><li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址<ul><li>注意，此时对象mark word，最后是<strong>10，代表重量级锁状态</strong></li></ul></li><li>然后自己进入 Monitor 的 EntryList BLOCKED</li></ul></li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.11.png"></p><ul><li>当 Thread-0退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会<strong>进入重量级解锁流程</strong>，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><h3 id="3-5-4-自旋优化"><a href="#3-5-4-自旋优化" class="headerlink" title="3.5.4 自旋优化"></a>3.5.4 自旋优化</h3><p><strong>重量级锁</strong>竞争时，还可以使用自旋来优化，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>），这时就可以避免线程进入阻塞状态。</p><ul><li>自旋成功</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.12.png"></p><ul><li>自旋失败</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.13.png"></p><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋反而浪费性能（一定自旋不开），多核 CPU 自旋才能发挥优势。</li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能</li></ul><h3 id="3-5-5-偏向锁"><a href="#3-5-5-偏向锁" class="headerlink" title="3.5.5 偏向锁"></a>3.5.5 偏向锁</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p><p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。即，<strong>偏向锁用于优化轻量级锁重入</strong></p><blockquote><p>JDK15已经默认禁用偏向锁机制</p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 A</span><br>m2();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><span class="hljs-comment">// 同步块 B</span><br>m3();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>            <span class="hljs-comment">// 同步块 C</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用偏向锁前：</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.14.png"></p><p>使用偏向锁前：</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.15.png"></p><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><ul><li><strong>Normal</strong>：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li><li><strong>Biased</strong>：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li><li><strong>Lightweight</strong>：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li><li><strong>Heavyweight</strong>：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.16.png"></p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101，这时它的thread、epoch、age 都为 0</li><li>但是偏向锁默认是<strong>有延迟</strong>的，不会在程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态<ul><li>如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay=0 来禁用延迟</li></ul></li><li>如果没有开启偏向锁，对象的Mark Word后三位应该是001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li></ul><h4 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h4><p>以下几种情况会使对象的偏向锁失效</p><ul><li>调用对象的hashCode方法<ul><li>调用了对象的 hashCode后，偏向锁的对象MarkWord中存储的线程 id会被hashCode所覆盖，导致偏向锁失效<ul><li>轻量级锁会在锁记录中记录 hashCode</li><li>重量级锁会在 Monitor 中记录 hashCode</li></ul></li></ul></li><li>多个线程使用该对象，，会将偏向锁升级为轻量级锁（不存在竞争时），存在竞争会升级到重量锁</li><li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li></ul><h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul><li>没有超过阈值时，重偏向会重置Thread ID</li></ul></li><li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li></ul><h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><p>当撤销偏向锁的阈值超过40以后，JVM就会将<strong>整个类的对象都改为不可偏向的</strong></p><h3 id="3-5-6-锁消除"><a href="#3-5-6-锁消除" class="headerlink" title="3.5.6 锁消除"></a>3.5.6 锁消除</h3><p>锁消除是发生在编译器级别的一种锁优化方式。如果判断到一段代码中，在<strong>堆上的所有数据都不会逃逸</strong>出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。 运行时就会消除锁，提高运行效率</p><p>锁消除是指虚拟机即时编译器（JIT）运行时，对一些代码上要求同步，但是被检测到<strong>不可能存在共享数据竞争</strong>的锁进行消除。</p><h3 id="3-5-7-锁粗化"><a href="#3-5-7-锁粗化" class="headerlink" title="3.5.7 锁粗化"></a>3.5.7 锁粗化</h3><p>在遇到一连串地对同一锁不断进行请求和释放的操作时，<strong>把所有的锁操作整合成锁的一次请求</strong>，从而减少对锁的请求同步次数。</p><h3 id="3-5-8-概述"><a href="#3-5-8-概述" class="headerlink" title="3.5.8 概述"></a>3.5.8 概述</h3><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.17.1.png"></p><h2 id="3-6、Wait-Notify"><a href="#3-6、Wait-Notify" class="headerlink" title="3.6、Wait/Notify"></a>3.6、Wait/Notify</h2><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.17.png"></p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li></ul><h4 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h4><p><code>obj.wait() </code>让进入 object 监视器的线程到 waitSet 等待。无限制等待，直到notify 为止</p><p><code>obj.wait(long n) </code>有时限的等待, 到 n 毫秒后结束等待，或是被 notify</p><p><code>obj.notify()</code> 在 object 上正在 waitSet 等待的线程中挑一个唤醒</p><p><code>obj.notifyAll() </code>让 object 上正在 waitSet 等待的线程全部唤醒</p><p><strong>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法</strong></p><ul><li><strong>锁对象调用wait方法（</strong>obj.wait），就会使当前线程进入WaitSet中，变为WAITING状态。</li><li>处于BLOCKED和WAITING状态的线程都为阻塞状态，CPU都不会分给他们时间片。但是有所区别：<ul><li>BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li></ul></li><li>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于WAITING状态的线程只有被<strong>锁对象调用了notify方法</strong>(obj.notify/obj.notifyAll)，才会被唤醒。</li></ul><blockquote><p>是锁对象调用wait\notify方法，调用前线程必须获得此对象的锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//只有在对象被锁住后才能调用wait方法</span><br><span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>LOCK.wait();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Wait与Sleep的区别"><a href="#Wait与Sleep的区别" class="headerlink" title="Wait与Sleep的区别"></a>Wait与Sleep的区别</h4><p><strong>不同点</strong></p><ul><li>Sleep是<strong>Thread</strong>类的静态方法，Wait是<strong>Object</strong>的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li><strong>Sleep在阻塞的时候不会释放锁</strong>，而Wait在阻塞的时候会释放锁</li><li>Sleep不需要与synchronized一起使用，而<strong>Wait需要与synchronized一起使用</strong>（对象被锁以后才能使用）</li></ul><p><strong>相同点</strong></p><ul><li>阻塞状态都为<strong>TIMED_WAITING</strong></li></ul><h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 等待的A线程</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br><span class="hljs-keyword">while</span>(条件不成立) &#123;<br>lock.wait();<br>&#125;<br><span class="hljs-comment">// 干活</span><br>&#125;<br><br><span class="hljs-comment">// 正在运行的B线程</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-7、同步模式之保护性暂停"><a href="#3-7、同步模式之保护性暂停" class="headerlink" title="3.7、同步模式之保护性暂停"></a>3.7、同步模式之保护性暂停</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果<br><strong>要点</strong></p><ul><li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li><li>因为要等待另一方的结果，因此归类到<strong>同步模式</strong></li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.18.png"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedSuspension01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String hello = <span class="hljs-string">&quot;hello thread!&quot;</span>;<br>        Guarded guarded = <span class="hljs-keyword">new</span> Guarded();<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;想要得到结果&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (guarded) &#123;<br>                System.out.println(<span class="hljs-string">&quot;结果是：&quot;</span>+guarded.getResponse());<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;得到结果&quot;</span>);<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;设置结果&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (guarded) &#123;<br>                guarded.setResponse(hello);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Guarded</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 要返回的结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">//优雅地使用wait/notify</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//如果返回结果为空就一直等待，避免虚假唤醒</span><br>        <span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(Object response)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.response = response;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">//唤醒休眠的线程</span><br>            <span class="hljs-keyword">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Guarded&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;response=&quot;</span> + response +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="带超时判断的暂停"><a href="#带超时判断的暂停" class="headerlink" title="带超时判断的暂停"></a>带超时判断的暂停</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time)</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-comment">//获取开始时间</span><br><span class="hljs-keyword">long</span> currentTime = System.currentTimeMillis();<br><span class="hljs-comment">//用于保存已经等待了的时间</span><br><span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">//看经过的时间-开始时间是否超过了指定时间</span><br><span class="hljs-keyword">long</span> waitTime = time -passedTime;<br><span class="hljs-keyword">if</span>(waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-comment">//等待剩余时间</span><br><span class="hljs-keyword">this</span>.wait(waitTime);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//获取当前时间</span><br>passedTime = System.currentTimeMillis()-currentTime;<br>            &#125;<br>&#125;<br><span class="hljs-keyword">return</span> response;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="join源码——使用保护性暂停模式"><a href="#join源码——使用保护性暂停模式" class="headerlink" title="join源码——使用保护性暂停模式"></a>join源码——使用保护性暂停模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">long</span> base = System.currentTimeMillis();<br><span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            <span class="hljs-keyword">long</span> delay = millis - now;<br>            <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            wait(delay);<br>            now = System.currentTimeMillis() - base;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-8、异步模式之生产者-消费者"><a href="#3-8、异步模式之生产者-消费者" class="headerlink" title="3.8、异步模式之生产者/消费者"></a>3.8、异步模式之生产者/消费者</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>要点</strong></p><ul><li>不需要产生结果和消费结果的线程一一对应</li><li>消费队列可以用来平衡生产和消费的线程资源</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.19.png"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MessageQueue queue = <span class="hljs-keyword">new</span> MessageQueue(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> id = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                queue.put(<span class="hljs-keyword">new</span> Message(id , <span class="hljs-string">&quot;值&quot;</span>+id));<br>            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                Message message = queue.take();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;消费者&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 消息队列类 ， java 线程之间通信</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueue</span> </span>&#123;<br>    <span class="hljs-comment">// 消息的队列集合</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// 队列容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capcity;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capcity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capcity = capcity;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 检查队列是否为空</span><br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-keyword">while</span>(list.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列为空, 消费者线程等待&quot;</span>);<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 从队列头部获取消息并返回</span><br>            Message message = list.removeFirst();<br>            log.debug(<span class="hljs-string">&quot;已消费消息 &#123;&#125;&quot;</span>, message);<br>            list.notifyAll();<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 存入消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-comment">// 检查对象是否已满</span><br>            <span class="hljs-keyword">while</span>(list.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列已满, 生产者线程等待&quot;</span>);<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将消息加入队列尾部</span><br>            list.addLast(message);<br>            log.debug(<span class="hljs-string">&quot;已生产消息 &#123;&#125;&quot;</span>, message);<br>            list.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> Object value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, value=&quot;</span> + value +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.19.1.png"></p><h2 id="3-9、park-unpark"><a href="#3-9、park-unpark" class="headerlink" title="3.9、park/unpark"></a>3.9、park/unpark</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>park/unpark都是LockSupport类中的的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//暂停线程运行</span><br>LockSupport.park;<br><br><span class="hljs-comment">//恢复线程运行</span><br>LockSupport.unpark(thread);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;park&quot;</span>);<br>        <span class="hljs-comment">//暂停线程运行</span><br>        LockSupport.park();<br>        System.out.println(<span class="hljs-string">&quot;resume&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    thread.start();<br>    <br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">&quot;unpark&quot;</span>);<br>    <span class="hljs-comment">//恢复线程运行</span><br>    LockSupport.unpark(thread);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>与wait/notify的区别</strong></p><ul><li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必。Object.wait()方法需要在synchronized块中执行；</li><li>park ，unpark 是以<strong>线程为单位</strong>来<strong>阻塞</strong>和<strong>唤醒</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</li><li>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify<ul><li><strong>在wait()之前执行了notify()会抛出IllegalMonitorStateException异常</strong>；</li><li><strong>在park()之前执行了unpark()，线程不会被阻塞，直接跳过park()，继续执行后续内容；</strong></li></ul></li><li><strong>park不会释放锁</strong>，而wait会释放锁</li></ul><p><strong>Thread.sleep()和LockSupport.park()的区别</strong><br>LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。</p><p>（1）从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且<strong>都不会释放当前线程占有的锁资源</strong>；</p><p>（2）Thread.sleep()没法从外部唤醒，只能自己醒过来；</p><p>（3）LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；</p><p>（4）Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；</p><p>（5）LockSupport.park()方法不需要捕获中断异常；</p><p>（6）Thread.sleep()本身就是一个native方法；</p><p>（7）LockSupport.park()底层是调用的Unsafe的native方法；</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象**_counter, _cond,__mutex**组成</p><ul><li>先调用park再调用unpark时<ul><li>先调用park<ul><li>线程运行时，会将Park对象中的**_counter的值设为0**；</li><li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li><li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li></ul></li><li>然后调用unpark<ul><li>调用unpark方法后，会将counter的值设置为1</li><li>去唤醒阻塞队列cond中的线程</li><li>线程继续运行并将counter的值设为0</li></ul></li></ul></li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.20.png"></p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.21.png"></p><p>先调用unpark，再调用park</p><ul><li>调用unpark<ul><li>会将counter设置为1（运行时0）</li></ul></li><li>调用park方法<ul><li>查看counter是否为0</li><li>因为unpark已经把counter设置为1，所以此时将counter设置为0，但<strong>不放入</strong>阻塞队列cond中</li></ul></li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.22.png"></p><blockquote><ul><li><code>interrupt()</code>会使得中断状态为<code>true</code>，并调用<code>unpark</code></li><li><code>park</code>调用后一定会消耗掉<code>permit</code>，无论<code>unpark</code>操作先做还是后做。</li><li>如果<code>中断状态</code>为true，那么<code>park</code>无法阻塞。</li><li><code>unpark</code>会使得<code>permit</code>为1，并唤醒处于阻塞的线程。</li></ul></blockquote><h2 id="3-10、线程中的状态转换"><a href="#3-10、线程中的状态转换" class="headerlink" title="3.10、线程中的状态转换"></a>3.10、线程中的状态转换</h2><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.23.png"></p><h3 id="情况一：NEW-–-gt-RUNNABLE"><a href="#情况一：NEW-–-gt-RUNNABLE" class="headerlink" title="情况一：NEW –&gt; RUNNABLE"></a>情况一：NEW –&gt; RUNNABLE</h3><ul><li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE</li></ul><h3 id="情况二：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况二：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况二： RUNNABLE &lt;–&gt; WAITING"></a>情况二： RUNNABLE &lt;–&gt; WAITING</h3><ul><li>当调用了t 线程用 synchronized(obj) 获取了对象锁后<ul><li>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li><li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li></ul></li></ul></li></ul><h3 id="情况三：RUNNABLE-lt-–-gt-WAITING"><a href="#情况三：RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;–&gt; WAITING"></a>情况三：RUNNABLE &lt;–&gt; WAITING</h3><ul><li><p>当前线程</p><p>调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING</p><ul><li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li></ul></li><li><p>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</p></li></ul><h3 id="情况四：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;–&gt; WAITING"></a>情况四： RUNNABLE &lt;–&gt; WAITING</h3><ul><li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li></ul><h3 id="情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 synchronized(obj) 获取了对象锁后</p><ul><li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li></ul></li></ul><h3 id="情况六：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li><p>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING</p><ul><li>注意是当前线程在t 线程对象的监视器上等待</li></ul></li><li><p>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</p></li></ul><h3 id="情况七：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ul><h3 id="情况八：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li></ul><h3 id="情况九：RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;–&gt; BLOCKED"></a>情况九：RUNNABLE &lt;–&gt; BLOCKED</h3><ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然 BLOCKED</li></ul><h3 id="情况十：-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;–&gt; TERMINATED"></a>情况十： RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/image-20210330110237353.png" alt="image-20210330110237353"></p><h2 id="3-11、多把锁"><a href="#3-11、多把锁" class="headerlink" title="3.11、多把锁"></a>3.11、多把锁</h2><p><strong>将锁的粒度细分</strong></p><ul><li>好处，可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;<br>    <span class="hljs-comment">//额外创建对象来作为锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object studyRoom = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object bedRoom = <span class="hljs-keyword">new</span> Object();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-12、活跃性"><a href="#3-12、活跃性" class="headerlink" title="3.12、活跃性"></a>3.12、活跃性</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p><p>如：t1线程获得A对象 锁，接下来想获取B对象的锁t2线程获得B对象锁，接下来想获取A对象的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Object A = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">final</span> Object B = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">synchronized</span> (A) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (B) &#123;<br>                <br>            &#125;<br>        &#125;<br>    &#125;).start();<br>    <br>    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">synchronized</span> (B) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (A) &#123;<br><br>            &#125;<br>        &#125;<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h4><ul><li>互斥条件<ul><li>在一段时间内，一种资源只能被一个进程所使用</li></ul></li><li>请求和保持条件<ul><li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li></ul></li><li>不可抢占条件<ul><li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li></ul></li><li>循环等待条件<ul><li>发生死锁时，必然存在一个进程——资源的循环链。</li></ul></li></ul><h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><ul><li>jps+jstack ThreadID</li><li>在JAVA控制台中的Terminal中输入<strong>jps</strong>指令可以查看运行中的线程ID  <img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.23.1.png"><ul><li><p>使用<strong>jstack ThreadID</strong>可以查看线程状态。</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.23.2.png"></p></li></ul></li><li>jconsole检测死锁</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.23.3.png"></p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.23.4.png"></p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.23.5.png"></p><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.24.png"></p><h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.25.png"></p><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p><h4 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h4><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p><h4 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h4><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p><p>在使用顺序加锁时，可能会出现饥饿现象</p><h2 id="3-12、ReentrantLock"><a href="#3-12、ReentrantLock" class="headerlink" title="3.12、ReentrantLock"></a>3.12、ReentrantLock</h2><h3 id="和synchronized相比具有的的特点"><a href="#和synchronized相比具有的的特点" class="headerlink" title="和synchronized相比具有的的特点"></a>和synchronized相比具有的的特点</h3><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁 (先到先得)</li><li>支持多个条件变量( 具有<strong>多个</strong>waitset)</li></ul><p>与 synchronized 一样，都支持可重入</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取ReentrantLock对象</span><br><span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">//加锁</span><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//需要执行的代码</span><br>&#125;<span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//释放锁</span><br>lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p><p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;加可打断锁&quot;</span>);<br>                <span class="hljs-comment">//加锁，可打断锁</span><br>                lock.lockInterruptibly();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-comment">//被打断，返回，不再向下执行</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>                <span class="hljs-comment">//释放锁</span><br>                lock.unlock();<br>            &#125;<br>        &#125;);<br><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            t1.start();<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-comment">//打断</span><br>            t1.interrupt();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</p></blockquote><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p><p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位</p><p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p><p>不设置等待时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-comment">//如果未设置等待时间，一旦获取失败，直接返回false</span><br>            <span class="hljs-keyword">if</span>(!lock.tryLock()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>                <span class="hljs-comment">//获取失败，不再向下执行，返回</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);<br>            lock.unlock();<br>        &#125;);<br><br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            t1.start();<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置等待时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//判断获取锁是否成功，最多等待1秒</span><br>                <span class="hljs-keyword">if</span>(!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>                    <span class="hljs-comment">//获取失败，不再向下执行，直接返回</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-comment">//被打断，不再向下执行，直接返回</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;);<br><br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            t1.start();<br>            <span class="hljs-comment">//打断等待</span><br>            t1.interrupt();<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span><br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><blockquote><p>公平锁一般没有必要，会降低并发度</p></blockquote><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet的阻塞队列，当条件不满足时进入waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul><p>使用要点：</p><ul><li>await 前需要<strong>获得锁</strong></li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock04</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>        <span class="hljs-comment">//获得条件变量</span><br>        Condition condition = lock.newCondition();<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">while</span>(!judge) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;不满足条件，等待...&quot;</span>);<br>                    <span class="hljs-comment">//等待</span><br>                    condition.await();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;执行完毕！&quot;</span>);<br>                lock.unlock();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1</span>);<br>                judge = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">//释放</span><br>                condition.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br><br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>wait()与await()</strong></p><ul><li><p>await是ConditionObject类里面的方法，ConditionObject实现了Condition接口</p></li><li><p>ReentrantLock里面默认有实现newCondition()方法，新建一个条件对象。该方法就是用在ReentrantLock中根据条件来设置等待。唤醒方法也是由专门的Signal()或者Signal()来执行。另外await会导致当前线程被阻塞，会<strong>放弃锁</strong>，这点和wait是一样的。</p></li><li><p>由于所在的超类不同使用场景也不同，wait一般用于Synchronized中，而await只能用于ReentrantLock锁中</p></li><li><p><code>Condition</code>对象可以提供和<code>Object</code>的<code>wait</code>和<code>notify</code>一样的行为，但是后者必须先获取<code>synchronized</code>这个内置的<code>monitor</code>锁才能调用，而<code>Condition</code>则必须先获取<code>ReentrantLock</code>。这两种方式在阻塞等待时都会将相应的锁释放掉</p></li></ul><h2 id="3-13、同步模式之顺序控制"><a href="#3-13、同步模式之顺序控制" class="headerlink" title="3.13、同步模式之顺序控制"></a>3.13、同步模式之顺序控制</h2><h3 id="固定运行顺序"><a href="#固定运行顺序" class="headerlink" title="固定运行顺序"></a>固定运行顺序</h3><h4 id="Wait-Notify版"><a href="#Wait-Notify版" class="headerlink" title="Wait/Notify版"></a>Wait/Notify版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> startFromT1 = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">while</span> (!startFromT1)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;线程t1开始运行&quot;</span>);<br>                startFromT1 = !startFromT1;<br>                lock.notifyAll();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">while</span> (startFromT1)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;线程t2开始运行&quot;</span>);<br>                startFromT1 = !startFromT1;<br>                lock.notifyAll();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>存在的缺点</strong>：</p><ul><li>首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该wait</li><li>第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决此问题</li><li>最后，唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个</li></ul><h4 id="Park-Unpark版"><a href="#Park-Unpark版" class="headerlink" title="Park/Unpark版"></a>Park/Unpark版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkUnPark</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;线程t2开始运行&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;线程t1开始运行&quot;</span>);<br>            LockSupport.unpark(t2);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc</p><h4 id="Wait-Notify版-1"><a href="#Wait-Notify版-1" class="headerlink" title="Wait/Notify版"></a>Wait/Notify版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Symbol symbol = <span class="hljs-keyword">new</span> Symbol(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            symbol.print(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            symbol.print(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            symbol.print(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Symbol</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Symbol</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = flag;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> waitFlag, <span class="hljs-keyword">int</span> nextFlag, String str)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.flag != waitFlag) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                flag = nextFlag;<br>                <span class="hljs-keyword">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Lock-条件变量版"><a href="#Lock-条件变量版" class="headerlink" title="Lock 条件变量版"></a>Lock 条件变量版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal();<br>    <span class="hljs-keyword">static</span> Condition conditionA = awaitSignal.newCondition();<br>    <span class="hljs-keyword">static</span> Condition conditionB = awaitSignal.newCondition();<br>    <span class="hljs-keyword">static</span> Condition conditionC = awaitSignal.newCondition();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            awaitSignal.run(<span class="hljs-string">&quot;a&quot;</span>, conditionA, conditionB);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            awaitSignal.run(<span class="hljs-string">&quot;b&quot;</span>, conditionB, conditionC);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            awaitSignal.run(<span class="hljs-string">&quot;c&quot;</span>, conditionC, conditionA);<br>        &#125;).start();<br>        awaitSignal.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//唤醒一个等待的线程</span><br>            conditionA.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            awaitSignal.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String str, Condition thisCondition, Condition nextCondition)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;loopNumber; i++) &#123;<br>            lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//全部进入等待状态</span><br>                thisCondition.await();<br>                System.out.print(str);<br>                nextCondition.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber=<span class="hljs-number">5</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLoopNumber</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> loopNumber;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoopNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>简化后</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.igotcha.chapter.chapter3.alternateOutput;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Gotcha</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/9/1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@describe</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockCondition02</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    Condition c1 = lock.newCondition();<br>    Condition c2 = lock.newCondition();<br>    Condition c3 = lock.newCondition();<br><br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>)&#123;<br>                    c1.await();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>                count++;<br>                c2.signal();<span class="hljs-comment">// 唤醒条件2</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span> != <span class="hljs-number">1</span>)&#123;<br>                    c2.await();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>                count++;<br>                c3.signal();<span class="hljs-comment">// 唤醒条件3</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    Thread t3 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span> != <span class="hljs-number">2</span>)&#123;<br>                    c3.await();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;C&quot;</span>);<br>                count++;<br>                c1.signal();<span class="hljs-comment">// 唤醒条件1</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">long</span> t1 = System.currentTimeMillis();<br>        LockCondition02 l2 = <span class="hljs-keyword">new</span> LockCondition02();<br>        l2.t3.start();<br>        l2.t1.start();<br>        l2.t2.start();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (System.currentTimeMillis() - t1 &gt;= <span class="hljs-number">50</span>)<br>                System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Park-Unpark-版"><a href="#Park-Unpark-版" class="headerlink" title="Park/Unpark 版"></a>Park/Unpark 版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkUnPark</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SyncPark syncPark = <span class="hljs-keyword">new</span> SyncPark(<span class="hljs-number">5</span>);<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            syncPark.print(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            syncPark.print(<span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            syncPark.print(<span class="hljs-string">&quot;c&quot;</span>);<br>        &#125;);<br>        syncPark.setThreads(t1, t2, t3);<br>        syncPark.start();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncPark</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;<br>    <span class="hljs-keyword">private</span> Thread[] threads;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SyncPark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setThreads</span><span class="hljs-params">(Thread... threads)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.threads = threads;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            LockSupport.park();<br>            System.out.print(str);<br>            LockSupport.unpark(nextThread());<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Thread <span class="hljs-title">nextThread</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(threads[i] == current) &#123;<br>                index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index &lt; threads.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> threads[index+<span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> threads[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            thread.start();<br>        &#125;<br>        LockSupport.unpark(threads[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-14、ThreadLocal"><a href="#3-14、ThreadLocal" class="headerlink" title="3.14、ThreadLocal"></a>3.14、ThreadLocal</h2><p>ThreadLocal是一个关于创建线程局部变量的类。通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量。</p><p><strong>类关系图</strong></p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/image-20210824153043627.png" alt="image-20210824153043627"></p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/image-20210823211216473.png" alt="image-20210823211216473"></p><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul><li><p><code>initialValue</code>：初始化。在<code>get</code>方法里懒加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//触发时机：调用get方法之前没有调用set方法，则get方法内部会触发initialValue，也就是说get的时候如果没拿到东西，则会触发initialValue。</span><br><br><span class="hljs-comment">// 由子类提供实现。</span><br><span class="hljs-comment">// protected的含义就是交给子类干的。</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>get</code>：得到这个线程对应的value。如果调用get之前没set过，则get内部会执行<code>initialValue</code>方法进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取当前线程下的entry里的value值。</span><br><span class="hljs-comment"> * 先获取当前线程下的ThreadLocalMap，</span><br><span class="hljs-comment"> * 然后以当前ThreadLocal为key取出map中的value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    Thread t = Thread.currentThread();<br>    <span class="hljs-comment">// 获取当前线程对应的ThreadLocalMap对象。</span><br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-comment">// 若获取到了。则获取此ThreadLocalMap下的entry对象，若entry也获取到了，那么直接获取entry对应的value返回即可。</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 获取此ThreadLocalMap下的entry对象</span><br>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">// 若entry也获取到了</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-comment">// 直接获取entry对应的value返回。</span><br>            T result = (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 若没获取到ThreadLocalMap或没获取到Entry，则设置初始值。</span><br>    <span class="hljs-comment">// 知识点：初始值方法是延迟加载，只有在get才会用到，这下看到了吧，只有在这获取没获取到才会初始化，下次就肯定有值了，所以只会执行一次！！！</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>set</code>：为这个线程设置一个新值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置当前线程的线程局部变量的值</span><br><span class="hljs-comment"> * 实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    Thread t = Thread.currentThread();<br>    <span class="hljs-comment">// 获取当前线程对应的ThreadLocalMap实例，注意这里是将t传进去了，t是当前线程，就是说ThreadLocalMap是在线程里持有的引用。</span><br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-comment">// 若当前线程有对应的ThreadLocalMap实例，则将当前ThreadLocal对象作为key，value做为值存到ThreadLocalMap的entry里。</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 若当前线程没有对应的ThreadLocalMap实例，则创建ThreadLocalMap，并将此线程与之绑定</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>set其实干的事和<code>initialValue</code>是一样的，都是set值，只是调用时机不同。set是想用就用，api摆在这里，你想用就调一下set方法。很自由。</p></blockquote></li><li><p><code>remove</code>：删除这个线程对应的值，防止内存泄露的最佳手段。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前线程的ThreadLocalMap对象，并将其移除。</span><br>    ThreadLocalMap m = getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// 直接移除以当前ThreadLocal为key的value</span><br>        m.remove(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 本地线程。Thread：线程。Local：本地</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 构造器</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadLocal</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">// 初始值，用来初始化值用的，比如：ThreadLocal&lt;Integer&gt; count = new ThreadLocal&lt;&gt;();</span><br>    <span class="hljs-comment">// 你想Integer value = count.get(); value++;这样是报错的，因为count现在还没值，取出来的是个null,所以你需要先重写此方法为value赋上初始值，本身方法是protected也代表就是为了子类重写的。</span><br>    <span class="hljs-comment">// 此方法是一个延迟调用方法，在线程第一次调用get的时候才执行，下面具体分析源码就知道了。</span><br> <span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">// 创建ThreadLocalMap，ThreadLocal底层其实就是一个map来维护的。</span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">// 返回该当前线程对应的线程局部变量值。</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">// 获取ThreadLocalMap</span><br> <span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">// 设置当前线程的线程局部变量的值</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">// 将当前线程局部变量的值删除，目的是为了减少内存占用。其实当线程结束后对应该线程的局部变量将自动被垃圾回收，所以无需我们调用remove，我们调用remove无非也就是加快内存回收速度。</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">// 设置初始值，调用initialValue</span><br> <span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">setInitialValue</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">// 静态内部类，一个map来维护的！！！</span><br> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<br>  <br>        <span class="hljs-comment">// ThreadLocalMap的静态内部类，继承了弱引用，这正是不会造成内存泄漏根本原因</span><br>        <span class="hljs-comment">// Entry的key为ThreadLocal并且是弱引用。value是值</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;&#125;<br> &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>这个东西是归<code>Thread</code>类所有的。它的引用在<code>Thread</code>类里，这也证实了一个问题：<code>ThreadLocalMap</code>类内部为什么有<code>Entry</code>数组，而不是<code>Entry</code>对象？</p><p>因为你业务代码能new好多个<code>ThreadLocal</code>对象，各司其职。但是在一次请求里，也就是一个线程里，<code>ThreadLocalMap</code>是同一个，而不是多个，不管你new几次<code>ThreadLocal</code>，<code>ThreadLocalMap</code>在一个线程里就一个，因为再说一次，<code>ThreadLocalMap</code>的引用是在<code>Thread</code>里的，所以它里面的<code>Entry</code>数组存放的是一个线程里你new出来的多个<code>ThreadLocal</code>对象。</p><p>核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在调用ThreadLocal.get()方法的时候就会调用这个方法，它的返回是当前线程里的threadLocals的引用。</span><br><span class="hljs-comment">// 这个引用指向的是ThreadLocal里的ThreadLocalMap对象</span><br><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-comment">// ThreadLocal.ThreadLocalMap</span><br>    ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一句话总结就是：<code>Thread</code>维护了<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>里维护了<code>Entry</code>，而<code>Entry</code>里存的是以<code>ThreadLocal</code>为key，传入的值为value的键值对。</p></blockquote><p><strong>下面这段程序会输出什么？为什么？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThreadLocalNpe</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">()</span> </span>&#123;<br>        threadLocal.set(<span class="hljs-number">1L</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> threadLocal.get();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            set();<br>            System.out.println(get());<br>        &#125;).start();<br>        <span class="hljs-comment">// 目的就是为了让子线程先运行完</span><br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        System.out.println(get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">1<br>Exception in thread &quot;main&quot; java.lang.NullPointerException<br> at com.chentongwei.study.thread.TestThreadLocalNpe.get(TestThreadLocalNpe.java:16)<br> at com.chentongwei.study.thread.TestThreadLocalNpe.main(TestThreadLocalNpe.java:26)<br></code></pre></td></tr></table></figure><p>为什么第二个输出导致空指针，因为get方法用的long而不是Long，long是基本类型，默认值是0。<code>ThreadLocal</code>里的泛型是Long，get却是基本类型，这需要拆箱操作的，也就是会执行<code>null.longValue()</code>的操作，会导致空指针。</p><p><strong>使用场景</strong></p><ul><li><p>Spring实现事务隔离级别</p><p>Spring采用Threadlocal的方式，来保证单个线程中的数据库操作使用的是同一个数据库连接，同时，采用这种方式可以使业务层使用事务时不需要感知并管理connection对象，通过传播级别，巧妙地管理多个事务配置之间的切换，挂起和恢复。</p></li></ul><p><strong>ThreadLocal的实例以及其值存放在栈上吗</strong></p><p>其实不是的，因为ThreadLocal实例实际上也是被其创建的类持有（更顶端应该是被线程持有），而ThreadLocal的值其实也是被线程实例持有，它们都是位于堆上，只是通过一些技巧将可见性修改成了线程可见。</p><p><strong>ThreadLocalMap的key为什么设计成弱引用</strong></p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/image-20210824153716407.png" alt="image-20210824153716407"></p><ul><li><p>key不设置成弱引用的话就会造成和entry中value一样内存泄漏的场景。</p><blockquote><p> ThreadLocal的不足，可以通过看看netty的fastThreadLocal来弥补</p></blockquote></li></ul><hr><h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="4-1、JAVA内存模型（JMM）"><a href="#4-1、JAVA内存模型（JMM）" class="headerlink" title="4.1、JAVA内存模型（JMM）"></a>4.1、JAVA内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享内存）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p><p><strong>JMM体现在以下几个方面</strong></p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受cpu缓存的影响</li><li>有序性 - 保证指令不会受cpu指令并行优化的影响</li></ul><h2 id="4-2、可见性"><a href="#4-2、可见性" class="headerlink" title="4.2、可见性"></a>4.2、可见性</h2><h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><p><strong>退出不出的循环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span> (run) &#123;<br>            <span class="hljs-comment">//如果run为真，则一直执行</span><br>        &#125;<br>    &#125;).start();<br><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);<br>    run = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么无法退出该循环</strong></p><ul><li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.1.png"></p><ul><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的高速缓存中， 减少对主存中 run 的访问，提高效率</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.2.png"></p><ul><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是<strong>旧值</strong></li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.3.png"></p><p><strong>解决方法</strong></p><ul><li>使用<strong>volatile</strong>易变关键字</li><li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Volatile01</span> </span>&#123;<br>    <span class="hljs-comment">//使用易变关键字</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (run) &#123;<br>                <span class="hljs-comment">//如果run为真，则一直执行</span><br>            &#125;<br>        &#125;).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);<br>        run = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能保证原子性</strong>，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p><ul><li><p>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。（当代码块内变量完全被synchronized 接管时，也保证<strong>有序性</strong>）</p></li><li><p>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</p></li><li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p><ul><li><p>因为使用了<strong>synchronized</strong>关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String x)</span> </span>&#123;<br>    <span class="hljs-comment">//使用了synchronized关键字</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        print(x);<br>        newLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="两阶终止模式优化"><a href="#两阶终止模式优化" class="headerlink" title="两阶终止模式优化"></a>两阶终止模式优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTerminationPattern</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>        monitor.start();<br>        monitor.start();<br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        monitor.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;<br>    Thread monitor;<br>    <span class="hljs-comment">//设置标记，用于判断是否被终止了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>        monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//开始不停的监控</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(stop) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//线程休眠</span><br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于停止监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//打断线程</span><br>        monitor.interrupt();<br>        <span class="hljs-comment">//修改标记</span><br>        stop = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同步模式之犹豫模式"><a href="#同步模式之犹豫模式" class="headerlink" title="同步模式之犹豫模式"></a>同步模式之犹豫模式</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong></p><ul><li>用一个标记来判断该任务是否已经被执行过了</li><li>需要避免线程安全问题<ul><li>加锁的代码块要尽量的小，以保证性能</li></ul></li></ul><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HesitationMode</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Monitor2 monitor2 = <span class="hljs-keyword">new</span> Monitor2();<br>        monitor2.start();<br>        monitor2.start();<br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        monitor2.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor2</span> </span>&#123;<br>    Thread monitor;<br>    <span class="hljs-comment">//设置标记，用于判断是否被终止了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//设置标记，用于判断是否已经启动过了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//启动监控器线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//上锁，避免多线程运行时出现线程安全问题</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-comment">//已被启动，直接返回</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//启动监视器，改变标记</span><br>            starting = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>        monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//开始不停的监控</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(stop) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//线程休眠</span><br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        monitor.start();<br>    &#125;<br>    <span class="hljs-comment">//用于停止监控器线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//打断线程</span><br>        monitor.interrupt();<br>        stop = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3、有序性"><a href="#4-3、有序性" class="headerlink" title="4.3、有序性"></a>4.3、有序性</h2><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul><li>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.4.png"></p><p>这种特性称之为『<strong>指令重排</strong>』，<strong>多线程下『指令重排』会影响正确性</strong>。</p><h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><ul><li>事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.5.png"></p><blockquote><p>现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。</p></blockquote><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.6.png"></p><ul><li>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong></li><li>指令重排的前提是，重排指令<strong>不能影响结果</strong>，例如</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子 </span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>; <br>System.out.println( a + b );<br><br><span class="hljs-comment">// 不能重排的例子 </span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = a - <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p><ul><li>禁止的是加volatile关键字变量之前的代码被重排序</li></ul><h2 id="4-5、volatile-原理"><a href="#4-5、volatile-原理" class="headerlink" title="4.5、volatile 原理"></a>4.5、volatile 原理</h2><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>num = <span class="hljs-number">2</span>;<br>ready = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// ready 是 volatile 赋值带写屏障</span><br><span class="hljs-comment">// 写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br><span class="hljs-comment">// 读屏障</span><br><span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br><span class="hljs-keyword">if</span>(ready) &#123;<br>r.r1 = num + num;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r.r1 = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.7.png"></p><h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p></li></ul><h3 id="不能保证原子性"><a href="#不能保证原子性" class="headerlink" title="不能保证原子性"></a>不能保证原子性</h3><ul><li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.8.png"></p><h3 id="double-checked-locking-问题"><a href="#double-checked-locking-问题" class="headerlink" title="double-checked locking 问题"></a>double-checked locking 问题</h3><p>以著名的 double-checked locking 单例模式为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t2</span><br><span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><br><span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span><br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li></ul><p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">0:</span> <span class="hljs-string">getstatic</span>  <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attr">3:</span> <span class="hljs-string">ifnonnull</span>  <span class="hljs-number">37</span><br><span class="hljs-attr">6:</span> <span class="hljs-string">ldc</span>      <span class="hljs-comment">#3 // class cn/itcast/n5/Singleton</span><br><span class="hljs-attr">8:</span> <span class="hljs-string">dup</span><br><span class="hljs-attr">9:</span> <span class="hljs-string">astore_0</span><br><span class="hljs-attr">10:</span> <span class="hljs-string">monitorenter</span><br><span class="hljs-attr">11:</span> <span class="hljs-string">getstatic</span>  <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attr">14:</span> <span class="hljs-string">ifnonnull</span>     <span class="hljs-number">27</span><br><span class="hljs-attr">17:</span> <span class="hljs-string">new</span> <span class="hljs-comment">#3 // class cn/itcast/n5/Singleton</span><br><span class="hljs-attr">20:</span> <span class="hljs-string">dup</span><br><span class="hljs-attr">21:</span> <span class="hljs-string">invokespecial</span>    <span class="hljs-comment">#4 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-attr">24:</span> <span class="hljs-string">putstatic</span>  <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attr">27:</span> <span class="hljs-string">aload_0</span><br><span class="hljs-attr">28:</span> <span class="hljs-string">monitorexit</span><br><span class="hljs-attr">29:</span> <span class="hljs-string">goto</span> <span class="hljs-number">37</span><br><span class="hljs-attr">32:</span> <span class="hljs-string">astore_1</span><br><span class="hljs-attr">33:</span> <span class="hljs-string">aload_0</span><br><span class="hljs-attr">34:</span> <span class="hljs-string">monitorexit</span><br><span class="hljs-attr">35:</span> <span class="hljs-string">aload_1</span><br><span class="hljs-attr">36:</span> <span class="hljs-string">athrow</span><br><span class="hljs-attr">37:</span> <span class="hljs-string">getstatic</span>  <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attr">40:</span> <span class="hljs-string">areturn</span><br></code></pre></td></tr></table></figure><p>其中</p><ul><li>17 表示创建对象，将对象引用入栈 // new Singleton</li><li>20 表示复制一份对象引用 // 引用地址</li><li>21 表示利用一个对象引用，调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE<br><strong>也许 jvm 会优化为：先执行 24，再执行 21</strong>。如果两个线程 t1，t2 按如下时间序列执行：</li></ul><p>关键在于 <strong>0: getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取INSTANCE 变量的值</strong></p><p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例<br>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p><strong>happens-before 规定了对共享变量的写操作对其它线程的读操作可见</strong>，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ul><li><p>线程解锁m之前对变量的写，对于接下来对m加锁的其它线程对该变量的读可见</p><ul><li><code>synchronized(m)</code></li></ul></li><li><p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p><ul><li><code>volatile static int x</code></li></ul></li><li><p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p></li><li><p>线程结束前对变量的写，对其它线程得知它结束后的读可见</p><ul><li>比如其它线程调用 <code>t1.isAlive()</code> 或 <code>t1.join()</code>等待它结束</li></ul></li><li><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见</p><ul><li>通过<code>t2.interrupted</code> 或 <code>t2.isInterrupted</code></li></ul></li><li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p></li><li><p>使用<code>volatile</code>指令</p></li><li><p>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</p></li></ul><h2 id="4-6、线程安全单例习题"><a href="#4-6、线程安全单例习题" class="headerlink" title="4.6、线程安全单例习题"></a>4.6、线程安全单例习题</h2><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题</p><blockquote><p>饿汉式：类加载就会导致该单实例对象被创建<br>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></blockquote><p>实现1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：为什么加 final,答：防止子类继承后覆盖父类方法，破坏单例模式</span><br><span class="hljs-comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例，答：增加readResolve方法，反序列化过程中，发现readResolve有对象，就直接用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><span class="hljs-comment">// 问题3：为什么设置为私有? 是否能防止反射创建新的实例?，答：防止其他类用构造方法创建这个类的对象，不能防止暴力反射</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?，答：可以，静态成员变量在类加载阶段完成，由JVM保证</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由，答：提供更好的封装性，提供懒汉模式，提供泛型支持</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：枚举单例是如何限制实例个数的，答：反编译后得知，其是本质上枚举类的静态成员变量</span><br><span class="hljs-comment">// 问题2：枚举单例在创建时是否有并发问题，答：没有，静态成员变量在类加载阶段完成，由JVM保证</span><br><span class="hljs-comment">// 问题3：枚举单例能否被反射破坏单例，答：不能</span><br><span class="hljs-comment">// 问题4：枚举单例能否被反序列化破坏单例，答：不会，枚举类默认实现序列化接口，保证了不会被破坏</span><br><span class="hljs-comment">// 问题5：枚举单例属于懒汉式还是饿汉式，答：饿汉式</span><br><span class="hljs-comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做，答：增加构造方法</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//懒汉式单例</span><br><span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点，答：将锁加到了静态方法上，即类上。可以保证线程安全</span><br>    <span class="hljs-comment">// 缺点，锁的范围比较大，性能较低</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-keyword">null</span> )&#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现4：DCL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><span class="hljs-comment">// 问题1：解释为什么要加 volatile ，答：防止指令重排序，发生（先赋值操作，再构造方法，导致其他线程可能拿到一个null）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义，答：减小锁的范围，提高性能</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br><span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗，答：防止同时多个线程都在首次创建对象</span><br><span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123; <br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现5（推荐）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><span class="hljs-comment">// 问题1：属于懒汉式还是饿汉式，答：懒汉式，因为类加载是懒汉式。只加载外部类时候，不会加载内部类</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>&#125;<br><span class="hljs-comment">// 问题2：在创建时是否有并发问题，答：不会，静态成员变量在类加载阶段完成，由JVM保证</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><h2 id="5-1、无锁解决线程安全问题"><a href="#5-1、无锁解决线程安全问题" class="headerlink" title="5.1、无锁解决线程安全问题"></a>5.1、无锁解决线程安全问题</h2><p>使用<strong>原子整数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicInteger balance = <span class="hljs-keyword">new</span> AtomicInteger();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-comment">//获取余额</span><br><span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//取款</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;<br><br><span class="hljs-comment">//方法内会启动 1000 个线程，每个线程做 -10的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">long</span> start = System.nanoTime();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>account.withdraw(<span class="hljs-number">10</span>);<br>&#125;));<br>&#125;<br>ts.forEach(Thread::start);<br>ts.forEach(t -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>t.join();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;);<br><span class="hljs-keyword">long</span> end = System.nanoTime();<br>System.out.println(account.getBalance() + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程安全的做法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br><span class="hljs-comment">//使用原子整数</span><br><span class="hljs-keyword">private</span> AtomicInteger balance;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//得到原子整数的值</span><br><span class="hljs-keyword">return</span> balance.get();<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-comment">//获得修改前的值</span><br><span class="hljs-keyword">int</span> prev = balance.get();<br><span class="hljs-comment">//获得修改后的值</span><br><span class="hljs-keyword">int</span> next = prev-amount;<br><span class="hljs-comment">//比较并设值</span><br><span class="hljs-keyword">if</span>(balance.compareAndSet(prev, next)) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>        <span class="hljs-comment">// 可以简化为下面的方法</span><br>    <span class="hljs-comment">// balance.addAndGet(-1 * amount);</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Account.demo(<span class="hljs-keyword">new</span> AccountCas(<span class="hljs-number">10000</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2、CAS与volatile"><a href="#5-2、CAS与volatile" class="headerlink" title="5.2、CAS与volatile"></a>5.2、CAS与volatile</h2><p><code>AtomicInteger</code>的解决方法，内部并没有用锁来保护共享变量的线程安全。</p><p>他实现的<strong>关键是 compareAndSet</strong>（比较并设置值），它的<strong>简称就是 CAS</strong> （也有 Compare And Swap 的说法），它必须是<strong>原子操作</strong>。</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/5.1.png"></p><blockquote><ul><li>其实 CAS 的底层是 <strong>lock cmpxchg</strong> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的<strong>原子性</strong>。</li><li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li></ul></blockquote><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。<ul><li>如果<strong>两者相等</strong>，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li><li>如果<strong>两者不相等</strong>，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。</li></ul></li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到<strong>主存中获取</strong> 它的值，线程操作 volatile 变量都是直接操作主存。即<strong>一个线程对 volatile 变量的修改，对另一个线程可见</strong>。</p><blockquote><p><strong>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）</strong></p></blockquote><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的新值来实现【比较并交换】的效果</p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>一般情况下，使用无锁比使用加锁的<strong>效率更高。</strong></p><h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p><ul><li><p>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，再进行重试。</p></li><li><p>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，上锁之后其他线程都无法操作，我改完了解开锁，你们才有机会。</p></li><li><p>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</p><ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li></ul></li><li><p>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</p></li></ul><h2 id="5-3、原子整数"><a href="#5-3、原子整数" class="headerlink" title="5.3、原子整数"></a>5.3、原子整数</h2><p>J.U.C 并发包（java.util .concurrent）提供了</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p><strong>以 AtomicInteger 为例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ </span><br>System.out.println(i.getAndIncrement());<br><span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>System.out.println(i.incrementAndGet());<br><span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>System.out.println(i.decrementAndGet());<br><span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>System.out.println(i.getAndDecrement());<br> <br><span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0） </span><br>System.out.println(i.getAndAdd(<span class="hljs-number">5</span>)); <br><span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0） </span><br>System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） </span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span><br>System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br> <br><span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span><br>System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br> <br><span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） </span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 </span><br><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 </span><br><span class="hljs-keyword">final</span> System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br> <br><span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） </span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br></code></pre></td></tr></table></figure><h2 id="5-4、原子引用"><a href="#5-4、原子引用" class="headerlink" title="5.4、原子引用"></a>5.4、原子引用</h2><ul><li>AtomicReference</li><li>AtomicMarkableReference</li><li>AtomicStampedReference</li></ul><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br><span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作    </span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccountImpl account)</span> </span>&#123;<br>List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">long</span> start = System.nanoTime();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>account.withdraw(BigDecimal.TEN);<br>&#125;));<br>&#125;<br>ts.forEach(Thread::start);<br>ts.forEach(t -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>t.join();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;);<br><span class="hljs-keyword">long</span> end = System.nanoTime();<br>System.out.println(account.getBalance() + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br><span class="hljs-comment">//原子引用，泛型类型为小数类型</span><br>AtomicReference&lt;BigDecimal&gt; balance;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountImpl</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;BigDecimal&gt;(balance);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> balance.get();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>BigDecimal pre = balance.get();<br>BigDecimal next = pre.subtract(amount);<br><span class="hljs-keyword">if</span>(balance.compareAndSet(pre, next)) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>DecimalAccount.demo(<span class="hljs-keyword">new</span> DecimalAccountImpl(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;10000&quot;</span>)));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br><span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>String pre = str.get();<br>System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>other();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//把str中的A改为C</span><br>System.out.println(<span class="hljs-string">&quot;change A-&gt;C &quot;</span> + str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>));<br>&#125;).start();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;change A-&gt;B &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>));<br>&#125;).start();<br>Thread.sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;change B-&gt;A &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>));<br>&#125;).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>主线程仅能判断出共享变量的值与初值 A <strong>是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况</p><p>如果主线程希望：只要有其它线程【<strong>动过了</strong>】共享变量，那么自己的 <strong>cas 就算失败</strong>，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong></p></blockquote><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicStampedReference01</span> </span>&#123;<br>    <span class="hljs-comment">//指定版本号</span><br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            String pre = str.getReference();<br>            <span class="hljs-comment">//获得版本号</span><br>            <span class="hljs-keyword">int</span> stamp = str.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                other();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C stamp &quot;</span> + stamp + str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = str.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;B stamp &quot;</span> + stamp + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));<br>        &#125;).start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = str.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;change B-&gt;A stamp &quot;</span> + stamp +  str.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了 <strong>AtomicMarkableReference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicMarkableReference01</span> </span>&#123;<br>    <span class="hljs-comment">//指定版本号</span><br>    <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            String pre = str.getReference();<br>            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                other();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C mark &quot;</span> +  str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;A mark &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul><li><strong>AtomicStampedReference</strong> 需要传入<strong>整型变量</strong>作为版本号，来判定是否被更改过</li><li><strong>AtomicMarkableReference</strong>需要传入<strong>布尔变量</strong>作为标记，来判断是否被更改过</li></ul><h2 id="5-5、原子数组"><a href="#5-5、原子数组" class="headerlink" title="5.5、原子数组"></a>5.5、原子数组</h2><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArra</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerArray01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        demo(<br>                ()-&gt; <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>),<br>                (array) -&gt; array.length(),<br>                (array, index) -&gt; array.getAndIncrement(index),<br>                array -&gt; System.out.println(array)<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment">     参数2，获取数组长度的方法</span><br><span class="hljs-comment">     参数3，自增方法，回传 array, index</span><br><span class="hljs-comment">     参数4，打印数组的方法</span><br><span class="hljs-comment">     */</span><br><span class="hljs-comment">// supplier 提供者 无中生有 ()-&gt;结果</span><br><span class="hljs-comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span><br><span class="hljs-comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            Supplier&lt;T&gt; arraySupplier,</span></span><br><span class="hljs-params"><span class="hljs-function">            Function&lt;T, Integer&gt; lengthFun,</span></span><br><span class="hljs-params"><span class="hljs-function">            BiConsumer&lt;T, Integer&gt; putConsumer,</span></span><br><span class="hljs-params"><span class="hljs-function">            Consumer&lt;T&gt; printConsumer )</span>  </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        T array = arraySupplier.get();<br>        <span class="hljs-keyword">int</span> length = lengthFun.apply(array);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">// 每个线程对数组作 10000 次操作</span><br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    putConsumer.accept(array, j%length);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;); <span class="hljs-comment">// 等所有线程结束</span><br>        printConsumer.accept(array);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 线程安全，输出结果</span><br><span class="hljs-comment">//[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span><br></code></pre></td></tr></table></figure><h2 id="5-6、原子字段更新器"><a href="#5-6、原子字段更新器" class="headerlink" title="5.6、原子字段更新器"></a>5.6、原子字段更新器</h2><ul><li>AtomicReferenceFieldUpdater // 域 字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdate</li></ul><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能<strong>配合 volatile 修饰的字段使用</strong>，否则会出现异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Student student = <span class="hljs-keyword">new</span> Student();<br>       <br>      <span class="hljs-comment">// 获得原子更新器</span><br>      <span class="hljs-comment">// 泛型</span><br>      <span class="hljs-comment">// 参数1 持有属性的类 参数2 被更新的属性的类</span><br>      <span class="hljs-comment">// newUpdater中的参数：第三个为属性的名称</span><br>      AtomicReferenceFieldUpdater&lt;Student, String&gt; updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>); <br>      <span class="hljs-comment">// 修改</span><br>      updater.compareAndSet(student, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Nyima&quot;</span>);<br>      System.out.println(student);<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>   <span class="hljs-keyword">volatile</span> String name;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-7、原子累加器"><a href="#5-7、原子累加器" class="headerlink" title="5.7、原子累加器"></a>5.7、原子累加器</h2><p>LongAdder的性能高于AtomicLong。主要是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p><h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p>Cell源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 防止缓存行伪共享</span><br><span class="hljs-meta">@sun</span>.misc.Contended<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cell</span> </span>&#123;<br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value;<br>Cell(<span class="hljs-keyword">long</span> x) &#123; value = x; &#125;<br><span class="hljs-comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> prev, <span class="hljs-keyword">long</span> next)</span> </span>&#123;<br><span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-keyword">this</span>, valueOffset, prev, next);<br>&#125;<br><span class="hljs-comment">// 省略不重要代码</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Cell 即为累加单元</p></blockquote><p>缓存行伪共享得从缓存说起<br>缓存与内存的速度比较</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/5.2.png"></p><p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至<strong>缓存</strong>来提升效率。<br>而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的<strong>一致性</strong>，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/5.3.png"></p><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p><ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1]</li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p><p>比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</p><p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</p><p><strong>累加主要调用以下方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">// as 为累加单元数组,b 为基础值,x 为累加值</span><br>    Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;<br>    <span class="hljs-comment">// 进入 if 的两个条件</span><br>    <span class="hljs-comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span><br>    <span class="hljs-comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span><br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;<br>        <span class="hljs-comment">// uncontended 表示 cell 没有竞争</span><br>        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (<br>            <span class="hljs-comment">// as 还没有创建</span><br>            as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            <span class="hljs-comment">// 当前线程对应的 cell 还没有</span><br>            (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||<br>            <span class="hljs-comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span><br>            !(uncontended = a.cas(v = a.value, v + x)))&#123;<br>              <span class="hljs-comment">// 进入 cell 数组创建、cell 创建的流程</span><br>              longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/5.4.png"></p><h2 id="5-8、Unsafe"><a href="#5-8、Unsafe" class="headerlink" title="5.8、Unsafe"></a>5.8、Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetUnsafe</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;<br><span class="hljs-comment">// 通过反射获得Unsafe对象</span><br>Class unsafeClass = Unsafe.class;<br><span class="hljs-comment">// 获得构造函数，Unsafe的构造函数为私有的</span><br>Constructor constructor = unsafeClass.getDeclaredConstructor();<br><span class="hljs-comment">// 设置为允许访问私有内容</span><br>constructor.setAccessible(<span class="hljs-keyword">true</span>);<br><span class="hljs-comment">// 创建Unsafe对象</span><br>Unsafe unsafe = (Unsafe) constructor.newInstance();<br><br><span class="hljs-comment">// 创建Person对象</span><br>Person person = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-comment">// 获得其属性 name 的偏移量</span><br>Field field = Person.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">long</span> offset = unsafe.objectFieldOffset(field);<br><br><span class="hljs-comment">// 通过unsafe的CAS操作改变值</span><br>unsafe.compareAndSwapObject(person, offset, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Gotcha&quot;</span>);<br>System.out.println(person);<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">// 配合CAS操作，必须用volatile修饰</span><br> <span class="hljs-keyword">volatile</span> String name;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br><span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br><span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h1><h2 id="6-1、定义"><a href="#6-1、定义" class="headerlink" title="6.1、定义"></a>6.1、定义</h2><p>如果一个对象在<strong>不能够修</strong>改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。</p><blockquote><p>线程不安全：SimpleDateFormat（日期格式化类）</p><p>线程安全：DateTimeFormatter（新的日期格式化类）</p></blockquote><ul><li>不可变对象，实际是另一种避免竞争的方式。</li></ul><h2 id="6-2、不可变设计"><a href="#6-2、不可变设计" class="headerlink" title="6.2、不可变设计"></a>6.2、不可变设计</h2><h3 id="String类中不可变的体现"><a href="#String类中不可变的体现" class="headerlink" title="String类中不可变的体现"></a>String类中不可变的体现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br><br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <br>   <span class="hljs-comment">//....</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ﬁnal-的使用"><a href="#ﬁnal-的使用" class="headerlink" title="ﬁnal 的使用"></a>ﬁnal 的使用</h3><p>发现该类、类中所有属性都是 final 的<br><strong>属性</strong>用 final 修饰<strong>保证了该属性是只读的，不能修改</strong><br><strong>类</strong>用 final 修饰<strong>保证了该类中的方法不能被覆盖</strong>，防止子类无意间破坏不可变性</p><h3 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h3><p>以 substring 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">int</span> subLen = value.length - beginIndex;<br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);<br>    &#125;<br>    <span class="hljs-comment">//返回的是一个新的对象</span><br>    <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure><p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br>            <span class="hljs-keyword">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br>    <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);<br>    &#125;<br>    <span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br>&#125;<br></code></pre></td></tr></table></figure><p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为<strong>保护性拷贝</strong>（defensive copy）</p><hr><h2 id="6-3、final的原理"><a href="#6-3、final的原理" class="headerlink" title="6.3、final的原理"></a>6.3、final的原理</h2><h3 id="设置final变量时的原理"><a href="#设置final变量时的原理" class="headerlink" title="设置final变量时的原理"></a>设置final变量时的原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinal</span> </span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">0:</span> <span class="hljs-string">aload_0</span><br><span class="hljs-attr">1:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-attr">4:</span> <span class="hljs-string">aload_0</span><br><span class="hljs-attr">5:</span> <span class="hljs-string">bipush</span> <span class="hljs-number">20</span><br><span class="hljs-attr">7:</span> <span class="hljs-string">putfield</span> <span class="hljs-comment">#2 // Field a:I</span><br><span class="hljs-string">&lt;--</span> <span class="hljs-string">写屏障</span><br><span class="hljs-attr">10:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><blockquote><p>发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入<strong>写屏障</strong>，保证在其它线程读到它的值时不会出现为 0 的情况</p></blockquote><h3 id="获取final变量时的原理"><a href="#获取final变量时的原理" class="headerlink" title="获取final变量时的原理"></a>获取final变量时的原理</h3><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/6.2.png"></p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/6.3.png"></p><hr><h2 id="6-4、享元模式"><a href="#6-4、享元模式" class="headerlink" title="6.4、享元模式"></a>6.4、享元模式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>当需要重用数量有限的同一类对象时，通过共享尽来最小化内存使用</p><blockquote><p>归类 Structual patterns</p></blockquote><h3 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h3><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的valueOf 会缓存 -128~127 之间的 Long 对象，<strong>在这个范围之间会重用对象</strong>，大于这个范围，才会新建 Long 对象：</p><ul><li>Byte, Short, Long 缓存的范围都是 -128~127</li><li>Character 缓存的范围是 0~127</li><li>Integer的默认范围是 -128~127。最小值不能变，但最大值可以通过调整虚拟机参数 <code> -Djava.lang.Integer.IntegerCache.high</code> 来改变</li><li>Boolean 缓存了 TRUE 和 FALSE</li></ul><h4 id="String-串池"><a href="#String-串池" class="headerlink" title="String 串池"></a>String 串池</h4><p>详见JVM笔记</p><h4 id="BigDecimal-BigInteger"><a href="#BigDecimal-BigInteger" class="headerlink" title="BigDecimal BigInteger"></a>BigDecimal BigInteger</h4><p>有一部分数字进行了缓存</p><blockquote><p>为什么BigDecimal是不可变类，线程安全。但还要用AtomicReference保护BigDecima</p><p>答：BigDecimal只能保证单个操作是原子的，多个操作组合起来不是原子操作</p></blockquote><h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><p>下面自定义一个连接池进行模拟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyWeight01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pool pool = <span class="hljs-keyword">new</span> Pool(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                Connection connection = pool.borrow();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                pool.free(connection);<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;享元模式之自定义连接池&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span></span>&#123;<br>    <span class="hljs-comment">//1.连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> poolSize;<br>    <span class="hljs-comment">//2.连接对象数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br>    <span class="hljs-comment">//3.连接状态数组,0 表示空闲,1表示繁忙</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br><br>    <span class="hljs-comment">//4.构造方法初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.poolSize = poolSize;<br>        <span class="hljs-keyword">this</span>.connections = <span class="hljs-keyword">new</span> Connection[poolSize];<br>        <span class="hljs-keyword">this</span>.states = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[poolSize]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> MockConnection(<span class="hljs-string">&quot;第&quot;</span>+i+<span class="hljs-string">&quot;个连接&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//5.借连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">borrow</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-keyword">if</span> (states.get(i)==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//存在空闲连接，则CAS获取</span><br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        log.debug(<span class="hljs-string">&quot;借出 &#123;&#125;&quot;</span>,connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//没有空闲连接，则线程进入等待</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;当前无可用连接&quot;</span>);<br>                    <span class="hljs-keyword">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//6.还连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(Connection connection)</span></span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i]==connection)&#123;<br>                log.debug(<span class="hljs-string">&quot;归还 &#123;&#125;&quot;</span>,connection);<br>                states.set(i,<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>)&#123;<br>                    <span class="hljs-keyword">this</span>.notifyAll();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Connection</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MockConnection</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MockConnection&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <br><span class="hljs-comment">// 省略其他Connection接口需要实现的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Statement <span class="hljs-title">createStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/6.1.png"></p><h2 id="6-5、无状态"><a href="#6-5、无状态" class="headerlink" title="6.5、无状态"></a>6.5、无状态</h2><p>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的<br>因为成员变量保存的数据也可以称为状态信息，因此<strong>没有成员变量就称之为无状态</strong></p><ul><li>即没有成员变量</li></ul><hr><h1 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h1><h2 id="7-1、自定义线程池"><a href="#7-1、自定义线程池" class="headerlink" title="7.1、自定义线程池"></a>7.1、自定义线程池</h2><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.1.png"></p><ul><li>阻塞队列中维护了由主线程（或者其他线程）所产生的的任务</li><li>主线程类似于<strong>生产者</strong>，产生任务并放入阻塞队列中</li><li>线程池类似于<strong>消费者</strong>，得到阻塞队列中已有的任务并执行</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;自定义线程池&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool01</span> </span>&#123;<br>    <span class="hljs-comment">//任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br><br>    <span class="hljs-comment">//线程集合</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet();<br><br>    <span class="hljs-comment">//核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> coreSize;<br><br>    <span class="hljs-comment">//获取任务的超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timeout;<br><br>    <span class="hljs-comment">//时间单位</span><br>    <span class="hljs-keyword">private</span> TimeUnit unit;<br><br>    <span class="hljs-comment">//拒绝策略</span><br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br><br>    <span class="hljs-comment">//执行任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span></span>&#123;<br>        <span class="hljs-comment">//当任务数没有超过coreSize时，直接交给worker对象执行</span><br>        <span class="hljs-comment">//当任务数超过coreSize时，进入阻塞队列</span><br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize)&#123;<br>                Worker worker = <span class="hljs-keyword">new</span> Worker(task);<br>                log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;,处理 任务&#123;&#125;&quot;</span>,worker,task);<br>                worker.start();<br>                workers.add(worker);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//taskQueue.put(task);</span><br>                <span class="hljs-comment">//1.死等</span><br>                <span class="hljs-comment">//2.带超时的等待</span><br>                <span class="hljs-comment">//3.让调用者放弃任务执行</span><br>                <span class="hljs-comment">//4.让调用者抛出异常</span><br>                <span class="hljs-comment">//5.让调用者自己执行任务</span><br>                taskQueue.tryPut(rejectPolicy,task);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPool01</span><span class="hljs-params">(<span class="hljs-keyword">int</span> coreSize, <span class="hljs-keyword">long</span> timeout, TimeUnit unit,<span class="hljs-keyword">int</span> queueCapcity,RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.coreSize = coreSize;<br>        <span class="hljs-keyword">this</span>.timeout = timeout;<br>        <span class="hljs-keyword">this</span>.unit = unit;<br>        <span class="hljs-keyword">this</span>.taskQueue = <span class="hljs-keyword">new</span> BlockingQueue&lt;&gt;(queueCapcity);<br>        <span class="hljs-keyword">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//执行任务</span><br>                <span class="hljs-comment">//1.当task不为空直接执行</span><br>                <span class="hljs-comment">//2.当task执行完毕，从任务队列中获取任务继续执行</span><br>                <span class="hljs-comment">//while (task != null || (task = taskQueue.take()) != null )&#123;</span><br>                <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = taskQueue.take(timeout,unit)) != <span class="hljs-keyword">null</span> )&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        log.debug(<span class="hljs-string">&quot;正在执行&#123;&#125;任务&quot;</span>,task);<br>                        task.run();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        task = <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (workers)&#123;<br>                    log.debug(<span class="hljs-string">&quot;worker&#123;&#125; 被移除&quot;</span>,<span class="hljs-keyword">this</span>);<br>                    workers.remove(<span class="hljs-keyword">this</span>);<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="任务阻塞队列"><a href="#任务阻塞队列" class="headerlink" title="任务阻塞队列"></a>任务阻塞队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;任务阻塞队列&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-comment">//1.任务队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br><br>    <span class="hljs-comment">//2.锁</span><br>    <span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-comment">//3.生产者条件变量</span><br>    <span class="hljs-keyword">private</span> Condition fullWaitSet = lock.newCondition();<br><br>    <span class="hljs-comment">//4.消费者条件变量</span><br>    <span class="hljs-keyword">private</span> Condition emptyWaitSet = lock.newCondition();<br><br>    <span class="hljs-comment">//5.容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capcity;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capcity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capcity = capcity;<br>    &#125;<br><br>    <span class="hljs-comment">//阻塞获取</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">take</span><span class="hljs-params">()</span></span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty())&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            T t = queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;  <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//带超时的阻塞获取</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">take</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//将时间统一转换为纳秒</span><br>            <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty())&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (nanos&lt;=<span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                    <span class="hljs-comment">//等待的时间 = 等待时间 - 已等待时间 = 剩余等待时间</span><br>                    nanos = emptyWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            T t = queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;  <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//阻塞添加</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T element)</span></span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务阻塞队列&#123;&#125;&quot;</span>,element);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;将任务加入任务阻塞队列&#123;&#125;&quot;</span>,element);<br>            queue.addLast(element);<br>            emptyWaitSet.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//带超时时间的阻塞添加</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">put</span><span class="hljs-params">(T element,<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//将时间统一转换为纳秒</span><br>            <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务阻塞队列&#123;&#125;&quot;</span>,element);<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)&#123;<br>                        log.debug(<span class="hljs-string">&quot;任务&#123;&#125;不再等待，直接移除&quot;</span>,element);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;将任务加入任务阻塞队列&#123;&#125;&quot;</span>,element);<br>            queue.addLast(element);<br>            emptyWaitSet.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取阻塞队列容量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (queue.size()==capcity)&#123;<br>                rejectPolicy.reject(<span class="hljs-keyword">this</span>,task);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;将任务加入任务阻塞队列&#123;&#125;&quot;</span>,task);<br>                queue.addLast(task);<br>                emptyWaitSet.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">//拒绝策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RejectPolicy</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; queue,T task)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool01Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ThreadPool01 threadPool = <span class="hljs-keyword">new</span> ThreadPool01(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS,<br>                <span class="hljs-number">1</span>,(queue,task)-&gt;&#123;<br>            <span class="hljs-comment">//1.死等</span><br>            <span class="hljs-comment">//queue.put(task);</span><br>            <span class="hljs-comment">//2.带超时的等待</span><br>            <span class="hljs-comment">//queue.put(task,500,TimeUnit.MILLISECONDS);</span><br>            <span class="hljs-comment">//3.让调用者放弃任务执行</span><br>            <span class="hljs-comment">//System.out.println(&quot;放弃执行&quot; + task);;</span><br>            <span class="hljs-comment">//4.让调用者抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;任务执行失败&quot;</span> + task);<br>            <span class="hljs-comment">//5.让调用者自己执行任务</span><br>            <span class="hljs-comment">//task.run();</span><br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> j = i;<br>            threadPool.execute(()-&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(j);&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.2.png"></p><hr><h2 id="7-2、ThreadPoolExecutor"><a href="#7-2、ThreadPoolExecutor" class="headerlink" title="7.2、ThreadPoolExecutor"></a>7.2、ThreadPoolExecutor</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.3.png"></p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程池状态</span><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-comment">// RUNNING 高3位为111</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// SHUTDOWN 高3位为000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 001</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 010</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 011</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><table><thead><tr><th>状态名称</th><th>高3位的值</th><th>描述</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>接收新任务，同时处理任务队列中的任务</td></tr><tr><td>SHUTDOWN</td><td>000</td><td>不接受新任务，但是处理任务队列中的任务</td></tr><tr><td>STOP</td><td>001</td><td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td></tr><tr><td>TIDYING</td><td>010</td><td>任务执行完毕，活动线程为0时，即将进入终结阶段</td></tr><tr><td>TERMINATED</td><td>011</td><td>终结状态</td></tr></tbody></table><p>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示</strong></p><ul><li>使用一个数来表示两个值的主要原因是：<strong>可以通过一次CAS同时更改两个属性的值</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">// 并不是所有平台的int都是32位。</span><br><span class="hljs-comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span><br><span class="hljs-comment">// 高3位为0，剩余位数全为1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数</span><br><span class="hljs-comment">// CAPACITY 的高3位为 0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>获取线程池状态、线程数量以及合并两个值的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Packing and unpacking ctl</span><br><span class="hljs-comment">// 获取运行状态</span><br><span class="hljs-comment">// 该操作会让除高3位以外的数全部变为0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><br><span class="hljs-comment">// 获取运行线程数</span><br><span class="hljs-comment">// 该操作会让高3位为0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><br><span class="hljs-comment">// 计算ctl新值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><h3 id="线程池属性"><a href="#线程池属性" class="headerlink" title="线程池属性"></a>线程池属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 工作线程，内部封装了Thread</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><br><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br><br><span class="hljs-comment">// 锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br><span class="hljs-comment">//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;Worker&gt;();<br></code></pre></td></tr></table></figure><h3 id="构造方法及其参数"><a href="#构造方法及其参数" class="headerlink" title="构造方法及其参数"></a>构造方法及其参数</h3><p><strong>ThreadPoolExecutor最全面的构造方法</strong></p><p>也是构造自定义线程池的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler handler)</span></span><br></code></pre></td></tr></table></figure><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a><strong>参数解释</strong></h4><ul><li>corePoolSize：核心线程数</li><li>maximumPoolSize：最大线程数<ul><li>maximumPoolSize - corePoolSize = 救急线程数</li></ul></li><li>keepAliveTime：救急线程空闲时的最大生存时间</li><li>unit：时间单位</li><li>workQueue：阻塞队列（存放任务）<ul><li>有界阻塞队列 ArrayBlockingQueue</li><li>无界阻塞队列 LinkedBlockingQueue</li><li>最多只有一个同步元素的 SynchronousQueue</li><li>优先队列 PriorityBlockingQueue</li></ul></li><li>threadFactory：线程工厂（给线程取名字）</li><li>handler：拒绝策略</li></ul><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li>当一个任务传给线程池以后，可能有以下几种可能<ul><li>将任务分配给一个核心线程来执行</li><li>核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行</li><li>阻塞队列满了，使用救急线程来执行任务<ul><li>救急线程用完以后，超过生存时间（keepAliveTime）后会被释放</li></ul></li><li>任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略</li></ul></li></ul><h4 id="拒绝策略-1"><a href="#拒绝策略-1" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行<strong>拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.4.png"></p><ul><li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>这是默认策略</strong></li><li>CallerRunsPolicy：让调用者运行任务</li><li>DiscardPolicy：放弃本次任务</li><li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li></ul><h3 id="Executors创建线程池类"><a href="#Executors创建线程池类" class="headerlink" title="Executors创建线程池类"></a>Executors创建线程池类</h3><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>内部调用的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>共有两个参数：</p><ul><li><strong>核心线程数：nThreads =  最大线程数（没有救急线程）</strong>，因此也不需要超时时间</li><li><strong>线程工厂：threadFactory</strong></li></ul></li><li><p><strong>阻塞队列无界</strong>，可以放任意数量的任务</p></li></ul><blockquote><p>适用于任务量已知，相对耗时的任务</p></blockquote><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;FixedThreadPoolTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedThreadPoolTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 自定义线程工厂</span><br>        ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>            AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;gotchaThread_&quot;</span> + atomicInteger.getAndIncrement());<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 创建核心线程数量为2的线程池</span><br>        <span class="hljs-comment">// 通过 ThreadFactory可以给线程添加名字</span><br>        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">2</span>,factory);<br><br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;1&quot;</span>));<br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;2&quot;</span>));<br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;3&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.5.png"></p><h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><p>内部调用的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>共有一个参数：<ul><li><strong>线程工厂：threadFactory</strong></li></ul></li><li>没有核心线程，最大线程数为Integer.MAX_VALUE，<strong>所有创建的线程都是救急线程</strong>，空闲时生存时间为60秒</li><li>阻塞队列使用的是<code>SynchronousQueue</code><ul><li>SynchronousQueue是一种特殊的队列<ul><li><strong>没有容量</strong>，没有线程来取是放不进去的</li><li>只有当线程取任务时，才会将任务放入该阻塞队列中</li></ul></li></ul></li><li>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲1分钟后释放线程</li></ul><blockquote><p>适用于任务数量密集，但每个任务执行时间较短的情况</p></blockquote><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;CachedThreadPool&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachedThreadPoolTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 自定义线程工厂</span><br>        ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>            AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;gotchaThread_&quot;</span> + atomicInteger.getAndIncrement());<br>            &#125;<br>        &#125;;<br><br><br>        ExecutorService pool = Executors.newCachedThreadPool(factory);<br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;1&quot;</span>));<br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;2&quot;</span>));<br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;3&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.6.png"></p><h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><p>内部调用的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                threadFactory));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>共有一个参数：<ul><li><strong>线程工厂：threadFactory</strong></li></ul></li><li><code>FinalizableDelegatedExecutorService</code>应用的是<strong>装饰器模式</strong>，只对外暴露了ExecutorService接口，因此不能调用<code>ThreadPoolExecutor</code>中特有的方法</li></ul><blockquote><p>适用于希望多个任务排队执行。线程数固定为1，任务数多于1时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p></blockquote><p><strong>注意</strong></p><ul><li><p>SingleThread和自己创建一个线程来运行多个任务的区别</p><ul><li>当线程正在执行的任务发生错误时，如果是自己创建的线程，该任务和剩余的任务就无法再继续运行下去。而SingleThread会创建一个新线程，继续执行任务队列中剩余的任务。</li></ul></li><li><p>SingleThread和newFixedThreadPool(1)的区别</p><ul><li>newFixedThreadPool(1)传值为1，可以将FixedThreadPool强转为ThreadPoolExecutor，然后通过setCorePoolSize改变核心线程数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 强转为ThreadPoolExecutor</span><br>ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 改变核心线程数</span><br>threadPool.setCorePoolSize(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><ul><li>而SingleThread无法修改核心线程数</li></ul></li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;SingleThread&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleThreadTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 自定义线程工厂</span><br>        ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>            AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;gotchaThread_&quot;</span> + atomicInteger.getAndIncrement());<br>            &#125;<br>        &#125;;<br><br>        ExecutorService pool = Executors.newSingleThreadExecutor(factory);<br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;1&quot;</span>));<br>        pool.execute(()-&gt;&#123;<br>            <span class="hljs-comment">//当此任务出现异常时，之后的任务也会正常执行</span><br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>/<span class="hljs-number">0</span>;<br>            log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>        &#125;);<br>        pool.execute(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;3&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.7.png"></p><h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><p>内部调用的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>共有两个参数：<ul><li><strong>核心线程数：corePoolSize</strong></li><li><strong>线程工厂：threadFactory</strong></li></ul></li><li>延时执行<ul><li>schedule()</li></ul></li><li>定时执行<ul><li>scheduleAtFixedRate()：时间间隔取，线程运行时间与等待时间较大的</li><li>scheduleWithFixedDelay()：时间间隔取，线程运行时间与等待时间之和</li></ul></li></ul><p><strong>示例</strong></p><p><strong>延时执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;ScheduledThreadPoolExecutorTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledThreadPoolExecutorTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 自定义线程工厂</span><br>        ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>            AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;gotchaThread_&quot;</span> + atomicInteger.getAndIncrement());<br>            &#125;<br>        &#125;;<br><br>        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">2</span>,factory);<br>        pool.schedule(()-&gt;<br>            &#123;<br>                log.debug(<span class="hljs-string">&quot;Task1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;,<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        pool.schedule(()-&gt; log.debug(<span class="hljs-string">&quot;Task2&quot;</span>),<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.8.png"></p><p><strong>定时执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;ScheduledThreadPoolExecutorTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledThreadPoolExecutorTest02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br>        pool.scheduleAtFixedRate(()-&gt; log.debug(<span class="hljs-string">&quot;Task&quot;</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.9.png"></p><hr><h4 id="提交任务方法"><a href="#提交任务方法" class="headerlink" title="提交任务方法"></a>提交任务方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行任务</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;<br><br><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span><br>&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)<span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，带超时时间</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-keyword">long</span> timeout, TimeUnit unit) <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span><br>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubmitTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>      <span class="hljs-comment">//  submitTest(pool);</span><br>      <span class="hljs-comment">//  invokeAllTest(pool);</span><br>        invokeAnyTest(pool);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submitTest</span><span class="hljs-params">(ExecutorService pool)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        Future&lt;String&gt; future = pool.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;开始运行&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>        &#125;);<br>        System.out.println(future.get());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAllTest</span><span class="hljs-params">(ExecutorService pool)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        List&lt;Future&lt;String&gt;&gt; futures = pool.invokeAll(Arrays.asList(<br>                () -&gt; &#123;<br>                        System.out.println(<span class="hljs-string">&quot;任务1开始运行&quot;</span>);<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务1OK&quot;</span>;<br>                    &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;任务2开始运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务2OK&quot;</span>;<br>                    &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;任务3开始运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务3OK&quot;</span>;<br>                &#125;<br>            )<br>        );<br>        futures.forEach((future)-&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(future.get());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAnyTest</span><span class="hljs-params">(ExecutorService pool)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException</span>&#123;<br>        String result = pool.invokeAny(Arrays.asList(<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;任务1开始运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务1OK&quot;</span>;<br>                &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;任务2开始运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务2OK&quot;</span>;<br>                &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;任务3开始运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务3OK&quot;</span>;<br>                &#125;<br>        ));<br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 SHUTDOWN</span><br><span class="hljs-comment">- 不会接收新任务</span><br><span class="hljs-comment">- 但已提交任务会执行完</span><br><span class="hljs-comment">- 此方法不会阻塞调用线程的执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>    checkShutdownAccess();<br>    <span class="hljs-comment">// 修改线程池状态</span><br>    advanceRunState(SHUTDOWN);<br>    <span class="hljs-comment">// 仅会打断空闲线程</span><br>    interruptIdleWorkers();<br>    onShutdown(); <span class="hljs-comment">// 扩展点 ScheduledThreadPoolExecutor</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span><br>    tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 STOP</span><br><span class="hljs-comment">- 不会接收新任务</span><br><span class="hljs-comment">- 会将队列中的任务返回</span><br><span class="hljs-comment">- 并用 interrupt 的方式中断正在执行的任务</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Runnable&gt; tasks;<br><span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>checkShutdownAccess();<br><span class="hljs-comment">// 修改线程池状态</span><br>advanceRunState(STOP);<br><span class="hljs-comment">// 打断所有线程</span><br>interruptWorkers();<br><span class="hljs-comment">// 获取队列中剩余任务</span><br>tasks = drainQueue();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>mainLock.unlock();<br>&#125;<br><span class="hljs-comment">// 尝试终结</span><br>tryTerminate();<br><span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="isShutdown"><a href="#isShutdown" class="headerlink" title="isShutdown()"></a>isShutdown()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>isTerminated()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h5 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination()"></a>awaitTermination()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事</span><br>情，可以利用此方法等待<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br></code></pre></td></tr></table></figure><hr><h3 id="处理执行任务异常"><a href="#处理执行任务异常" class="headerlink" title="处理执行任务异常"></a>处理执行任务异常</h3><h4 id="主动捕获"><a href="#主动捕获" class="headerlink" title="主动捕获"></a>主动捕获</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>pool.submit(() -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>log.error(<span class="hljs-string">&quot;error:&quot;</span>, e);<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="使用-Future"><a href="#使用-Future" class="headerlink" title="使用 Future"></a>使用 Future</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;);<br>log.debug(<span class="hljs-string">&quot;result:&#123;&#125;&quot;</span>, f.get());<br></code></pre></td></tr></table></figure><hr><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Gotcha</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@describe</span> 定时任务，设置，每周周一08:00执行</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduleTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//获取当前时间</span><br>        LocalDateTime now = LocalDateTime.now();<br>        <span class="hljs-comment">//获取到周四的时间</span><br>        LocalDateTime time = now.withHour(<span class="hljs-number">8</span>).withMinute(<span class="hljs-number">0</span>).withSecond(<span class="hljs-number">0</span>).withNano(<span class="hljs-number">0</span>).with(DayOfWeek.MONDAY);<br>        <span class="hljs-comment">//如果当前时间&gt;周一08:00，应当使用下周的周一</span><br>        <span class="hljs-keyword">if</span> (now.compareTo(time)&gt;<span class="hljs-number">0</span>)&#123;<br>            time = time.plusWeeks(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//求出下次执行到现在的时间差</span><br>        <span class="hljs-keyword">long</span> initailDelay = Duration.between(now, time).toMillis();<br>        <span class="hljs-keyword">long</span> period = <span class="hljs-number">1000</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">7</span>;<br>        <span class="hljs-comment">//执行任务</span><br>        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>        pool.scheduleAtFixedRate(()-&gt; System.out.println(<span class="hljs-string">&quot;hello&quot;</span>),initailDelay,period, TimeUnit.MILLISECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-3、异步模式之工作线程"><a href="#7-3、异步模式之工作线程" class="headerlink" title="7.3、异步模式之工作线程"></a>7.3、异步模式之工作线程</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。</p><p>例如，饭店的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）注意，<strong>不同任务类型应该使用不同的线程池，这样能够避免饥饿</strong>，并能提升效率</p><hr><h2 id="7-4、Tomcat线程池"><a href="#7-4、Tomcat线程池" class="headerlink" title="7.4、Tomcat线程池"></a>7.4、Tomcat线程池</h2><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.10.png"></p><ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore</li><li>Acceptor 只负责【接收新的 socket 连接】</li><li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li><li>Executor 线程池中的工作线程最终负责【处理请求】</li></ul><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p><ul><li>如果总线程数达到 maximumPoolSize，这时不会立刻抛 RejectedExecutionException 异常而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li></ul><h3 id="线程池相关配置"><a href="#线程池相关配置" class="headerlink" title="线程池相关配置"></a>线程池相关配置</h3><p>在server.xml中配置</p><h4 id="Connector配置"><a href="#Connector配置" class="headerlink" title="Connector配置"></a>Connector配置</h4><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>acceptorThreadCount</td><td>1</td><td>acceptor 线程数量</td></tr><tr><td>pollerThreadCount</td><td>1</td><td>poller 线程数量</td></tr><tr><td>minSpareThreads</td><td>10</td><td>核心线程数，即 corePoolSize</td></tr><tr><td>maxThreads</td><td>200</td><td>最大线程数，即 maximumPoolSize</td></tr><tr><td>executor</td><td></td><td>Executor 名称，用来引用下面的 Executor</td></tr></tbody></table><h4 id="Executor线程配置"><a href="#Executor线程配置" class="headerlink" title="Executor线程配置"></a>Executor线程配置</h4><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>threadPriority</td><td>5</td><td>线程优先级</td></tr><tr><td>daemon</td><td>true</td><td>是否守护线程</td></tr><tr><td>minSpareThreads</td><td>25</td><td>核心线程数，即 corePoolSize</td></tr><tr><td>maxThreads</td><td>200</td><td>最大线程数，即 maximumPoolSize</td></tr><tr><td>maxIdleTime</td><td>60000</td><td>线程生存时间，单位是毫秒，默认值即 1 分钟</td></tr><tr><td>maxQueueSize</td><td>Integer.MAX_VALUE</td><td>队列长度</td></tr><tr><td>prestartminSpareThreads</td><td>false</td><td>核心线程是否在服务器启动时启动</td></tr></tbody></table><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.11.png"></p><hr><h2 id="7-5、Fork-Join线程池"><a href="#7-5、Fork-Join线程池" class="headerlink" title="7.5、Fork/Join线程池"></a>7.5、Fork/Join线程池</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种<strong>分治</strong>思想，适用于能够进行任务拆分的 cpu 密集型运算。<br>任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解。<br>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率。<br>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池。</p><blockquote><p>提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值）</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;ForkAndJoinTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkAndJoinTest01</span>  </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">4</span>);<br>        System.out.println(pool.invoke(<span class="hljs-keyword">new</span> MyTask(<span class="hljs-number">5</span>)));<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.n = n;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了</span><br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>                log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, n);<br>                <span class="hljs-keyword">return</span> n;<br>            &#125;<br>            <span class="hljs-comment">// 将任务进行拆分(fork)</span><br>            MyTask t1 = <span class="hljs-keyword">new</span> MyTask(n - <span class="hljs-number">1</span>);<br>            t1.fork();<br>            log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);<br>            <span class="hljs-comment">// 合并(join)结果</span><br>            <span class="hljs-keyword">int</span> result = n + t1.join();<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.12.png"></p><p>图解</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.13.png"></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;ForkAndJoinTest02&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkAndJoinTest02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">4</span>);<br>        System.out.println(pool.invoke(<span class="hljs-keyword">new</span> MyTask(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">int</span> begin;<br>        <span class="hljs-keyword">int</span> end;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.begin = begin;<br>            <span class="hljs-keyword">this</span>.end = end;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + begin + <span class="hljs-string">&quot;,&quot;</span> + end + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 5, 5</span><br>            <span class="hljs-keyword">if</span> (begin == end) &#123;<br>                log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, begin);<br>                <span class="hljs-keyword">return</span> begin;<br>            &#125;<br>            <span class="hljs-comment">// 4, 5</span><br>            <span class="hljs-keyword">if</span> (end - begin == <span class="hljs-number">1</span>) &#123;<br>                log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, begin, end, end + begin);<br>                <span class="hljs-keyword">return</span> end + begin;<br>            &#125;<br>            <span class="hljs-comment">// 1 5</span><br>            <span class="hljs-keyword">int</span> mid = (end + begin) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 3</span><br>            MyTask t1 = <span class="hljs-keyword">new</span> MyTask(begin, mid); <span class="hljs-comment">// 1,3</span><br>            t1.fork();<br>            MyTask t2 = <span class="hljs-keyword">new</span> MyTask(mid + <span class="hljs-number">1</span>, end); <span class="hljs-comment">// 4,5</span><br>            t2.fork();<br>            log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125; = ?&quot;</span>, t1, t2);<br>            <span class="hljs-keyword">int</span> result = t1.join() + t2.join();<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, t1, t2, result);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.14.png"></p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.15.png"></p><hr><h1 id="八、JUC"><a href="#八、JUC" class="headerlink" title="八、JUC"></a>八、JUC</h1><h2 id="8-1、概述"><a href="#8-1、概述" class="headerlink" title="8.1、概述"></a>8.1、概述</h2><p>JUC就是<code>java.util .concurrent</code>工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.1.png"></p><hr><h2 id="8-2、AQS"><a href="#8-2、AQS" class="headerlink" title="8.2、AQS"></a>8.2、AQS</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>AQS全称是AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.2.png"></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>AQS 要实现的功能目标</p><ul><li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire</li><li>获取锁超时机制</li><li>通过打断取消机制</li><li>独占机制及共享机制</li><li>条件不满足时的等待机制</li></ul><h3 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h3><ul><li>获取锁的逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(state 状态不允许获取) &#123;<br><span class="hljs-keyword">if</span>(队列中还没有此线程) &#123;<br>入队并阻塞<br>&#125;<br>&#125;<br>获取到锁，当前线程出队<br></code></pre></td></tr></table></figure><ul><li>释放锁的逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(state 状态允许了) &#123;<br>恢复阻塞的线程(s)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><blockquote><p>子类主要实现这如下方法</p><ul><li>tryAcquire，尝试获取锁</li><li>tryRelease，尝试释放锁</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively，判断是否持有独占锁</li></ul></blockquote><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>实现自定义不可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;AQSTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AQSTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Lock lock = <span class="hljs-keyword">new</span> MyLock();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;t1线程开始&quot;</span>);<br>                sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;t2线程开始&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;);<br>        t1.run();<br>        t2.run();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//自定义不可重入锁</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> MySync sync = <span class="hljs-keyword">new</span> MySync();<br><br><br>    <span class="hljs-comment">//独占锁,同步器类</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span>&#123;<br>        <span class="hljs-comment">//尝试获取锁</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span>(compareAndSetState(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-comment">//加上了锁,设置owner为当前线程</span><br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//是否持有独占锁</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> getState()==<span class="hljs-number">1</span> ;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();<br>        &#125;<br>    &#125;<br><br><br><br>    <span class="hljs-comment">//加锁(不成功会进入等待队列)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//加锁，可打断锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//尝试加锁，一次</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//尝试加锁，带超时</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>,unit.toNanos(time));<br>    &#125;<br><br>    <span class="hljs-comment">//解锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//创建条件变量</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.3.png"></p><hr><h2 id="8-3、ReentrantLock-原理"><a href="#8-3、ReentrantLock-原理" class="headerlink" title="8.3、ReentrantLock 原理"></a>8.3、ReentrantLock 原理</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>有两个构造方法，默认为非公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;<br>    sync = <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>FairSync、NonfairSync都继承自 AQS</p></blockquote><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.4.png"></p><h3 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h3><h4 id="加锁解锁流程"><a href="#加锁解锁流程" class="headerlink" title="加锁解锁流程"></a>加锁解锁流程</h4><ul><li>没有竞争时</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.5.png"></p><ul><li>第一个竞争线程出现</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.6.png"></p><p>Thread-1 执行了</p><ol><li>CAS 尝试将 state 由 0 改为 1，结果失败</li><li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li><li>接下来进入 addWaiter 逻辑，构造 Node 队列<br>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态，-1表示该节点有后继节点，该节点执行后要唤醒后继节点。<br>Node 的创建是懒惰的，其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li></ol><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.7.png"></p><p>当前线程进入 acquireQueued 逻辑</p><ol><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li><li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li><li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</li></ol><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.8.png"></p><ol start="4"><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时state 仍为 1，失败</li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回true</li><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li></ol><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.9.png"></p><p>再次有多个线程经历上述过程竞争失败，变成这个样子</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.10.png"></p><p>Thread-0 释放锁，进入 tryRelease 流程，如果成功，设置 exclusiveOwnerThread 为 null，state = 0</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.11.png"></p><p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程<br>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1。回到 Thread-1 的 acquireQueued 流程</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.12.png"></p><p>如果加锁成功（没有竞争），会设置</p><ul><li>exclusiveOwnerThread 为 Thread-1，state = 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ul><p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了，不巧又被 Thread-4 占了先<br>Thread-4 被设置为 exclusiveOwnerThread，state = 1，Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.13.png"></p><h4 id="加锁源码"><a href="#加锁源码" class="headerlink" title="加锁源码"></a>加锁源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7316153563782823691L</span>;<br><span class="hljs-comment">// 加锁实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span><br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>setExclusiveOwnerThread(Thread.currentThread());<br><span class="hljs-keyword">else</span><br><span class="hljs-comment">// 如果尝试失败，进入 ㈠</span><br>acquire(<span class="hljs-number">1</span>);<br>&#125;<br>    <br><span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-comment">// ㈡ tryAcquire</span><br><span class="hljs-keyword">if</span> (<br>!tryAcquire(arg) &amp;&amp;<br><span class="hljs-comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span><br>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>) &#123;<br>selfInterrupt();<br>&#125;<br>&#125;<br>    <br>    <span class="hljs-comment">// ㈡ 进入 ㈢</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br><span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>&#125;<br>    <br><span class="hljs-comment">// ㈢ Sync 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br><span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br><span class="hljs-keyword">int</span> c = getState();<br><span class="hljs-comment">// 如果还没有获得锁</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span><br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br><span class="hljs-comment">// state++</span><br><span class="hljs-keyword">int</span> nextc = c + acquires;<br><span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(nextc);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">// 获取失败, 回到调用处</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>    <br><span class="hljs-comment">// ㈣ AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span><br>Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br><span class="hljs-comment">// 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部</span><br>Node pred = tail;<br><span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br>node.prev = pred;<br><span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br><span class="hljs-comment">// 双向链表</span><br>pred.next = node;<br><span class="hljs-keyword">return</span> node;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 尝试将 Node 加入 AQS, 进入 ㈥</span><br>enq(node);<br><span class="hljs-keyword">return</span> node;<br>&#125;<br>    <br><span class="hljs-comment">// ㈥ AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br>Node t = tail;<br><span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span><br><span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node())) &#123;<br>tail = head;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span><br>node.prev = t;<br><span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>t.next = node;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>    <br>    <span class="hljs-comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">final</span> Node p = node.predecessor();<br><span class="hljs-comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span><br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br><span class="hljs-comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span><br>setHead(node);<br><span class="hljs-comment">// 上一个节点 help GC</span><br>p.next = <span class="hljs-keyword">null</span>;<br>failed = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 返回中断标记 false</span><br><span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>    <span class="hljs-keyword">if</span> (<br><span class="hljs-comment">// 判断是否应当 park, 进入 ㈦</span><br>shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br><span class="hljs-comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span><br>parkAndCheckInterrupt()<br>) &#123;<br>interrupted = <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failed)<br>cancelAcquire(node);<br>&#125;<br>&#125;<br>    <br>    <span class="hljs-comment">// ㈦ AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br><span class="hljs-comment">// 获取上一个节点的状态</span><br><span class="hljs-keyword">int</span> ws = pred.waitStatus;<br><span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br><span class="hljs-comment">// 上一个节点都在阻塞, 那么自己也阻塞好了</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">// &gt; 0 表示取消状态</span><br><span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span><br><span class="hljs-keyword">do</span> &#123;<br>node.prev = pred = pred.prev;<br>&#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>pred.next = node;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 这次还没有阻塞</span><br><span class="hljs-comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span><br>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>    <br><span class="hljs-comment">// ㈧ 阻塞当前线程</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>LockSupport.park(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意<br>是否需要 unpark 是由当前节点的<code>前驱节点的 waitStatus == Node.SIGNAL </code>来决定，而不是本节点的waitStatus 决定</p></blockquote><h4 id="解锁源码"><a href="#解锁源码" class="headerlink" title="解锁源码"></a>解锁源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-comment">// 解锁实现</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>sync.release(<span class="hljs-number">1</span>);<br>&#125;<br>    <br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-comment">// 尝试释放锁, 进入 ㈠</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br><span class="hljs-comment">// 队列头节点 unpark</span><br>Node h = head;<br><span class="hljs-keyword">if</span> (<br><span class="hljs-comment">// 队列不为 null</span><br>h != <span class="hljs-keyword">null</span> &amp;&amp;<br><span class="hljs-comment">// waitStatus == Node.SIGNAL 才需要 unpark</span><br>h.waitStatus != <span class="hljs-number">0</span><br>) &#123;<br><span class="hljs-comment">// unpark AQS 中等待的线程, 进入 ㈡</span><br>unparkSuccessor(h);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>    <br>    <span class="hljs-comment">// ㈠ Sync 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br><span class="hljs-comment">// state--</span><br><span class="hljs-keyword">int</span> c = getState() - releases;<br><span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br><span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>free = <span class="hljs-keyword">true</span>;<br>setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>&#125;<br>setState(c);<br><span class="hljs-keyword">return</span> free;<br>&#125;<br>    <br><span class="hljs-comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br><span class="hljs-comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0</span><br><span class="hljs-comment">// 不成功也可以</span><br><span class="hljs-keyword">int</span> ws = node.waitStatus;<br><span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>) &#123;<br>compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span><br>    Node s = node.next;<br><span class="hljs-comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span><br><span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>s = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<br><span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>s = t;<br>&#125;<br><span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>LockSupport.unpark(s.thread);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br><span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br><span class="hljs-keyword">int</span> c = getState();<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br><span class="hljs-comment">// state++</span><br><span class="hljs-keyword">int</span> nextc = c + acquires;<br><span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(nextc);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>    <br><span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br><span class="hljs-comment">// state--</span><br><span class="hljs-keyword">int</span> c = getState() - releases;<br><span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br><span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>free = <span class="hljs-keyword">true</span>;<br>setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>&#125;<br>   setState(c);<br><span class="hljs-keyword">return</span> free;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><h4 id="不可打断模式"><a href="#不可打断模式" class="headerlink" title="不可打断模式"></a>不可打断模式</h4><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 如果打断标记已经是 true, 则 park 会失效</span><br>LockSupport.park(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">// interrupted 会清除打断标记</span><br><span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">final</span> Node p = node.predecessor();<br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>setHead(node);<br>p.next = <span class="hljs-keyword">null</span>;<br>failed = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 还是需要获得锁后, 才能返回打断状态</span><br><span class="hljs-keyword">return</span> interrupted;<br>&#125;<br><span class="hljs-keyword">if</span> (<br>shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>parkAndCheckInterrupt()<br>) &#123;<br><span class="hljs-comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span><br>interrupted = <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failed)<br>cancelAcquire(node);<br>&#125;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<br>!tryAcquire(arg) &amp;&amp;<br>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>) &#123;<br><span class="hljs-comment">// 如果打断状态为 true</span><br>selfInterrupt();<br>&#125;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selfInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 重新产生一次中断</span><br>Thread.currentThread().interrupt();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可打断模式"><a href="#可打断模式" class="headerlink" title="可打断模式"></a>可打断模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br><span class="hljs-comment">// 如果没有获得到锁, 进入 ㈠</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg))<br>doAcquireInterruptibly(arg);<br>&#125;<br>    <br><span class="hljs-comment">// ㈠ 可打断的获取锁流程</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<br><span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">final</span> Node p = node.predecessor();<br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>setHead(node);<br>p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>failed = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>parkAndCheckInterrupt()) &#123;<br><span class="hljs-comment">// 在 park 过程中如果被 interrupt 会进入此</span><br><span class="hljs-comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failed)<br>cancelAcquire(node);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;<br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>acquire(<span class="hljs-number">1</span>);<br>&#125;<br>    <br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<br>!tryAcquire(arg) &amp;&amp;<br>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>) &#123;<br>selfInterrupt();<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br><span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br><span class="hljs-keyword">int</span> c = getState();<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span><br><span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br><span class="hljs-keyword">int</span> nextc = c + acquires;<br><span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(nextc);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>    <br><span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;<br>Node t = tail;<br>Node h = head;<br>Node s;<br><span class="hljs-comment">// h != t 时表示队列中有 Node</span><br><span class="hljs-keyword">return</span> h != t &amp;&amp;<br>(<br><span class="hljs-comment">// (s = h.next) == null 表示队列中还有没有老二</span><br>(s = h.next) == <span class="hljs-keyword">null</span> ||<br>   <span class="hljs-comment">// 或者队列中老二线程不是此线程</span><br>s.thread != Thread.currentThread()<br>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>每个条件变量其实就对应着一个<strong>等待队列</strong>，其实现类是 ConditionObject</p><h4 id="await-流程"><a href="#await-流程" class="headerlink" title="await 流程"></a>await 流程</h4><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程。创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.14.png"></p><p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.15.png"></p><p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.16.png"></p><p>park 阻塞 Thread-0</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.17.png"></p><h4 id="signal-流程"><a href="#signal-流程" class="headerlink" title="signal 流程"></a>signal 流程</h4><p>假设 Thread-1 要来唤醒 Thread-0</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.18.png"></p><p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.19.png"></p><p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</p><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.20.png"></p><p>Thread-1 释放锁，进入 unlock 流程</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1173984872572414699L</span>;<br><span class="hljs-comment">// 第一个等待节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br><span class="hljs-comment">// 最后一个等待节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConditionObject</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <br><span class="hljs-comment">// ㈠ 添加一个 Node 至等待队列</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addConditionWaiter</span><span class="hljs-params">()</span> </span>&#123;<br>Node t = lastWaiter;<br><span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>unlinkCancelledWaiters();<br>t = lastWaiter;<br>&#125;<br><span class="hljs-comment">// 创建一个关联当前线程的新 Node, 添加至队列尾部</span><br>Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);<br><span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>)<br>firstWaiter = node;<br><span class="hljs-keyword">else</span><br>t.nextWaiter = node;<br>lastWaiter = node;<br><span class="hljs-keyword">return</span> node;<br>&#125;<br>    <br><span class="hljs-comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// 已经是尾节点了</span><br><span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>) &#123;<br>lastWaiter = <span class="hljs-keyword">null</span>;<br>&#125;<br>first.nextWaiter = <span class="hljs-keyword">null</span>;<br>&#125; <span class="hljs-keyword">while</span> (<br><span class="hljs-comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span><br>!transferForSignal(first) &amp;&amp;<br><span class="hljs-comment">// 队列还有节点</span><br>(first = firstWaiter) != <span class="hljs-keyword">null</span><br>);<br>&#125;<br>    <br><span class="hljs-comment">// 外部类方法, 方便阅读, 放在此处</span><br><span class="hljs-comment">// ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferForSignal</span><span class="hljs-params">(Node node)</span> </span>&#123;<br><span class="hljs-comment">// 如果状态已经不是 Node.CONDITION, 说明被取消了</span><br><span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 加入 AQS 队列尾部</span><br>Node p = enq(node);<br><span class="hljs-keyword">int</span> ws = p.waitStatus;<br><span class="hljs-keyword">if</span> (<br><span class="hljs-comment">// 上一个节点被取消</span><br>ws &gt; <span class="hljs-number">0</span> ||<br><span class="hljs-comment">// 上一个节点不能设置状态为 Node.SIGNAL</span><br>!compareAndSetWaitStatus(p, ws, Node.SIGNAL)<br>) &#123;<br><span class="hljs-comment">// unpark 取消阻塞, 让线程重新同步状态</span><br>LockSupport.unpark(node.thread);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>    <br><span class="hljs-comment">// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignalAll</span><span class="hljs-params">(Node first)</span> </span>&#123;<br>lastWaiter = firstWaiter = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">do</span> &#123;<br>Node next = first.nextWaiter;<br>first.nextWaiter = <span class="hljs-keyword">null</span>;<br>transferForSignal(first);<br>first = next;<br>&#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-keyword">null</span>);<br>&#125;<br>    <br><span class="hljs-comment">// ㈡</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlinkCancelledWaiters</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br>    <br><span class="hljs-comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>Node first = firstWaiter;<br><span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>doSignal(first);<br>&#125;<br>    <br><span class="hljs-comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>Node first = firstWaiter;<br><span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>doSignalAll(first);<br>&#125;<br>    <br><span class="hljs-comment">// 不可打断等待 - 直到被唤醒</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>Node node = addConditionWaiter();<br><span class="hljs-comment">// 释放节点持有的锁, 见 ㈣</span><br><span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br><span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br><span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br><span class="hljs-comment">// park 阻塞</span><br>LockSupport.park(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">// 如果被打断, 仅设置打断状态</span><br><span class="hljs-keyword">if</span> (Thread.interrupted())<br>interrupted = <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span><br><span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted)<br>selfInterrupt();<br>&#125;<br>    <br>    <span class="hljs-comment">// 外部类方法, 方便阅读, 放在此处</span><br><span class="hljs-comment">// ㈣ 因为某线程可能重入，需要将 state 全部释放</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fullyRelease</span><span class="hljs-params">(Node node)</span> </span>&#123;<br><span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">int</span> savedState = getState();<br><span class="hljs-keyword">if</span> (release(savedState)) &#123;<br>failed = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">return</span> savedState;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failed)<br>node.waitStatus = Node.CANCELLED;<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">// 打断模式 - 在退出等待时重新设置打断状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REINTERRUPT = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 打断模式 - 在退出等待时抛出异常</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THROW_IE = -<span class="hljs-number">1</span>;<br><span class="hljs-comment">// 判断打断模式</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> </span>&#123;<br><span class="hljs-keyword">return</span> Thread.interrupted() ?(transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :<span class="hljs-number">0</span>;<br>&#125;<br>    <br><span class="hljs-comment">// ㈤ 应用打断模式</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> interruptMode)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">if</span> (interruptMode == THROW_IE)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)<br>selfInterrupt();<br>&#125;<br>    <br><span class="hljs-comment">// 等待 - 直到被唤醒或打断</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>&#125;<br><span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>Node node = addConditionWaiter();<br><span class="hljs-comment">// 释放节点持有的锁</span><br><span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br><span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br><span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br><span class="hljs-comment">// park 阻塞</span><br>LockSupport.park(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-comment">// 如果被打断, 退出等待队列</span><br><span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span><br><span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>interruptMode = REINTERRUPT;<br><span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span><br><span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)<br>unlinkCancelledWaiters();<br><span class="hljs-comment">// 应用打断模式, 见 ㈤</span><br><span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>reportInterruptAfterWait(interruptMode);<br>&#125;<br>    <br><span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">awaitNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>&#125;<br><span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>Node node = addConditionWaiter();<br><span class="hljs-comment">// 释放节点持有的锁</span><br><span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br><span class="hljs-comment">// 获得最后期限</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = System.nanoTime() + nanosTimeout;<br><span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br><span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br><span class="hljs-comment">// 已超时, 退出等待队列</span><br><span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;<br>transferAfterCancelledWait(node);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns</span><br><span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)<br>LockSupport.parkNanos(<span class="hljs-keyword">this</span>, nanosTimeout);<br><span class="hljs-comment">// 如果被打断, 退出等待队列</span><br><span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>nanosTimeout = deadline - System.nanoTime();<br>&#125;<br><span class="hljs-comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span><br><span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>interruptMode = REINTERRUPT;<br><span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span><br><span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)<br>unlinkCancelledWaiters();<br><span class="hljs-comment">// 应用打断模式, 见 ㈤</span><br><span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>reportInterruptAfterWait(interruptMode);<br><span class="hljs-keyword">return</span> deadline - System.nanoTime();<br>&#125;<br>    <br>    <span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-comment">// 工具方法 省略 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="8-4、读写锁"><a href="#8-4、读写锁" class="headerlink" title="8.4、读写锁"></a>8.4、读写锁</h2><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>当读操作远远高于写操作时，这时候使用<strong>读写锁</strong>，让读-读可以并发，提高性能。类似于数据库中的 <code>select ...from ... lock in share mode</code></p><p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantReadWriteLockTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        DataContainer dataContainer = <span class="hljs-keyword">new</span> DataContainer();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            dataContainer.read();<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            dataContainer.read();<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;DataContainer&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainer</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Object data;<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock rw = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.ReadLock r = rw.readLock();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.WriteLock w = rw.writeLock();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;获取读锁...&quot;</span>);<br>        r.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;读取&quot;</span>);<br>            sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;释放读锁...&quot;</span>);r.unlock();<br>        &#125;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;获取写锁...&quot;</span>);<br>        w.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;写入&quot;</span>);<br>            sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;释放写锁...&quot;</span>);<br>            w.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.21.png"></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><strong>读锁不支持条件变量</strong></li><li><strong>重入时锁升级不支持</strong>：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li><li><strong>重入时降级支持</strong>：即持有写锁的情况下去获取读锁</li></ul><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个</p><h5 id="t1-w-lock，t2-r-lock"><a href="#t1-w-lock，t2-r-lock" class="headerlink" title="t1 w.lock，t2 r.lock"></a>t1 w.lock，t2 r.lock</h5><ul><li>t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.22.png"></p><ul><li>t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么 tryAcquireShared 返回 -1 表示失败</li></ul><blockquote><p>tryAcquireShared 返回值</p><p>-1 表示失败</p><p>0 表示成功，但后继节点不会继续唤醒</p><p>正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1</p></blockquote><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.23.png"></p><ul><li>这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.24.png"></p><ul><li>t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁</li><li>如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.25.png"></p><h5 id="t3-r-lock，t4-w-lock"><a href="#t3-r-lock，t4-w-lock" class="headerlink" title="t3 r.lock，t4 w.lock"></a>t3 r.lock，t4 w.lock</h5><ul><li>这种状态下，假设又有 t3 加读锁（shared）和 t4 加写锁（Ex），这期间 t1 仍然持有锁，就变成了下面的样子</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.26.png"></p><h5 id="t1-w-unlock"><a href="#t1-w-unlock" class="headerlink" title="t1 w.unlock"></a>t1 w.unlock</h5><ul><li>这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.27.png"></p><ul><li>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行<br>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.28.png"></p><ul><li>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.29.png"></p><ul><li>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.30.png"></p><ul><li>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.31.png"></p><ul><li>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.32.png"></p><ul><li>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</li></ul><h5 id="t2-r-unlock，t3-r-unlock"><a href="#t2-r-unlock，t3-r-unlock" class="headerlink" title="t2 r.unlock，t3 r.unlock"></a>t2 r.unlock，t3 r.unlock</h5><ul><li>t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.33.png"></p><ul><li>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.34.png"></p><ul><li>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他竞争，tryAcquire(1) 成功，修改头结点，流程结束</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.35.png"></p><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><h5 id="写锁上锁流程"><a href="#写锁上锁流程" class="headerlink" title="写锁上锁流程"></a>写锁上锁流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-comment">// ... 省略无关代码</span><br><span class="hljs-comment">// 外部类 WriteLock 方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>sync.acquire(<span class="hljs-number">1</span>);<br>&#125;<br>    <br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<br><span class="hljs-comment">// 尝试获得写锁失败</span><br>!tryAcquire(arg) &amp;&amp;<br><span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span><br><span class="hljs-comment">// 进入 AQS 队列阻塞</span><br>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>) &#123;<br>selfInterrupt();<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br><span class="hljs-comment">// 获得低 16 位, 代表写锁的 state 计数</span><br>Thread current = Thread.currentThread();<br><span class="hljs-keyword">int</span> c = getState();<br>    <span class="hljs-keyword">int</span> w = exclusiveCount(c);<br><span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (<br><span class="hljs-comment">// c != 0 and w == 0 表示有读锁, 或者</span><br>w == <span class="hljs-number">0</span> ||<br><span class="hljs-comment">// 如果 exclusiveOwnerThread 不是自己</span><br>current != getExclusiveOwnerThread()<br>) &#123;<br><span class="hljs-comment">// 获得锁失败</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-comment">// 写锁计数超过低 16 位, 报异常</span><br><span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br><span class="hljs-comment">// 写锁重入, 获得锁成功</span><br>setState(c + acquires);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<br><span class="hljs-comment">// 判断写锁是否该阻塞, 或者</span><br>writerShouldBlock() ||<br><span class="hljs-comment">// 尝试更改计数失败</span><br>!compareAndSetState(c, c + acquires)<br>) &#123;<br><span class="hljs-comment">// 获得锁失败</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-comment">// 获得锁成功</span><br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>    <br><span class="hljs-comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">writerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="写锁释放流程"><a href="#写锁释放流程" class="headerlink" title="写锁释放流程"></a>写锁释放流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-comment">// ... 省略无关代码</span><br><span class="hljs-comment">// WriteLock 方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>sync.release(<span class="hljs-number">1</span>);<br>&#125;<br>    <br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-comment">// 尝试释放写锁成功</span><br>   <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br><span class="hljs-comment">// unpark AQS 中等待的线程</span><br>Node h = head;<br><span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>unparkSuccessor(h);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>    <br><span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br><span class="hljs-keyword">int</span> nextc = getState() - releases;<br><span class="hljs-comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span><br><span class="hljs-keyword">boolean</span> free = exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (free) &#123;<br>setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>&#125;<br>setState(nextc);<br><span class="hljs-keyword">return</span> free;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="读锁上锁流程"><a href="#读锁上锁流程" class="headerlink" title="读锁上锁流程"></a>读锁上锁流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-comment">// ReadLock 方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br>    <br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span><br><span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>) &#123;<br>doAcquireShared(arg);<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>Thread current = Thread.currentThread();<br><span class="hljs-keyword">int</span> c = getState();<br><span class="hljs-comment">// 如果是其它线程持有写锁, 获取读锁失败</span><br><span class="hljs-keyword">if</span> (<br>exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp; getExclusiveOwnerThread() != current<br>) &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-keyword">int</span> r = sharedCount(c);<br><span class="hljs-keyword">if</span> (<br><span class="hljs-comment">// 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且</span><br>!readerShouldBlock() &amp;&amp;<br><span class="hljs-comment">// 小于读锁计数, 并且</span><br>r &lt; MAX_COUNT &amp;&amp;<br><span class="hljs-comment">// 尝试增加计数成功</span><br>compareAndSetState(c, c + SHARED_UNIT)<br>) &#123;<br><span class="hljs-comment">// ... 省略不重要的代码</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>&#125;<br>    <br><span class="hljs-comment">// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span><br><span class="hljs-comment">// true 则该阻塞, false 则不阻塞</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">readerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();<br>&#125;<br>    <br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-comment">// 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fullTryAcquireShared</span><span class="hljs-params">(Thread current)</span> </span>&#123;<br>HoldCounter rh = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">int</span> c = getState();<br><span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != current)<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readerShouldBlock()) &#123;<br><span class="hljs-comment">// ... 省略不重要的代码</span><br>&#125;<br><span class="hljs-keyword">if</span> (sharedCount(c) == MAX_COUNT)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br><span class="hljs-keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;<br><span class="hljs-comment">// ... 省略不重要的代码</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span><br><span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br><span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">final</span> Node p = node.predecessor();<br><span class="hljs-keyword">if</span> (p == head) &#123;<br>    <span class="hljs-comment">// 再一次尝试获取读锁</span><br><span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br><span class="hljs-comment">// 成功</span><br><span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// ㈠</span><br><span class="hljs-comment">// r 表示可用资源数, 在这里总是 1 允许传播</span><br><span class="hljs-comment">//（唤醒 AQS 中下一个 Share 节点）</span><br>setHeadAndPropagate(node, r);<br>p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br><span class="hljs-keyword">if</span> (interrupted)<br>selfInterrupt();<br>failed = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (<br><span class="hljs-comment">// 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）</span><br>shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br><span class="hljs-comment">// park 当前线程</span><br>parkAndCheckInterrupt()<br>) &#123;<br>interrupted = <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failed)<br>cancelAcquire(node);<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;<br>Node h = head; <span class="hljs-comment">// Record old head for check below</span><br><span class="hljs-comment">// 设置自己为 head</span><br>setHead(node);<br><span class="hljs-comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span><br><span class="hljs-comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span><br><span class="hljs-comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span><br><span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||(h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>Node s = node.next;<br><span class="hljs-comment">// 如果是最后一个节点或者是等待共享读锁的节点</span><br><span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared()) &#123;<br><span class="hljs-comment">// 进入 ㈡</span><br>doReleaseShared();<br>&#125;<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span><br>    <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br>Node h = head;<br><span class="hljs-comment">// 队列还有节点</span><br><span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<br><span class="hljs-keyword">int</span> ws = h.waitStatus;<br><span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br><span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br><span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop to recheck cases</span><br><span class="hljs-comment">// 下一个节点 unpark 如果成功获取读锁</span><br><span class="hljs-comment">// 并且下下个节点还是 shared, 继续 doReleaseShared</span><br>unparkSuccessor(h);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br><span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop on failed CAS</span><br>&#125;<br><span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// loop if head changed</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="读锁释放流程"><a href="#读锁释放流程" class="headerlink" title="读锁释放流程"></a>读锁释放流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-comment">// ReadLock 方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br>    <br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>doReleaseShared();<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>    <br><span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br><span class="hljs-comment">// ... 省略不重要的代码</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">int</span> c = getState();<br><span class="hljs-keyword">int</span> nextc = c - SHARED_UNIT;<br><span class="hljs-keyword">if</span> (compareAndSetState(c, nextc)) &#123;<br><span class="hljs-comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span><br><span class="hljs-comment">// 计数为 0 才是真正释放</span><br><span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>&#125;<br>    &#125;<br>&#125;<br>    <br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span><br><span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br>Node h = head;<br><span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<br><span class="hljs-keyword">int</span> ws = h.waitStatus;<br><span class="hljs-comment">// 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span><br><span class="hljs-comment">// 防止 unparkSuccessor 被多次执行</span><br><span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br><span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br><span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop to recheck cases</span><br>unparkSuccessor(h);<br>&#125;<br><span class="hljs-comment">// 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br><span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop on failed CAS</span><br>&#125;<br><span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// loop if head changed</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p><h4 id="加解读锁"><a href="#加解读锁" class="headerlink" title="加解读锁"></a>加解读锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.readLock();<br>lock.unlockRead(stamp);<br></code></pre></td></tr></table></figure><blockquote><p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead();<br><span class="hljs-comment">// 验戳</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br><span class="hljs-comment">// 锁升级</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="加解写锁"><a href="#加解写锁" class="headerlink" title="加解写锁"></a>加解写锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StampedLockTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        DataContainerStamped container = <span class="hljs-keyword">new</span> DataContainerStamped(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;container.read(<span class="hljs-number">2000</span>)).start();<br>        <span class="hljs-comment">//new Thread(()-&gt;container.read(2000)).start();</span><br>        sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;container.write(<span class="hljs-number">2</span>)).start();<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;DataContainerStamped&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainerStamped</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StampedLock lock = <span class="hljs-keyword">new</span> StampedLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataContainerStamped</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> readTime)</span></span>&#123;<br>        <span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead();<br>        log.debug(<span class="hljs-string">&quot;加锁,乐观读锁，&#123;&#125;&quot;</span>,stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(readTime);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lock.validate(stamp))&#123;<br>            log.debug(<span class="hljs-string">&quot;解锁,乐观读锁，&#123;&#125;&quot;</span>,stamp);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br><br>        <span class="hljs-comment">//锁升级-乐观锁升级为读锁</span><br>        log.debug(<span class="hljs-string">&quot;更新,读锁，&#123;&#125;&quot;</span>,stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            stamp = lock.tryReadLock();<br>            log.debug(<span class="hljs-string">&quot;加锁,正常读锁，&#123;&#125;&quot;</span>,stamp);<br>            sleep(readTime);<br>            log.debug(<span class="hljs-string">&quot;读取结束，&#123;&#125;&quot;</span>,stamp);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;解锁,正常读锁，&#123;&#125;&quot;</span>,stamp);<br>            lock.unlockRead(stamp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newData)</span></span>&#123;<br>        <span class="hljs-keyword">long</span> stamp = lock.writeLock();<br>        log.debug(<span class="hljs-string">&quot;加锁,写锁，&#123;&#125;&quot;</span>,stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">this</span>.data = newData;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;解锁,写锁，&#123;&#125;&quot;</span>,stamp);<br>            lock.unlockWrite(stamp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.36.png"></p><blockquote><p>注意</p><ul><li>StampedLock 不支持条件变量</li><li>StampedLock 不支持可重入</li></ul></blockquote><h2 id="8-5、Semaphore"><a href="#8-5、Semaphore" class="headerlink" title="8.5、Semaphore"></a>8.5、Semaphore</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>信号量，用来限制能同时访问共享资源的线程上限。</p><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;SemaphoreTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//1.创建信号量</span><br>        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//2.十个线程执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                    log.debug(<span class="hljs-string">&quot;线程开始运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;线程结束运行&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.37.png"></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现）</li><li>用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好，（需要线程数和数据库连接数是相等的）</li></ul><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><h4 id="加锁解锁流程-1"><a href="#加锁解锁流程-1" class="headerlink" title="加锁解锁流程"></a>加锁解锁流程</h4><p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减一</p><ul><li>刚开始，permits（state）为 3，这时 5 个线程来获取资源</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.38.png"></p><ul><li>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.39.png"></p><ul><li>这时 Thread-4 释放了 permits，状态如下</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.40.png"></p><ul><li>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</li></ul><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.41.png"></p><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">2694183684443567898L</span>;<br>NonfairSync(<span class="hljs-keyword">int</span> permits) &#123;<br><span class="hljs-comment">// permits 即 state</span><br><span class="hljs-keyword">super</span>(permits);<br>&#125;<br><span class="hljs-comment">// Semaphore 方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br><span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>doAcquireSharedInterruptibly(arg);<br>&#125;<br><span class="hljs-comment">// 尝试获得共享锁</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br><span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>&#125;<br><span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">int</span> available = getState();<br><span class="hljs-keyword">int</span> remaining = available - acquires;<br><span class="hljs-keyword">if</span> (<br><span class="hljs-comment">// 如果许可已经用完, 返回负数, 表示获取失败, 进入 doAcquireSharedInterruptibly</span><br>remaining &lt; <span class="hljs-number">0</span> ||<br><span class="hljs-comment">// 如果 cas 重试成功, 返回正数, 表示获取成功</span><br>compareAndSetState(available, remaining)<br>    ) &#123;<br><span class="hljs-keyword">return</span> remaining;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br><span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">final</span> Node p = node.predecessor();<br><span class="hljs-keyword">if</span> (p == head) &#123;<br><span class="hljs-comment">// 再次尝试获取许可</span><br><span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br><span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 成功后本线程出队（AQS）, 所在 Node设置为 head</span><br><span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span><br><span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span><br><span class="hljs-comment">// r 表示可用资源数, 为 0 则不会继续传播</span><br>setHeadAndPropagate(node, r);<br>p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>failed = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞</span><br><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failed)<br>cancelAcquire(node);<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">// Semaphore 方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>doReleaseShared();<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">int</span> current = getState();<br><span class="hljs-keyword">int</span> next = current + releases;<br><span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br><span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-6、CountdownLatch-用于线程同步"><a href="#8-6、CountdownLatch-用于线程同步" class="headerlink" title="8.6、CountdownLatch-用于线程同步"></a>8.6、CountdownLatch-用于线程同步</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><code>CountdownLatch</code>用来进行<strong>线程同步</strong>协作，等待所有线程完成倒计时。</p><p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p><h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;CountdownLatchTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountdownLatchTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">3</span>);<br>        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>        pool.execute(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;线程任务开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            latch.countDown();<br>            log.debug(<span class="hljs-string">&quot;线程任务结束，&#123;&#125;&quot;</span>,latch.getCount());<br>        &#125;);<br>        pool.execute(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;线程任务开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            latch.countDown();<br>            log.debug(<span class="hljs-string">&quot;线程任务结束，&#123;&#125;&quot;</span>,latch.getCount());<br>        &#125;);<br>        pool.execute(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;线程任务开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            latch.countDown();<br>            log.debug(<span class="hljs-string">&quot;线程任务结束，&#123;&#125;&quot;</span>,latch.getCount());<br>        &#125;);<br>        latch.await();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.42.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//等待多个线程准备完毕</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountdownLatchTest02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">10</span>);<br>        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        Random r = <span class="hljs-keyword">new</span> Random();<br>        String[] all = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>        System.out.println(<span class="hljs-string">&quot;等待所有玩家加载&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt; <span class="hljs-number">10</span>;j++) &#123;<br>            <span class="hljs-keyword">int</span> k = j;<br>            pool.execute(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(r.nextInt(<span class="hljs-number">100</span>));<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    all[k] = i + <span class="hljs-string">&quot;%&quot;</span>;<br>                    System.out.print(<span class="hljs-string">&quot;\r&quot;</span>+Arrays.toString(all));<br>                &#125;<br>                latch.countDown();<br>            &#125;);<br>        &#125;<br>        latch.await();<br>        System.out.println(<span class="hljs-string">&quot;\n游戏开始&quot;</span>);<br>        pool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.43.png"></p><blockquote><p>注意：</p><p>CountDownLatch对象不能重用，如果需要重用可以使用CyclicBarrier</p></blockquote><hr><h2 id="8-7、CyclicBarrier-用于线程同步"><a href="#8-7、CyclicBarrier-用于线程同步" class="headerlink" title="8.7、CyclicBarrier-用于线程同步"></a>8.7、CyclicBarrier-用于线程同步</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>CyclicBarrier，循环栅栏，用来进行线程协作，等待线程满足某个计数。</p><p>构造时设置<strong>计数个数</strong>，每个线程执行到某个需要“同步”的时刻调用 <code>await()</code> 方法进行等待，当等待的线程数满足计数个数时，继续执行</p><h3 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;CyclicBarrierTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>        CyclicBarrier barrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++) &#123;<br>            pool.execute(()-&gt;&#123;<br>                log.debug(<span class="hljs-string">&quot;任务1开始&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sleep(<span class="hljs-number">1000</span>);<br>                    barrier.await();<span class="hljs-comment">//2-1=1</span><br>                    log.debug(<span class="hljs-string">&quot;任务1结束&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            pool.execute(()-&gt;&#123;<br>                log.debug(<span class="hljs-string">&quot;任务2开始&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sleep(<span class="hljs-number">2000</span>);<br>                    barrier.await();<span class="hljs-comment">//1-1=0</span><br>                    log.debug(<span class="hljs-string">&quot;任务2结束&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        pool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.44.png"></p><blockquote><p>注意：</p><p>线程数需要和CyclicBarrier对象中计数是一样的</p></blockquote><hr><h2 id="8-8、线程安全集合类概述"><a href="#8-8、线程安全集合类概述" class="headerlink" title="8.8、线程安全集合类概述"></a>8.8、线程安全集合类概述</h2><p><img src="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.45.png"></p><p>线程安全集合类可以分为三大类：</p><ul><li>遗留的线程安全集合如 <code>Hashtable </code>， <code>Vector</code>，此类型集合线程安全是由方法上加了<code>synchronized</code>关键字实现的。性能较低</li><li>使用Collections装饰的线程安全集合，如下：此类型集合线程安全是将原本的不是线程安全集合传入，多加了<code>fina Object mutex</code>属性，并<code>synchronized(mutex)</code>加锁，是装饰器模式的一种体现。性能较低<ul><li><code>Collections.synchronizedCollection</code></li><li><code>Collections.synchronizedList</code></li><li><code>Collections.synchronizedMap</code></li><li><code>Collections.synchronizedSet</code></li><li><code>Collections.synchronizedNavigableMap</code></li><li><code>Collections.synchronizedNavigableSet</code></li><li><code>Collections.synchronizedSortedMap</code></li><li><code>Collections.synchronizedSortedSet</code></li></ul></li><li><code>java.util.concurrent.*</code>，主要分为三类，Blocking、CopyOnWrite、Concurrent<ul><li>Blocking 大部分实现基于锁，并提供用来阻塞的方法</li><li>CopyOnWrite 之类容器修改开销相对较重</li><li>Concurrent 类型的容器<ul><li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</li><li>弱一致性<ul><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li><li>求大小弱一致性，size 操作未必是 100% 准确</li><li>读取弱一致性</li></ul></li></ul></li></ul></li></ul><blockquote><p>遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历</p></blockquote><h3 id="8-9、ConcurrentHashMap"><a href="#8-9、ConcurrentHashMap" class="headerlink" title="8.9、ConcurrentHashMap"></a>8.9、ConcurrentHashMap</h3><p>详见容器源码</p><h3 id="8-10、BlockingQueue"><a href="#8-10、BlockingQueue" class="headerlink" title="8.10、BlockingQueue"></a>8.10、BlockingQueue</h3><p>详见容器源码</p><h3 id="8-11、ConcurrentLinkedQueue"><a href="#8-11、ConcurrentLinkedQueue" class="headerlink" title="8.11、ConcurrentLinkedQueue"></a>8.11、ConcurrentLinkedQueue</h3><p>详见容器源码</p><h3 id="8-12、CopyOnWriteArrayList"><a href="#8-12、CopyOnWriteArrayList" class="headerlink" title="8.12、CopyOnWriteArrayList"></a>8.12、CopyOnWriteArrayList</h3><p>详见容器源码</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM学习</title>
    <link href="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h3 id="1-3-比较"><a href="#1-3-比较" class="headerlink" title="1.3 比较"></a>1.3 比较</h3><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.0.1.png" alt="2.0.1"></p><hr><h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.1.png" alt="2.1"></p><ul><li>线程共享：方法区、堆</li><li>线程隔离：虚拟机栈、程序计数器、本地方法栈</li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721113517327.png" alt="image-20210721113517327"></p><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><h4 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h4><p>Program Counter Register 程序计数器（寄存器）</p><ul><li>作用是，记住下一条jvm指令的执行地址</li><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>每条线程都有一个独立的程序计数器，此内存区域是唯一一个在《Java虚拟机规范》中<strong>没有规定任何OutOfMemoryError情况的区域</strong>（<strong>不存在内存溢出</strong>）<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li></ul><h3 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h3><h4 id="2-2-1-定义"><a href="#2-2-1-定义" class="headerlink" title="2.2.1 定义"></a>2.2.1 定义</h4><p>Java Virtual Machine Stacks （Java虚拟机栈），虚拟机栈描述的是Java方法执行的线程内存模型，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>、<strong>方法出口</strong>等信息。</p><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721194930197.png" alt="image-20210721194930197"></p><h4 id="2-2-2-特点"><a href="#2-2-2-特点" class="headerlink" title="2.2.2 特点"></a>2.2.2 特点</h4><ul><li>生命周期与线程相同</li><li>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</li><li>每个线程只能有一个<strong>活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li><li><strong>垃圾回收不涉及栈内存</strong>，因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li><li>方法内的局部变量是否线程安全？<ul><li>如果方法内局部变量没有逃离方法（return）的作用访问，它是线程安全的</li><li>如果是局部变量引用了对象，并逃离方法的作用范围，线程可能不安全</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li></ul><h4 id="2-2-3-演示"><a href="#2-2-3-演示" class="headerlink" title="2.2.3 演示"></a>2.2.3 演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method1();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">int</span> c = a + b;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.1.2.png" alt="2.1.2"></p><h4 id="2-2-4-栈内存溢出"><a href="#2-2-4-栈内存溢出" class="headerlink" title="2.2.4 栈内存溢出"></a>2.2.4 栈内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p>原因：</p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4 id="2-2-5-线程运行诊断"><a href="#2-2-5-线程运行诊断" class="headerlink" title="2.2.5 线程运行诊断"></a>2.2.5 线程运行诊断</h4><p>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程</p><ul><li>用<strong>top</strong>定位哪个进程对cpu的占用过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong>，（用ps命令进一步定位是哪个线程引起的cpu占用过高）</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul><h4 id="2-2-6-栈帧的内部结构"><a href="#2-2-6-栈帧的内部结构" class="headerlink" title="2.2.6 栈帧的内部结构"></a>2.2.6 栈帧的内部结构</h4><p>每个栈帧中存储着：</p><ul><li><p>局部变量表（Local Variables）</p></li><li><p>操作数栈（operand Stack）（或表达式栈）</p></li><li><p>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</p></li><li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p></li><li><p>一些附加信息</p></li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721195636046.png" alt="image-20210721195636046"></p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>局部变量表也被称之为局部变量数组或本地变量表</p><p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p><ul><li><p> 定义为一个数字<strong>数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。 </p></li><li><p> 由于局部变量表是建立在线程的栈上，是<strong>线程的私有数据</strong>，因此不存在数据安全问题 </p></li><li><p> 局部变量表所需的<strong>容量大小是在编译期确定</strong>下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。 </p></li><li><p> <strong>方法嵌套调用的次数由栈的大小决定。</strong>一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。 </p></li><li><p> <strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 </p></li></ul><p><strong>静态变量与局部变量的对比</strong></p><p><strong>类变量表有两次初始化的机会</strong>，第一次是在“<strong>准备阶段</strong>”，执行系统初始化，对类变量设置零值，另一次则是在“<strong>初始化</strong>”阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着<strong>一旦定义了局部变量则必须人为的初始化</strong>，否则无法使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> a;<span class="hljs-comment">//这样是对的</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i; <span class="hljs-comment">//这样是错的</span><br>    System. out. println(i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的<strong>操作数栈</strong>，也可以称之为表达式栈（Expression Stack）</p><p><strong>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></p><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p><ul><li><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</p></li><li><p>比如：执行复制、交换、求和等操作</p></li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721215213032.png" alt="image-20210721215213032"></p><blockquote><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p></blockquote><ul><li>栈顶缓存技术（Top Of Stack Cashing）技术</li></ul><blockquote><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中</strong>，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p></blockquote><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>每一个栈帧内部都包含一个指向<strong>运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</p><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong>。</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721220507542.png" alt="image-20210721220507542"></p><h5 id="方法出口（返回地址）"><a href="#方法出口（返回地址）" class="headerlink" title="方法出口（返回地址）"></a>方法出口（返回地址）</h5><p> 存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li><p>正常执行完成</p></li><li><p>出现未处理的异常，非正常退出</p></li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。<strong>方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><hr><h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><h4 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h4><p>本地方法栈是为虚拟机使用到的本地（native）方法服务</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常</p><ul><li>本地方法栈，也是线程私有的。</li></ul><hr><h3 id="2-4-Java堆"><a href="#2-4-Java堆" class="headerlink" title="2.4 Java堆"></a>2.4 Java堆</h3><ul><li>堆针对一个JVM进程来说是唯一的，也就是<strong>一个进程只有一个JVM</strong>，但是进程包含多个线程，他们是共享同一堆空间的。</li></ul><h4 id="2-4-1-定义"><a href="#2-4-1-定义" class="headerlink" title="2.4.1 定义"></a>2.4.1 定义</h4><p>Heap 堆：通过<code>new</code>关键字，创建对象都会使用堆内存</p><h4 id="2-4-2-特点"><a href="#2-4-2-特点" class="headerlink" title="2.4.2 特点"></a>2.4.2 特点</h4><ul><li>它是线程共享的，堆中对象都需要<strong>考虑线程安全</strong>的问题</li><li>有垃圾回收机制</li><li><strong>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置</strong>。</li></ul><blockquote><p>根据《Java虚拟机规范》规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上他应该被视为连续的</p></blockquote><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721222718429.png" alt="image-20210721222718429"></p><h4 id="2-4-3-堆内存溢出"><a href="#2-4-3-堆内存溢出" class="headerlink" title="2.4.3 堆内存溢出"></a>2.4.3 堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4 id="2-4-4-堆内存诊断"><a href="#2-4-4-堆内存诊断" class="headerlink" title="2.4.4 堆内存诊断"></a>2.4.4 堆内存诊断</h4><ol><li><p>jps工具<br> 查看当前系统中有哪些 java 进程</p></li><li><p>jmap工具<br> 查看堆内存占用情况<code>jmap - heap</code>进程id</p></li><li><p>jconsole工具<br> 图形界面的，多功能的监测工具，可以连续监测</p></li><li><p>jvirsalvm工具</p></li></ol><p>  可视化，动态监测程序的线程状况，可以查看当前堆快照，并分析各类的实例所占内存比</p><h4 id="2-4-5-为对象分配内存：TLAB"><a href="#2-4-5-为对象分配内存：TLAB" class="headerlink" title="2.4.5 为对象分配内存：TLAB"></a>2.4.5 为对象分配内存：TLAB</h4><ul><li>TLAB：Thread Local Allocation Buffer，目的是为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p><strong>什么是TLAB？</strong></p><ul><li> 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。 </li><li> 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。 </li><li> 对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210722105315793.png" alt="image-20210722105315793"></p><hr><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><h4 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1 定义"></a>2.5.1 定义</h4><p>方法区存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化以及接口初始化中使用的特殊方法。</p><p>类加载后会将类的class文件读入jvm的方法区</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210722114949976.png" alt="image-20210722114949976"></p><h4 id="2-5-2-内部结构"><a href="#2-5-2-内部结构" class="headerlink" title="2.5.2 内部结构"></a>2.5.2 内部结构</h4><h5 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h5><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ol><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ol><h5 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h5><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p><h5 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h5><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外） </li></ol><ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul><h5 id="非final的类变量"><a href="#非final的类变量" class="headerlink" title="非final的类变量"></a>非final的类变量</h5><ul><li><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p></li><li><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p></li></ul><blockquote><p>static final 全局常量</p><p>被声明为final的类变量的处理方法则不同，每个final全局常量在编译成字节码文件的时候就会被分配了。</p></blockquote><h4 id="2-5-3-特点"><a href="#2-5-3-特点" class="headerlink" title="2.5.3 特点"></a>2.5.3 特点</h4><ul><li>线程共享</li><li>方法区在逻辑上是堆的一部分，但实现不同（hotspot虚拟机，JDK1.8之前在永久代中实现，JDK1.8之后在元空间中实现）</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.2.png"></p><h4 id="2-5-4-方法区内存溢出"><a href="#2-5-4-方法区内存溢出" class="headerlink" title="2.5.4 方法区内存溢出"></a>2.5.4 方法区内存溢出</h4><ul><li>1.8 以前会导致永久代内存溢出</li><li>1.8 之后会导致元空间内存溢出</li></ul><blockquote><p>方法区和永久代的关系</p><blockquote><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p></blockquote></blockquote><h4 id="2-5-5-运行时常量池"><a href="#2-5-5-运行时常量池" class="headerlink" title="2.5.5 运行时常量池"></a>2.5.5 运行时常量池</h4><p>运行时常量池是方法区的一部分。</p><ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量与符号引用等信息</li><li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li></ul><p><strong>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></p><p><strong>通过反编译来查看类的信息</strong></p><ul><li>输入 <strong>javac 对应类的绝对路径</strong></li><li> <strong>javap -v 类的绝对路径</strong></li></ul><p><strong>反编译以后类的信息</strong></p><p>类的基本信息</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.2.2.png"></p><p>常量池</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.2.3.png"></p><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.2.4.png"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.2.5.png"></p><h5 id="2-5-5-1-字符串池-StringTable"><a href="#2-5-5-1-字符串池-StringTable" class="headerlink" title="2.5.5.1 字符串池-StringTable"></a>2.5.5.1 字符串池-StringTable</h5><p>JDK1.6之前，位于常量池中，JDK1.8之后位于堆中</p><p>底层是<strong>HashTable</strong>（用来放字符串对象且里面的<strong>元素不重复</strong>），可能发生哈希碰撞，可以设置哈希桶的个数进行调优</p><p><strong>特点</strong></p><ul><li>常量池中的字符串仅是符号，<strong>第一次用到时才变为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是 <code>StringBuilder</code>的<code>append</code>方法（JDK1.8）</li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译期优化</strong></li><li>可以使用<code>intern</code>方法，主动将串池中还没有的字符串对象放入串池<ul><li>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入,返回常量池对象，如果没有则<strong>放入串池</strong>， 会把串池中的对象返回</li><li>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入,返回常量池对象，如果没有会把此对象<strong>复制</strong>一份，放入串池， 会把串池中的对象返回</li></ul></li><li><strong>无论是串池还是堆里面的字符串，都是对象</strong></li></ul><h6 id="1-使用字符串直接赋值创建字符串的过程"><a href="#1-使用字符串直接赋值创建字符串的过程" class="headerlink" title="1. 使用字符串直接赋值创建字符串的过程"></a>1. 使用<strong>字符串直接赋值</strong>创建字符串的过程</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String a = <span class="hljs-string">&quot;a&quot;</span>; <br>String b = <span class="hljs-string">&quot;b&quot;</span>;<br>String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><p>反编译后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br><span class="hljs-number">2</span>: astore_1<br><span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br><span class="hljs-number">5</span>: astore_2<br><span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br><span class="hljs-number">8</span>: astore_3<br><span class="hljs-number">9</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><h6 id="2-使用拼接字符串变量对象创建字符串的过程"><a href="#2-使用拼接字符串变量对象创建字符串的过程" class="headerlink" title="2. 使用拼接字符串变量对象创建字符串的过程"></a>2. 使用拼接<strong>字符串变量对象</strong>创建字符串的过程</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String a = <span class="hljs-string">&quot;a&quot;</span>;<br>String b = <span class="hljs-string">&quot;b&quot;</span>;<br>String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">//拼接字符串对象来创建新的字符串</span><br>String ab2 = a+b; <br>        <span class="hljs-comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span><br>System.out.println(ab == ab2);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>       <span class="hljs-number">2</span>: astore_1<br>       <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>       <span class="hljs-number">5</span>: astore_2<br>       <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>       <span class="hljs-number">8</span>: astore_3<br>       <span class="hljs-number">9</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>      <span class="hljs-number">12</span>: dup<br>      <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>      <span class="hljs-number">16</span>: aload_1<br>      <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>   <span class="hljs-comment">//;)Ljava/lang/StringBuilder;</span><br>      <span class="hljs-number">20</span>: aload_2<br>      <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>   <span class="hljs-comment">//;)Ljava/lang/StringBuilder;</span><br>      <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br>      <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span><br>      <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：<code>StringBuilder().append(“a”).append(“b”).toString()</code></p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><h6 id="3-使用拼接字符串常量对象的方法创建字符串"><a href="#3-使用拼接字符串常量对象的方法创建字符串" class="headerlink" title="3. 使用拼接字符串常量对象的方法创建字符串"></a>3. 使用<strong>拼接字符串常量对象</strong>的方法创建字符串</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String a = <span class="hljs-string">&quot;a&quot;</span>;<br>String b = <span class="hljs-string">&quot;b&quot;</span>;<br>String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br>String ab2 = a+b;<br><span class="hljs-comment">//使用拼接字符串的方法创建字符串</span><br>String ab3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>  stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span><br>     <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>     <span class="hljs-number">2</span>: astore_1<br>     <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>     <span class="hljs-number">5</span>: astore_2<br>     <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>     <span class="hljs-number">8</span>: astore_3<br>     <span class="hljs-number">9</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>    <span class="hljs-number">12</span>: dup<br>    <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>    <span class="hljs-number">16</span>: aload_1<br>    <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>  <span class="hljs-comment">//;)Ljava/lang/StringBuilder;</span><br>    <span class="hljs-number">20</span>: aload_2<br>    <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>  <span class="hljs-comment">//;)Ljava/lang/StringBuilder;</span><br>    <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br>    <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span><br>    <span class="hljs-comment">//ab3初始化时直接从串池中获取字符串</span><br>    <span class="hljs-number">29</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>    <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span><br>    <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul><h6 id="4-使用new-String-构造方法创建字符串"><a href="#4-使用new-String-构造方法创建字符串" class="headerlink" title="4. 使用new String()构造方法创建字符串"></a>4. 使用new String()构造方法创建字符串</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>        String s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>        String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br><br>        System.out.println(s == s1);  <span class="hljs-comment">//false</span><br>        System.out.println(s == s2);  <span class="hljs-comment">//false</span><br>        System.out.println(s1 == s2); <span class="hljs-comment">//false</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>String s = new String(“abc”)：首先会在String Pool查询是否有字符串“abc”，如果没有，则创建一个“abc”对象，放到String Pool中。如果存在，就不再创建</p><p>然后遇到new，则会在堆中创建一个“abc”对象，然后用<strong>s指向堆中的“abc”</strong>。因此这一步创建了两个对象</p><blockquote><p>注意：s是引用，不是对象，真正的对象时存在堆中的“abc”。s记录了“abc”的地址</p></blockquote></li><li><p>String s1 = “abc”：首先会在String Pool查询是否有字符串“abc”，如果存在，s1指向位于String Pool中“abc”的地址</p></li><li><p>String s2 = new String(“abc”)：首先会在String Pool查询是否有字符串“abc”，如果没有，则创建一个“abc”对象，放到String Pool中。如果存在，就不再创建</p><p>然后遇到new，则会在堆中创建一个“abc”对象，然后用<strong>s2指向堆中的“abc”</strong>。因此这一步创建了一个对象</p></li></ul><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ul><li>不管是<code>String s = new String(&quot;xx&quot;)</code>还是<code>String s = &quot;xxx&quot;</code>都会先在<code>String Pool</code>中查找想要创建的字符串是否已经存在。<ul><li>如果存在，则都不会再在<code>String Pool</code>中创建对象。<ul><li>但是<code>new</code>还会在堆中创建一个对象，</li><li><code>String = &quot;XXX&quot;</code>方式会直接把字符串常量池中的地址返回给变量<code>s</code></li></ul></li><li>如果不存在<ul><li><code>new</code>会在常量池和堆中<strong>分别创建一个对象</strong>，然后指向堆中的对象</li><li><code>String = &quot; &quot;</code>仅仅在常量池中创建对象</li></ul></li></ul></li></ul><h6 id="intern-方法的作用"><a href="#intern-方法的作用" class="headerlink" title="intern()方法的作用"></a>intern()方法的作用</h6><ul><li><p>任何一个字符串只要调用了<code>.intern()</code>方法都会去<code>String Pool</code>中查找该字符串是否存在，如果存在，则返回该字符串在<code>String Pool</code>的地址</p></li><li><p>如果不存在，则会在<code>String Pool</code>中创建该字符串，然后返回地址。<strong>那么这里的创建方式呢，根据JDK版本的不同，又会有两种方式。假设该字符串已经在堆中存在</strong></p><ul><li><p>JDK1.6：常量池和堆完全分开，会创建新对象</p></li><li><p>JDK1.7以上：常量池是堆的一部分，不会创建新对象，而是指向堆中对象的一个引用。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>        String s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>        String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-comment">// s指向堆中 s1指向常量池  所以 false</span><br>        System.out.println(s == s1);<br>        <span class="hljs-comment">// s指向堆中 s2指向堆中另外一块内存区域  所以false</span><br>        System.out.println(s == s2);<br>        <span class="hljs-comment">// s1指向常量池 s2指向堆 所以false</span><br>        System.out.println(s1 == s2);<br><span class="hljs-comment">// s指向堆  s.intern()是常量池中的地址 所以 false</span><br>        System.out.println(s == s.intern());<br>        <span class="hljs-comment">// s1指向常量池  s1.intern()也指向常量池 所以true</span><br>        System.out.println(s1 == s1.intern());<br>        <span class="hljs-comment">// s.intern()和s2.intern()都指向常量池 所以true</span><br>        System.out.println(s.intern() == s2.intern());<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>习题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>String s3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<span class="hljs-comment">//编译器优化，变为ab，储存在字符串常量池</span><br>String s4 = s1 + s2;<span class="hljs-comment">//StringBuilder.append.toString,储存在堆中，并试图放到字符串常量池中一份（发现已存在）</span><br>String s5 = <span class="hljs-string">&quot;ab&quot;</span>;<span class="hljs-comment">//发现字符串常量池中已有ab，直接引用ab</span><br>String s6 = s4.intern();<span class="hljs-comment">//发现池中存在，入池失败，返回常量池对象</span><br><span class="hljs-comment">// 问</span><br>System.out.println(s3 == s4);<span class="hljs-comment">//false</span><br>System.out.println(s3 == s5);<span class="hljs-comment">//true</span><br>System.out.println(s3 == s6);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK1.8</span><br>String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>);<span class="hljs-comment">//堆中（不会试图添加到常量池中）</span><br>String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<span class="hljs-comment">//常量池中</span><br>x2.intern();<span class="hljs-comment">//入池失败</span><br>System.out.println(x1 == x2);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK1.8</span><br>String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>);<span class="hljs-comment">//堆中（不会试图添加到常量池中）</span><br>x2.intern();<span class="hljs-comment">//入池成功</span><br>String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<span class="hljs-comment">//从池中获取,与x2堆中是同一个对象</span><br>System.out.println(x1 == x2);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK1.6</span><br>String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>);<span class="hljs-comment">//堆中（不会试图添加到常量池中）</span><br>x2.intern();<span class="hljs-comment">//入池成功</span><br>String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<span class="hljs-comment">//从池中获取,与x2堆中不是同一个对象</span><br>System.out.println(x1 == x2);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK1.8</span><br>String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);<br>System.out.println(s == s.intern()); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>分析：</p><p><code>String s = new String(&quot;1&quot;) + new String(&quot;1&quot;)</code>：会在堆中创建对象<code>s = &quot;11&quot;</code>。但是不会在常量池中创建。如果接下来调用s.intern()。那么，会尝试在常量池中创建对象，此时根据JDK版本不同，会有两种情况：</p><ul><li>JDK1.6：常量池和堆完全分开，会创建新对象</li><li>JDK1.7以上：常量池是堆的一部分，不会创建新对象，而是<strong>指向堆中对象的一个引用</strong>。因此在上面的例子中，二者指向的是同一个对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    String s0 = <span class="hljs-string">&quot;beijing&quot;</span>;<br>    String s1 = <span class="hljs-string">&quot;bei&quot;</span>;<br>    String s2 = <span class="hljs-string">&quot;jing&quot;</span>;<br>    String s3 = s1 + s2;<br>    System.out.println(s0 == s3); <span class="hljs-comment">// false s3指向对象实例，s0指向字符串常量池中的&quot;beijing&quot;</span><br>    String s7 = <span class="hljs-string">&quot;shanxi&quot;</span>;<br>    <span class="hljs-keyword">final</span> String s4 = <span class="hljs-string">&quot;shan&quot;</span>;<br>    <span class="hljs-keyword">final</span> String s5 = <span class="hljs-string">&quot;xi&quot;</span>;<br>    String s6 = s4 + s5;<br>    System.out.println(s6 == s7); <span class="hljs-comment">// true s4和s5是final修饰的，编译期就能确定s6的值了</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li><p>不使用final修饰，即为变量。如s3行的s1和s2，会通过new StringBuilder进行拼接</p></li><li><p>使用final修饰，即为常量。会在编译器进行代码优化。在实际开发中，能够使用final的，尽量使用</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ① String s = new String(&quot;1&quot;)</span><br><span class="hljs-comment"> * 创建了两个对象</span><br><span class="hljs-comment"> * 堆空间中一个new对象</span><br><span class="hljs-comment"> * 字符串常量池中一个字符串常量&quot;1&quot;（注意：此时字符串常量池中已有&quot;1&quot;）</span><br><span class="hljs-comment"> * ② s.intern()由于字符串常量池中已存在&quot;1&quot;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * s  指向的是堆空间中的对象地址</span><br><span class="hljs-comment"> * s2 指向的是堆空间中常量池中&quot;1&quot;的地址</span><br><span class="hljs-comment"> * 所以不相等</span><br><span class="hljs-comment"> */</span><br>String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);<br>s.intern();<br>String s2 = <span class="hljs-string">&quot;1&quot;</span>;<br>System.out.println(s==s2); <span class="hljs-comment">// jdk1.6 false jdk7/8 false</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ① String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;)</span><br><span class="hljs-comment"> * 等价于new String（&quot;11&quot;），但是，常量池中并不生成字符串&quot;11&quot;；</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ② s3.intern()</span><br><span class="hljs-comment"> * 由于此时常量池中并无&quot;11&quot;，所以把s3中记录的对象的地址存入常量池</span><br><span class="hljs-comment"> * 所以s3 和 s4 指向的都是一个地址</span><br><span class="hljs-comment">*/</span><br>String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);<br>s3.intern();<br>String s4 = <span class="hljs-string">&quot;11&quot;</span>;<br>System.out.println(s3==s4); <span class="hljs-comment">//jdk1.6 false jdk7/8 true</span><br></code></pre></td></tr></table></figure><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723151600561.png" alt="image-20210723151600561"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723151833638.png" alt="image-20210723151833638"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723151925809.png" alt="image-20210723151925809"></p><hr><h3 id="2-6-直接内存"><a href="#2-6-直接内存" class="headerlink" title="2.6 直接内存"></a>2.6 直接内存</h3><h4 id="2-6-1-定义"><a href="#2-6-1-定义" class="headerlink" title="2.6.1 定义"></a>2.6.1 定义</h4><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。常见于 NIO 操作时，用于<strong>数据缓冲区</strong></p><h4 id="2-6-2-特点"><a href="#2-6-2-特点" class="headerlink" title="2.6.2 特点"></a>2.6.2 特点</h4><ul><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li><li>也会发生内存溢出异常</li></ul><p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><h5 id="不使用直接内存时"><a href="#不使用直接内存时" class="headerlink" title="不使用直接内存时"></a>不使用直接内存时</h5><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.3.png"></p><h5 id="使用直接内存时"><a href="#使用直接内存时" class="headerlink" title="使用直接内存时"></a>使用直接内存时</h5><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.4.png"></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="2-6-3-分配和回收原理"><a href="#2-6-3-分配和回收原理" class="headerlink" title="2.6.3 分配和回收原理"></a>2.6.3 分配和回收原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><ul><li>使用了<code>Unsafe</code>对象完成直接内存的分配回收，并且回收需要主动调用<code>freeMemory</code>方法</li><li><code>ByteBuffer</code>的实现类内部，使用了<code>Cleaner</code>（虚引用）来监测<code>ByteBuffer</code>对象，一旦<code>ByteBuffer</code>对象被垃圾回收，那么就会由<code>ReferenceHandler</code>线程通过<code>Cleaner</code>的<code>clean</code>方法调用<code>freeMemory</code>来释放直接内存</li></ul><h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="3-1-如何判断对象可回收"><a href="#3-1-如何判断对象可回收" class="headerlink" title="3.1 如何判断对象可回收"></a>3.1 如何判断对象可回收</h3><h4 id="3-1-1-引用计数法"><a href="#3-1-1-引用计数法" class="headerlink" title="3.1.1 引用计数法"></a>3.1.1 引用计数法</h4><p>每一个对象有一个引用计数器，当对象被引用一次则计数器加一，当引用对象失效一次则计数器减一，对于计数器为0的对象意味着是垃圾对象，可以被GC回收</p><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.1.png"></p><h4 id="3-1-2-可达性分析算法"><a href="#3-1-2-可达性分析算法" class="headerlink" title="3.1.2 可达性分析算法"></a>3.1.2 可达性分析算法</h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</p><ul><li>如，各个线程被调用的方法中使用到的参数、局部变量等</li></ul></li><li><p>方法区中类静态属性引用的对象</p><ul><li>Java类的引用类型静态变量</li></ul></li><li><p>方法区中常量引用的对象</p><ul><li>字符串常量池（String Table）里的引用</li></ul></li><li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象</p></li><li><p>所有被同步锁synchronized持有的对象</p></li><li><p>Java虚拟机内部的引用。 </p><ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li></ul></li><li><p>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p></li></ul></li></ul><h4 id="3-1-3-五种引用"><a href="#3-1-3-五种引用" class="headerlink" title="3.1.3 五种引用"></a>3.1.3 五种引用</h4><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.2.png"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210714222004243.png" alt="image-20210714222004243"></p><h5 id="1-强引用-不回收"><a href="#1-强引用-不回收" class="headerlink" title="1. 强引用 - 不回收"></a>1. 强引用 - 不回收</h5><p><code>new</code>一个对象时候，就是强引用，只有GC Root<strong>都不引用</strong>该对象时（显式地将强引用赋值为null），才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuffer str = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello gotcha&quot;</span>);<br>StringBuffer str1 = str;<br></code></pre></td></tr></table></figure><p>局部变量str,str1指向StringBuffer实例所在堆空间，通过str,str1可以操作该实例，那么str,str1就是StringBuffer实例的强引用</p><p><strong>对应内存结构</strong></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210714222459049.png" alt="image-20210714222459049"></p><blockquote><p>强引用特点</p><ul><li><p>强引用可以直接访问目标对象。</p></li><li><p>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</p></li><li><p>强引用可能导致内存泄漏。</p></li></ul></blockquote><h5 id="2-软引用（SoftReference）-GC后仍内存不足时，回收"><a href="#2-软引用（SoftReference）-GC后仍内存不足时，回收" class="headerlink" title="2. 软引用（SoftReference）- GC后仍内存不足时，回收"></a>2. 软引用（SoftReference）- GC后仍内存不足时，回收</h5><p>当GC Root指向软引用对象时（仅有软引用引用该对象时），在<strong>垃圾回收后，内存仍不足</strong>时会再次触发垃圾回收，<strong>回收软引用所引用的对象</strong></p><p>软引用通常用来实现<strong>内存敏感的缓存</strong>。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>可以配合引用队列来释放软引用自身</p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><p><strong>软引用的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使用<strong>引用队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span><br>ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br><span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);<br><br><span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span><br>Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<br><span class="hljs-keyword">while</span>(poll != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span><br>list.remove(poll);<br><span class="hljs-comment">//移动到引用队列中的下一个元素</span><br>poll = queue.poll();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-弱引用（WeakReference）-GC时回收"><a href="#3-弱引用（WeakReference）-GC时回收" class="headerlink" title="3. 弱引用（WeakReference）- GC时回收"></a>3. 弱引用（WeakReference）- GC时回收</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><p>可以配合引用队列来释放弱引用自身</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><blockquote><p>由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p></blockquote><blockquote><p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p></blockquote><h5 id="4-虚引用（PhantomReference）-对象回收追踪"><a href="#4-虚引用（PhantomReference）-对象回收追踪" class="headerlink" title="4. 虚引用（PhantomReference）- 对象回收追踪"></a>4. <strong>虚引用</strong>（PhantomReference）- 对象回收追踪</h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><p>为一个对象设置虚引用关联的唯一目的在于<strong>跟踪垃圾回收过程</strong>。比如：能在这个对象被收集器回收时收到一个系统通知。</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><blockquote><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p></blockquote><table><thead><tr><th>引用类型</th><th>被回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVM停止运行时</td></tr><tr><td>软引用</td><td>GC后，内存依旧不足时</td><td>对象缓存</td><td>内存不足时</td></tr><tr><td>弱引用</td><td>jvm垃圾回收时</td><td>对象缓存</td><td>gc运行后</td></tr><tr><td>虚引用</td><td>未知</td><td>对象回收追踪</td><td>未知</td></tr></tbody></table><h5 id="5-终结器引用（FinalReference）"><a href="#5-终结器引用（FinalReference）" class="headerlink" title="5. 终结器引用（FinalReference）"></a>5. 终结器引用（FinalReference）</h5><p>所有的类都继承自Object类，Object类有一个<code>finalize</code>方法，其内部配合引用队列使用。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的<code>finalize</code>方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h6 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h6><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，<strong>总会先调用这个对象的finalize()方法</strong>。</p><p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><p><strong>永远不要主动调用某个对象的finalize()方法</strong>，应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li><p>在finalize()时可能会导致对象复活。</p></li><li><p>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</p></li><li><p>一个糟糕的finalize()会严重影响Gc的性能。</p></li></ul><p>从功能上来说，finalize()方法与C中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C中的析构函数。</p><p>由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。</p><h5 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h5><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li><p><strong>可触及的</strong>：从根节点开始，可以到达这个对象。</p></li><li><p><strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</p></li><li><p><strong>不可触及的</strong>：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。</p></li></ul><p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h6 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h6><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ol><li><p>如果对象objA到GC Roots没有引用链，则进行第一次标记。</p></li><li><p>进行筛选，判断此对象是否有必要执行finalize()方法</p></li><li><p>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</p></li><li><p>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</p></li><li><p>finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</p></li></ol><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CanReliveObj</span> </span>&#123;<br>    <span class="hljs-comment">// 类变量，属于GC Roots的一部分</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CanReliveObj canReliveObj;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-keyword">super</span>.finalize();<br>        System.out.println(<span class="hljs-string">&quot;调用当前类重写的finalize()方法&quot;</span>);<br>        canReliveObj = <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        canReliveObj = <span class="hljs-keyword">new</span> CanReliveObj();<br>        canReliveObj = <span class="hljs-keyword">null</span>;<br>        System.gc();<br>        System.out.println(<span class="hljs-string">&quot;-----------------第一次gc操作------------&quot;</span>);<br>        <span class="hljs-comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span><br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">if</span> (canReliveObj == <span class="hljs-keyword">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----------------第二次gc操作------------&quot;</span>);<br>        canReliveObj = <span class="hljs-keyword">null</span>;<br>        System.gc();<br>        <span class="hljs-comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span><br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">if</span> (canReliveObj == <span class="hljs-keyword">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">-----------------第一次gc操作------------<br>调用当前类重写的finalize()方法<br>obj is still alive<br>-----------------第二次gc操作------------<br>obj is dead<br></code></pre></td></tr></table></figure><blockquote><p>在第一次GC时，执行了finalize方法，但finalize()方法只会被调用一次，所以第二次该对象被GC标记并清除了。</p></blockquote><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li>软引用和弱引用<strong>可以配合</strong>引用队列<ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li></ul></li></ul><p><strong>大概思路为：</strong>查看引用队列中有无软/弱引用，如果有，则将该软/弱引用从存放它的集合中移除（这里为一个list集合）</p><h3 id="3-2-垃圾回收算法"><a href="#3-2-垃圾回收算法" class="headerlink" title="3.2 垃圾回收算法"></a>3.2 垃圾回收算法</h3><h4 id="3-2-1-标记-清除"><a href="#3-2-1-标记-清除" class="headerlink" title="3.2.1 标记-清除"></a>3.2.1 标记-清除</h4><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.3.png" alt="img"></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清零，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：</p><ul><li><p><strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p></li><li><p>在进行GC的时候，需要停止整个应用程序，用户体验较差</p></li><li><p>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个<strong>空闲列表</strong></p></li></ul><h4 id="3-2-2-标记-复制"><a href="#3-2-2-标记-复制" class="headerlink" title="3.2.2 标记-复制"></a>3.2.2 标记-复制</h4><p><strong>定义</strong>：将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题。</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.4.png" alt="img"></p><p><strong>缺点</strong>：会占用双倍的内存空间。</p><p><strong>应用场景</strong>：在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><p><strong>改进</strong>：由于新生代都是朝生夕死的，所以不需要1：1划分内存空间，可以将内存划分为一块较大的Eden和两块较小的Suvivor空间。每次使用Eden和其中一块Survivor。当回收的时候，将Eden和Survivor中还活着的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才使用过的Suevivor空间。其中Eden和Suevivor的大小比例是8：1。缺点是需要老年代进行分配担保，如果第二块的Survovor空间不够的时候，需要对老年代进行垃圾回收，然后存储新生代的对象，这些新生代当然会直接进入来老年代。</p><h4 id="3-2-3-标记-整理"><a href="#3-2-3-标记-整理" class="headerlink" title="3.2.3 标记-整理"></a>3.2.3 标记-整理</h4><p><strong>定义</strong>：将不被GC Root引用的对象回收，清除其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.5.png" alt="img"></p><p>标记-清除算法是一种<strong>非移动式</strong>的回收算法，标记-压缩是<strong>移动式</strong>的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，<strong>JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销</strong>。</p><h5 id="指针碰撞（Bump-the-Pointer）"><a href="#指针碰撞（Bump-the-Pointer）" class="headerlink" title="指针碰撞（Bump the Pointer）"></a>指针碰撞（Bump the Pointer）</h5><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump tHe Pointer）。</p><p><strong>优点</strong></p><ul><li><p>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</p></li><li><p>消除了复制算法当中，内存减半的高额代价。</p></li></ul><p><strong>缺点</strong></p><ul><li><p>从效率上来说，标记-整理算法要低于复制算法。</p></li><li><p>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</p></li><li><p>移动过程中，需要全程暂停用户应用程序。即：STW</p></li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th></th><th>Mark-Sweep（标记-清除）</th><th>Mark-Compact（标记-整理）</th><th>Copying<strong>（标记-复制）</strong></th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><hr><h3 id="3-3-分代回收"><a href="#3-3-分代回收" class="headerlink" title="3.3 分代回收"></a>3.3 分代回收</h3><p>分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><ul><li>年轻代（Young Gen）</li></ul><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况使用<strong>标记-复制</strong>，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><p>新生代收集：Minor GC / Young GC</p><ul><li>老年代（Tenured Gen）</li></ul><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由<strong>标记-清除</strong>或者是标记-清除与标记-整理的混合实现。</p><ol><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>Compact阶段的开销与存活对象的数据成正比。</li></ol><p>老年代收集：Major GC / Old GC</p><h4 id="3-3-1-回收流程"><a href="#3-3-1-回收流程" class="headerlink" title="3.3.1 回收流程"></a>3.3.1 回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.6.png" alt="img"></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.7.png" alt="img"></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.8.png" alt="img"></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.9.png" alt="img"></p><p>如果新生代老年代中的内存都满了，就会先触发Minor Gc，再触发<strong>Full GC</strong>（会触发 <strong>stop the world</strong>且时间更长），扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><hr><h4 id="3-3-2-GC-分析"><a href="#3-3-2-GC-分析" class="headerlink" title="3.3.2 GC 分析"></a>3.3.2 GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><ul><li><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p></li><li><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p></li></ul><h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><blockquote><p>线程开启了一个新线程，新的线程OOM，不影响主线程运行</p></blockquote><hr><h3 id="3-4-垃圾回收器种类"><a href="#3-4-垃圾回收器种类" class="headerlink" title="3.4 垃圾回收器种类"></a>3.4 垃圾回收器种类</h3><h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a>按线程数分</h4><h5 id="串行回收器"><a href="#串行回收器" class="headerlink" title="串行回收器"></a>串行回收器</h5><p>串行回收指的是在<strong>同一时间段内只允许有一个CPU用于执行垃圾回收操作</strong>，此时工作线程被暂停，直至垃圾收集工作结束。</p><p>如，Serial、Serial Old</p><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.10.png" alt="img"></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5 id="并行回收器"><a href="#并行回收器" class="headerlink" title="并行回收器"></a>并行回收器</h5><p>并行回收指<strong>运用多个CPU，多条垃圾收集线程并行工作</strong>，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。此时<strong>用户线程仍处于等待状态</strong>。</p><p>如，ParNew、Parallel Scavenge、Parallel old</p><h4 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h4><h5 id="独占式回收器"><a href="#独占式回收器" class="headerlink" title="独占式回收器"></a>独占式回收器</h5><p>独占式垃圾回收器（Stop the world）一旦运行，就<strong>停止应用程序中的所有用户线程</strong>，直到垃圾回收过程完全结束。</p><h5 id="并发式回收器"><a href="#并发式回收器" class="headerlink" title="并发式回收器"></a>并发式回收器</h5><p>并发式垃圾回收器与应用程序线程<strong>交替工作</strong>，以尽可能减少应用程序的停顿时间。</p><p>如，CMS、G1</p><h4 id="按碎片处理方式区分"><a href="#按碎片处理方式区分" class="headerlink" title="按碎片处理方式区分"></a>按碎片处理方式区分</h4><h5 id="压缩式垃圾回收器"><a href="#压缩式垃圾回收器" class="headerlink" title="压缩式垃圾回收器"></a>压缩式垃圾回收器</h5><p>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</p><h5 id="非压缩式垃圾回收器"><a href="#非压缩式垃圾回收器" class="headerlink" title="非压缩式垃圾回收器"></a>非压缩式垃圾回收器</h5><p>非压缩式的垃圾回收器不进行这步操作。</p><h4 id="按工作区间区分"><a href="#按工作区间区分" class="headerlink" title="按工作区间区分"></a>按工作区间区分</h4><h5 id="年轻代垃圾回收器"><a href="#年轻代垃圾回收器" class="headerlink" title="年轻代垃圾回收器"></a>年轻代垃圾回收器</h5><p>如，Serial、ParNew、Parallel Scavenge</p><h5 id="老年代垃圾回收器"><a href="#老年代垃圾回收器" class="headerlink" title="老年代垃圾回收器"></a>老年代垃圾回收器</h5><p>如，SerialOld、Parallel Old、CMS</p><hr><h4 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h4><ul><li><p><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</p></li><li><p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</p></li><li><p><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</p></li><li><p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p></li><li><p>内存占用：Java堆区所占的内存大小。</p></li><li><p>快速：一个对象从诞生到被回收所经历的时间。</p></li></ul><h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715105056153.png" alt="image-20210715105056153"></p><p><strong>特点</strong></p><ul><li>单位时间内，STW（stop the world，停掉其他所有工作线程）总时间最短</li></ul><h5 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h5><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。</p><p>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p><p>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715105213520.png" alt="image-20210715105213520"></p><p><strong>特点</strong></p><ul><li>尽可能让<strong>单次</strong>STW时间变短（尽量不影响其他线程运行）</li></ul><hr><h4 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h4><h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p><p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p><p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p><h6 id="抢先式中断：（目前没有虚拟机采用了）"><a href="#抢先式中断：（目前没有虚拟机采用了）" class="headerlink" title="抢先式中断：（目前没有虚拟机采用了）"></a>抢先式中断：（目前没有虚拟机采用了）</h6><ul><li>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li></ul><h6 id="主动式中断："><a href="#主动式中断：" class="headerlink" title="主动式中断："></a>主动式中断：</h6><p>设置一个中断标志，各个线程运行到Safe Point的时候主动<strong>轮询</strong>这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</p><h5 id="安全区域（Safe-Resion）"><a href="#安全区域（Safe-Resion）" class="headerlink" title="安全区域（Safe Resion）"></a>安全区域（Safe Resion）</h5><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p><h5 id="实际执行时："><a href="#实际执行时：" class="headerlink" title="实际执行时："></a>实际执行时：</h5><ol><li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Relgion，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li></ol><hr><h3 id="3-5-几种垃圾回收器"><a href="#3-5-几种垃圾回收器" class="headerlink" title="3.5 几种垃圾回收器"></a>3.5 几种垃圾回收器</h3><h4 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h4><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p><p>Serial收集器是HotSpot中client模式下的默认新生代垃圾收集器。</p><p>Serial收集器采用<strong>标记-复制算法</strong>、<strong>串行回收</strong>和”stop-the-World”机制的方式执行内存回收。</p><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是<strong>标记-整理</strong>算法。</p><ul><li><p>Serial old是运行在Client模式下默认的老年代的垃圾回收器</p></li><li><p>Serial 0ld在Server模式下主要有两个用途：① 与新生代的Parallel scavenge配合使用 ② 作为老年代CMS收集器的后备垃圾收集方案</p></li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715150100026.png" alt="image-20210715150100026"></p><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><p>优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。</p><blockquote><p>在HotSpot虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC，且老年代用Serial Old GC</p></blockquote><p><strong>总结</strong></p><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p><hr><h4 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h4><p>ParNew收集器其实就是Serial收集器的多线程版本。Par是Parallel的缩写，New：只能处理的是新生代</p><p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用<strong>标记-复制</strong>算法、”Stop-the-World”机制。</p><p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715150735810.png" alt="image-20210715150735810"></p><ul><li><p>对于新生代，回收次数频繁，使用并行方式高效。</p></li><li><p>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</p></li></ul><blockquote><p>在程序中，开发人员可以通过选项”<code>-XX:+UseParNewGC</code>“手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。<code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和CPU数据相同的线程数。</p></blockquote><blockquote><p>除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p></blockquote><hr><h4 id="Parallel-Scavenge回收器：吞吐量优先"><a href="#Parallel-Scavenge回收器：吞吐量优先" class="headerlink" title="Parallel Scavenge回收器：吞吐量优先"></a>Parallel Scavenge回收器：吞吐量优先</h4><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了<strong>标记-复制</strong>算法、并行回收和”Stop the World”机制。</p><p>那么Parallel 收集器的出现是否多此一举？</p><ul><li><p>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为<strong>吞吐量优先</strong>的垃圾收集器。</p></li><li><p><strong>自适应调节策略</strong>也是Parallel Scavenge与ParNew一个重要区别。</p></li><li><p><strong>JDK1.8默认使用</strong>的垃圾回收器</p></li></ul><blockquote><p><strong>GC自适应调节策略</strong>：</p><p>Parallel Scavenge收集器可设置</p><p>-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p></blockquote><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><hr><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>Parallel Old 是Parallel Scavenge收集器的老年代版本，在JDK1.6时提供。用于代替老年代的Serial Old收集器。</p><p>Parallel Old收集器采用了<strong>标记-整理</strong>算法（老年代没有幸存区），但同样也是基于并行回收和”Stop-the-World”机制。</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715151403328.png" alt="image-20210715151403328"></p><hr><h4 id="CMS回收器：响应时间优先"><a href="#CMS回收器：响应时间优先" class="headerlink" title="CMS回收器：响应时间优先"></a>CMS回收器：响应时间优先</h4><p>在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次<strong>实现了让垃圾收集线程与用户线程同时工作</strong>。</p><p>CMS收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。但是会<strong>产生内存碎片</strong></p><ul><li>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li></ul><p>CMS的垃圾收集算法采用<strong>标记-清除</strong>算法，并且也会”Stop-the-World”</p><p>不幸的是，CMS作为<strong>老年代</strong>的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择<strong>ParNew</strong>或者Serial收集器中的一个。</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：暂停所有的其他线程，并标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。<strong>仍然存在Stop The World问题</strong></p><p><strong>并发清除</strong>： 开启用户线程，同时 GC 线程对标记的对象进行清除回收</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715154114166.png" alt="image-20210715154114166"></p><blockquote><p>由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了</p></blockquote><ul><li>为什么CMS不能用标记-整理方法</li></ul><p>因为当并发清除的时候，整理内存会导致，原来的用户线程使用的内存无法使用</p><blockquote><p>CMS收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择<strong>空闲列表</strong>（Free List）执行内存分配。</p></blockquote><ul><li><p>CMS的优点</p><ul><li>并发收集</li><li>低延迟</li></ul></li><li><p>缺点</p><ul><li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</li><li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li>CMS收集器无法处理浮动垃圾。可能出现“<code>Concurrent Mode Failure</code>“失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ul></li></ul><blockquote><p>设置的参数</p><ul><li><p><code>-XX:+UseConcMarkSweepGC</code>手动指定使用CMS收集器执行内存回收任务。<br>开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开。即：ParNew（Young区用）+CMS（Old区用）+ Serial Old的组合。 </p></li><li><p> <code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。 </p></li><li><p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</p></li><li><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</p></li><li><p> <code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。 </p></li><li><p> <code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次Full GC后对内存空间进行压缩整理。 </p></li><li><p> <code>-XX:ParallelcMSThreads</code> 设置CMS的线程数量。 </p></li><li><p>CMS默认启动的线程数是（ParallelGCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p></li></ul></blockquote><blockquote><p>JDK9中：CMS被标记为Deprecate（JEP291）</p><p>JDK14中：移除了CMS垃圾回收器（JEP363）</p></blockquote><hr><h4 id="G1收集器：区域化分代式"><a href="#G1收集器：区域化分代式" class="headerlink" title="G1收集器：区域化分代式"></a>G1收集器：区域化分代式</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</p><p>Garbage First(G1)是一个<strong>并行</strong>回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p><p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong>。</p><p>这种方式的侧重点在于<strong>回收垃圾最大量的区间</strong>（Region），所以G1叫做：垃圾优先（Garbage First）。</p><p>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为“全功能的垃圾收集器”。</p><p>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.13.png" alt="img"></p><hr><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><h6 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h6><ul><li><p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</p></li><li><p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p></li></ul><h6 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h6><ul><li><p>从分代上看，G1<strong>依然属于分代型垃圾回收器</strong>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p></li><li><p>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</p></li><li><p>和之前的各类回收器不同，它同时<strong>兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代</p></li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210716104300313.png" alt="image-20210716104300313"></p><h6 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h6><ul><li><p>CMS：<strong>标记-清除</strong>算法，会产生内存碎片，若干次GC后需要进行碎片整理</p></li><li><p>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是<strong>标记-复制</strong>算法，但整体上实际可看作是<strong>标记-整理</strong>算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。<strong>尤其是当Java堆非常大的时候，G1的优势更加明显</strong>。</p></li></ul><h6 id="可预测的停顿时间模型（即：软实时soft-real-time）"><a href="#可预测的停顿时间模型（即：软实时soft-real-time）" class="headerlink" title="可预测的停顿时间模型（即：软实时soft real-time）"></a>可预测的停顿时间模型（即：软实时soft real-time）</h6><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li><p>由于分区的原因，G1可以<strong>只选取部分区域进行内存回收</strong>，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</p></li><li><p>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个<strong>优先列表</strong>，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p></li><li><p>相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是<strong>最差情况要好很多</strong>。</p></li></ul><hr><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</p><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p><hr><h5 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区Region：化整为零</h5><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<strong>所有的Region大小相同，且在JVM生命周期内不会被改变</strong>。</p><p>虽然还保留有新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离的</strong>了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210716105026391.png" alt="image-20210716105026391"></p><p>一个region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，S表示属于survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p><p>设置H的原因：对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。<strong>如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p>每个Region都是通过<strong>指针碰撞</strong>来分配空间</p><hr><h5 id="G1垃圾回收流程"><a href="#G1垃圾回收流程" class="headerlink" title="G1垃圾回收流程"></a>G1垃圾回收流程</h5><p>G1GC的垃圾回收过程主要包括如下三个环节：</p><ul><li><p> 年轻代GC（Young GC） </p></li><li><p> 老年代并发标记过程（Concurrent Marking） </p></li><li><p>混合回收（Mixed GC）<br>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。） </p></li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210716105424690.png" alt="image-20210716105424690"></p><p><strong>Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC</strong>顺序，进行垃圾回收。</p><p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；**G1的年轻代收集阶段是一个并行的独占式收集器(会stw)**。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p><p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了</strong>。同时，这个老年代Region是和年轻代一起被回收的。</p><p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><hr><h5 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h5><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.20.png" alt="img"></p><p>在G1收集器可能存在如下问题：</p><ul><li><p> 一个对象被不同区域引用的问题 （跨区/代引用），如上图</p></li><li><p> 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？ </p></li><li><p> 在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？ </p></li><li><p> 这样的话会降低MinorGC的效率； </p></li></ul><p><strong>解决方法：</strong></p><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set（记忆集）来避免全局扫描：</p><p><strong>每个Region都有一个对应的Remembered Set；</strong></p><p>每次Reference类型数据写操作时，都会产生一个Write Barrier（写屏障）暂时中断操作；</p><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p><p>如果不同，通过CardTable（卡表）把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</p><p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><blockquote><p> 例如，下图中，Region1 和 Region 3 分别引用了 Region2 中的对象。则在Region2 对应的RememberSet中进行记录。对Region2进行GC时，发现有两个对象时有被其他区域引用的，则不清理</p></blockquote><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210716111525903.png" alt="image-20210716111525903"></p><hr><h5 id="G1回收过程一：年轻代GC"><a href="#G1回收过程一：年轻代GC" class="headerlink" title="G1回收过程一：年轻代GC"></a>G1回收过程一：年轻代GC</h5><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p><p><strong>年轻代垃圾回收只会回收Eden区和Survivor区。</strong></p><p>首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><ul><li>会发生STW</li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210716111223590.png" alt="image-20210716111223590"></p><p>然后开始如下回收过程：</p><ol><li><strong>第一阶段，扫描根</strong>。根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li><li><strong>第二阶段，更新RSet</strong>。处理dirty card queue（脏卡表）中的card，更新RSet。此阶段完成后，<strong>RSet可以准确的反映老年代对所在的内存分段中对象的引用</strong>。</li><li><strong>第三阶段，处理RSet</strong>。识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li><li><strong>第四阶段，复制对象</strong>。此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li><li><strong>第五阶段，处理引用</strong>。处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ol><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210719212540339.png" alt="image-20210719212540339"></p><hr><h5 id="G1回收过程二：并发标记-YongGC"><a href="#G1回收过程二：并发标记-YongGC" class="headerlink" title="G1回收过程二：并发标记+ YongGC"></a>G1回收过程二：并发标记+ YongGC</h5><ol><li><strong>初始标记</strong>：标记从根节点直接可达的对象。这个阶段是<strong>STW</strong>的，并且会触发一次年轻代GC。</li><li><strong>根区域扫描</strong>（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在YoungGC之前完成。（因为YongGC 会操作 Survivor区 ）</li><li><strong>并发标记</strong>（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收（也叫做<strong>实时回收</strong>）。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li><strong>重新标记</strong>（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li><strong>独占清理</strong>（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是<strong>STW</strong>的。这个阶段并不会实际上去做垃圾的收集</li><li><strong>并发清理</strong>：识别并清理完全空闲的区域。</li></ol><p>重新标记阶段，方法</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的</p><p>灰色：正在处理中的 </p><p>白色：还未处理的</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.21.png" alt="img"></p><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为<strong>处理中</strong>状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理</li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.22.png" alt="img"></p><hr><h5 id="G1回收过程三：混合回收"><a href="#G1回收过程三：混合回收" class="headerlink" title="G1回收过程三：混合回收"></a>G1回收过程三：混合回收</h5><p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了<strong>回收整个Young Region，还会回收一部分的Old Region</strong>。这里需要注意：是<strong>一部分老年代</strong>，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210719213658936.png" alt="image-20210719213658936"></p><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段（即，这部分内存全部为垃圾）被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收</p><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p><hr><h5 id="G1回收可选的过程四：Full-GC"><a href="#G1回收可选的过程四：Full-GC" class="headerlink" title="G1回收可选的过程四：Full GC"></a>G1回收可选的过程四：Full GC</h5><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>什么时候会发生Full GC呢？</p><ul><li><p>堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</p></li><li><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p></li><li><p>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</p></li></ul><hr><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><h6 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h6><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别<ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><h6 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h6><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h6 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h6><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.23.png" alt="img"></p><hr><h3 id="3-6-垃圾收集器总结"><a href="#3-6-垃圾收集器总结" class="headerlink" title="3.6 垃圾收集器总结"></a>3.6 垃圾收集器总结</h3><h4 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h4><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715121053340.png" alt="image-20210715121053340"></p><ol><li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li><li>其中Serial Old作为CMS出现”<code>Concurrent Mode Failure</code>“失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14中：弃用Parallel Scavenge和Serialold GC组合（JEP366）</li><li>（蓝色虚框）JDK14中：删除CMS垃圾回收器（JEP363）</li></ol><hr><h4 id="7种经典垃圾回收器"><a href="#7种经典垃圾回收器" class="headerlink" title="7种经典垃圾回收器"></a>7种经典垃圾回收器</h4><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><table><thead><tr><th>垃圾收集器</th><th>分类</th><th>作用位置</th><th>使用算法</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Serial</td><td>串行运行</td><td>作用于新生代</td><td>复制算法</td><td>响应速度优先</td><td>适用于单CPU环境下的client模式</td></tr><tr><td>ParNew</td><td>并行运行</td><td>作用于新生代</td><td>复制算法</td><td>响应速度优先</td><td>多CPU环境Server模式下与CMS配合使用</td></tr><tr><td>Parallel Scavenge</td><td>并行运行</td><td>作用于新生代</td><td>复制算法</td><td>吞吐量优先</td><td>适用于后台运算而不需要太多交互的场景</td></tr><tr><td>Serial Old</td><td>串行运行</td><td>作用于老年代</td><td>标记-压缩算法</td><td>响应速度优先</td><td>适用于单CPU环境下的Client模式</td></tr><tr><td>Parallel Old</td><td>并行运行</td><td>作用于老年代</td><td>标记-压缩算法</td><td>吞吐量优先</td><td>适用于后台运算而不需要太多交互的场景</td></tr><tr><td>CMS</td><td>并发运行</td><td>作用于老年代</td><td>标记-清除算法</td><td>响应速度优先</td><td>适用于互联网或B／S业务</td></tr><tr><td>G1</td><td>并发、并行运行</td><td>作用于新生代、老年代</td><td>标记-压缩算法、复制算法</td><td>响应速度优先</td><td>面向服务端应用</td></tr></tbody></table><p>GC发展阶段：Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p><hr><h3 id="3-7-GC-调优"><a href="#3-7-GC-调优" class="headerlink" title="3.7 GC 调优"></a>3.7 GC 调优</h3><p>查看虚拟机参数命令</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">-XX:+PrintFlagsFinal -version <span class="hljs-string">| findstr &quot;</span>GC<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>可以根据参数去查询具体的信息</p><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p><ul><li>CMS G1 ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul><li>新生代的特点<ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB（Thread Local Allocation Buffer）：线程本地分配缓存区，这是一个线程专用的内存分配区域</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li>新生代内存越大越好么？<ul><li>不是<ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li></ul></li></ul><h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><p>以CMS为例</p><ul><li>CMS的老年代内存越大越好</li><li>如果没有发生过Full GC，优先调优新生代</li><li>观察发生Full GC时老年代的占用，将老年代预设内存调大1/4~1/3<ul><li>-XX:CMSInitiatingOccupancyFraction=percent</li></ul></li></ul><hr><h3 id="3-8-GC日志分析"><a href="#3-8-GC日志分析" class="headerlink" title="3.8 GC日志分析"></a>3.8 GC日志分析</h3><p>通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p><ul><li><p><code>-XX:+PrintGC</code> 输出GC日志。类似：<code>-verbose:gc</code></p></li><li><p><code>-XX:+PrintGCDetails</code> 输出GC的详细日志</p></li><li><p><code>-XX:+PrintGCTimestamps</code> 输出GC的时间戳（以基准时间的形式）</p></li><li><p><code>-XX:+PrintGCDatestamps</code> 输出GcC的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）</p></li><li><p><code>-XX:+PrintHeapAtGC</code> 在进行GC的前后打印出堆的信息</p></li><li><p><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</p></li></ul><ol><li>打开GC日志</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-verbose:gc<br></code></pre></td></tr></table></figure><p>这个只会显示总的GC堆的变化，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) 80832K-&gt;19298K(227840K),<span class="hljs-number">0.0084018</span> secs]<br>[GC (Metadata GC Threshold) 109499K-&gt;21465K(228352K),<span class="hljs-number">0.0184066</span> secs]<br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Metadata GC Threshold)</span> 21465K-&gt;16716<span class="hljs-title">K</span><span class="hljs-params">(201728K)</span>,0.0619261 secs]</span><br></code></pre></td></tr></table></figure><p>参数解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代，老年代。<br>Allocation Failure：GC发生的原因。<br>80832K-&gt;19298K：堆在GC前的大小和GC后的大小。<br>228840k：现在的堆大小。<br><span class="hljs-number">0.0084018</span> secs：GC持续的时间。<br></code></pre></td></tr></table></figure><ol start="2"><li>打开GC日志</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-verbose:gc -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure><p>输入信息如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen:70640K-&gt;10116K(141312K)] 80541K-&gt;20017K(227328K),<span class="hljs-number">0.0172573</span> secs] [Times:user=<span class="hljs-number">0.03</span> sys=<span class="hljs-number">0.00</span>,real=<span class="hljs-number">0.02</span> secs]<br>[GC (Metadata GC Threshold) [PSYoungGen:98859K-&gt;8154K(142336K)] 108760K-&gt;21261K(228352K),<span class="hljs-number">0.0151573</span> secs] [Times:user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.01</span>,real=<span class="hljs-number">0.02</span> secs]<br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Metadata GC Threshold)</span>[PSYoungGen:8154K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(142336K)</span>]</span><br><span class="hljs-function">[ParOldGen:13107K-&gt;16809<span class="hljs-title">K</span><span class="hljs-params">(62464K)</span>] 21261K-&gt;16809<span class="hljs-title">K</span><span class="hljs-params">(204800K)</span>,[Metaspace:20599K-&gt;20599<span class="hljs-title">K</span><span class="hljs-params">(1067008K)</span>],0.0639732 secs]</span><br><span class="hljs-function">[Times:user</span>=<span class="hljs-number">0.14</span> sys=<span class="hljs-number">0.00</span>,real=<span class="hljs-number">0.06</span> secs]<br></code></pre></td></tr></table></figure><p>参数解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">GC，Full FC：同样是GC的类型<br>Allocation Failure：GC原因<br>PSYoungGen：使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化<br>ParOldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化<br>Metaspace： 元数据区GC前后大小的变化，JDK1<span class="hljs-number">.8</span>中引入了元数据区以替代永久代<br>xxx secs：指GC花费的时间<br>Times：user：指的是垃圾收集器花费的所有CPU时间，sys：花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。<br></code></pre></td></tr></table></figure><ol start="3"><li>打开GC日志</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCDatestamps<br></code></pre></td></tr></table></figure><p>输入信息如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2019</span>-09-24T22:<span class="hljs-number">15</span>:<span class="hljs-number">24.518</span>+0800: <span class="hljs-number">3.287</span>: [GC (Allocation Failure) [PSYoungGen:136162K-&gt;5113K(136192K)] 141425K-&gt;17632K(222208K),<span class="hljs-number">0.0248249</span> secs] [Times:user=<span class="hljs-number">0.05</span> sys=<span class="hljs-number">0.00</span>,real=<span class="hljs-number">0.03</span> secs]<br><br><span class="hljs-number">2019</span>-09-24T22:<span class="hljs-number">15</span>:<span class="hljs-number">25.559</span>+0800: <span class="hljs-number">4.329</span>: [GC (Metadata GC Threshold) [PSYoungGen:97578K-&gt;10068K(274944K)] 110096K-&gt;22658K(360960K),<span class="hljs-number">0.0094071</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>,real=<span class="hljs-number">0.01</span> secs]<br><br><span class="hljs-number">2019</span>-09-24T22:<span class="hljs-number">15</span>:<span class="hljs-number">25.569</span>+0800: <span class="hljs-number">4.338</span>: [<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Metadata GC Threshold)</span> [PSYoungGen:10068K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(274944K)</span>][ParoldGen:12590K-&gt;13564<span class="hljs-title">K</span><span class="hljs-params">(56320K)</span>] 22658K-&gt;13564<span class="hljs-title">K</span><span class="hljs-params">(331264K)</span>,[Metaspace:20590K-&gt;20590<span class="hljs-title">K</span><span class="hljs-params">(1067008K)</span>],0.0494875 secs] [Times: user</span>=<span class="hljs-number">0.17</span> sys=<span class="hljs-number">0.02</span>,real=<span class="hljs-number">0.05</span> secs]<br></code></pre></td></tr></table></figure><blockquote><p>说明：带上了日期和实践</p></blockquote><p>如果想把GC日志存到文件的话，是下面的参数：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">-Xloggc:/<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/gc.<span class="hljs-keyword">log</span><br></code></pre></td></tr></table></figure><p><strong>日志补充说明</strong></p><ul><li><p> “<code>GC</code>“和”<code>Full GC</code>“说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World” </p></li><li><p> 使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”<code>DefNew</code>“ </p></li><li><p> 使用ParNew收集器在新生代的名字会变成”<code>ParNew</code>“，意思是”Parallel New Generation” </p></li><li><p> 使用Parallel scavenge收集器在新生代的名字是”<code>PSYoungGen</code>“ </p></li><li><p> 老年代的收集和新生代道理一样，名字也是收集器决定的 </p></li><li><p> 使用G1收集器的话，会显示为”garbage-first heap” </p></li><li><p><strong>Allocation Failure</strong><br>表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。 </p></li><li><p><strong>[PSYoungGen：5986K-&gt;696K(8704K) ] 5986K-&gt;704K(9216K)</strong><br>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）<br>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小） </p></li><li><p> user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核的原因，时间总和可能会超过real时间 </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Heap（堆）<br>PSYoungGen（Parallel Scavenge收集器新生代）total 9216K，used 6234K [<span class="hljs-number">0x00000000ff600000</span>,<span class="hljs-number">0x0000000100000000</span>,<span class="hljs-number">0x0000000100000000</span>)<br>eden space（堆中的Eden区默认占比是<span class="hljs-number">8</span>）8192K，<span class="hljs-number">768</span> used [<span class="hljs-number">0x00000000ff600000</span>,<span class="hljs-number">0x00000000ffc16b08</span>,<span class="hljs-number">0x00000000ffe00000</span>)<br>from space（堆中的Survivor，这里是From Survivor区默认占比是<span class="hljs-number">1</span>）1024K， <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x0000000100000000</span>)<br>to space（堆中的Survivor，这里是to Survivor区默认占比是<span class="hljs-number">1</span>，需要先了解一下堆的分配策略）1024K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ffe00000</span>,<span class="hljs-number">0x00000000ffe00000</span>,<span class="hljs-number">0x00000000fff00000</span>)<br>                                                                         <br>ParOldGen（老年代总大小和使用大小）total 10240K， used 7001K ［<span class="hljs-number">0x00000000fec00000</span>,<span class="hljs-number">0x00000000ff600000</span>,<span class="hljs-number">0x00000000ff600000</span>)<br>object space（显示个使用百分比）10240K，<span class="hljs-number">688</span> used [<span class="hljs-number">0x00000000fec00000</span>,<span class="hljs-number">0x00000000ff2d6630</span>,<span class="hljs-number">0x00000000ff600000</span>)<br><br>PSPermGen（永久代总大小和使用大小）total 21504K， used 4949K [<span class="hljs-number">0x00000000f9a00000</span>,<span class="hljs-number">0x00000000faf00000</span>,<span class="hljs-number">0x00000000fec00000</span>)<br>object space（显示个使用百分比，自己能算出来）21504K， <span class="hljs-number">238</span> used [<span class="hljs-number">0x00000000f9a00000</span>,<span class="hljs-number">0x00000000f9ed55e0</span>,<span class="hljs-number">0x00000000faf00000</span>)<br>                                     <br></code></pre></td></tr></table></figure><hr><h4 id="Minor-GC日志"><a href="#Minor-GC日志" class="headerlink" title="Minor GC日志"></a>Minor GC日志</h4><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210720100250419.png" alt="image-20210720100250419"></p><h4 id="Full-GC日志"><a href="#Full-GC日志" class="headerlink" title="Full GC日志"></a>Full GC日志</h4><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210720100328546.png" alt="image-20210720100328546"></p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAllocation</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">byte</span> [] allocation1, allocation2, allocation3, allocation4;<br>    allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];<br>    allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];<br>    allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];<br>    allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span> *_1MB];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    testAllocation();<br>&#125;<br></code></pre></td></tr></table></figure><p>设置JVM参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-Xms10m -Xmx10m -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure><p><strong>图示</strong></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210720101832143.png" alt="image-20210720101832143"></p><hr><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><h3 id="4-1-类文件结构"><a href="#4-1-类文件结构" class="headerlink" title="4.1 类文件结构"></a>4.1 类文件结构</h3><p>HelloWorld.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HelloWorld 示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行<code>javac -parameters -d . HellowWorld.java</code><br>编译为<code>HelloWorld.class</code>后是这个样子的：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@localhost ~]<span class="hljs-comment"># od -t xC HelloWorld.class</span><br>0000000 ca fe ba be<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>34<span class="hljs-number"> 00 </span>23 0a<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 00 </span>15 09<br>0000020<span class="hljs-number"> 00 </span>16<span class="hljs-number"> 00 </span>17<span class="hljs-number"> 08 </span>00<span class="hljs-number"> 18 </span>0a<span class="hljs-number"> 00 </span>19<span class="hljs-number"> 00 </span>1a<span class="hljs-number"> 07 </span>00 1b 07<br>0000040<span class="hljs-number"> 00 </span>1c<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 06 </span>3c<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 69 </span>74 3e<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 03 </span>28 29<br>0000060<span class="hljs-number"> 56 </span>01<span class="hljs-number"> 00 </span>04<span class="hljs-number"> 43 </span>6f<span class="hljs-number"> 64 </span>65<span class="hljs-number"> 01 </span>00 0f 4c<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 65 </span>4e<br>0000100<span class="hljs-number"> 75 </span>6d<span class="hljs-number"> 62 </span>65<span class="hljs-number"> 72 </span>54<span class="hljs-number"> 61 </span>62 6c<span class="hljs-number"> 65 </span>01<span class="hljs-number"> 00 </span>12 4c 6f 63<br>0000120<span class="hljs-number"> 61 </span>6c<span class="hljs-number"> 56 </span>61<span class="hljs-number"> 72 </span>69<span class="hljs-number"> 61 </span>62 6c<span class="hljs-number"> 65 </span>54<span class="hljs-number"> 61 </span>62 6c<span class="hljs-number"> 65 </span>01<br>0000140<span class="hljs-number"> 00 </span>04<span class="hljs-number"> 74 </span>68<span class="hljs-number"> 69 </span>73<span class="hljs-number"> 01 </span>00 1d 4c<span class="hljs-number"> 63 </span>6e 2f<span class="hljs-number"> 69 </span>74 63<br>0000160<span class="hljs-number"> 61 </span>73<span class="hljs-number"> 74 </span>2f 6a<span class="hljs-number"> 76 </span>6d 2f<span class="hljs-number"> 74 </span>35 2f<span class="hljs-number"> 48 </span>65 6c 6c 6f<br>0000200<span class="hljs-number"> 57 </span>6f<span class="hljs-number"> 72 </span>6c<span class="hljs-number"> 64 </span>3b<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 04 </span>6d<span class="hljs-number"> 61 </span>69 6e<span class="hljs-number"> 01 </span>00 16<br>0000220<span class="hljs-number"> 28 </span>5b 4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74 72<br>0000240<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 67 </span>3b<span class="hljs-number"> 29 </span>56<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 04 </span>61<span class="hljs-number"> 72 </span>67<span class="hljs-number"> 73 </span>01<span class="hljs-number"> 00 </span>13<br>0000260 5b 4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74<span class="hljs-number"> 72 </span>69<br>0000300 6e<span class="hljs-number"> 67 </span>3b<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 10 </span>4d<span class="hljs-number"> 65 </span>74<span class="hljs-number"> 68 </span>6f<span class="hljs-number"> 64 </span>50<span class="hljs-number"> 61 </span>72 61<br>0000320 6d<span class="hljs-number"> 65 </span>74<span class="hljs-number"> 65 </span>72<span class="hljs-number"> 73 </span>01<span class="hljs-number"> 00 </span>0a<span class="hljs-number"> 53 </span>6f<span class="hljs-number"> 75 </span>72<span class="hljs-number"> 63 </span>65 46<br>0000340<span class="hljs-number"> 69 </span>6c<span class="hljs-number"> 65 </span>01<span class="hljs-number"> 00 </span>0f<span class="hljs-number"> 48 </span>65 6c 6c 6f<span class="hljs-number"> 57 </span>6f<span class="hljs-number"> 72 </span>6c 64<br>0000360 2e 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>0c<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 00 </span>08<span class="hljs-number"> 07 </span>00 1d 0c<span class="hljs-number"> 00 </span>1e<br>0000400<span class="hljs-number"> 00 </span>1f<span class="hljs-number"> 01 </span>00 0b<span class="hljs-number"> 68 </span>65 6c 6c 6f<span class="hljs-number"> 20 </span>77 6f<span class="hljs-number"> 72 </span>6c 64<br>0000420<span class="hljs-number"> 07 </span>00<span class="hljs-number"> 20 </span>0c<span class="hljs-number"> 00 </span>21<span class="hljs-number"> 00 </span>22<span class="hljs-number"> 01 </span>00 1b<span class="hljs-number"> 63 </span>6e 2f<span class="hljs-number"> 69 </span>74<br>0000440<span class="hljs-number"> 63 </span>61<span class="hljs-number"> 73 </span>74 2f 6a<span class="hljs-number"> 76 </span>6d 2f<span class="hljs-number"> 74 </span>35 2f<span class="hljs-number"> 48 </span>65 6c 6c<br>0000460 6f<span class="hljs-number"> 57 </span>6f<span class="hljs-number"> 72 </span>6c<span class="hljs-number"> 64 </span>01<span class="hljs-number"> 00 </span>10 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c 61<br>0000500 6e<span class="hljs-number"> 67 </span>2f 4f<span class="hljs-number"> 62 </span>6a<span class="hljs-number"> 65 </span>63<span class="hljs-number"> 74 </span>01<span class="hljs-number"> 00 </span>10 6a<span class="hljs-number"> 61 </span>76 61<br>0000520 2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>79<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 65 </span>6d<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 03 </span>6f<br>0000540<span class="hljs-number"> 75 </span>74<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 15 </span>4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f<span class="hljs-number"> 69 </span>6f 2f<span class="hljs-number"> 50 </span>72<br>0000560<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 74 </span>53<span class="hljs-number"> 74 </span>72<span class="hljs-number"> 65 </span>61 6d 3b<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 13 </span>6a<span class="hljs-number"> 61 </span>76<br>0000600<span class="hljs-number"> 61 </span>2f<span class="hljs-number"> 69 </span>6f 2f<span class="hljs-number"> 50 </span>72<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 74 </span>53<span class="hljs-number"> 74 </span>72<span class="hljs-number"> 65 </span>61 6d<br>0000620<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 07 </span>70<span class="hljs-number"> 72 </span>69 6e<span class="hljs-number"> 74 </span>6c 6e<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 15 </span>28 4c 6a<br>0000640<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74<span class="hljs-number"> 72 </span>69 6e<span class="hljs-number"> 67 </span>3b<br>0000660<span class="hljs-number"> 29 </span>56<span class="hljs-number"> 00 </span>21<span class="hljs-number"> 00 </span>05<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>01<br>0000700<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 00 </span>08<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>2f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>01<br>0000720<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>05 2a b7<span class="hljs-number"> 00 </span>01 b1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>0a 00<br>0000740<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 06 </span>00<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 04 </span>00 0b<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>0c 00<br>0000760<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 05 </span>00 0c<span class="hljs-number"> 00 </span>0d<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>0e 00<br>0001000 0f<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>37<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00 00<br>0001020<span class="hljs-number"> 09 </span>b2<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 12 </span>03 b6<span class="hljs-number"> 00 </span>04 b1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>0a<br>0001040<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>0a<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 00 </span>08<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 00 </span>0b<br>0001060<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>0c<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>10<span class="hljs-number"> 00 </span>11<span class="hljs-number"> 00 </span>00<br>0001100<span class="hljs-number"> 00 </span>12<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>05<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 10 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 13 </span>00<br>0001120<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 02 </span>00 14<br></code></pre></td></tr></table></figure><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs abnf">u4    magic<span class="hljs-comment">;</span><br>u2             minor_version<span class="hljs-comment">;    </span><br>u2             major_version<span class="hljs-comment">;    </span><br>u2             constant_pool_count<span class="hljs-comment">;    </span><br>cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>]<span class="hljs-comment">;    </span><br>u2             access_flags<span class="hljs-comment">;    </span><br>u2             this_class<span class="hljs-comment">;    </span><br>u2             super_class<span class="hljs-comment">;   </span><br>u2             interfaces_count<span class="hljs-comment">;    </span><br>u2             interfaces[interfaces_count]<span class="hljs-comment">;   </span><br>u2             fields_count<span class="hljs-comment">;    </span><br>field_info     fields[fields_count]<span class="hljs-comment">;   </span><br>u2             methods_count<span class="hljs-comment">;    </span><br>method_info    methods[methods_count]<span class="hljs-comment">;    </span><br>u2             attributes_count<span class="hljs-comment">;    </span><br>attribute_info attributes[attributes_count]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>u数字：代表字节数</p></blockquote><table><thead><tr><th></th><th>类型</th><th>名称</th><th>说明</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>魔数</td><td>u4</td><td>magic</td><td>魔数,识别Class文件格式</td><td>4个字节</td><td>1</td></tr><tr><td>版本号</td><td>u2</td><td>minor_version</td><td>副版本号(小版本)</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>u2</td><td>major_version</td><td>主版本号(大版本)</td><td>2个字节</td><td>1</td></tr><tr><td>常量池集合</td><td>u2</td><td>constant_pool_count</td><td>常量池计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>cp_info</td><td>constant_pool</td><td>常量池表</td><td>n个字节</td><td>constant_pool_count- 1</td></tr><tr><td>访问标识</td><td>u2</td><td>access_flags</td><td>访问标识</td><td>2个字节</td><td>1</td></tr><tr><td>索引集合</td><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>u2</td><td>interfaces_count</td><td>接口计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td><td>interfaces_count</td></tr><tr><td>字段表集合</td><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>field_info</td><td>fields</td><td>字段表</td><td>n个字节</td><td>fields_count</td></tr><tr><td>方法表集合</td><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>method_info</td><td>methods</td><td>方法表</td><td>n个字节</td><td>methods_count</td></tr><tr><td>属性表集合</td><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>attribute_info</td><td>attributes</td><td>属性表</td><td>n个字节</td><td>attributes_count</td></tr></tbody></table><hr><h4 id="Class文件数据类型"><a href="#Class文件数据类型" class="headerlink" title="Class文件数据类型"></a>Class文件数据类型</h4><table><thead><tr><th>数据类型</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>无符号数</td><td>无符号数可以用来描述数字、索引引用、数量值或按照utf-8编码构成的字符串值。</td><td>其中无符号数属于基本的数据类型。 以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节</td></tr><tr><td>表</td><td>表是由多个无符号数或其他表构成的复合数据结构。</td><td>所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td></tr></tbody></table><hr><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>u4 magic;</p><p>对应字节码文件的0~3个字节（一个16进制数可以用4位表示，相当于半个字节）</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><ul><li><p>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符。</p></li><li><p>魔数值固定为0xCAFEBABE。不会改变。</p></li></ul><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>u2 minor_version;</p><p>u2 major_version;</p><p>对应字节码文件的4~7个字节</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p><p>H 34 = 52，代表JDK8</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>Class文件使用了一个前置的容量计数器（<strong>constant_pool_count</strong>）加若干个连续的数据项（<strong>constant_pool</strong>）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2（无符号数）</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info（表）</td><td>constant_pool</td><td>constant_pool_count - 1</td></tr></tbody></table><h5 id="常量池计数器"><a href="#常量池计数器" class="headerlink" title="常量池计数器"></a>常量池计数器</h5><ul><li><p>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</p></li><li><p>常量池容量计数值（u2类型）：从1开始，表示常量池中有多少项常量。即constant_pool_count=1表示常量池中有0个常量项。</p></li></ul><p>u2  constant_pool_count;   </p><p>对应字节码文件的8~9个字节</p><p>0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09</p><p>H 23 = 35，代表常量池中有35个项目，#1~#34项，注意 #0 项不计入，也没有值（从#1开始）</p><blockquote><p>为什么要空出0</p><p>这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值0来表示。</p></blockquote><h5 id="常量池表"><a href="#常量池表" class="headerlink" title="常量池表"></a>常量池表</h5><p>constant_pool是一种表结构，以1 ~ constant_pool_count - 1为索引。表明了后面有多少个常量项。</p><p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）</p><p>它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte（标记字节、标签字节）。</p><table><thead><tr><th>类型</th><th>标志/标识（十进制）</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><blockquote><ul><li><p>这14种常量项结构的共同点是：表开始的第一位是一个u1类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</p></li><li><p>在常量池列表中，CONSTANT_Utf8_info常量项是一种使用改进过的UTF-8编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</p></li><li><p>这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_Utf8_info占用字节不固定，其大小由length决定。为什么呢？因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过utf-8编码，就可以知道其长度。</p></li></ul></blockquote><blockquote><ul><li><p>常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用Class文件空间最大的数据项目之一。</p></li><li><p>常量池中为什么要包含这些内容？Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p></li></ul></blockquote><h5 id="字面量和符号引用"><a href="#字面量和符号引用" class="headerlink" title="字面量和符号引用"></a>字面量和符号引用</h5><p>在对这些常量解读前，我们需要搞清楚几个概念。</p><p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。如下表：</p><table><thead><tr><th>常量</th><th>具体的常量</th></tr></thead><tbody><tr><td>字面量</td><td>文本字符串</td></tr><tr><td></td><td>声明为final的常量值</td></tr><tr><td>符号引用</td><td>类和接口的全限定名</td></tr><tr><td></td><td>字段的名称和描述符</td></tr><tr><td></td><td>方法的名称和描述符</td></tr></tbody></table><p><strong>全限定名</strong></p><p>top/igotcha/test/Demo这个就是类的全限定名，仅仅是把包名的“.“替换成”/”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。</p><p><strong>简单名称</strong></p><p>简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的add()方法和num字段的简单名称分别是add和num。</p><p><strong>描述符</strong></p><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见下表：</p><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型byte</td></tr><tr><td>C</td><td>基本数据类型char</td></tr><tr><td>D</td><td>基本数据类型double</td></tr><tr><td>F</td><td>基本数据类型float</td></tr><tr><td>I</td><td>基本数据类型int</td></tr><tr><td>J</td><td>基本数据类型long</td></tr><tr><td>S</td><td>基本数据类型short</td></tr><tr><td>Z</td><td>基本数据类型boolean</td></tr><tr><td>V</td><td>代表void类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td>[</td><td>数组类型，代表一维数组。比如：<code>double[] is [D</code></td></tr></tbody></table><p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法java.lang.String tostring()的描述符为()Ljava/lang/String; ，方法int abc(int[]x, int y)的描述符为([II)I。</p><blockquote><p>虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息。因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再<strong>在类加载过程中的解析阶段将其替换为直接引用</strong>，并翻译到具体的内存地址中。</p></blockquote><ul><li><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。</p></li><li><p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</p></li></ul><hr><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>0000000 ca fe ba be 00 00 00 34 00 23 <strong>0a</strong> 00 06 00 15 09</p><p><strong>第#1项</strong>，H 0a = 10，查表得知，10 表示 Method 信息（方法信息长度固定四个字节）</p><p>0000000 ca fe ba be 00 00 00 34 00 23 0a <strong>00 06 00 15</strong> 09</p><p>H 00 06 = 6 ，H 00 15= 21， 表示它引用了常量池中 #6 和 #21 项来获得这个方法的【所属类】和【方法名】</p><p>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 <strong>09</strong></p><p><strong>第#2项</strong> ，H 09 = 9 ，查表得知，9表示 Field 信息（成员变量信息长度固定四个字节）</p><p>0000020 <strong>00 16 00 17</strong> 08 00 18 0a 00 19 00 1a 07 00 1b 07</p><p>H 00 16 = 22 ，H 00 17 = 23 ，表示它引用了常量池中 #22 和 # 23 项来获得这个成员变量的【所属类】和【成员变量名】</p><p>0000020 00 16 00 17 **08 **00 18 0a 00 19 00 1a 07 00 1b 07</p><p><strong>第#3项</strong>，H 08 = 8 ，查表得知，8表示字符串常量名称（字符串常量信息长度固定两个字节）</p><p>0000020 00 16 00 17 08 <strong>00 18</strong> 0a 00 19 00 1a 07 00 1b 07</p><p>H 00 18 = 24，表示它引用了常量池中 #24 项</p><p>0000020 00 16 00 17 08 00 18 <strong>0a</strong> 00 19 00 1a 07 00 1b 07</p><p><strong>第#4项</strong>，H 0a = 10，查表得知，10 表示 Method 信息（方法信息长度固定四个字节）</p><p>0000020 00 16 00 17 08 00 18 0a <strong>00 19 00 1a</strong> 07 00 1b 07</p><p>H 00 19 = 25 ，H 00 1a = 26， 表示它引用了常量池中 #6 和 #21 项来获得这个方法的【所属类】和【方法名】</p><p>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a <strong>07</strong> 00 1b 07</p><p><strong>第#5项</strong>，H 07 = 7，查表得知，7 表示 Class信息（类信息长度固定两个字节）</p><p>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 <strong>00 1b</strong> 07</p><p>H 00 1b = 27， 表示它引用了常量池中 #27 项</p><p>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b <strong>07</strong></p><p><strong>第#6项</strong>，H 07 = 7，查表得知，7 表示 Class信息（类信息长度固定两个字节）<br>0000040 <strong>00 1c</strong> 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p><p>H 00 1c = 28， 表示它引用了常量池中 #28 项</p><p>0000040 00 1c <strong>01</strong> 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p><p><strong>第#7项</strong>，H 01 = 1，查表得知，1 表示 utf8 串</p><p>0000040 00 1c 01 <strong>00 06</strong> 3c 69 6e 69 74 3e 01 00 03 28 29</p><p>H 00 06  = 6 表示长度是6个字节</p><p>0000040 00 1c 01 00 06 <strong>3c 69 6e 69 74 3e</strong> 01 00 03 28 29</p><p>H 3c 69 6e 69 74 3e 是<init> </init></p><p>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e <strong>01</strong> 00 03 28 29</p><p><strong>第#8项</strong>，H 01 = 1，查表得知，1 表示 utf8 串</p><p>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01<strong>00 03</strong> 28 29</p><p>H 00 03  = 3 表示长度是3个字节</p><p>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 <strong>28 29</strong><br>0000060 <strong>56</strong> 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p><p>H 28 29 56 是 ()V，表示无参、无返回值</p><p>………………略</p><p>参考文献：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><hr><h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p><strong>访问标识（access_flag、访问标志、访问标记）</strong></p><p>在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。各种访问标记如下所示：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><p>类的访问权限通常为ACC_开头的常量。</p><p>每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类，则该标记为ACC_PUBLIC | ACC_FINAL。</p><p>使用ACC_SUPER可以让类更准确地定位到父类的方法super.method()，现代编译器都会设置并且使用这个标记。</p><blockquote><p><strong>补充说明：</strong></p><ol><li> 带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。 </li></ol><ul><li><p>如果一个class文件被设置了ACC_INTERFACE标志，那么同时也得设置ACC_ABSTRACT标志。同时它不能再设置ACC_FINAL、ACC_SUPER 或ACC_ENUM标志。</p></li><li><p>如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表中除ACC_ANNOTATION外的其他所有标志。当然，ACC_FINAL和ACC_ABSTRACT这类互斥的标志除外。这两个标志不得同时设置。</p></li></ul><ol start="2"><li>ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。针对Java虚拟机指令集的编译器都应当设置这个标志。对于Java SE 8及后续版本来说，无论class文件中这个标志的实际值是什么，也不管class文件的版本号是多少，Java虚拟机都认为每个class文件均设置了ACC_SUPER标志。 </li></ol><ul><li>ACC_SUPER标志是为了向后兼容由旧Java编译器所编译的代码而设计的。目前的ACC_SUPER标志在由JDK1.0.2之前的编译器所生成的access_flags中是没有确定含义的，如果设置了该标志，那么0racle的Java虚拟机实现会将其忽略</li></ul><ol start="3"><li> ACC_SYNTHETIC标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。 </li><li>注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，那么也必须设置ACC_INTERFACE标志。 </li><li>ACC_ENUM标志表明该类或其父类为枚举类型。 </li></ol></blockquote><hr><h4 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h4><p>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</p><table><thead><tr><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>this_class</td></tr><tr><td>u2</td><td>super_class</td></tr><tr><td>u2</td><td>interfaces_count</td></tr><tr><td>u2</td><td>interfaces[interfaces_count]</td></tr></tbody></table><p>这三项数据来确定这个类的继承关系：</p><ul><li><p>类索引用于确定这个类的全限定名</p></li><li><p>父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为空。</p></li><li><p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</p></li></ul><h5 id="this-class（类索引）"><a href="#this-class（类索引）" class="headerlink" title="this_class（类索引）"></a>this_class（类索引）</h5><p>2字节无符号整数，指向常量池的索引。它提供了类的全限定名，如top/igotcha/java/Demo。this_class的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为CONSTANT_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口。</p><h5 id="super-class（父类索引）"><a href="#super-class（父类索引）" class="headerlink" title="super_class（父类索引）"></a>super_class（父类索引）</h5><p>2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是java/lang/object类。同时，由于Java不支持多继承，所以其父类只有一个。</p><p>super_class指向的父类不能是final。</p><h5 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h5><p>指向常量池索引集合，它提供了一个符号引用到所有已实现的接口</p><p>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的CONSTANT_Class（当然这里就必须是接口，而不是类）。</p><h6 id="Ⅰ-interfaces-count（接口计数器）"><a href="#Ⅰ-interfaces-count（接口计数器）" class="headerlink" title="Ⅰ. interfaces_count（接口计数器）"></a>Ⅰ. interfaces_count（接口计数器）</h6><p>interfaces_count项的值表示当前类或接口继承/实现的接口数量。</p><h6 id="Ⅱ-interfaces-（接口索引集合）"><a href="#Ⅱ-interfaces-（接口索引集合）" class="headerlink" title="Ⅱ. interfaces[]（接口索引集合）"></a>Ⅱ. interfaces[]（接口索引集合）</h6><p>interfaces[]中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为interfaces_count。每个成员interfaces[i]必须为CONSTANT_Class_info结构，其中0 &lt;= i &lt; interfaces_count。在interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口。</p><hr><h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p><strong>fields</strong></p><p>用于描述接口或类中声明的变量。字段（field）包括<strong>类级变量</strong>以及<strong>实例级变量</strong>，但是不包括方法内部、代码块内部声明的局部变量。</p><p>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p><p>它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符（public、private或protected）、是类变量还是实例变量（static修饰符）、是否是常量（final修饰符）等。</p><blockquote><p> <strong>注意：</strong></p><ul><li><p>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p></li><li><p>在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</p></li></ul></blockquote><h5 id="字段计数器"><a href="#字段计数器" class="headerlink" title="字段计数器"></a>字段计数器</h5><p><strong>fields_count（字段计数器）</strong></p><p>fields_count的值表示当前class文件fields表的成员个数。使用两个字节来表示。</p><p>fields表中每个成员都是一个field_info结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>字段名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><h5 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h5><h6 id="Ⅰ-字段表访问标识"><a href="#Ⅰ-字段表访问标识" class="headerlink" title="Ⅰ. 字段表访问标识"></a>Ⅰ. 字段表访问标识</h6><p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static修饰符、final修饰符、volatile修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table><h6 id="Ⅱ-描述符索引"><a href="#Ⅱ-描述符索引" class="headerlink" title="Ⅱ. 描述符索引"></a>Ⅱ. 描述符索引</h6><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte，char，double，float，int，long，short，boolean）及代表无返回值的void类型都用一个大写字符来表示，而对象则用字符L加对象的全限定名来表示，如下所示：</p><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型byte</td></tr><tr><td>C</td><td>基本数据类型char</td></tr><tr><td>D</td><td>基本数据类型double</td></tr><tr><td>F</td><td>基本数据类型float</td></tr><tr><td>I</td><td>基本数据类型int</td></tr><tr><td>J</td><td>基本数据类型long</td></tr><tr><td>S</td><td>基本数据类型short</td></tr><tr><td>Z</td><td>基本数据类型boolean</td></tr><tr><td>V</td><td>代表void类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td>[</td><td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td></tr></tbody></table><h6 id="Ⅲ-属性表集合"><a href="#Ⅲ-属性表集合" class="headerlink" title="Ⅲ. 属性表集合"></a>Ⅲ. 属性表集合</h6><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在attribute_count中，属性具体内容存放在attributes数组中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 以常量属性为例，结构为：</span><br>ConstantValue_attribute&#123;<br>u2 attribute_name_index;<br>u4 attribute_length;<br>    u2 constantvalue_index;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于常量属性而言，attribute_length值恒为2。</p></blockquote><hr><h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><p>methods：指向常量池索引集合，它完整描述了每个方法的签名。</p><ul><li><p>在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private或protected），方法的返回值类型以及方法的参数信息等。</p></li><li><p>如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来。</p></li><li><p>一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法<code>&lt;clinit&gt;()</code>和实例初始化方法<code>&lt;init&gt;()</code>）。</p></li></ul><blockquote><p><strong>注意：</strong></p><p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，<strong>特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合</strong>，也就是因为返回值不会包含在特征签名之中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中。</p><p>也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p></blockquote><h5 id="方法计数器"><a href="#方法计数器" class="headerlink" title="方法计数器"></a>方法计数器</h5><p><strong>methods_count（方法计数器）</strong></p><p>methods_count的值表示当前class文件methods表的成员个数。使用两个字节来表示。</p><p>methods表中每个成员都是一个method_info结构。</p><h5 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h5><p><strong>methods[]（方法表）</strong></p><p>methods表中的每个成员都必须是一个method_info结构，用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access_flags项既没有设置ACC_NATIVE标志也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。</p><p>method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</p><p>方法表的结构实际跟字段表是一样的，方法表结构如下：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>方法名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><p><strong>方法表访问标志</strong></p><p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>public，方法可以从包外访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>private，方法只能本类访问</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>protected，方法在自身和子类可以访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>static，静态方法</td></tr></tbody></table><h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>方法表集合之后的属性表集合，指的是class文件所携带的辅助信息，比如该class文件的源文件的名称。以及任何带有RetentionPolicy.CLASS 或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解。</p><p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p><p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性。</p><h5 id="属性计数器"><a href="#属性计数器" class="headerlink" title="属性计数器"></a>属性计数器</h5><p><strong>attributes_count（属性计数器）</strong></p><p>attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是一个attribute_info结构。</p><h5 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h5><p><strong>attributes[]（属性表）</strong></p><p>属性表的每个项的值必须是attribute_info结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p><p><strong>属性的通用格式</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td><td>属性表</td></tr></tbody></table><p><strong>属性类型</strong></p><p>属性表实际上可以有很多类型，上面看到的Code属性只是其中一种，Java8里面定义了23种属性。下面这些是虚拟机中预定义的属性：</p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java代码编译成的字节码指令</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>final关键字定义的常量池</td></tr><tr><td>Deprecated</td><td>类，方法，字段表</td><td>被声明为deprecated的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td></tr><tr><td>InnerClass</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LineNumberTable</td><td>Code属性</td><td>Java源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td>StackMapTable</td><td>Code属性</td><td>JDK1.6中新增的属性，供新的类型检查检验器和处理目标方法的局部变量和操作数有所需要的类是否匹配</td></tr><tr><td>Signature</td><td>类，方法表，字段表</td><td>用于支持泛型情况下的方法签名</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>用于存储额外的调试信息</td></tr><tr><td>Synthetic</td><td>类，方法表，字段表</td><td>标志方法或字段为编译器自动生成的</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>是哟很难过特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类，方法表，字段表</td><td>为动态注解提供支持</td></tr><tr><td>RuntimeInvisibleAnnotations</td><td>类，方法表，字段表</td><td>用于指明哪些注解是运行时不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotation</td><td>方法表</td><td>作用与RuntimeVisibleAnnotations属性类似，只不过作用对象或方法</td></tr><tr><td>RuntimeInvisibleParameterAnnotation</td><td>方法表</td><td>作用与RuntimeInvisibleAnnotations属性类似，只不过作用对象或方法</td></tr><tr><td>AnnotationDefault</td><td>方法表</td><td>用于记录注解类元素的默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>用于保存invokeddynamic指令引用的引导方法限定符</td></tr></tbody></table><hr><h3 id="4-2-字节码指令"><a href="#4-2-字节码指令" class="headerlink" title="4.2 字节码指令"></a>4.2 字节码指令</h3><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><p><code>public cn.itcast.jvm.t5.HelloWorld();</code> 构造方法的字节码指令</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2a</span> b<span class="hljs-number">7</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> b<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>2a =&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数</li><li>b7 =&gt; invokespecial 预备调用构造方法</li><li>00 01 引用常量池中 #1 项，即【Method java/lang/Object.”<init>“:()V 】</init></li><li>b1 表示返回</li></ul><h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><p><code>public static void main(java.lang.String[]); </code>主方法的字节码指令</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">b2</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">12</span> <span class="hljs-number">03</span> b<span class="hljs-number">6</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> b<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>b2 =&gt; getstatic 用来加载静态变量</li><li>00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】</li><li>12 =&gt; ldc 加载参数</li><li>03 引用常量池中 #3 项，即 【String hello world】</li><li>b6 =&gt; invokevirtual 预备调用成员方法</li><li>00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】</li><li>b1 表示返回</li></ul><p>参考文献：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 javap 工具来反编译 class 文件</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs clean">[root@localhost ~]# javap -v HelloWorld.<span class="hljs-keyword">class</span><br>Classfile /root/HelloWorld.<span class="hljs-keyword">class</span><br>Last modified Jul <span class="hljs-number">7</span>, <span class="hljs-number">2019</span>; size <span class="hljs-number">597</span> bytes<br>MD5 checksum <span class="hljs-number">361</span>dca1c3f4ae38644a9cd5060ac6dbc<br>Compiled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;HelloWorld.java&quot;</span><br>public <span class="hljs-keyword">class</span> cn.itcast.jvm.t5.HelloWorld<br>minor version: <span class="hljs-number">0</span><br>major version: <span class="hljs-number">52</span><br>flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>#<span class="hljs-number">1</span> = Methodref #<span class="hljs-number">6.</span>#<span class="hljs-number">21</span> <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>#<span class="hljs-number">2</span> = Fieldref #<span class="hljs-number">22.</span>#<span class="hljs-number">23</span> <span class="hljs-comment">//java/lang/System.out:Ljava/io/PrintStream;</span><br>#<span class="hljs-number">3</span> = String #<span class="hljs-number">24</span> <span class="hljs-comment">// hello world</span><br>#<span class="hljs-number">4</span> = Methodref #<span class="hljs-number">25.</span>#<span class="hljs-number">26</span> <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>#<span class="hljs-number">5</span> = Class #<span class="hljs-number">27</span> <span class="hljs-comment">// cn/itcast/jvm/t5/HelloWorld</span><br>#<span class="hljs-number">6</span> = Class #<span class="hljs-number">28</span> <span class="hljs-comment">// java/lang/Object</span><br>#<span class="hljs-number">7</span> = Utf8 &lt;init&gt;<br>#<span class="hljs-number">8</span> = Utf8 ()V<br>#<span class="hljs-number">9</span> = Utf8 Code<br>#<span class="hljs-number">10</span> = Utf8 LineNumberTable<br>#<span class="hljs-number">11</span> = Utf8 LocalVariableTable<br>#<span class="hljs-number">12</span> = Utf8 this<br>#<span class="hljs-number">13</span> = Utf8 Lcn/itcast/jvm/t5/HelloWorld;<br>    #<span class="hljs-number">14</span> = Utf8 main<br> #<span class="hljs-number">15</span> = Utf8 (Ljava/lang/String;)V<br>#<span class="hljs-number">16</span> = Utf8 args<br>#<span class="hljs-number">17</span> = Utf8 [Ljava/lang/String;<br>#<span class="hljs-number">18</span> = Utf8 MethodParameters<br>#<span class="hljs-number">19</span> = Utf8 SourceFile<br>#<span class="hljs-number">20</span> = Utf8 HelloWorld.java<br>#<span class="hljs-number">21</span> = NameAndType #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span> <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>#<span class="hljs-number">22</span> = Class #<span class="hljs-number">29</span> <span class="hljs-comment">// java/lang/System</span><br>#<span class="hljs-number">23</span> = NameAndType #<span class="hljs-number">30</span>:#<span class="hljs-number">31</span> <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>#<span class="hljs-number">24</span> = Utf8 hello world<br>#<span class="hljs-number">25</span> = Class #<span class="hljs-number">32</span> <span class="hljs-comment">// java/io/PrintStream</span><br>#<span class="hljs-number">26</span> = NameAndType #<span class="hljs-number">33</span>:#<span class="hljs-number">34</span> <span class="hljs-comment">// println:(Ljava/lang/String;)V</span><br>#<span class="hljs-number">27</span> = Utf8 cn/itcast/jvm/t5/HelloWorld<br>#<span class="hljs-number">28</span> = Utf8 java/lang/Object<br>#<span class="hljs-number">29</span> = Utf8 java/lang/System<br>#<span class="hljs-number">30</span> = Utf8 out<br>#<span class="hljs-number">31</span> = Utf8 Ljava/io/PrintStream;<br>#<span class="hljs-number">32</span> = Utf8 java/io/PrintStream<br>#<span class="hljs-number">33</span> = Utf8 println<br>#<span class="hljs-number">34</span> = Utf8 (Ljava/lang/String;)V<br>&#123;<br>public cn.itcast.jvm.t5.HelloWorld();<br>descriptor: ()V<br>flags: ACC_PUBLIC<br>Code:<br>stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br><span class="hljs-number">0</span>: aload_0<br><span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span> <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-number">4</span>: return<br>LineNumberTable:<br>line <span class="hljs-number">4</span>: <span class="hljs-number">0</span><br>LocalVariableTable:<br>Start Length Slot Name Signature<br>  <span class="hljs-number">0</span>    <span class="hljs-number">5</span>    <span class="hljs-number">0</span>  this Lcn/itcast/jvm/t5/HelloWorld;<br>public static void main(java.lang.String[]);<br>descriptor: ([Ljava/lang/String;)V<br>flags: ACC_PUBLIC, ACC_STATIC<br>Code:<br>stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br><span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="hljs-number">3</span>: ldc #<span class="hljs-number">3</span> <span class="hljs-comment">// String hello world</span><br><span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">4</span> <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="hljs-number">8</span>: return<br>LineNumberTable:<br>line <span class="hljs-number">6</span>: <span class="hljs-number">0</span><br>line <span class="hljs-number">7</span>: <span class="hljs-number">8</span><br>LocalVariableTable:<br>Start Length Slot Name Signature<br>  <span class="hljs-number">0</span> <span class="hljs-number">9</span>   <span class="hljs-number">0</span>   args [Ljava/lang/String;<br>MethodParameters:<br>Name Flags<br>args<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> &#123;</span>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        <br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <br><span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;        <br><span class="hljs-keyword">int</span> c = a + b;        <br>System.out.<span class="hljs-built_in">println</span>(c);   <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="常量池载入运行时常量池"><a href="#常量池载入运行时常量池" class="headerlink" title="常量池载入运行时常量池"></a>常量池载入运行时常量池</h5><p>常量池也属于方法区，只不过这里单独提出来了</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.24.png" alt="img"></p><h5 id="方法字节码载入方法区"><a href="#方法字节码载入方法区" class="headerlink" title="方法字节码载入方法区"></a>方法字节码载入方法区</h5><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.25.png" alt="img"></p><h5 id="main线程开始运行，分配栈帧内存"><a href="#main线程开始运行，分配栈帧内存" class="headerlink" title="main线程开始运行，分配栈帧内存"></a>main线程开始运行，分配栈帧内存</h5><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.26.png" alt="img"></p><h5 id="执行引擎开始执行字节码"><a href="#执行引擎开始执行字节码" class="headerlink" title="执行引擎开始执行字节码"></a>执行引擎开始执行字节码</h5><h6 id="bipush-10"><a href="#bipush-10" class="headerlink" title="bipush 10"></a>bipush 10</h6><ul><li>将一个 byte 压入操作数栈（其长度会补齐 4 个字节，因为操作数栈长度是4个字节），类似的指令还有<ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul></li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.27.png" alt="img"></p><h6 id="istore-1"><a href="#istore-1" class="headerlink" title="istore 1"></a>istore 1</h6><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p>对应代码中的</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.28.png" alt="img"></p><h6 id="ldc-3"><a href="#ldc-3" class="headerlink" title="ldc #3"></a>ldc #3</h6><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.29.png" alt="img"></p><h6 id="istore-2"><a href="#istore-2" class="headerlink" title="istore 2"></a>istore 2</h6><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.30.png" alt="img"></p><h6 id="iload1-iload2"><a href="#iload1-iload2" class="headerlink" title="iload1 iload2"></a>iload1 iload2</h6><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.31.png" alt="img"></p><h6 id="iadd"><a href="#iadd" class="headerlink" title="iadd"></a>iadd</h6><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.32.png" alt="img"></p><h6 id="istore-3"><a href="#istore-3" class="headerlink" title="istore 3"></a>istore 3</h6><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.33.png" alt="img"></p><h6 id="getstatic-4"><a href="#getstatic-4" class="headerlink" title="getstatic #4"></a>getstatic #4</h6><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.34.png" alt="img"></p><h6 id="iload-3"><a href="#iload-3" class="headerlink" title="iload 3"></a>iload 3</h6><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.35.png" alt="img"></p><h6 id="invokevirtual-5"><a href="#invokevirtual-5" class="headerlink" title="invokevirtual 5"></a>invokevirtual 5</h6><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p><p>生成新的栈帧（分配 locals、stack等）</p><p>传递参数，执行新栈帧中的字节码</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.36.png" alt="img"></p><p>执行完毕，弹出栈帧</p><p>清除 main 操作数栈内容</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.37.png" alt="img"></p><h6 id="return"><a href="#return" class="headerlink" title="return"></a>return</h6><p>完成 main 方法调用，弹出 main 栈帧，程序结束</p><h4 id="从字节码角度分析i-与-i"><a href="#从字节码角度分析i-与-i" class="headerlink" title="从字节码角度分析i++与++i"></a>从字节码角度分析i++与++i</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = a++ + ++a + a--;<br>System.out.println(a);<br>System.out.println(b);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> static void main(java.lang.String[]);<br><span class="hljs-attribute">descriptor</span>: ([Ljava/lang/String;)V<br><span class="hljs-attribute">flags</span>: (<span class="hljs-number">0</span>x<span class="hljs-number">0009</span>) ACC_PUBLIC, ACC_STATIC<br><span class="hljs-attribute">Code</span>:<br><span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br><span class="hljs-attribute">0</span>: bipush <span class="hljs-number">10</span><br><span class="hljs-attribute">2</span>: istore_<span class="hljs-number">1</span><br><span class="hljs-attribute">3</span>: iload_<span class="hljs-number">1</span><br><span class="hljs-attribute">4</span>: iinc <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-attribute">7</span>: iinc <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-attribute">10</span>: iload_<span class="hljs-number">1</span><br><span class="hljs-attribute">11</span>: iadd<br><span class="hljs-attribute">12</span>: iload_<span class="hljs-number">1</span><br><span class="hljs-attribute">13</span>: iinc <span class="hljs-number">1</span>, -<span class="hljs-number">1</span><br><span class="hljs-attribute">16</span>: iadd<br><span class="hljs-attribute">17</span>: istore_<span class="hljs-number">2</span><br><span class="hljs-attribute">18</span>: getstatic #<span class="hljs-number">2</span> // Field java/lang/System.out:Ljava/io/PrintStream;<br><span class="hljs-attribute">21</span>: iload_<span class="hljs-number">1</span><br><span class="hljs-attribute">22</span>: invokevirtual #<span class="hljs-number">3</span> // Method java/io/PrintStream.println:(I)V<br><span class="hljs-attribute">25</span>: getstatic #<span class="hljs-number">2</span> // Field java/lang/System.out:Ljava/io/PrintStream;<br><span class="hljs-attribute">28</span>: iload_<span class="hljs-number">2</span><br><span class="hljs-attribute">29</span>: invokevirtual #<span class="hljs-number">3</span> // Method java/io/PrintStream.println:(I)V<br><span class="hljs-attribute">32</span>: return<br><span class="hljs-attribute">LineNumberTable</span>:<br><span class="hljs-attribute">line</span> <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br><span class="hljs-attribute">line</span> <span class="hljs-number">9</span>: <span class="hljs-number">3</span><br><span class="hljs-attribute">line</span> <span class="hljs-number">10</span>: <span class="hljs-number">18</span><br><span class="hljs-attribute">line</span> <span class="hljs-number">11</span>: <span class="hljs-number">25</span><br><span class="hljs-attribute">line</span> <span class="hljs-number">12</span>: <span class="hljs-number">32</span><br><span class="hljs-attribute">LocalVariableTable</span>:<br><span class="hljs-attribute">Start</span> Length Slot Name Signature<br><span class="hljs-attribute">0</span><span class="hljs-number">33</span>  <span class="hljs-number">0</span>  args <span class="hljs-meta">[Ljava/lang/String;</span><br><span class="hljs-meta">330   1   a I</span><br><span class="hljs-meta">18 15  2   b    I</span><br></code></pre></td></tr></table></figure><p>注意</p><blockquote><p>iinc 指令是直接在局部变量 slot 上进行运算，iinc有两个参数，第一个参数是操作哪个solt，第二个参数是自增几<br>a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc</p></blockquote><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.38.png" alt="img"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.39.png" alt="image-20201022125325530"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.40.png" alt="image-20201022125325530"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.41.png" alt="image-20201022125325530"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.42.png" alt="image-20201022125325530"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.43.png" alt="image-20201022125325530"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.44.png" alt="image-20201022125325530"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.45.png"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.46.png"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.47.png"></p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.48.png"></p><h4 id="条件判断指令"><a href="#条件判断指令" class="headerlink" title="条件判断指令"></a>条件判断指令</h4><table><thead><tr><th>指令</th><th>助记符</th><th>含义</th></tr></thead><tbody><tr><td>0x99</td><td>ifeq</td><td>判断是否 == 0</td></tr><tr><td>0x9a</td><td>ifne</td><td>判断是否 != 0</td></tr><tr><td>0x9b</td><td>iflt</td><td>判断是否 &lt; 0</td></tr><tr><td>0x9c</td><td>ifge</td><td>判断是否 &gt;= 0</td></tr><tr><td>0x9d</td><td>ifgt</td><td>判断是否 &gt; 0</td></tr><tr><td>0x9e</td><td>ifle</td><td>判断是否 &lt;= 0</td></tr><tr><td>0x9f</td><td>if_icmpeq</td><td>两个int是否 ==</td></tr><tr><td>0xa0</td><td>if_icmpne</td><td>两个int是否 !=</td></tr><tr><td>0xa1</td><td>if_icmplt</td><td>两个int是否 &lt;</td></tr><tr><td>0xa2</td><td>if_icmpge</td><td>两个int是否 &gt;=</td></tr><tr><td>0xa3</td><td>if_icmpgt</td><td>两个int是否 &gt;</td></tr><tr><td>0xa4</td><td>if_icmple</td><td>两个int是否 &lt;=</td></tr><tr><td>0xa5</td><td>if_acmpeq</td><td>两个引用是否 ==</td></tr><tr><td>0xa6</td><td>if_acmpne</td><td>两个引用是否 !=</td></tr><tr><td>0xc6</td><td>ifnull</td><td>判断是否 == null</td></tr><tr><td>0xc7</td><td>ifnonnull</td><td>判断是否 != null</td></tr></tbody></table><ul><li>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节</li><li>goto 用来进行跳转到指定行号的字节码</li></ul><blockquote><p> long，float，double 的比较<br>参考 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp</a></p></blockquote><h4 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h4><ul><li><code>while</code>和<code>for</code>的字节码，是一样的</li></ul><h4 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h4><p>理解如下x结果为什么是0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>) &#123;<br>x = x++;<br>i++;<br>&#125;<br>System.out.println(x); <span class="hljs-comment">//结果为0</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">Code:<br>     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><span class="hljs-regexp">//</span>操作数栈分配<span class="hljs-number">2</span>个空间，局部变量表分配<span class="hljs-number">3</span>个空间<br>        <span class="hljs-number">0</span>: iconst_0<span class="hljs-regexp">//</span>准备一个常数<span class="hljs-number">0</span><br>        <span class="hljs-number">1</span>: istore_1<span class="hljs-regexp">//</span>将常数<span class="hljs-number">0</span>放入局部变量表的<span class="hljs-number">1</span>号槽位 i=<span class="hljs-number">0</span><br>        <span class="hljs-number">2</span>: iconst_0<span class="hljs-regexp">//</span>准备一个常数<span class="hljs-number">0</span><br>        <span class="hljs-number">3</span>: istore_2<span class="hljs-regexp">//</span>将常数<span class="hljs-number">0</span>放入局部变量的<span class="hljs-number">2</span>号槽位 x=<span class="hljs-number">0</span><br>        <span class="hljs-number">4</span>: iload_1<span class="hljs-regexp">//</span>将局部变量表<span class="hljs-number">1</span>号槽位的数放入操作数栈中<br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><span class="hljs-regexp">//</span>将数字<span class="hljs-number">10</span>放入操作数栈中，此时操作数栈中有<span class="hljs-number">2</span>个数<br>        <span class="hljs-number">7</span>: if_icmpge     <span class="hljs-number">21</span><span class="hljs-regexp">//</span>比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到<span class="hljs-number">21</span>。<br>        这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空<br>       <span class="hljs-number">10</span>: iload_2<span class="hljs-regexp">//</span>将局部变量<span class="hljs-number">2</span>号槽位的数放入操作数栈中，放入的值是<span class="hljs-number">0</span><br>       <span class="hljs-number">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span><span class="hljs-regexp">//</span>将局部变量<span class="hljs-number">2</span>号槽位的数加<span class="hljs-number">1</span>，自增后，槽位中的值为<span class="hljs-number">1</span><br>       <span class="hljs-number">14</span>: istore_2<span class="hljs-regexp">//</span>将操作数栈中的数放入到局部变量表的<span class="hljs-number">2</span>号槽位，<span class="hljs-number">2</span>号槽位的值又变为了<span class="hljs-number">0</span><br>       <span class="hljs-number">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-regexp">//</span><span class="hljs-number">1</span>号槽位的值自增<span class="hljs-number">1</span><br>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">4</span> <span class="hljs-regexp">//</span>跳转到第<span class="hljs-number">4</span>条指令<br>       <span class="hljs-number">21</span>: getstatic     <span class="hljs-comment">#2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">24</span>: iload_2<br>       <span class="hljs-number">25</span>: invokevirtual <span class="hljs-comment">#3                  // Method java/io/PrintStream.println:(I)V</span><br>       <span class="hljs-number">28</span>: return<br></code></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">static</span> &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br><span class="hljs-keyword">static</span> &#123;<br>i = <span class="hljs-number">30</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>System.out.println(i); <span class="hljs-comment">//结果为30</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">stack=1,</span> <span class="hljs-string">locals=0,</span> <span class="hljs-string">args_size=0</span><br>         <span class="hljs-attr">0:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">10</span><br>         <span class="hljs-attr">2:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>         <span class="hljs-attr">5:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">20</span><br>         <span class="hljs-attr">7:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>        <span class="hljs-attr">10:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">30</span><br>        <span class="hljs-attr">12:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>        <span class="hljs-attr">15:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br><span class="hljs-keyword">private</span> String a = <span class="hljs-string">&quot;s1&quot;</span>;<br>    <br>&#123;<br>b = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br><br>&#123;<br>a = <span class="hljs-string">&quot;s2&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo4</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.a = a;<br><span class="hljs-keyword">this</span>.b = b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Demo4 d = <span class="hljs-keyword">new</span> Demo4(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">30</span>);<br>System.out.println(d.a);<span class="hljs-comment">//输出：s3</span><br>System.out.println(d.b);<span class="hljs-comment">//输出：30</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Code:</span><br>     <span class="hljs-string">stack=2,</span> <span class="hljs-string">locals=3,</span> <span class="hljs-string">args_size=3</span><br>        <span class="hljs-attr">0:</span> <span class="hljs-string">aload_0</span><br>        <span class="hljs-attr">1:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-attr">4:</span> <span class="hljs-string">aload_0</span><br>        <span class="hljs-attr">5:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#2                  // String s1</span><br>        <span class="hljs-attr">7:</span> <span class="hljs-string">putfield</span>      <span class="hljs-comment">#3                  // Field a:Ljava/lang/String;</span><br>       <span class="hljs-attr">10:</span> <span class="hljs-string">aload_0</span><br>       <span class="hljs-attr">11:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">20</span><br>       <span class="hljs-attr">13:</span> <span class="hljs-string">putfield</span>      <span class="hljs-comment">#4                  // Field b:I</span><br>       <span class="hljs-attr">16:</span> <span class="hljs-string">aload_0</span><br>       <span class="hljs-attr">17:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">10</span><br>       <span class="hljs-attr">19:</span> <span class="hljs-string">putfield</span>      <span class="hljs-comment">#4                  // Field b:I</span><br>       <span class="hljs-attr">22:</span> <span class="hljs-string">aload_0</span><br>       <span class="hljs-attr">23:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#5                  // String s2</span><br>       <span class="hljs-attr">25:</span> <span class="hljs-string">putfield</span>      <span class="hljs-comment">#3                  // Field a:Ljava/lang/String;</span><br>       <span class="hljs-string">//原始构造方法在最后执行</span><br>       <span class="hljs-attr">28:</span> <span class="hljs-string">aload_0</span><br>       <span class="hljs-attr">29:</span> <span class="hljs-string">aload_1</span><br>       <span class="hljs-attr">30:</span> <span class="hljs-string">putfield</span>      <span class="hljs-comment">#3                  // Field a:Ljava/lang/String;</span><br>       <span class="hljs-attr">33:</span> <span class="hljs-string">aload_0</span><br>       <span class="hljs-attr">34:</span> <span class="hljs-string">iload_2</span><br>       <span class="hljs-attr">35:</span> <span class="hljs-string">putfield</span>      <span class="hljs-comment">#4                  // Field b:I</span><br>       <span class="hljs-attr">38:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo5</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Demo5 demo5 = <span class="hljs-keyword">new</span> Demo5();<br>demo5.test1();<br>demo5.test2();<br>demo5.test3();<br>Demo5.test4();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用<strong>invokevirtual</strong>指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用<strong>invokestatic</strong>指令</li></ul><ul><li><strong>invokespecial</strong>，<strong>invokestatic</strong>都属于<strong>静态绑定</strong>（编译期间就可以确定）</li><li><strong>invokevirtual</strong>，属于<strong>动态绑定</strong>（运行期间才可以确定）</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Code</span>:<br>      <span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-attribute">0</span>: new           #<span class="hljs-number">2</span>                  // class com/nyima/JVM/day<span class="hljs-number">5</span>/Demo<span class="hljs-number">5</span> <br>         <span class="hljs-attribute">3</span>: dup<br>         <span class="hljs-attribute">4</span>: invokespecial #<span class="hljs-number">3</span>                  // Method <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>:()V<br>         <span class="hljs-attribute">7</span>: astore_<span class="hljs-number">1</span><br>         <span class="hljs-attribute">8</span>: aload_<span class="hljs-number">1</span><br>         <span class="hljs-attribute">9</span>: invokespecial #<span class="hljs-number">4</span>                  // Method test<span class="hljs-number">1</span>:()V<br>        <span class="hljs-attribute">12</span>: aload_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">13</span>: invokespecial #<span class="hljs-number">5</span>                  // Method test<span class="hljs-number">2</span>:()V<br>        <span class="hljs-attribute">16</span>: aload_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">17</span>: invokevirtual #<span class="hljs-number">6</span>                  // Method test<span class="hljs-number">3</span>:()V<br>        <span class="hljs-attribute">20</span>: invokestatic  #<span class="hljs-number">7</span>                  // Method test<span class="hljs-number">4</span>:()V<br>        <span class="hljs-attribute">23</span>: return<br></code></pre></td></tr></table></figure><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li><li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li><li>成员方法与静态方法调用的另一个区别是，执行方法前是否需要<strong>【对象引用】</strong></li><li>还有一个执行 invokespecial 的情况是通过 super 调用父类方法</li></ul><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong>（虚方法表）</li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Code</span>:<span class="hljs-string"></span><br>     <span class="hljs-attr">stack</span>=<span class="hljs-string">1, locals=3, args_size=1</span><br>        <span class="hljs-attr">0</span>: <span class="hljs-string">iconst_0</span><br>        <span class="hljs-attr">1</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-attr">2</span>: <span class="hljs-string">bipush        10</span><br>        <span class="hljs-attr">4</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-attr">5</span>: <span class="hljs-string">goto          12</span><br>        <span class="hljs-attr">8</span>: <span class="hljs-string">astore_2</span><br>        <span class="hljs-attr">9</span>: <span class="hljs-string">bipush        20</span><br>       <span class="hljs-attr">11</span>: <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">12</span>: <span class="hljs-string">return</span><br>     <span class="hljs-attr">//多出来一个异常表</span><br>     <span class="hljs-attr">Exception</span> <span class="hljs-string">table:</span><br>        <span class="hljs-attr">from</span>    <span class="hljs-string">to  target type</span><br>       <span class="hljs-attr">2</span>     <span class="hljs-string">5     8   Class java/lang/Exception</span><br></code></pre></td></tr></table></figure><ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br>&#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>i = <span class="hljs-number">30</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的字节码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Code</span>:<br>     <span class="hljs-attribute">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-attribute">0</span>: iconst_<span class="hljs-number">0</span><br>        <span class="hljs-attribute">1</span>: istore_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">2</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-attribute">4</span>: istore_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">5</span>: goto          <span class="hljs-number">19</span><br>        <span class="hljs-attribute">8</span>: astore_<span class="hljs-number">2</span><br>        <span class="hljs-attribute">9</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-attribute">11</span>: istore_<span class="hljs-number">1</span><br>       <span class="hljs-attribute">12</span>: goto          <span class="hljs-number">19</span><br>       <span class="hljs-attribute">15</span>: astore_<span class="hljs-number">2</span><br>       <span class="hljs-attribute">16</span>: bipush        <span class="hljs-number">30</span><br>       <span class="hljs-attribute">18</span>: istore_<span class="hljs-number">1</span><br>       <span class="hljs-attribute">19</span>: return<br>     <span class="hljs-attribute">Exception</span> table:<br>        <span class="hljs-attribute">from</span>    to  target type<br>          <span class="hljs-attribute">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/ArithmeticException<br>          <span class="hljs-attribute">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">15</span>   Class java/lang/Exception<br></code></pre></td></tr></table></figure><ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul><h5 id="multi-catch"><a href="#multi-catch" class="headerlink" title="multi-catch"></a>multi-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_3</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>Method test = Demo3_11_3.class.getMethod(<span class="hljs-string">&quot;test&quot;</span>);<br>test.invoke(<span class="hljs-keyword">null</span>);<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException |InvocationTargetException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Code:</span><br><span class="hljs-string">stack=3,</span> <span class="hljs-string">locals=2,</span> <span class="hljs-string">args_size=1</span><br><span class="hljs-attr">0:</span> <span class="hljs-string">ldc</span> <span class="hljs-comment">#2</span><br><span class="hljs-attr">2:</span> <span class="hljs-string">ldc</span> <span class="hljs-comment">#3</span><br><span class="hljs-attr">4:</span> <span class="hljs-string">iconst_0</span><br><span class="hljs-attr">5:</span> <span class="hljs-string">anewarray</span> <span class="hljs-comment">#4</span><br><span class="hljs-attr">8:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#5</span><br><span class="hljs-attr">11:</span> <span class="hljs-string">astore_1</span><br><span class="hljs-attr">12:</span> <span class="hljs-string">aload_1</span><br><span class="hljs-attr">15:</span> <span class="hljs-string">anewarray</span> <span class="hljs-comment">#6</span><br><span class="hljs-attr">18:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#7</span><br><span class="hljs-attr">21:</span> <span class="hljs-string">pop</span><br><span class="hljs-attr">22:</span> <span class="hljs-string">goto</span> <span class="hljs-number">30</span><br><span class="hljs-attr">25:</span> <span class="hljs-string">astore_1</span><br><span class="hljs-attr">26:</span> <span class="hljs-string">aload_1</span><br><span class="hljs-attr">27:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#11 // e.printStackTrace:()V</span><br><span class="hljs-attr">30:</span> <span class="hljs-string">return</span><br><span class="hljs-attr">Exception table:</span><br><span class="hljs-string">from</span> <span class="hljs-string">to</span> <span class="hljs-string">target</span> <span class="hljs-string">type</span><br><span class="hljs-number">0</span>    <span class="hljs-number">22</span>   <span class="hljs-number">25</span> <span class="hljs-string">Class</span> <span class="hljs-string">java/lang/NoSuchMethodException</span><br><span class="hljs-number">0</span>    <span class="hljs-number">22</span>   <span class="hljs-number">25</span>     <span class="hljs-string">Class</span> <span class="hljs-string">java/lang/IllegalAccessException</span><br>      <span class="hljs-number">0</span>    <span class="hljs-number">22</span>   <span class="hljs-number">25</span>     <span class="hljs-string">Class</span> <span class="hljs-string">java/lang/reflect/InvocationTargetException</span><br></code></pre></td></tr></table></figure><ul><li>异常出现时，<strong>都进入</strong> 25，执行astore_1</li></ul><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>i = <span class="hljs-number">30</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Code</span>:<span class="hljs-string"></span><br>     <span class="hljs-attr">stack</span>=<span class="hljs-string">1, locals=4, args_size=1</span><br>        <span class="hljs-attr">0</span>: <span class="hljs-string">iconst_0</span><br>        <span class="hljs-attr">1</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-attr">//try块</span><br>        <span class="hljs-attr">2</span>: <span class="hljs-string">bipush        10</span><br>        <span class="hljs-attr">4</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-meta">//try块执行完后，会执行finally</span>    <span class="hljs-string"></span><br>        <span class="hljs-attr">5</span>: <span class="hljs-string">bipush        30</span><br>        <span class="hljs-attr">7</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-attr">8</span>: <span class="hljs-string">goto          27</span><br>       <span class="hljs-meta">//catch块</span>     <span class="hljs-string"></span><br>       <span class="hljs-attr">11</span>: <span class="hljs-string">astore_2 //异常信息放入局部变量表的2号槽位</span><br>       <span class="hljs-attr">12</span>: <span class="hljs-string">bipush        20</span><br>       <span class="hljs-attr">14</span>: <span class="hljs-string">istore_1</span><br>       <span class="hljs-meta">//catch块执行完后，会执行finally</span>        <span class="hljs-string"></span><br>       <span class="hljs-attr">15</span>: <span class="hljs-string">bipush        30</span><br>       <span class="hljs-attr">17</span>: <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">18</span>: <span class="hljs-string">goto          27</span><br>       <span class="hljs-meta">//出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码</span>   <span class="hljs-string"></span><br>       <span class="hljs-attr">21</span>: <span class="hljs-string">astore_3</span><br>       <span class="hljs-attr">22</span>: <span class="hljs-string">bipush        30</span><br>       <span class="hljs-attr">24</span>: <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">25</span>: <span class="hljs-string">aload_3</span><br>       <span class="hljs-attr">26</span>: <span class="hljs-string">athrow  //抛出异常</span><br>       <span class="hljs-attr">27</span>: <span class="hljs-string">return</span><br>     <span class="hljs-attr">Exception</span> <span class="hljs-string">table:</span><br>        <span class="hljs-attr">from</span>    <span class="hljs-string">to  target type</span><br>            <span class="hljs-attr">2</span>     <span class="hljs-string">5    11   Class java/lang/Exception</span><br>            <span class="hljs-attr">2</span>     <span class="hljs-string">5    21   any//剩余的异常类型，比如 Error</span><br>           <span class="hljs-attr">11</span>    <span class="hljs-string">15    21  any//剩余的异常类型，比如 Error</span><br></code></pre></td></tr></table></figure><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p><h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = Demo3.test();<br>        <span class="hljs-comment">//结果为20</span><br>System.out.println(i);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> i;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>i = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Code</span>:<span class="hljs-string"></span><br>     <span class="hljs-attr">stack</span>=<span class="hljs-string">1, locals=3, args_size=0</span><br>        <span class="hljs-attr">0</span>: <span class="hljs-string">bipush        10</span><br>        <span class="hljs-attr">2</span>: <span class="hljs-string">istore_0</span><br>        <span class="hljs-attr">3</span>: <span class="hljs-string">iload_0</span><br>        <span class="hljs-attr">4</span>: <span class="hljs-string">istore_1  //暂存返回值</span><br>        <span class="hljs-attr">5</span>: <span class="hljs-string">bipush        20</span><br>        <span class="hljs-attr">7</span>: <span class="hljs-string">istore_0</span><br>        <span class="hljs-attr">8</span>: <span class="hljs-string">iload_0</span><br>        <span class="hljs-attr">9</span>: <span class="hljs-string">ireturn//ireturn会返回操作数栈顶的整型值20</span><br>       <span class="hljs-attr">//如果出现异常，还是会执行finally块中的内容，没有抛出异常</span><br>       <span class="hljs-attr">10</span>: <span class="hljs-string">astore_2</span><br>       <span class="hljs-attr">11</span>: <span class="hljs-string">bipush        20</span><br>       <span class="hljs-attr">13</span>: <span class="hljs-string">istore_0</span><br>       <span class="hljs-attr">14</span>: <span class="hljs-string">iload_0</span><br>       <span class="hljs-attr">15</span>: <span class="hljs-string">ireturn//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span><br>     <span class="hljs-attr">Exception</span> <span class="hljs-string">table:</span><br>        <span class="hljs-attr">from</span>    <span class="hljs-string">to  target  type</span><br>            <span class="hljs-attr">0</span>     <span class="hljs-string">5    10    any</span><br></code></pre></td></tr></table></figure><ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li><li>所以<strong>不要在finally中进行返回操作</strong></li></ul><h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i = Demo3.test();<br>      <span class="hljs-comment">//最终结果为20</span><br>      System.out.println(i);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i;<br>      <span class="hljs-keyword">try</span> &#123;<br>         i = <span class="hljs-number">10</span>;<br>         <span class="hljs-comment">//这里应该会抛出异常</span><br>         i = i/<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         i = <span class="hljs-number">20</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会发现打印结果为20，并未抛出异常</p><h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = Demo4.test();<br>        <span class="hljs-comment">//最终结果为10</span><br>System.out.println(i);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> i;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Code</span>:<br>     <span class="hljs-attribute">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>        <span class="hljs-attribute">0</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-attribute">2</span>: istore_<span class="hljs-number">0</span> //赋值给i <span class="hljs-number">10</span><br>        <span class="hljs-attribute">3</span>: iload_<span class="hljs-number">0</span>//加载到操作数栈顶<br>        <span class="hljs-attribute">4</span>: istore_<span class="hljs-number">1</span> //加载到局部变量表的<span class="hljs-number">1</span>号位置<br>        <span class="hljs-attribute">5</span>: bipush        <span class="hljs-number">20</span><br>        <span class="hljs-attribute">7</span>: istore_<span class="hljs-number">0</span> //赋值给i <span class="hljs-number">20</span><br>        <span class="hljs-attribute">8</span>: iload_<span class="hljs-number">1</span> //加载局部变量表<span class="hljs-number">1</span>号位置的数<span class="hljs-number">10</span>到操作数栈<br>        <span class="hljs-attribute">9</span>: ireturn //返回操作数栈顶元素 <span class="hljs-number">10</span><br>       <span class="hljs-attribute">10</span>: astore_<span class="hljs-number">2</span><br>       <span class="hljs-attribute">11</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-attribute">13</span>: istore_<span class="hljs-number">0</span><br>       <span class="hljs-attribute">14</span>: aload_<span class="hljs-number">2</span> //加载异常<br>       <span class="hljs-attribute">15</span>: athrow //抛出异常<br>     <span class="hljs-attribute">Exception</span> table:<br>        <span class="hljs-attribute">from</span>    to  target type<br>         <span class="hljs-attribute">3</span>      <span class="hljs-number">5</span>    <span class="hljs-number">10</span>    any<br></code></pre></td></tr></table></figure><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>Lock lock = <span class="hljs-keyword">new</span> Lock();<br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>System.out.println(i);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">2</span>: istore_1<br>        <span class="hljs-number">3</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class com/nyima/JVM/day06/Lock</span><br>        <span class="hljs-number">6</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈顶，用于构造函数消耗</span><br>        <span class="hljs-number">7</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">//剩下的一份放到局部变量表的2号位置</span><br>       <span class="hljs-number">11</span>: aload_2 <span class="hljs-comment">//加载到操作数栈</span><br>       <span class="hljs-number">12</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈，用于加锁时消耗</span><br>       <span class="hljs-number">13</span>: astore_3 <span class="hljs-comment">//将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span><br>       <span class="hljs-number">14</span>: monitorenter <span class="hljs-comment">//加锁</span><br>       <span class="hljs-comment">//锁住后代码块中的操作    </span><br>       <span class="hljs-number">15</span>: getstatic     #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">18</span>: iload_1<br>       <span class="hljs-number">19</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span><br>       <span class="hljs-comment">//加载局部变量表中三号槽位对象的引用，用于解锁    </span><br>       <span class="hljs-number">22</span>: aload_3    <br>       <span class="hljs-number">23</span>: monitorexit <span class="hljs-comment">//解锁</span><br>       <span class="hljs-number">24</span>: goto          <span class="hljs-number">34</span><br>       <span class="hljs-comment">//异常操作    </span><br>       <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span><br>       <span class="hljs-number">29</span>: aload_3<br>       <span class="hljs-number">30</span>: monitorexit <span class="hljs-comment">//解锁</span><br>       <span class="hljs-number">31</span>: aload         <span class="hljs-number">4</span><br>       <span class="hljs-number">33</span>: athrow<br>       <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span><br>     <span class="hljs-comment">//可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span><br>     Exception table:<br>        from   to  target type<br>         <span class="hljs-number">15</span>    <span class="hljs-number">24</span>    <span class="hljs-number">27</span>   any<br>         <span class="hljs-number">27</span>    <span class="hljs-number">31</span>    <span class="hljs-number">27</span>   any<br></code></pre></td></tr></table></figure><ul><li>无论会不会出现异常都会进行解锁操作</li></ul><blockquote><p>方法级别的 synchronized 不会在字节码指令中有所体现</p></blockquote><h3 id="4-3-编译期处理"><a href="#4-3-编译期处理" class="headerlink" title="4.3 编译期处理"></a>4.3 编译期处理</h3><p>所谓的<strong>语法糖</strong>，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是class字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码。</p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>经过编译期优化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;<br>   <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span><br>      <span class="hljs-keyword">super</span>();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><p>在JDK 5以后，它们的转换可以在编译期自动完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Integer x = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">int</span> y = x;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换过程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span><br>      Integer x = Integer.valueOf(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span><br>      <span class="hljs-keyword">int</span> y = x.intValue();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      list.add(<span class="hljs-number">10</span>);<span class="hljs-comment">// 实际调用的是 List.add(Object e)</span><br>      Integer x = list.get(<span class="hljs-number">0</span>);<span class="hljs-comment">// 实际调用的是 Object obj = List.get(int index);</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Code:</span><br>    <span class="hljs-string">stack=2,</span> <span class="hljs-string">locals=3,</span> <span class="hljs-string">args_size=1</span><br>       <span class="hljs-attr">0:</span> <span class="hljs-string">new</span>           <span class="hljs-comment">#2                  // class java/util/ArrayList</span><br>       <span class="hljs-attr">3:</span> <span class="hljs-string">dup</span><br>       <span class="hljs-attr">4:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-attr">7:</span> <span class="hljs-string">astore_1</span><br>       <span class="hljs-attr">8:</span> <span class="hljs-string">aload_1</span><br>       <span class="hljs-attr">9:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">10</span><br>      <span class="hljs-attr">11:</span> <span class="hljs-string">invokestatic</span>  <span class="hljs-comment">#4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br>      <span class="hljs-string">//这里进行了泛型擦除，实际调用的是add(Objcet</span> <span class="hljs-string">o)</span><br>      <span class="hljs-attr">14:</span> <span class="hljs-string">invokeinterface</span> <span class="hljs-comment">#5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><br>      <span class="hljs-attr">19:</span> <span class="hljs-string">pop</span><br>      <span class="hljs-attr">20:</span> <span class="hljs-string">aload_1</span><br>      <span class="hljs-attr">21:</span> <span class="hljs-string">iconst_0</span><br>      <span class="hljs-string">//这里也进行了泛型擦除，实际调用的是get(Object</span> <span class="hljs-string">o)</span>   <br>      <span class="hljs-attr">22:</span> <span class="hljs-string">invokeinterface</span> <span class="hljs-comment">#6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="hljs-string">//这里进行了类型转换，将Object转换成了Integer</span><br>      <span class="hljs-attr">27:</span> <span class="hljs-string">checkcast</span>     <span class="hljs-comment">#7                  // class java/lang/Integer</span><br>      <span class="hljs-attr">30:</span> <span class="hljs-string">astore_2</span><br>      <span class="hljs-attr">31:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><p>所以调用get函数取值时，有一个类型转换的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = (Integer) list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x = (Integer) list.get(<span class="hljs-number">0</span>).intValue();<br></code></pre></td></tr></table></figure><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>      <span class="hljs-comment">//将args赋值给arr，可以看出String...实际就是String[] </span><br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> Demo4 &#123;&#125;<br><br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      foo(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p></blockquote><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//数组赋初值的简化写法也是一种语法糖。</span><br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : arr) &#123;<br>System.out.println(x);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会帮我们转换为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; ++i) &#123;<br><span class="hljs-keyword">int</span> x = arr[i];<br>System.out.println(x);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果是集合使用foreach</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-keyword">for</span> (Integer x : list) &#123;<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-comment">//获得该集合的迭代器</span><br>      Iterator&lt;Integer&gt; iterator = list.iterator();<br>      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>         Integer x = iterator.next();<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">switch</span> (str) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;world&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在编译器中执行的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo6</span><span class="hljs-params">()</span> </span>&#123;<br>      <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;<br>      <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span><br>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;<br>         <span class="hljs-comment">//hello的hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :<br>            <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span><br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;<br>               x = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-comment">//world的hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :<br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;world&quot;</span>)) &#123;<br>               x = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      <span class="hljs-comment">//用第二个switch在进行输出判断</span><br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-keyword">switch</span> (sex) &#123;<br>         <span class="hljs-keyword">case</span> MALE:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> FEMALE:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器中执行的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>   <span class="hljs-comment">/**     </span><br><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><br><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><br><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><br><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><br><span class="hljs-comment">    */</span> <br>   <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>&#123;<br>      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span><br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">static</span> &#123;<br>         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span><br>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;<br>         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span><br>      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];<br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>&#123;   <br>   <span class="hljs-comment">//对应枚举类中的元素</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;    <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;    <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;<br>   <br>    <span class="hljs-keyword">static</span> &#123;       <br>    <span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span><br>    MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);    <br>        FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);   <br>        $VALUES = <span class="hljs-keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; <br>   &#125;<br> <br>   <span class="hljs-comment">//调用父类中的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>&#123;     <br>        <span class="hljs-keyword">super</span>(name, ordinal);    <br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;  <br>        <span class="hljs-keyword">return</span> $VALUES.clone();  <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);  <br>    &#125; <br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(资源变量 = 创建资源对象)&#123;<br>&#125; <span class="hljs-keyword">catch</span>( ) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中资源对象需要实现 <code>AutoCloseable</code>接口，例如<code>InputStream</code>、<code>OutputStream</code>、<code>Connection</code>、<code>Statement</code>、<code>ResultSet</code>等接口都实现 <code>AutoCloseable</code>，使用<code>try-withresources</code>可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">try</span>(InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>)) &#123;<br>System.out.println(is);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy9</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>);<br>            Throwable t = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(is);<br>&#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123;<br><span class="hljs-comment">// t 是我们代码出现的异常</span><br>t = e1;<br><span class="hljs-keyword">throw</span> e1;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 判断了资源不为空</span><br><span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// 如果我们代码有异常</span><br><span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>is.close();<br>&#125; <span class="hljs-keyword">catch</span> (Throwable e2) &#123;<br><span class="hljs-comment">// 如果 close 出现异常，作为被压制异常添加</span><br>t.addSuppressed(e2);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e</span><br>is.close();<br>&#125;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>addSuppressed(Throwable e)作用是：添加被压制异常。是为了防止异常信息的丢失（如try-with-resources 生成的 fianlly 中如果抛出了异常）</p></blockquote><h4 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a>方法重写时的桥接方法</h4><p>方法重写时对返回值分两种情况：</p><ul><li>父子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类（见下面的例子）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 此方法才是真正重写了父类 public Number m() 方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 调用 public Integer m()</span><br><span class="hljs-keyword">return</span> m();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的<code>public Integer m()</code>没有命名冲突</p></blockquote><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//用额外创建的类来创建匿名内部类对象</span><br>      Runnable runnable = <span class="hljs-keyword">new</span> Demo8$<span class="hljs-number">1</span>();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//创建了一个额外的类，实现了Runnable接口</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() &#123;&#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果匿名内部类中引用了<strong>局部变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(x);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转化后代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(x);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-comment">//多创建了一个变量</span><br>   <span class="hljs-keyword">int</span> val$x;<br>   <span class="hljs-comment">//变为了有参构造器</span><br>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) &#123;<br>      <span class="hljs-keyword">this</span>.val$x = x;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(val$x);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解释了为什么匿名内部类引用局部变量时，局部变量必须是final的。因为在创建Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的val$x属性， 所以x不应该再发生变化了，如果变化，val$x属性没有机会再跟着一起变化。</p></blockquote><blockquote><p>特别说明：在jdk1.8之后，匿名内部类使用局部变量的时候，局部变量已经不需要使用final修饰了，可以编译通过，并不是编译器的实现机制改变了，只是编译器在编译的时候不允许对这个变量进行变更，也就是说，如果你内外只是使用这个变量，而不进行重新赋值，那么就编译通过，如果内外有重新赋值，那么还是会报编译错误。</p></blockquote><h3 id="4-4-类加载阶段"><a href="#4-4-类加载阶段" class="headerlink" title="4.4 类加载阶段"></a>4.4 类加载阶段</h3><h4 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h4><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210720164326498.png" alt="image-20210720164326498"></p><ul><li><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p></li><li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine（执行引擎）决定。</p></li><li><p>加载的类信息存放于一块称为<strong>方法区</strong>的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p></li></ul><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>类加载过程的第一步，主要完成下面3件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为<strong>方法区</strong>的运行时数据结构</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口</li></ol><blockquote><p>创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。</p></blockquote><ul><li><p>将类的字节码载入<strong>方法区</strong>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p><ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p></li><li><p>加载和链接可能是<strong>交替运行</strong>的</p></li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.49.png" alt="img"></p><ul><li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<strong>堆内存</strong>中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><blockquote><p>数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p></blockquote><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p><ul><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.491.png" alt="img"></p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。</p><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在JDK 7以前是存储与instanceKlass（方法区中）末尾。但在JDK 7以后就存储在_java_mirror末尾（堆中）了</li><li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li><li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong><ul><li>于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行 </li></ul></li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li></ul><blockquote><p>比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INT_CONSTANT = <span class="hljs-number">10</span>; <span class="hljs-comment">// 在链接阶段的准备环节赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUM1 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">10</span>); <span class="hljs-comment">// 在初始化阶段clinit&gt;()中赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="hljs-number">100</span>); <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="hljs-number">100</span>); <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中概值</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String s0 = <span class="hljs-string">&quot;helloworld0&quot;</span>;  <span class="hljs-comment">// 在链接阶段的准备环节赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;helloworld1&quot;</span>); <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String s2 = <span class="hljs-string">&quot;hellowrold2&quot;</span>;   <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><br></code></pre></td></tr></table></figure><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>解析的含义</strong></p><p>将常量池中的<strong>符号引用解析为直接引用</strong></p><ul><li><p>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</p></li><li><p>解析以后，会将常量池中的符号引用解析为直接引用</p></li></ul><h6 id="未解析演示"><a href="#未解析演示" class="headerlink" title="未解析演示"></a>未解析演示</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>      ClassLoader loader = Demo1.class.getClassLoader();<br>      <span class="hljs-comment">//只加载不解析</span><br>      Class&lt;?&gt; c = loader.loadClass(<span class="hljs-string">&quot;com.nyima.JVM.day8.C&quot;</span>);<br>      <span class="hljs-comment">//用于阻塞主线程</span><br>      System.in.read();<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>   D d = <span class="hljs-keyword">new</span> D();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>此时只加载了类C</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.50.png" alt="img"></p><p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.51.png" alt="img"></p><h6 id="解析演示"><a href="#解析演示" class="headerlink" title="解析演示"></a>解析演示</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>      <span class="hljs-comment">//解析</span><br>      <span class="hljs-keyword">new</span> C();<br>      <span class="hljs-comment">//用于阻塞主线程</span><br>      System.in.read();<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>   D d = <span class="hljs-keyword">new</span> D();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>此时已加载并解析了类C和类D，并且常量池类D已经指向内存空间中D的位置</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.52.png" alt="img"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化即调用 <strong>cinit()V</strong> ，虚拟机会保证这个类的『构造方法』的线程安全</p><h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li><p>main 方法所在的类，总会被首先初始化</p></li><li><p>首次访问这个类的静态变量或静态方法时</p></li><li><p>子类初始化，如果父类还没初始化，会引发</p></li><li><p>子类访问父类的静态变量，只会触发父类的初始化。不会导致子类初始化，只有真正声明这个字段的类才会被初始化。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassiveUse</span> </span>&#123;<br> <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Child.num);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child类的初始化&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Parent类的初始化&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Class.forName</p></li><li><p>new 会导致初始化</p></li></ul><p>以下情况不会初始化</p><ul><li><p>访问类的 static ﬁnal 静态常量（基本类型和字符串）</p></li><li><p>类对象.class 不会触发初始化</p></li><li><p><strong>创建该类对象的数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Parent[] parents= <span class="hljs-keyword">new</span> Parent[<span class="hljs-number">10</span>];<span class="hljs-comment">//不会初始化</span><br>System.out.println(parents.getClass()); <br><span class="hljs-comment">// new的话才会初始化</span><br>parents[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Parent();<br></code></pre></td></tr></table></figure></li><li><p><strong>类加载器的.loadClass方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz = ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;com.test.java.Person&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>Class.forNamed的参数2为false时</p></li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h5 id="指针碰撞和空闲列表"><a href="#指针碰撞和空闲列表" class="headerlink" title="指针碰撞和空闲列表"></a>指针碰撞和空闲列表</h5><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<strong>指针碰撞</strong>”（Bump thePointer）。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<strong>空闲列表</strong>”（FreeList）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p><p>下面两张图可以解释指针碰撞和空闲列表：</p><ul><li><strong>指针碰撞</strong></li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.521.png" alt="img"></p><ul><li> <strong>空闲列表</strong></li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.522.png" alt="img"></p><h3 id="4-5-类加载器"><a href="#4-5-类加载器" class="headerlink" title="4.5 类加载器"></a>4.5 类加载器</h3><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(扩展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p><ul><li><p>这个类加载器使用C/C++语言实现的，嵌套在JVM内部。</p></li><li><p>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</p></li><li><p>并不继承自ava.lang.ClassLoader，没有父加载器。</p></li><li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p></li><li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p></li></ul><h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>扩展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><ul><li><p>Java语言实现，由sun.misc.Launcher$ExtClassLoader实现。</p></li><li><p>派生于ClassLoader类，父类加载器为启动类加载器</p></li><li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p></li></ul><h4 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h4><ul><li><p>java语言编写，由sun.misc.Launcher$AppClassLoader实现</p></li><li><p>派生于ClassLoader类，父类加载器为扩展类加载器</p></li><li><p>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</p></li><li><p>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</p></li><li><p>通过ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</p></li></ul><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul><li>不是重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul><h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是<strong>双亲委派</strong>模式，即把请求交由父类处理，它是一种任务委派模式。</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ul><li><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</p></li><li><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</p></li><li><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p></li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721112334183.png" alt="image-20210721112334183"></p><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul><li><p>避免类的重复加载，沙箱安全机制</p></li><li><p>保护程序安全，防止核心API被随意篡改 </p></li><li><p>自定义类：java.lang.String</p></li><li><p>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</p></li></ul><blockquote><p>沙箱安全机制</p><p>如自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class）。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p></blockquote><h5 id="loadClass源码"><a href="#loadClass源码" class="headerlink" title="loadClass源码"></a>loadClass源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// 首先查找该类是否已经被该类加载器加载过了</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-comment">//如果没有被加载过</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//看是否被启动类加载器加载过</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>                <span class="hljs-comment">//捕获异常，但不做任何处理</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span><br>                <span class="hljs-comment">//然后让应用类加载器去找classpath下找该类</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// 记录时间</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="什么地方违反了双亲委派模型"><a href="#什么地方违反了双亲委派模型" class="headerlink" title="什么地方违反了双亲委派模型"></a>什么地方违反了双亲委派模型</h4><p><strong>第一次破坏双亲委派机制</strong></p><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协。<strong>为了兼容这些已有的代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</strong>只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。</p><p><strong>第二次破坏双亲委派机制：线程上下文类加载器</strong></p><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<strong>越基础的类由越上层的加载器进行加载</strong>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，但是<strong>这样无法实现基础类型调用用户代码</strong></p><p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，<strong>启动类加载器绝不可能认识、加载这些代码的</strong>（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</p><p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（ThreadContextClassLoader）</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<strong>这是一种父类加载器去请求子类加载器完成类加载的行为</strong>，违背了双亲委派模型，但也是无可奈何的事情。 ，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p><blockquote><p>SPI机制简介 SPI的全名为Service Provider Interface，主要是应用于厂商自定义组件或插件中。在java.util.ServiceLoader的文档里有比较详细的介绍。简单的总结下java SPI机制的思想：我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块、xml解析模块、jdbc模块等方案。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。</p><p>使用线程上下文类加载器打破双亲委派模型</p></blockquote><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210724161029353.png" alt="image-20210724161029353"></p><p><strong>第三次破坏双亲委派机制</strong></p><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p><p><strong>Tomcat 加载器为何违背双亲委派模型</strong></p><p>Tomcat 如果使用默认的类加载机制行不行？<br>我们思考一下：Tomcat是个web容器， 那么它要解决什么问题：</p><ol><li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖<strong>同一个第三方类库的不同版本</strong>，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互<strong>隔离</strong>。</li><li>部署在同一个web容器中相同的类库相同的版本可以<strong>共享</strong>。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。</li><li>web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让<strong>容器的类库和程序的类库隔离</strong>开来。</li><li>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，<strong>web容器需要支持 jsp 修改后不用重启</strong>。</li></ol><p>再看看我们的问题：Tomcat 如果使用默认的类加载机制行不行？<br>答案是不行的。为什么？我们看，第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的累加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。第三个问题和第一个问题一样。我们再看第四个问题，我们想我们要怎么实现jsp文件的热修改，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以<strong>直接卸载掉这jsp文件的类加载器</strong>，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p><ul><li>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li><li>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li><li>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li><li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；</li></ul><ul><li>比较两个类是否“相等”，<code>只有在这两个类是由同一个类加载器加载的前提下才有意义</code>，否则，即使这两个类来自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这个两个类就必定不相等。</li></ul><h3 id="4-6-运行期优化"><a href="#4-6-运行期优化" class="headerlink" title="4.6 运行期优化"></a>4.6 运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><blockquote><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p></blockquote><h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul><li>解释器<ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器<ul><li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由来），并优化这些热点代码</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><ul><li><p><strong>标量</strong>（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p></li><li><p>相对的，那些还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量</p></li></ul><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// to do something  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p><p>JVM内有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p><p>第二个原因则更重要：<strong>方法内联</strong></p><p>如果JVM检测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123; <br>    <span class="hljs-comment">//这里调用了add2方法</span><br>    <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);  <br>&#125;  <br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2)</span> </span>&#123;  <br>    <span class="hljs-keyword">return</span> x1 + x2;  <br>&#125;<br></code></pre></td></tr></table></figure><p>方法调用被替换后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;  <br>    <span class="hljs-comment">//被替换为了方法本身</span><br>    <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reflect1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;foo...&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>      Method foo = Demo3.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>);<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">16</span>; i++) &#123;<br>         foo.invoke(<span class="hljs-keyword">null</span>);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>invoke方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,InvocationTargetException</span>&#123;<br>    <span class="hljs-keyword">if</span> (!override) &#123;<br>        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;<br>            Class&lt;?&gt; caller = Reflection.getCallerClass();<br>            checkAccess(caller, clazz, obj, modifiers);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类，默认使用DelegatingMethodAccessorImpl类</span><br>    MethodAccessor ma = methodAccessor;             <span class="hljs-comment">// read volatile</span><br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) &#123;<br>        ma = acquireMethodAccessor();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.53.png" alt="img"></p><p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p><p>NativeMethodAccessorImpl源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MethodAccessorImpl</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;<br>    <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numInvocations;<br><br>    NativeMethodAccessorImpl(Method var1) &#123;<br>        <span class="hljs-keyword">this</span>.method = var1;<br>    &#125;<br><br><span class="hljs-comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><br><span class="hljs-comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object var1, Object[] var2)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;<br>        <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="hljs-keyword">this</span>.method.getDeclaringClass())) &#123;<br>            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="hljs-keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="hljs-keyword">this</span>.method.getDeclaringClass(), <span class="hljs-keyword">this</span>.method.getName(), <span class="hljs-keyword">this</span>.method.getParameterTypes(), <span class="hljs-keyword">this</span>.method.getReturnType(), <span class="hljs-keyword">this</span>.method.getExceptionTypes(), <span class="hljs-keyword">this</span>.method.getModifiers());<br>            <span class="hljs-keyword">this</span>.parent.setDelegate(var3);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> invoke0(<span class="hljs-keyword">this</span>.method, var1, var2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.parent = var1;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">invoke0</span><span class="hljs-params">(Method var0, Object var1, Object[] var2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReflectionFactory.inflationThreshold()方法的返回值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inflationThreshold = <span class="hljs-number">15</span>;<br></code></pre></td></tr></table></figure><ul><li>一开始if条件不满足，就会调用本地方法invoke0</li><li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li></ul></li></ul><p>动态生成的访问器反编译后如下：</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.54.png" alt="img"></p><blockquote><p>通过查看 ReflectionFactory 源码可知<br>sun.reflect.noInflation 可以用来禁用膨胀（直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算）<br>sun.reflect.inflationThreshold 可以修改膨胀阈值</p></blockquote><hr><h2 id="五、对象实例化"><a href="#五、对象实例化" class="headerlink" title="五、对象实例化"></a>五、对象实例化</h2><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723134508418.png" alt="image-20210723134508418"></p><h3 id="5-1-创建对象的方式"><a href="#5-1-创建对象的方式" class="headerlink" title="5.1 创建对象的方式"></a>5.1 创建对象的方式</h3><ul><li><p>new：最常见的方式、Xxx的静态方法，XxxBuilder/XxxFactory的静态方法</p></li><li><p>Class的newInstance方法：反射的方式，只能调用空参的构造器，权限必须是public</p><ul><li><code>Demo demo01 = Demo.class.newInstance();</code></li></ul></li><li><p>Constructor的newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求</p><ul><li><code>Demo demo02= Demo.class.getDeclaredConstructor(Integer.class, String.class).newInstance(12,&quot;张三&quot;);</code></li></ul></li><li><p>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone()</p></li><li><p>使用序列化：从文件中、从网络中获取一个对象的二进制流</p></li><li><p>第三方库 Objenesis</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo</span><span class="hljs-params">(Integer id, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Demo&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-创建对象的步骤"><a href="#5-2-创建对象的步骤" class="headerlink" title="5.2 创建对象的步骤"></a>5.2 创建对象的步骤</h3><h4 id="1-判断对象对应的类是否加载、链接、初始化"><a href="#1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1. 判断对象对应的类是否加载、链接、初始化"></a>1. 判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。</p><p>如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件；</p><ul><li><p>如果没有找到文件，则抛出ClassNotFoundException异常</p></li><li><p>如果找到，则进行类加载，并生成对应的Class对象</p></li></ul><h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2. 为对象分配内存"></a>2. 为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><p><strong>如果内存规整</strong>：虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p><ul><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li></ul><p><strong>如果内存不规整</strong>：虚拟机需要维护一个空闲列表（Free List）来为对象分配内存。</p><ul><li>已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</li></ul><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h4 id="3-处理并发问题"><a href="#3-处理并发问题" class="headerlink" title="3. 处理并发问题"></a>3. 处理并发问题</h4><ul><li><p>采用CAS失败重试、区域加锁保证更新的原子性</p></li><li><p>每个线程预先分配一块TLAB：通过设置 <code>-XX:+UseTLAB</code>参数来设定</p></li></ul><h4 id="4-初始化分配到的内存"><a href="#4-初始化分配到的内存" class="headerlink" title="4. 初始化分配到的内存"></a>4. 初始化分配到的内存</h4><p>所有类属性设置默认值，保证对象实例字段在不赋值时可以直接使用</p><h4 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5. 设置对象的对象头"></a>5. 设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><h4 id="6-执行init方法进行初始化"><a href="#6-执行init方法进行初始化" class="headerlink" title="6. 执行init方法进行初始化"></a>6. 执行init方法进行初始化</h4><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><p><strong>给对象属性赋值的操作</strong></p><ul><li><p>属性的默认初始化</p></li><li><p>显式初始化</p></li><li><p>代码块中初始化</p></li><li><p>构造器中初始化</p></li></ul><p><strong>对象实例化的过程</strong></p><ol><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ol><h4 id="对象的实例化过程"><a href="#对象的实例化过程" class="headerlink" title="对象的实例化过程"></a>对象的实例化过程</h4><p>对象实例化过程，就是执行类构造函数对应在字节码文件中的<code>&lt;init&gt;()</code>方法(实例构造器)，<code>&lt;init&gt;()</code>方法由非静态变量、非静态代码块以及对应的构造器组成。</p><ul><li><code>&lt;init&gt;()</code>方法可以重载多个，类有几个构造器就有几个<code>&lt;init&gt;()</code>方法；</li><li><code>&lt;init&gt;()</code>方法中的代码执行顺序为：父类变量初始化、父类代码块、父类构造器、子类变量初始化、子类代码块、子类构造器。</li></ul><p>静态变量、静态代码块、普通变量、普通代码块、构造器的执行顺序如下图：</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210824170126835.png" alt="image-20210824170126835"></p><p>具有父类的子类的实例化顺序如下：</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210824170152708.png" alt="image-20210824170152708"></p><hr><h2 id="六、对象内存模型"><a href="#六、对象内存模型" class="headerlink" title="六、对象内存模型"></a>六、对象内存模型</h2><h3 id="6-1-内存布局"><a href="#6-1-内存布局" class="headerlink" title="6.1 内存布局"></a>6.1 内存布局</h3><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723135415086.png" alt="image-20210723135415086"></p><h4 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h4><p>对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针。如果是数组，还需要记录数组的长度</p><h5 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h5><ul><li><p>哈希值（HashCode）</p></li><li><p>GC分代年龄</p></li><li><p>锁状态标志</p></li><li><p>线程持有的锁</p></li><li><p>偏向线程ID</p></li><li><p>翩向时间戳</p></li></ul><h5 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h5><p>指向类元数据InstanceKlass，确定该对象所属的类型。</p><h4 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h4><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）</p><ul><li><p>相同宽度的字段总是被分配在一起</p></li><li><p>父类中定义的变量会出现在子类之前</p></li><li><p>如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙</p></li></ul><h4 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h4><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723135955189.png" alt="image-20210723135955189"></p><h3 id="6-2-对象的访问方式"><a href="#6-2-对象的访问方式" class="headerlink" title="6.2 对象的访问方式"></a>6.2 对象的访问方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><ul><li>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723141137169.png" alt="image-20210723141137169"></p><h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><ul><li>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</li></ul><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723141341840.png" alt="image-20210723141341840"></p><hr><h3 id="6-3-内存泄露"><a href="#6-3-内存泄露" class="headerlink" title="6.3 内存泄露"></a>6.3 内存泄露</h3><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。</p><p><strong>内存泄漏的情况</strong></p><h4 id="1-静态集合类"><a href="#1-静态集合类" class="headerlink" title="1.静态集合类"></a>1.静态集合类</h4><p>静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，<strong>长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryLeak</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> List list = <span class="hljs-keyword">new</span> ArrayList();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">oomTests</span><span class="hljs-params">()</span></span>&#123;<br>        Object obj＝<span class="hljs-keyword">new</span> Object();<span class="hljs-comment">//局部变量</span><br>        list.add(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h4><p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p><h4 id="3-内部类持有外部类"><a href="#3-内部类持有外部类" class="headerlink" title="3.内部类持有外部类"></a>3.内部类持有外部类</h4><p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p><h4 id="4-各种连接，如数据库连接、网络连接和IO连接等"><a href="#4-各种连接，如数据库连接、网络连接和IO连接等" class="headerlink" title="4.各种连接，如数据库连接、网络连接和IO连接等"></a>4.各种连接，如数据库连接、网络连接和IO连接等</h4><p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p><h4 id="5-变量不合理的作用域"><a href="#5-变量不合理的作用域" class="headerlink" title="5.变量不合理的作用域"></a>5.变量不合理的作用域</h4><p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsingRandom</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String msg;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMsg</span><span class="hljs-params">()</span></span>&#123;<br>        readFromNet();<span class="hljs-comment">//从网络中接受数据保存到msg中</span><br>        saveDB();<span class="hljs-comment">//把msg保存到数据库中</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面这个伪代码，通过readFromNet方法把接受的消息保存在变量msg中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了内存泄漏。实际上这个msg变量可以放在receiveMsg方法内部，当方法使用完，那么msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。</p><h4 id="6-改变哈希值"><a href="#6-改变哈希值" class="headerlink" title="6.改变哈希值"></a>6.改变哈希值</h4><p>改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p><p>否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p><p>这也是 String 为什么被设置成了不可变类型，我们可以放心地把 String 存入 HashSet，或者把String 当做 HashMap 的 key 值；</p><p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的 hashCode 不可变。</p><h4 id="7-缓存泄露"><a href="#7-缓存泄露" class="headerlink" title="7.缓存泄露"></a>7.缓存泄露</h4><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p><p>对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p><h4 id="8-监听器和其他回调"><a href="#8-监听器和其他回调" class="headerlink" title="8.监听器和其他回调"></a>8.监听器和其他回调</h4><p>内存泄漏常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。</p><p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。</p><h4 id="9-ThreadLocal"><a href="#9-ThreadLocal" class="headerlink" title="9.ThreadLocal"></a>9.ThreadLocal</h4><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用<strong>弱引用</strong>的ThreadLocal实例，value为线程变量的副本。这些对象之间的引用关系如下</p><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210724165354000.png" alt="image-20210724165354000"></p><p>从上图中可以看出，threadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部<strong>强引用</strong>时，Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强引用，只有thead线程退出以后，value的强引用链条才会断掉。</p><p>但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p><blockquote><p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p></blockquote><p>永远无法回收，造成内存泄漏。</p><ul><li><p>为什么ThreadLocalMap的key要使用弱引用</p><ul><li><p>key 使用强引用</p><p>当ThreadLocalMap的key为强引用，回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，<strong>导致Entry内存泄漏</strong>。</p></li><li><p>key 使用弱引用</p><p>当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set()，get()，remove()方法的时候会被清除value值。(没有调用时，<strong>会导致Value内存泄漏</strong>)</p></li></ul></li></ul><blockquote><p>ThreadLocal正确的使用方法</p><ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li><li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础</title>
    <link href="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能<strong>键值对</strong>（key-value）数据库。</p><h2 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><ul><li><p>数据间没有必然的关联关系</p></li><li><p>内部采用单线程机制进行工作</p></li><li><p>高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。</p></li><li><p>多数据类型支持</p><ul><li><p>字符串类型 string</p></li><li><p>列表类型 list</p></li><li><p>散列类型 hash</p></li><li><p>集合类型 set</p></li><li><p>有序集合类型 sorted_set</p></li></ul></li><li><p>持久化支持。可以进行数据灾难恢复</p></li></ul><h2 id="1-3-应用"><a href="#1-3-应用" class="headerlink" title="1.3 应用"></a>1.3 应用</h2><ul><li>为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等</li><li>任务队列，如秒杀、抢购、购票排队等</li><li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等</li><li>时效性信息控制，如验证码控制、投票控制等</li><li>分布式数据共享，如分布式集群架构中的 session 分离</li><li>消息队列</li><li>分布式锁</li></ul><h2 id="1-4-综合应用"><a href="#1-4-综合应用" class="headerlink" title="1.4 综合应用"></a>1.4 综合应用</h2><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/1.1.png"></p><h2 id="1-5-数据存储格式"><a href="#1-5-数据存储格式" class="headerlink" title="1.5 数据存储格式"></a>1.5 数据存储格式</h2><ul><li>redis 自身是一个 Map，其中所有的数据都是采用<strong>key : value</strong>的形式存储</li><li>数据类型指的是存储的数据的类型，也就是 value 部分的类型，<strong>key 部分永远都是字符串</strong></li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/1.2.png"></p><h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><p><strong>所有的key都为String类型，讨论数据类型是说的value的类型</strong></p><h2 id="2-1-String"><a href="#2-1-String" class="headerlink" title="2.1 String"></a>2.1 String</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li><li>存储数据的格式：一个存储空间保存一个数据</li><li>存储内容：通常使用字符串，如果字符串以整数的形式展示，<strong>可以作为数字操作使用</strong></li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">//添加/修改String<br>set key value<br>mset key1 value1 key2 value2...<br>//设置生命周期<br>setex key seconds value <br><br>//得到String<br>get key <br>mget key1 key2...<br><br>//得到字符串长度<br>strlen key<br><br>//删除String<br>del key<br><br>//向字符串的后面追加字符，如果有就补在后面，如果没有就新建<br>append key value<br></code></pre></td></tr></table></figure><h3 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h3><h4 id="String作为数值的操作"><a href="#String作为数值的操作" class="headerlink" title="String作为数值的操作"></a>String作为数值的操作</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//增长指令，只有当value为数字时才能增长</span><br>incr <span class="hljs-built_in">key</span>  <br>incrby <span class="hljs-built_in">key</span> increment  <br>incrbyfloat <span class="hljs-built_in">key</span> increment <br><br><span class="hljs-comment">//减少指令，有当value为数字时才能减少</span><br>decr <span class="hljs-built_in">key</span>  <br>decrby <span class="hljs-built_in">key</span> increment<br></code></pre></td></tr></table></figure><ul><li>string在redis内部存储默认就是一个<strong>字符串</strong>，当遇到增减类操作incr，decr时会<strong>转成数值型</strong>进行计算。</li><li>redis所有的操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li><li>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li></ul><blockquote><p>redis可以用于控制数据库表主键id，为数据库表主键<strong>提供生成策略</strong>，保障数据库表的主键<strong>唯一性</strong></p><p>此方案适用于所有数据库，且支持数据库集群</p></blockquote><h4 id="指定生命周期"><a href="#指定生命周期" class="headerlink" title="指定生命周期"></a>指定生命周期</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>设置数据的生命周期，单位 秒<br>setex key seconds value<br><span class="hljs-regexp">//</span>设置数据的生命周期，单位 毫秒<br>psetex key milliseconds valu<br></code></pre></td></tr></table></figure><blockquote><p>redis可以控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作    </p></blockquote><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>数据操作不成功的反馈与数据正常操作之间的差异</p><ul><li><p>表示运行结果是否成功</p><ul><li><p>(integer) 0 → false 失败</p></li><li><p>(integer) 1 → true 成功</p></li></ul></li><li><p>表示运行结果值</p><ul><li>(integer) 3 → 3， 3个</li><li>(integer) 1 → 1， 1个</li></ul></li></ul></li><li><p>数据未获取到返回nil，含义等同于null</p></li><li><p>数据最大存储量 512MB</p></li><li><p>数值计算最大范围（java中的long的最大值） 9223372036854775807</p></li></ul><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li><p>习惯以数据库热点数据key命名</p><p>​    表名：主键名：主键值：字段名</p></li></ul><p>eg1：order：id        : 29437  ：name</p><p>eg2：equip：id        : 39047： type</p><p>eg3：news：id        :  20041 ：title</p><h2 id="2-2-Hash"><a href="#2-2-Hash" class="headerlink" title="2.2 Hash"></a>2.2 Hash</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>存储的数据：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</li><li>存储数据的格式：一个存储空间保存多个键值对数据</li><li>hash类型：底层使用<strong>哈希表</strong>结构实现数据存储</li><li>hash存储结构优化<ul><li>如果field数量较少，存储结构优化为类数组结构</li><li>如果field数量较多，存储结构使用HashMap结构</li></ul></li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/2.1.png"></p><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">//插入/修改（如果已存在同名的field，会被覆盖）</span><br>hset <span class="hljs-built_in">key</span> field <span class="hljs-built_in">value</span><br>hmset <span class="hljs-built_in">key</span> field1 value1 field2 value2...<br><span class="hljs-comment">//插入（如果已存在同名的field，不会被覆盖）</span><br>hsetnx <span class="hljs-built_in">key</span> field <span class="hljs-built_in">value</span><br><br><span class="hljs-comment">//取出</span><br>hget <span class="hljs-built_in">key</span> field<br>hmget <span class="hljs-built_in">key</span> field1 field2...<br>hgetall <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//删除</span><br><span class="hljs-built_in">hdel</span> <span class="hljs-built_in">key</span> field1 field2...<br><br><span class="hljs-comment">//获取field数量</span><br>hlen <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//查看是否存在指定的字段</span><br>hexists <span class="hljs-built_in">key</span> field<br><br><span class="hljs-comment">//获取哈希表中所有的字段名或字段值 </span><br>hkeys <span class="hljs-built_in">key</span><br>hvals <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//设置指定字段的数值数据增加/减少指定范围的值 </span><br>hincrby <span class="hljs-built_in">key</span> field increment<br>hincrbyfloat <span class="hljs-built_in">key</span> field increment<br><br>hdecrby <span class="hljs-built_in">key</span> field increment<br>hdecrbyfloat <span class="hljs-built_in">key</span> field increment<br></code></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>hash类型下的value<strong>只能存储字符串</strong>，不允许存储其他数据类型，<strong>不存在嵌套现象</strong>。如果数据未获取到， 对应的值为（nil）</li><li>每个 hash 可以存储 2^32 - 1 个键值</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，<strong>不可滥用</strong>，更<strong>不可以将hash作为对象列表使用</strong></li><li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体<strong>数据效率就很会低</strong>，有可能成为数据访问瓶颈</li></ul><h2 id="2-3-List"><a href="#2-3-List" class="headerlink" title="2.3 List"></a>2.3 List</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul><li><p>存储的数据：存储多个数据，并对数据进入存储空间的顺序进行区分</p></li><li><p>存储数据的格式：一个存储空间保存多个数据，且通过数据可以体现进入顺序</p></li><li><p>list类型：保存多个数据，底层使用<strong>双向链表</strong>存储结构实现</p></li><li><p><strong>元素有序，且可重</strong></p></li></ul><h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tcl">//添加修改数据,lpush为从左边添加，rpush为从右边添加<br>lpush key value1 value2 value3...<br>rpush key value1 value2 value3...<br><br>//查看数据, 从左边开始向右查看. 如果不知道<span class="hljs-keyword">list</span>有多少个元素，end的值可以为<span class="hljs-number">-1</span>,代表倒数第一个元素<br>//lpush先进的元素放在最后,rpush先进的元素放在最前面<br><span class="hljs-keyword">lrange</span> key start end<br>//得到长度<br>llen key<br>//取出对应索引的元素<br><span class="hljs-keyword">lindex</span> key index<br><br>//获取并移除元素（从<span class="hljs-keyword">list</span>左边或者右边移除）<br>lpop key<br>rpop key<br></code></pre></td></tr></table></figure><h3 id="拓展操作"><a href="#拓展操作" class="headerlink" title="拓展操作"></a>拓展操作</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//规定时间内获取并移除数据,b=block,给定一个时间，如果在指定时间内放入了元素，就移除</span><br><span class="hljs-function"><span class="hljs-title">blpop</span></span> key1 key2... timeout<br><span class="hljs-function"><span class="hljs-title">brpop</span></span> key1 key2... timeout<br><br><span class="hljs-comment">//从列表中取出最后一个元素，并插入到另外一个列表的头部</span><br>brpoplpush source destination timeout<br><br><span class="hljs-comment">//移除指定元素 count:移除的个数 value:移除的值。 移除多个相同元素时，从左边开始移除</span><br>lrem key count value<br></code></pre></td></tr></table></figure><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。</li><li>list具有索引的概念，但是操作数据时通常以<strong>队列</strong>的形式进行入队出队(rpush, rpop)操作，或以<strong>栈</strong>的形式进行入栈出栈(lpush, lpop)操作</li><li>获取全部数据操作结束索引设置为-1 (倒数第一个元素)</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</li></ul><h2 id="2-4-Set"><a href="#2-4-Set" class="headerlink" title="2.4 Set"></a>2.4 Set</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><ul><li><p>存储的数据：存储大量的数据，在查询方面提供更高的效率</p></li><li><p>存储数据的格式：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的</p></li><li><p>set类型：能够保存大量的数据，高效的内部存储机制，便于查询</p></li><li><p><strong>不重复且无需</strong></p></li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/2.2.png"></p><h3 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>添加数据<br>sadd key member1 member2...<br><br><span class="hljs-regexp">//</span>查看全部数据<br>smembers key<br><br><span class="hljs-regexp">//</span>移除数据<br>srem key member1 member2<br><br><span class="hljs-regexp">//</span>查看数据个数<br>scard key<br><br><span class="hljs-regexp">//</span>查看某个元素是否存在<br>sismember key member<br></code></pre></td></tr></table></figure><h3 id="扩展操作-1"><a href="#扩展操作-1" class="headerlink" title="扩展操作"></a>扩展操作</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>从set中任意选出count个元素<br>srandmember key [count]<br><br><span class="hljs-regexp">//</span>从set中任意选出count个元素并移除<br>spop key [count]<br><br><span class="hljs-regexp">//</span>求两个集合的交集、并集、差集<br>sinter key1 key2<br>sunion key1 key2<br>sdiff key1 key2<br><br><span class="hljs-regexp">//</span>求两个set的交集、并集、差集，并放入另一个set中<br>sinterstore destination key1 key2<br>sunionstore destination key1 key2<br>sdiffstore destination key1 key2<br><br><span class="hljs-regexp">//</span>求指定数据从原集合移动到目标集合中<br>smove source destination key<br></code></pre></td></tr></table></figure><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份</li><li>set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间</li></ul><h2 id="2-5-sorted-set"><a href="#2-5-sorted-set" class="headerlink" title="2.5 sorted_set"></a>2.5 sorted_set</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><ul><li><p>存储的数据：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行<strong>排序</strong>的方式</p></li><li><p>存储数据的格式：新的存储模型，可以保存<strong>可排序</strong>的数据</p></li><li><p>sorted_set类型：在set的存储结构基础上添加可排序字段</p></li><li><p><strong>不重但有序（score）</strong></p></li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/2.3.png"></p><h3 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">//插入元素, 需要指定score(用于排序)</span><br>zadd <span class="hljs-built_in">key</span> score1 member1 score2 member2<br><br><span class="hljs-comment">//查看元素(score升序), 当末尾添加withscore时，会将元素的score一起打印出来</span><br>zrange <span class="hljs-built_in">key</span> start end [withscore]<br><span class="hljs-comment">//查看元素(score降序), 当末尾添加withscore时，会将元素的score一起打印出来</span><br>zrevrange <span class="hljs-built_in">key</span> start end [withscore]<br><br><span class="hljs-comment">//移除元素</span><br>zrem <span class="hljs-built_in">key</span> member1 member2...<br><br><span class="hljs-comment">//按条件获取数据, 其中offset为索引开始位置，count为获取的数目</span><br>zrangebyscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">min</span> <span class="hljs-built_in">max</span> [withscore] [limit offset <span class="hljs-built_in">count</span>]<br>zrevrangebyscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">max</span> <span class="hljs-built_in">min</span> [withscore] [limit offset <span class="hljs-built_in">count</span>]<br><br><span class="hljs-comment">//按条件移除元素</span><br>zremrangebyrank <span class="hljs-built_in">key</span> start end<br>zremrangebysocre <span class="hljs-built_in">key</span> <span class="hljs-built_in">min</span> <span class="hljs-built_in">max</span><br><br><span class="hljs-comment">//按照从大到小的顺序移除count个值</span><br>zpopmax <span class="hljs-built_in">key</span> [<span class="hljs-built_in">count</span>]<br><span class="hljs-comment">//按照从小到大的顺序移除count个值</span><br>zpopmin <span class="hljs-built_in">key</span> [<span class="hljs-built_in">count</span>]<br><br><span class="hljs-comment">//获得元素个数</span><br>zcard <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//获得元素在范围内的个数</span><br>zcount <span class="hljs-built_in">min</span> <span class="hljs-built_in">max</span><br><br><span class="hljs-comment">//求交集、并集并放入destination中, 其中numkey为要去交集或并集集合的数目</span><br>zinterstore destination numkeys key1 key2...<br>zunionstore destination numkeys key1 key2...<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>min与max用于限定搜索查询的<strong>条件</strong></li><li>start与stop用于限定<strong>查询范围</strong>，作用于索引，表示开始和结束索引</li><li>offset与count用于限定查询范围，作用于查询结果，表示<strong>开始位置</strong>和<strong>数据总量</strong></li></ul><h3 id="拓展操作-1"><a href="#拓展操作-1" class="headerlink" title="拓展操作"></a>拓展操作</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//查看某个元素的索引(排名)</span><br>zrank <span class="hljs-built_in">key</span> member<br>zrevrank <span class="hljs-built_in">key</span> member<br><br><span class="hljs-comment">//查看某个元素索引的值</span><br>zscore <span class="hljs-built_in">key</span> member<br><span class="hljs-comment">//增加某个元素索引的值</span><br>zincrby <span class="hljs-built_in">key</span> increment membe<br></code></pre></td></tr></table></figure><h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>score保存的数据存储空间是64位，如果是整数，范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，<strong>可能会丢失精度</strong>，使用时候要<strong>慎重</strong></li><li>sorted_set 底层存储还是<strong>基于set</strong>结构的，因此数据<strong>不能重复</strong>，如果重复添加相同的数据，score值将被反复覆盖，<strong>保留最后一次</strong>修改的结果</li></ul><h1 id="三、通用指令"><a href="#三、通用指令" class="headerlink" title="三、通用指令"></a>三、通用指令</h1><h2 id="3-1-Key的特征"><a href="#3-1-Key的特征" class="headerlink" title="3.1 Key的特征"></a>3.1 Key的特征</h2><ul><li>key是一个<strong>字符串</strong>，通过key获取redis中保存的数据</li></ul><h2 id="3-2-Key的操作"><a href="#3-2-Key的操作" class="headerlink" title="3.2 Key的操作"></a>3.2 Key的操作</h2><h3 id="基本操作-5"><a href="#基本操作-5" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//查看key是否存在</span><br>exists <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//删除key</span><br>del <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//查看key的类型</span><br><span class="hljs-built_in">type</span> <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><h3 id="拓展操作-2"><a href="#拓展操作-2" class="headerlink" title="拓展操作"></a>拓展操作</h3><h4 id="时效性操作"><a href="#时效性操作" class="headerlink" title="时效性操作"></a>时效性操作</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//设置生命周期</span><br>expire <span class="hljs-built_in">key</span> seconds<br>pexpire <span class="hljs-built_in">key</span> milliseconds<br><br>expireat <span class="hljs-built_in">key</span> timestamp<br>pexpireat <span class="hljs-built_in">key</span> milliseconds-timestamp<br><br><span class="hljs-comment">//查看有效时间, 如果有有效时间则返回剩余有效时间, 如果为永久有效，则返回-1, 如果Key不存在则返回-2</span><br>ttl <span class="hljs-built_in">key</span><br>pttl <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//将有时限的数据设置为永久有效</span><br>persist <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>根据key查询符合条件的数据<br>keys pattern<br></code></pre></td></tr></table></figure><p><strong>查询规则</strong></p><p><code>*</code>匹配任意数量的任意符号</p><p> <code>?</code> 配合一个任意符号</p><p><code> []</code> 匹配一个指定符号</p><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xquery">//重命<span class="hljs-built_in">名key</span>，为了避免覆盖已有数据，尽量少去修改已<span class="hljs-built_in">有key</span>的名字，如果要使用最好使用renamenx<br><span class="hljs-keyword">rename</span><span class="hljs-built_in"> key</span> newKey<br>renamenx<span class="hljs-built_in"> key</span> newKey<br><br>//对所<span class="hljs-built_in">有key</span>排序<span class="hljs-built_in"></span><br><span class="hljs-built_in">sort</span><br><br>//查看所有关<span class="hljs-built_in">于key</span>的操作, 可以使用Tab快速切换<br>help @generic<br></code></pre></td></tr></table></figure><h2 id="3-3-数据库通用操作"><a href="#3-3-数据库通用操作" class="headerlink" title="3.3 数据库通用操作"></a>3.3 数据库通用操作</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>Redis为每个服务提供有16个数据库，编号从0到15</li><li>每个数据库之间的数据相互独立</li></ul><h3 id="基本操作-6"><a href="#基本操作-6" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>切换数据库 <span class="hljs-number">0</span>~<span class="hljs-number">15</span><br>select index<br><br><span class="hljs-regexp">//</span>其他操作<br>quit<br>ping<br>echo massage<br></code></pre></td></tr></table></figure><h3 id="拓展操作-3"><a href="#拓展操作-3" class="headerlink" title="拓展操作"></a>拓展操作</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>移动数据, 必须保证目的数据库中没有该数据<br>mov key db<br><br><span class="hljs-regexp">//</span>查看该库中数据总量<br>dbsize<br><br><span class="hljs-regexp">//</span>数据清除<br>flushdb<br>flushall<br></code></pre></td></tr></table></figure><h1 id="四、Jedis"><a href="#四、Jedis" class="headerlink" title="四、Jedis"></a>四、Jedis</h1><p><strong>JAVA</strong>操作Redis需要导入jar或引入Maven依赖</p><h2 id="4-1-Java操作redis的步骤"><a href="#4-1-Java操作redis的步骤" class="headerlink" title="4.1 Java操作redis的步骤"></a>4.1 Java操作redis的步骤</h2><ul><li>连接Redis</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//参数为Redis所在的ip地址和端口号</span><br>Jedis jedis = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Jedis(String <span class="hljs-params">host</span>, <span class="hljs-params">int</span> <span class="hljs-params">port</span>)</span><br></code></pre></td></tr></table></figure><ul><li>操作Redis</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//操作redis的指令和redis本身的指令几乎一致</span><br>jedis.<span class="hljs-built_in">set</span>(<span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span>, <span class="hljs-keyword">String</span> value);<br>jedis.<span class="hljs-built_in">get</span>(<span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span>);<br></code></pre></td></tr></table></figure><ul><li>断开连接</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">jedis.close()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="4-2-配置工具"><a href="#4-2-配置工具" class="headerlink" title="4.2 配置工具"></a>4.2 配置工具</h2><ul><li>配置文件</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">redis.host</span>=localhost<br><span class="hljs-attr">redis.port</span>=<span class="hljs-number">6379</span><br><span class="hljs-attr">redis.maxTotal</span>=<span class="hljs-number">30</span><br><span class="hljs-attr">redis.maxIdle</span>=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><ul><li>工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<br><span class="hljs-keyword">import</span> java.util.ResourceBundle;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtil</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Jedis jedis = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String host = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> port;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxTotal;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxIdle;<br><br><span class="hljs-comment">//使用静态代码块，只加载一次</span><br><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-comment">//读取配置文件</span><br>ResourceBundle resourceBundle = ResourceBundle.getBundle(<span class="hljs-string">&quot;redis&quot;</span>);<br><span class="hljs-comment">//获取配置文件中的数据</span><br>host = resourceBundle.getString(<span class="hljs-string">&quot;redis.host&quot;</span>);<br>port = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">&quot;redis.port&quot;</span>));<br><span class="hljs-comment">//读取最大连接数</span><br>maxTotal = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">&quot;redis.maxTotal&quot;</span>));<br><span class="hljs-comment">//读取最大活跃数</span><br>maxIdle = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">&quot;redis.maxIdle&quot;</span>));<br>JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>jedisPoolConfig.setMaxTotal(maxTotal);<br>jedisPoolConfig.setMaxIdle(maxIdle);<br><span class="hljs-comment">//获取连接池</span><br>JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(jedisPoolConfig, host, port);<br>jedis = jedisPool.getResource();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> jedis;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="五、Linux下环境配置"><a href="#五、Linux下环境配置" class="headerlink" title="五、Linux下环境配置"></a>五、Linux下环境配置</h1><h2 id="5-1-基础环境设置"><a href="#5-1-基础环境设置" class="headerlink" title="5.1 基础环境设置"></a>5.1 基础环境设置</h2><ul><li>创建软链接<ul><li> ln -s 原始目录名 快速访问目录名</li></ul></li><li>创建配置文件管理目录 <ul><li> mkdir conf mkdir config</li></ul></li><li>创建数据文件管理目录 <ul><li> mkdir data</li></ul></li></ul><h2 id="5-2-服务启动"><a href="#5-2-服务启动" class="headerlink" title="5.2 服务启动"></a>5.2 服务启动</h2><ul><li>默认配置启动<ul><li>redis-server</li><li>redis-server –-port 6379</li></ul></li><li>指定配置文件启动<ul><li>redis-server redis.conf</li><li> redis-server redis-6379.conf</li><li>redis-server conf/redis-6379.conf</li></ul></li></ul><h2 id="5-3-客户端连接"><a href="#5-3-客户端连接" class="headerlink" title="5.3 客户端连接"></a>5.3 客户端连接</h2><ul><li>默认连接<ul><li> redis-cli</li></ul></li><li>连接指定服务器<ul><li> redis-cli -h 127.0.0.1</li><li> redis-cli –port 6379</li><li> redis-cli -h 127.0.0.1 –port 6379</li></ul></li></ul><h2 id="5-4-服务端配置"><a href="#5-4-服务端配置" class="headerlink" title="5.4 服务端配置"></a>5.4 服务端配置</h2><ul><li><strong>daemonize yes</strong> 以守护进程方式启动，使用本启动方式，redis将以服务的形式存在，日志将不再打印到命令窗口中</li><li><strong>bind XXX.XXX.XXX.XXX</strong> 绑定主机地址</li><li>**port XXXX ** 设定当前服务启动端口号</li><li><strong>databases XX</strong> 设置数据库数量</li><li><strong>dir “/自定义目录/redis/data“</strong> 设定当前服务文件保存位置，包含日志文件、持久化文件等</li><li><strong>logfile “XXXX.log“</strong> 设定日志文件名，便于查阅</li><li><strong>loglevel debug|verbose|notice|warning</strong>  设置服务器以指定日志记录级别</li><li><strong>include /path/XXXX.conf</strong> 导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件</li></ul><h1 id="六、持久化"><a href="#六、持久化" class="headerlink" title="六、持久化"></a>六、持久化</h1><h2 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1 简介"></a>6.1 简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>利用<strong>永久性</strong>存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p><strong>防止</strong>数据的意外<strong>丢失</strong>，确保数据<strong>安全性</strong></p><h3 id="持久化过程保存什么"><a href="#持久化过程保存什么" class="headerlink" title="持久化过程保存什么"></a>持久化过程保存什么</h3><ul><li>将当前<strong>数据状态</strong>进行保存，<strong>快照</strong>形式，存储数据结果，存储格式简单，关注点在<strong>数据</strong></li><li>将数据的<strong>操作过程</strong>进行保存，<strong>日志</strong>形式，存储操作过程，存储格式复杂，关注点在数据的操作<strong>过程</strong></li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.1.png"></p><h2 id="6-2-RDB"><a href="#6-2-RDB" class="headerlink" title="6.2 RDB"></a>6.2 RDB</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>RDB全称<strong>redis database</strong>，在指定的时间间隔内将内存中的数据集快照写入磁盘，（即Snapshot快照），它恢复时直接将快照文件直接读到内存里。（Redis默认持久化方式）</p><h3 id="RDB启动方式——手动save"><a href="#RDB启动方式——手动save" class="headerlink" title="RDB启动方式——手动save"></a>RDB启动方式——手动save</h3><ul><li><p>命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">save</span><br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>手动执行一次保存操作</p></li></ul><blockquote><p>save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用。</p></blockquote><h4 id="RDB配置相关命令"><a href="#RDB配置相关命令" class="headerlink" title="RDB配置相关命令"></a>RDB配置相关命令</h4><ul><li>dbfilename dump.rdb<ul><li>说明：设置本地数据库文件名，默认值为 dump.rdb</li><li>经验：通常设置为<strong>dump-端口号.rdb</strong></li></ul></li><li>dir<ul><li>说明：设置存储.rdb文件的路径</li><li>经验：通常设置成存储空间较大的目录中，目录名称data</li></ul></li><li>rdbcompression yes<ul><li>说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩</li><li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</li></ul></li><li>rdbchecksum yes<ul><li>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行</li><li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</li></ul></li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.2.png"></p><h3 id="RDB启动方式——bgsave"><a href="#RDB启动方式——bgsave" class="headerlink" title="RDB启动方式——bgsave"></a>RDB启动方式——bgsave</h3><ul><li><p>命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bgsave</span><br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>手动启动后台保存操作，但<strong>不是立即执行</strong></p></li></ul><h4 id="RDB配置相关命令-1"><a href="#RDB配置相关命令-1" class="headerlink" title="RDB配置相关命令"></a>RDB配置相关命令</h4><ul><li>stop-writes-on-bgsave-error yes<ul><li>说明：后台存储过程中如果出现错误现象，是否停止保存操作</li><li>经验：通常默认为<strong>开启</strong>状态</li></ul></li></ul><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.3.png"></p><h3 id="RDB启动方式——自动save"><a href="#RDB启动方式——自动save" class="headerlink" title="RDB启动方式——自动save"></a>RDB启动方式——自动save</h3><h4 id="RDB配置相关命令-2"><a href="#RDB配置相关命令-2" class="headerlink" title="RDB配置相关命令"></a>RDB配置相关命令</h4><ul><li><p>配置</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">save</span> <span class="hljs-built_in">second</span> changes<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>满足<strong>限定时间</strong>范围内key的变化数量达到<strong>指定数量</strong>即进行持久化</p></li><li><p>参数</p><ul><li>second：监控时间范围</li><li>changes：监控key的变化量</li></ul></li><li><p>配置位置</p><p>在<strong>conf文件</strong>中进行配置</p></li></ul><h4 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.4.png"></p><h3 id="RDB启动方式对比"><a href="#RDB启动方式对比" class="headerlink" title="RDB启动方式对比"></a>RDB启动方式对比</h3><table><thead><tr><th>方式</th><th>手动save</th><th>bgsave</th><th>自动save</th></tr></thead><tbody><tr><td>读写</td><td>同步</td><td>异步</td><td>本质上是bgsave</td></tr><tr><td>阻塞客户端指令</td><td>是</td><td>否</td><td>本质上是bgsave</td></tr><tr><td>额外内存消耗</td><td>否</td><td>是</td><td>本质上是bgsave</td></tr><tr><td>启动新进程</td><td>否</td><td>是</td><td>本质上是bgsave</td></tr></tbody></table><h3 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h3><ul><li>优点<ul><li>RDB是一个紧凑压缩的二进制文件，<strong>存储效率较高</strong></li><li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于<strong>数据备份，全量复制</strong>等场景</li><li>RDB恢复数据的<strong>速度</strong>要比AOF<strong>快</strong>很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，<strong>用于灾难恢复</strong></li></ul></li><li>缺点<ul><li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作<strong>创建子进程</strong>，要<strong>牺牲</strong>掉一些<strong>性能</strong></li><li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式<strong>无法兼容</strong>现象</li></ul></li></ul><h2 id="6-3-AOF"><a href="#6-3-AOF" class="headerlink" title="6.3 AOF"></a>6.3 AOF</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>AOF全称<strong>Append Only File</strong>，以redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构造数据。即，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><ul><li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的<strong>主流</strong>方式</li></ul><h3 id="AOF写数据过程"><a href="#AOF写数据过程" class="headerlink" title="AOF写数据过程"></a>AOF写数据过程</h3><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.5.png"></p><h3 id="AOF写数据三种策略-appendfsync"><a href="#AOF写数据三种策略-appendfsync" class="headerlink" title="AOF写数据三种策略(appendfsync)"></a>AOF写数据三种策略(appendfsync)</h3><ul><li>always<ul><li>每次写入操作均同步到AOF文件中，数据零误差，<strong>性能较低</strong>,<strong>不建议使用</strong></li></ul></li><li>everysec<ul><li>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，<strong>性能较高</strong> ，<strong>建议使用</strong>，也是默认配置</li><li>在系统突然宕机的情况下丢失1秒内的数据</li></ul></li><li>no<ul><li>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong></li></ul></li></ul><h3 id="AOF功能开启"><a href="#AOF功能开启" class="headerlink" title="AOF功能开启"></a>AOF功能开启</h3><ul><li><p>配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><ul><li> 作用</li><li>是否开启AOF持久化功能，<strong>默认为不开启状态</strong></li></ul></li><li><p>配置</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">appendfsync always|<span class="hljs-type">everysec</span>|<span class="hljs-type">no</span><br></code></pre></td></tr></table></figure><ul><li>作用<ul><li>AOF写数据策略</li></ul></li></ul></li><li><p>配置</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">appendfilename filename</span><br></code></pre></td></tr></table></figure><ul><li>作用<ul><li>AOF持久化文件名，默认文件名未appendonly.aof，建议配置为appendonly-端口号.aof</li></ul></li></ul></li><li><p>配置</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">dir</span><br></code></pre></td></tr></table></figure><ul><li>作用<ul><li>AOF持久化文件保存路径，与RDB持久化文件保持一致即可</li></ul></li></ul></li></ul><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>进程内已超时的数据不再写入文件</li><li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<ul><li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</li></ul></li><li>对同一数据的多条写命令合并为一条命令<ul><li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c</li><li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li></ul></li></ul><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li><p>手动重写</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bgrewriteaof</span><br></code></pre></td></tr></table></figure></li><li><p>自动重写</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span>-aof-rewrite-min-size size <br><span class="hljs-keyword">auto</span>-aof-rewrite-percentage percentage<br></code></pre></td></tr></table></figure></li></ul><h3 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="手动重写"><a href="#手动重写" class="headerlink" title="手动重写"></a>手动重写</h4><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.6.png"></p><h4 id="自动重写"><a href="#自动重写" class="headerlink" title="自动重写"></a>自动重写</h4><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.7.png"></p><h4 id="缓冲策略"><a href="#缓冲策略" class="headerlink" title="缓冲策略"></a>缓冲策略</h4><p>AOF缓冲区同步文件策略，由参数<strong>appendfsync</strong>控制</p><ul><li>write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用 来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依 赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。</li><li>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞直到写入硬盘完成后返回，保证了数据持久化。</li></ul><h2 id="6-4-RDB与AOF对比"><a href="#6-4-RDB与AOF对比" class="headerlink" title="6.4 RDB与AOF对比"></a>6.4 RDB与AOF对比</h2><table><thead><tr><th>持久化方式</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>占用存储空间</td><td>小（数据级：压缩）</td><td>大（指令级：重写）</td></tr><tr><td>存储速度</td><td>慢</td><td>快</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>会丢失数据</td><td>依据策略决定</td></tr><tr><td>资源消耗</td><td>高/重量级</td><td>低/轻量级</td></tr><tr><td>启动优先级</td><td>低</td><td>高</td></tr></tbody></table><ul><li>对数据非常敏感，建议使用默认的AOF持久化方案<ul><li>AOF持久化策略使用<strong>everysecond</strong>，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li><li>注意：由于AOF文件<strong>存储体积较大</strong>，且<strong>恢复速度较慢</strong></li></ul></li><li>数据呈现阶段有效性，建议使用RDB持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且<strong>恢复速度较快</strong>，阶段 点数据恢复通常采用RDB方案</li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低</li></ul></li><li>综合比对<ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常<strong>敏感</strong>，选用<strong>AOF</strong></li><li>如能承受数分钟以内的数据丢失，且追求大数据集的<strong>恢复速度</strong>，选用<strong>RDB</strong></li><li><strong>灾难恢复选用RDB</strong></li><li>双保险策略，同时开启 RDB 和 AOF，<strong>重启后，Redis优先使用 AOF 来恢复数据</strong>，降低丢失数据</li></ul></li></ul><h1 id="七、事务"><a href="#七、事务" class="headerlink" title="七、事务"></a>七、事务</h1><h2 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h2><p>redis事务就是一个命令执行的队列，将一系列预定义命令<strong>包装成一个整体</strong>（一个队列）。当执行时，<strong>一次性按照添加顺序依次执行</strong>，中间不会被打断或者干扰</p><h2 id="7-2-事务的基本操作"><a href="#7-2-事务的基本操作" class="headerlink" title="7.2 事务的基本操作"></a>7.2 事务的基本操作</h2><ul><li><p>开启事务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">multi</span><br></code></pre></td></tr></table></figure><ul><li>作用<ul><li>作设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li></ul></li></ul></li><li><p>取消事务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">discard</span><br></code></pre></td></tr></table></figure><ul><li>作用<ul><li>终止当前事务的定义，发生在multi之后，exec之前</li></ul></li></ul></li><li><p>执行事务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span><br></code></pre></td></tr></table></figure><ul><li>作用<ul><li>设定事务的结束位置，同时执行事务。<strong>与multi成对出现</strong>，成对使用</li></ul></li></ul></li></ul><blockquote><p>加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</p></blockquote><h2 id="7-3-工作流程"><a href="#7-3-工作流程" class="headerlink" title="7.3 工作流程"></a>7.3 工作流程</h2><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/7.1.png"></p><h2 id="7-4-注意事项"><a href="#7-4-注意事项" class="headerlink" title="7.4 注意事项"></a>7.4 注意事项</h2><p><strong>定义事务的过程中，出现错误</strong></p><ul><li><p>语法错误，指命令书写格式有误 例如执行了一条不存在的指令</p><ul><li>处理结果：如果定义的事务中所包含的命令存在语法错误，整体事务中<strong>所有命令均不会执行</strong>。包括那些语法正确的命令</li></ul></li><li><p>运行错误，指命令<strong>格式正确</strong>，但是<strong>无法正确的执行</strong>。例如对list进行incr操作</p><ul><li>处理结果：<strong>能够正确运行的命令会执行</strong>，运行错误的命令不会被执行</li></ul></li></ul><blockquote><p>已经执行完毕的命令对应的数据<strong>不会自动回滚</strong>，需要程序员自己在代码中实现回滚。</p></blockquote><h2 id="7-5、基于特定条件的事务执行"><a href="#7-5、基于特定条件的事务执行" class="headerlink" title="7.5、基于特定条件的事务执行"></a>7.5、基于特定条件的事务执行</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">watch</span> key<span class="hljs-number">1</span>, key<span class="hljs-number">2</span>....<br></code></pre></td></tr></table></figure></li><li><p>取消对<strong>所有</strong>key的监视</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">unwatch</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul><li><p>使用 setnx 设置一个公共锁</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>上锁<br>setnx lock-key value<br><span class="hljs-regexp">//</span>释放锁<br>del lock-key<br></code></pre></td></tr></table></figure><ul><li>利用setnx命令的返回值特征，有值（被上锁了）则返回设置失败，无值（没被上锁）则返回设置成功</li><li>操作完毕通过del操作释放锁</li></ul></li></ul><p><strong>注意</strong>：上述解决方案是一种<strong>设计概念</strong>，依赖规范保障，具有风险性</p><h4 id="分布式锁加强"><a href="#分布式锁加强" class="headerlink" title="分布式锁加强"></a>分布式锁加强</h4><ul><li><p>使用 expire 为锁key添加<strong>时间限定</strong>，到时不释放，放弃锁</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">expire <span class="hljs-keyword">lock</span>-key seconds<br>pexpire <span class="hljs-keyword">lock</span>-key milliseconds<br></code></pre></td></tr></table></figure></li><li><p>由于操作通常都是微秒或毫秒级，因此该锁定时间<strong>不宜设置过大</strong>。具体时间需要业务测试后确认。</p><ul><li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。</li><li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</li><li>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%</li><li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li></ul></li></ul><h1 id="八、删除策略"><a href="#八、删除策略" class="headerlink" title="八、删除策略"></a>八、删除策略</h1><h2 id="8-1-数据删除策略"><a href="#8-1-数据删除策略" class="headerlink" title="8.1 数据删除策略"></a>8.1 数据删除策略</h2><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><h3 id="时效性数据的存储结构"><a href="#时效性数据的存储结构" class="headerlink" title="时效性数据的存储结构"></a>时效性数据的存储结构</h3><ul><li>Redis中的数据，在expire中以哈希的方式保存在其中。其value是数据在内存中的地址，filed是对应的生命周期</li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/8.1.png"></p><h3 id="数据删除策略的目标"><a href="#数据删除策略的目标" class="headerlink" title="数据删除策略的目标"></a>数据删除策略的目标</h3><p>在内存占用与CPU占用之间寻找一种<strong>平衡</strong>，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露</p><h2 id="8-2-三种删除策略"><a href="#8-2-三种删除策略" class="headerlink" title="8.2 三种删除策略"></a>8.2 三种删除策略</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><ul><li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务<strong>立即执行</strong>对键的删除操作</li><li>优点：<strong>节约内存</strong>，到时就删除，快速释放掉不必要的内存占用</li><li>缺点：<strong>CPU压力很大</strong>，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li><li>总结：用处理器性能换取存储空间 （<strong>拿时间换空间</strong>）</li></ul><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><ul><li>数据到达过期时间，不做处理。等下次访问该数据时<ul><li>如果未过期，返回数据</li><li>发现已过期，删除，返回不存在</li></ul></li><li>优点：<strong>节约CPU性能</strong>，发现必须删除的时候才删除</li><li>缺点：<strong>内存压力很大</strong>，出现长期占用内存的数据</li><li>总结：用存储空间换取处理器性能 （拿空间换时间）</li></ul><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/8.2.png"></p><ul><li>周期性轮询redis库中的时效性数据，采用<strong>随机抽取的策略</strong>，利用过期数据占比的方式控制删除频度</li><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li><li>总结：周期性抽查存储空间 （随机抽查，重点抽查）</li></ul><h2 id="8-3-删除策略对比"><a href="#8-3-删除策略对比" class="headerlink" title="8.3 删除策略对比"></a>8.3 删除策略对比</h2><table><thead><tr><th>删除方式</th><th>内存占用</th><th>CPU占用</th><th>本质</th></tr></thead><tbody><tr><td>定时删除</td><td>节约内存，无占用</td><td>不分时段占用CPU资源，频度高</td><td>拿时间换空间</td></tr><tr><td>惰性删除</td><td>内存占用严重</td><td>延时执行，CPU利用率高</td><td>拿空间换时间</td></tr><tr><td>定期删除</td><td>内存定期随机清理</td><td>每秒花费固定的CPU资源维护内存</td><td>随机抽查，重点抽查</td></tr></tbody></table><h2 id="8-4-逐出算法"><a href="#8-4-逐出算法" class="headerlink" title="8.4 逐出算法"></a>8.4 逐出算法</h2><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用<strong>freeMemoryIfNeeded()<strong>检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为</strong>逐出算法</strong></li><li><strong>注意</strong>：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息（OOM）。</li></ul><h3 id="影响数据逐出的相关配置"><a href="#影响数据逐出的相关配置" class="headerlink" title="影响数据逐出的相关配置"></a>影响数据逐出的相关配置</h3><ul><li><p>最大可使用内存</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory</span><br></code></pre></td></tr></table></figure><p>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</p></li><li><p>每次选取待删除数据的个数</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory-samples</span><br></code></pre></td></tr></table></figure><p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p></li><li><p>删除策略</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">maxmemory-<span class="hljs-keyword">policy</span><br></code></pre></td></tr></table></figure><p>达到最大内存后的，对被挑选出来的数据进行删除的策略</p></li><li><p>检测易失数据（可能会过期的数据集server.db[i].expires ）<br>① volatile-lru：挑选最近最少使用的数据淘汰<br>② volatile-lfu：挑选最近使用次数最少的数据淘汰<br>③ volatile-ttl：挑选将要过期的数据淘汰<br>④ volatile-random：任意选择数据淘汰</p></li><li><p>检测全库数据（所有数据集server.db[i].dict ）<br>⑤ allkeys-lru：挑选最近最少使用的数据淘汰<br>⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰<br>⑦ allkeys-random：任意选择数据淘汰</p></li><li><p>放弃数据驱逐<br>⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</p></li></ul><blockquote><p><strong>LRU</strong>：最长时间没被使用的数据</p><p><strong>LFU</strong>：一段时间内使用次数最少的数据</p></blockquote><h3 id="数据逐出策略配置依据"><a href="#数据逐出策略配置依据" class="headerlink" title="数据逐出策略配置依据"></a>数据逐出策略配置依据</h3><ul><li>使用<strong>INFO命令</strong>输出监控信息，查询缓存 <strong>hit 和 miss</strong> 的次数，根据业务需求调优Redis配置</li></ul><h1 id="九、高级数据类型"><a href="#九、高级数据类型" class="headerlink" title="九、高级数据类型"></a>九、高级数据类型</h1><h2 id="9-1-Bitmaps"><a href="#9-1-Bitmaps" class="headerlink" title="9.1 Bitmaps"></a>9.1 Bitmaps</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li><p>获取指定key对应偏移量上的bit值</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">getbit key <span class="hljs-built_in">offset</span><br></code></pre></td></tr></table></figure></li><li><p>设置指定key对应偏移量上的bit值，value只能是1或0</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">setbit key <span class="hljs-built_in">offset</span> value<br></code></pre></td></tr></table></figure></li></ul><h3 id="扩展操作-2"><a href="#扩展操作-2" class="headerlink" title="扩展操作"></a>扩展操作</h3><ul><li><p>对指定key按位进行交、并、非、异或操作，并将结果<strong>保存到destKey</strong>中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bitop</span> op destKey key<span class="hljs-number">1</span><span class="hljs-meta"> [key2...]</span><br></code></pre></td></tr></table></figure><ul><li>and：交</li><li>or：并</li><li>not：非</li><li>xor：异或</li></ul></li><li><p>统计指定key中1的数量</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">bitcount<span class="hljs-built_in"> key</span> [<span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>]<br></code></pre></td></tr></table></figure></li></ul><h2 id="9-2-HyperLogLog"><a href="#9-2-HyperLogLog" class="headerlink" title="9.2 HyperLogLog"></a>9.2 HyperLogLog</h2><h3 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h3><ul><li>基数是数据集<strong>去重后元素个数</strong></li><li>HyperLogLog 是用来做基数统计的，运用了LogLog的算法</li></ul><blockquote><p>{1,3,5,7,5,1,5,9}    基数集：{1,3,5,7,9}    基数：5</p><p>{1,1,1,2,2,1,1,1}    基数集：{1,2}    基数：2</p></blockquote><h3 id="基本操作-7"><a href="#基本操作-7" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p>添加数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pfadd</span> key element<span class="hljs-number">1</span>, element<span class="hljs-number">2</span>...Copy<br></code></pre></td></tr></table></figure></li><li><p>统计数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pfcount</span> key<span class="hljs-number">1</span> key<span class="hljs-number">2</span>....Copy<br></code></pre></td></tr></table></figure></li><li><p>合并数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pfmerge</span> destkey sourcekey<span class="hljs-meta"> [sourcekey...]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>HyperLogLog用于进行基数统计，<strong>不是集合，不保存数据</strong>，只记录数量而不是具体数据</li><li>核心是基数估算算法，最终数值<strong>存在一定误差</strong></li><li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li><li><strong>耗空间极小</strong>，每个hyperloglog key占用了12K的内存用于标记基数</li><li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存<strong>逐渐增大</strong></li><li>Pfmerge命令<strong>合并后占用</strong>的存储空间为<strong>12K</strong>，无论合并之前数据量多少</li></ul><h2 id="9-3-GEO"><a href="#9-3-GEO" class="headerlink" title="9.3 GEO"></a>9.3 GEO</h2><h4 id="基本操作-8"><a href="#基本操作-8" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>添加坐标点</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">geoadd key longitude latitude member <span class="hljs-comment">[longitude latitude member ...]</span> <br>georadius key longitude latitude radius m|km|ft|mi <span class="hljs-comment">[withcoord]</span> <span class="hljs-comment">[withdist]</span> <span class="hljs-comment">[withhash]</span> <span class="hljs-comment">[count count]</span>Copy<br></code></pre></td></tr></table></figure></li><li><p>获取坐标点</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">geopos <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...] <br>georadiusbymember <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> <span class="hljs-built_in">radius</span> m|km|ft|mi [withcoord] [withdist] [withhash] [count count]Copy<br></code></pre></td></tr></table></figure></li><li><p>计算坐标点距离</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">geodist <span class="hljs-built_in">key</span> member1 member2 [unit] <br>geohash <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...]<br></code></pre></td></tr></table></figure></li></ul><h1 id="十、主从复制"><a href="#十、主从复制" class="headerlink" title="十、主从复制"></a>十、主从复制</h1><h2 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h2><h3 id="多台服务器连接方案"><a href="#多台服务器连接方案" class="headerlink" title="多台服务器连接方案"></a>多台服务器连接方案</h3><ul><li>提供数据方：master<ul><li>主服务器，主节点，主库</li><li>主客户端</li></ul></li><li>接收数据的方：slave<ul><li>从服务器，从节点，从库</li><li>从客户端</li></ul></li><li>需要解决的问题<ul><li><strong>数据同步</strong></li></ul></li><li>核心工作<ul><li>master的数据<strong>复制</strong>到slave中</li></ul></li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.1.png"></p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主从复制即将master中的数据即时、有效的<strong>复制</strong>到slave中</p><p>特征：一个master可以拥有多个slave，一个slave只对应一个master</p><p>职责：</p><ul><li>master:<ul><li>写数据</li><li>执行写操作时，将出现变化的数据自动<strong>同步</strong>到slave</li><li>读数据（可忽略）</li></ul></li><li>slave:<ul><li>读数据</li><li>写数据（<strong>禁止</strong>）</li></ul></li></ul><h2 id="10-2-作用"><a href="#10-2-作用" class="headerlink" title="10.2 作用"></a>10.2 作用</h2><ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li></ul><h2 id="10-3-工作流程"><a href="#10-3-工作流程" class="headerlink" title="10.3 工作流程"></a>10.3 工作流程</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><ul><li>主从复制过程大体可以分为3个阶段<ul><li>建立连接阶段（即准备阶段）</li><li>数据同步阶段</li><li>命令传播阶段</li></ul></li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.2.png"></p><h3 id="阶段一：建立连接"><a href="#阶段一：建立连接" class="headerlink" title="阶段一：建立连接"></a>阶段一：建立连接</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号</p><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.3.png"></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li><p>方式一：客户端发送命令</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>方式二：启动服务器参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">redis-server -slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>方式三：服务器配置 （常用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>断开连接（<strong>客户端</strong>发送命令）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">slaveof</span> <span class="hljs-literal">no</span> one<br></code></pre></td></tr></table></figure><blockquote><p>注： slave断开连接后，<strong>不会删除已有数据</strong>，只是不再接受master发送的数据</p></blockquote></li></ul><p><strong>授权访问</strong></p><ul><li><p>master客户端发送命令设置密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">requirepass <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>master配置文件设置密码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">config <span class="hljs-builtin-name">set</span> requirepass &lt;password&gt; <span class="hljs-built_in"></span><br><span class="hljs-built_in">config </span><span class="hljs-builtin-name">get</span> requirepass<br></code></pre></td></tr></table></figure></li><li><p>slave客户端发送命令设置密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">auth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>slave配置文件设置密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">masterauth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>slave启动服务器设置密码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redis-<span class="hljs-keyword">server</span> –a &lt;<span class="hljs-keyword">password</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="阶段二：数据同步阶段"><a href="#阶段二：数据同步阶段" class="headerlink" title="阶段二：数据同步阶段"></a>阶段二：数据同步阶段</h3><ul><li>在slave初次连接master后，复制master中的所有数据到slave</li><li>将slave的数据库状态更新成master当前的数据库状态</li></ul><h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.4.png"></p><ul><li>全量复制<ul><li>将master执行bgsave之前，master中所有的数据同步到slave中</li></ul></li><li>部分复制（增量复制）<ul><li>将master执行bgsave操作中，新加入的数据（复制缓冲区中的数据）传给slave，slave通过bgrewriteaof指令来恢复数据</li></ul></li></ul><h4 id="master注意事项"><a href="#master注意事项" class="headerlink" title="master注意事项"></a>master注意事项</h4><ol><li>如果master数据量巨大，数据同步阶段应<strong>避开流量高峰期</strong>，<strong>避免</strong>造成master<strong>阻塞</strong>，影响业务正常执行</li><li>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入<strong>死循环</strong>状态。</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">repl</span>-backlog-size <span class="hljs-number">1</span>mb<br></code></pre></td></tr></table></figure><ol start="3"><li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区</li></ol><h4 id="slave注意事项"><a href="#slave注意事项" class="headerlink" title="slave注意事项"></a>slave注意事项</h4><ol><li>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，<strong>建议关闭</strong>此期间的对外服务</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">slave-serve-stale-data <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><ol><li>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</li><li>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</li><li>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，<strong>数据一致性变差，应谨慎选择</strong></li></ol><h3 id="阶段三：命令传播阶段"><a href="#阶段三：命令传播阶段" class="headerlink" title="阶段三：命令传播阶段"></a>阶段三：命令传播阶段</h3><ul><li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，<strong>同步</strong>的动作称为<strong>命令传播</strong></li><li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</li></ul><h4 id="命令传播阶段的部分复制"><a href="#命令传播阶段的部分复制" class="headerlink" title="命令传播阶段的部分复制"></a>命令传播阶段的部分复制</h4><ul><li><p>命令传播阶段出现了断网现象</p><ul><li>网络闪断闪连，忽略</li><li>短时间网络中断，部分复制</li><li>长时间网络中断，全量复制</li></ul></li><li><p>部分复制的<strong>三个核心要素</strong></p><ul><li>服务器的<strong>运行 id</strong>（run id）</li><li>主服务器的复制积压<strong>缓冲区</strong></li><li>主从服务器的复制<strong>偏移量</strong></li></ul></li></ul><h5 id="服务器运行ID（runid）"><a href="#服务器运行ID（runid）" class="headerlink" title="服务器运行ID（runid）"></a>服务器运行ID（runid）</h5><ul><li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</li><li>组成：运行id由40位字符组成，是一个随机的十六进制字符 例如fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</li><li>作用：运行id被用于在服务器间进行传输，识别身份<ul><li>如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</li></ul></li><li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过<strong>info Server</strong>命令，可以查看节点的runid</li></ul><h5 id="复制缓冲区"><a href="#复制缓冲区" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h5><ul><li>概念：复制缓冲区，又名复制积压缓冲区，是一个<strong>先进先出（FIFO）的队列</strong>，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</li><li>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区</li><li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</li><li>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</li></ul><h6 id="缓冲区工作原理"><a href="#缓冲区工作原理" class="headerlink" title="缓冲区工作原理"></a>缓冲区工作原理</h6><ul><li>组成<ul><li>偏移量</li><li>字节值</li></ul></li><li>工作原理<ul><li>通过offset区分不同的slave当前数据传播的差异</li><li>master记录<strong>已发送</strong>的信息对应的offset</li><li>slave记录<strong>已接收</strong>的信息对应的offset</li></ul></li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.5.png"></p><h6 id="主从服务器复制偏移量（offset）"><a href="#主从服务器复制偏移量（offset）" class="headerlink" title="主从服务器复制偏移量（offset）"></a>主从服务器复制偏移量（offset）</h6><ul><li>概念：一个数字，描述复制缓冲区中的指令字节位置</li><li>分类：<ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li></ul></li><li>数据来源： master端：发送一次记录一次 slave端：接收一次记录一次</li><li>作用：<strong>同步信息</strong>，比对master与slave的差异，当slave断线后，恢复数据使用</li></ul><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.6.png"></p><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.7.png"></p><h2 id="10-4-心跳机制"><a href="#10-4-心跳机制" class="headerlink" title="10.4 心跳机制"></a>10.4 心跳机制</h2><ul><li>进入<strong>命令传播阶段候</strong>，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</li><li>master心跳：<ul><li>指令：PING</li><li>周期：由repl-ping-slave-period决定，默认10秒</li><li>作用：判断slave是否在线</li><li>查询：INFO replication ，获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li></ul></li><li>slave心跳任务<ul><li>指令：REPLCONF ACK {offset}</li><li>周期：1秒</li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li><li>作用2：判断master是否在线</li></ul></li></ul><h3 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">2</span> <br><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><ul><li>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</li></ul></li><li><p>slave数量由slave发送<strong>REPLCONF ACK</strong>命令做确认</p></li><li><p>slave延迟由slave发送<strong>REPLCONF ACK</strong>命令做确认</p></li></ul><h1 id="十一、哨兵"><a href="#十一、哨兵" class="headerlink" title="十一、哨兵"></a>十一、哨兵</h1><h2 id="11-1-定义"><a href="#11-1-定义" class="headerlink" title="11.1 定义"></a>11.1 定义</h2><p>哨兵(sentinel) 是一个<strong>分布式系统</strong>，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过<strong>投票机制</strong>选择新的master并将所有slave连接到新的master。</p><h2 id="11-2-作用"><a href="#11-2-作用" class="headerlink" title="11.2 作用"></a>11.2 作用</h2><ul><li>监控<ul><li>不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测</li></ul></li><li>通知（提醒）<ul><li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</li></ul></li><li>自动故障转移<ul><li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li></ul></li></ul><blockquote><p>哨兵也是一台<strong>redis服务器</strong>，只是不提供数据服务 通常哨兵配置数量为<strong>单数</strong></p></blockquote><h2 id="11-3-配置哨兵"><a href="#11-3-配置哨兵" class="headerlink" title="11.3 配置哨兵"></a>11.3 配置哨兵</h2><ul><li><p>配置文件</p><ul><li>参看sentinel.conf</li></ul></li><li><p>启动哨兵</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">redis-sentinel sentinel端口号 <span class="hljs-string">.conf</span><br></code></pre></td></tr></table></figure></li><li><p>配置详解</p></li></ul><table><thead><tr><th>配置项</th><th>范例</th><th>说明</th></tr></thead><tbody><tr><td>sentinel auth-pass&lt;服务器名称&gt; <password></password></td><td>sentinel auth-pass mymaster gotcha</td><td>连接服务器口令</td></tr><tr><td>sentinel down-after-milliseconds &lt;自定义服务名称&gt;&lt;主机地址&gt;&lt;端口&gt;&lt;主从服务器总量&gt;</td><td>sentinel monitor mymaster 192.168.194.131 6381 1</td><td>设置哨兵监听的主服务器信息，最后的参数决定了最终参与选举的服务器数量（-1）</td></tr><tr><td>sentinel down-after-milliseconds&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td>sentinel down-after-milliseconds mymaster 3000</td><td>指定哨兵在监控Redis服务时，判定服务器挂掉的时间周期，默认30秒（30000），也是主从切换的启动条件之一</td></tr><tr><td>sentinel parallel-syncs&lt;服务名称&gt;&lt;服务器数（整数）&gt;</td><td>sentinel parallel-syncs mymaster 1</td><td>指定同时进行主从的slave数量，数值越大，要求网络资源越高，要求约小，同步时间约长</td></tr><tr><td>sentinel failover-timeout&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td>sentinel failover-timeout mymaster 9000</td><td>指定出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认3分钟</td></tr><tr><td>sentinel notification-script&lt;服务名称&gt;&lt;脚本路径&gt;</td><td></td><td>服务器无法正常联通时，设定的执行脚本，通常调试使用。</td></tr></tbody></table><h2 id="11-4-工作原理"><a href="#11-4-工作原理" class="headerlink" title="11.4 工作原理"></a>11.4 工作原理</h2><h3 id="监控阶段"><a href="#监控阶段" class="headerlink" title="监控阶段"></a>监控阶段</h3><ul><li>用于同步各个节点的状态信息<ul><li>获取各个sentinel的状态（是否在线）</li></ul></li><li>获取master的状态<ul><li>master属性<ul><li>runid</li><li>role：master</li><li>各个slave的详细信息</li></ul></li></ul></li><li>获取所有slave的状态（根据master中的slave信息）<ul><li>slave属性<ul><li>runid</li><li>role：slave</li><li>master_host、master_port</li><li>offset</li><li>…</li></ul></li></ul></li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/11.1.png"></p><h3 id="通知阶段"><a href="#通知阶段" class="headerlink" title="通知阶段"></a>通知阶段</h3><ul><li>各个哨兵将得到的信息相互同步（信息对称）</li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/11.2.png"></p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><h4 id="确认master下线"><a href="#确认master下线" class="headerlink" title="确认master下线"></a>确认master下线</h4><ul><li>当某个哨兵发现主服务器挂掉了，会将master中的SentinelRedistance中的master改为<strong>SRI_S_DOWN</strong>（主观下线），并通知其他哨兵，告诉他们发现master挂掉了。</li><li>其他哨兵在接收到该哨兵发送的信息后，也会尝试去连接master，如果超过半数（配置文件中设置的）确认master挂掉后，会将master中的SentinelRedistance中的master改为<strong>SRI_O_DOWN</strong>（客观下线）</li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/11.3.png"></p><h4 id="推选哨兵进行处理"><a href="#推选哨兵进行处理" class="headerlink" title="推选哨兵进行处理"></a>推选哨兵进行处理</h4><ul><li>在确认master挂掉以后，会推选出一个哨兵来进行故障转移工作（由该哨兵来指定哪个slave来做新的master）。</li><li>筛选方式是哨兵互相发送消息，并且参与投票，票多者当选。</li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/11.4.png"></p><h4 id="具体处理"><a href="#具体处理" class="headerlink" title="具体处理"></a>具体处理</h4><ul><li><p>由推选出来的哨兵对当前的slave进行筛选，筛选条件有：</p><ul><li><p>在线的</p></li><li><p>响应快的</p></li><li><p>与原master断开时间短的</p></li><li><p>优先原则</p><ul><li>优先级</li><li>offset</li><li>runid</li></ul></li></ul></li><li><p>发送指令（ sentinel ）</p><ul><li>向新的master发送<strong>slaveof no one</strong>(断开与原master的连接)</li><li>向其他slave发送slaveof 新masterIP端口（让其他slave与新的master相连）</li></ul></li><li><p>原master故障恢复后，作为slave连接</p></li></ul><h1 id="十二、集群"><a href="#十二、集群" class="headerlink" title="十二、集群"></a>十二、集群</h1><h2 id="12-1、定义"><a href="#12-1、定义" class="headerlink" title="12.1、定义"></a>12.1、定义</h2><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><ul><li>集群（Cluster）就是使用网络将若干台计算机<strong>联通</strong>起来，并提供<strong>统一的管理方式</strong>，使其对外呈现单机的服务效果</li></ul><h3 id="集群作用"><a href="#集群作用" class="headerlink" title="集群作用"></a>集群作用</h3><ul><li>分散单台服务器的访问压力，实现<strong>负载均衡</strong></li><li>分散单台服务器的存储压力，实现<strong>可扩展性</strong></li><li><strong>降低</strong>单台服务器宕机带来的<strong>业务灾难</strong></li></ul><h2 id="12-2-Redis集群结构设计"><a href="#12-2-Redis集群结构设计" class="headerlink" title="12.2 Redis集群结构设计"></a>12.2 Redis集群结构设计</h2><h3 id="数据存储设计"><a href="#数据存储设计" class="headerlink" title="数据存储设计"></a>数据存储设计</h3><ul><li>通过算法设计，计算出key应该保存的位置</li><li>将所有的存储空间计划切割成16384份（计算公式为<code>slot=CRC16(key)&amp;16383</code>），每台主机保存一部分 每份代表的是一个存储空间，不是一个key的保存空间</li><li>将key按照计算出的结果放到对应的存储空间</li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/12.1.png"></p><ul><li>增强可扩展性 ——槽<ul><li>增加一台新设备时，每个设备让出一部分槽，分给新设备，保持槽总量不变</li><li>减少一台设备时，每个设备分配到移除设备的一部分槽，保持槽总量不变</li></ul></li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/12.2.png"></p><h3 id="集群内部通讯设计"><a href="#集群内部通讯设计" class="headerlink" title="集群内部通讯设计"></a>集群内部通讯设计</h3><ul><li>各个数据库互相连通，保存各个库中槽的编号数据</li><li>一次命中，直接返回</li><li>一次未命中，告知具体的位置，key再直接去找对应的库保存数据</li></ul><p><img src="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/12.3.png"></p><h2 id="12-3-配置"><a href="#12-3-配置" class="headerlink" title="12.3 配置"></a>12.3 配置</h2><h3 id="Cluster配置"><a href="#Cluster配置" class="headerlink" title="Cluster配置"></a>Cluster配置</h3><ul><li><p>添加节点</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">cluster-enabled <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure></li><li><p>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">cluster</span>-config-<span class="hljs-keyword">file</span> &lt;filename&gt;<br></code></pre></td></tr></table></figure></li><li><p>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">cluster-<span class="hljs-keyword">node</span><span class="hljs-title">-timeout</span> <span class="hljs-tag">&lt;milliseconds&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>master连接的slave最小数量</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cluster-migration-<span class="hljs-keyword">barrier </span>&lt;<span class="hljs-built_in">count</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Cluster节点操作命令"><a href="#Cluster节点操作命令" class="headerlink" title="Cluster节点操作命令"></a>Cluster节点操作命令</h3><ul><li><p>查看集群节点信息</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cluster nodes</span><br></code></pre></td></tr></table></figure></li><li><p>进入一个从节点 redis，切换其主节点</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cluster replicate &lt;master-<span class="hljs-built_in">id</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>发现一个新节点，新增主节点</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">cluster</span> meet <span class="hljs-built_in">ip</span>:port<br></code></pre></td></tr></table></figure></li><li><p>忽略一个没有solt的节点</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cluster forget &lt;<span class="hljs-built_in">id</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>手动故障转移</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cluster failover</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="redis-trib命令"><a href="#redis-trib命令" class="headerlink" title="redis-trib命令"></a>redis-trib命令</h3><ul><li><p>添加节点</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">redis-trib.rb add-<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure></li><li><p>删除节点</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">redis-trib.rb del-<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure></li><li><p>重新分片</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">redis-trib<span class="hljs-selector-class">.rb</span> reshard<br></code></pre></td></tr></table></figure></li></ul><h1 id="十三、企业级解决方案"><a href="#十三、企业级解决方案" class="headerlink" title="十三、企业级解决方案"></a>十三、企业级解决方案</h1><h2 id="13-1-缓存预热"><a href="#13-1-缓存预热" class="headerlink" title="13.1 缓存预热"></a>13.1 缓存预热</h2><h3 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h3><p>服务器启动后迅速宕机</p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><ul><li>请求数量较高</li><li>主从之间数据吞吐量较大，数据同步操作频度较高</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>前置准备工作：<ul><li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li><li>利用LRU数据删除策略，构建数据留存队列 例如：storm与kafka配合</li></ul></li><li>准备工作：<ul><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li><li>热点数据主从同时预热</li></ul></li><li>实施：<ul><li>使用脚本程序固定触发数据预热过程</li><li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。</p><h2 id="13-2-缓存雪崩"><a href="#13-2-缓存雪崩" class="headerlink" title="13.2 缓存雪崩"></a>13.2 缓存雪崩</h2><h3 id="问题现象-1"><a href="#问题现象-1" class="headerlink" title="问题现象"></a>问题现象</h3><h4 id="数据库服务器崩溃（1）"><a href="#数据库服务器崩溃（1）" class="headerlink" title="数据库服务器崩溃（1）"></a>数据库服务器崩溃（1）</h4><ol><li>系统平稳运行过程中，忽然数据库连接量激增</li><li>应用服务器无法及时处理请求</li><li>大量408，500错误页面出现</li><li>客户反复刷新页面获取数据</li><li>数据库崩溃</li><li>应用服务器崩溃</li><li>重启应用服务器无效</li><li>Redis服务器崩溃</li><li>Redis集群崩溃</li><li>重启数据库后再次被瞬间流量放倒</li></ol><h3 id="问题排查-1"><a href="#问题排查-1" class="headerlink" title="问题排查"></a>问题排查</h3><ol><li>在一个<strong>较短</strong>的时间内，缓存中较多的key<strong>集中过期</strong></li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li><li>数据库同时接收到大量的请求无法及时处理</li><li>Redis大量请求被积压，开始出现超时现象</li><li>数据库流量激增，数据库崩溃</li><li>重启后仍然面对缓存中无数据可用</li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解</li><li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器，redis，数据库全部重启，效果不理想</li></ol><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>短时间范围内</li><li>大量key集中过期</li></ul><h3 id="解决方案（设计层面）"><a href="#解决方案（设计层面）" class="headerlink" title="解决方案（设计层面）"></a>解决方案（设计层面）</h3><ol><li>更多的页面静态化处理</li><li>构建<strong>多级缓存架构</strong> Nginx缓存+redis缓存+ehcache缓存</li><li>检测Mysql严重耗时业务进行优化 对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li><li>灾难预警机制 监控redis服务器性能指标<ul><li>CPU占用、CPU使用率</li><li>内存容量</li><li>查询平均响应时间</li><li>线程数</li></ul></li><li>限流、降级 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li></ol><h3 id="解决方案（操作层面）"><a href="#解决方案（操作层面）" class="headerlink" title="解决方案（操作层面）"></a>解决方案（操作层面）</h3><ol><li>LRU与LFU切换</li><li>数据有效期策略调整<ul><li>根据业务数据有效期进行<strong>分类错峰</strong>，A类90分钟，B类80分钟，C类70分钟</li><li>过期时间使用固定时间+随机值的形式，<strong>稀释</strong>集中到期的key的数量</li></ul></li><li><strong>超热</strong>数据使用永久key</li><li>定期维护（自动+人工） 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li><li>加锁 <strong>慎用</strong></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>缓存雪崩就是<strong>瞬间过期数据量太大</strong>，导致对数据库服务器造成压力。如能够<strong>有效避免过期时间集中</strong>，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p><h2 id="13-3-缓存击穿"><a href="#13-3-缓存击穿" class="headerlink" title="13.3 缓存击穿"></a>13.3 缓存击穿</h2><h3 id="问题现象-2"><a href="#问题现象-2" class="headerlink" title="问题现象"></a>问题现象</h3><h4 id="数据库服务器崩溃（2）"><a href="#数据库服务器崩溃（2）" class="headerlink" title="数据库服务器崩溃（2）"></a>数据库服务器崩溃（2）</h4><ol><li>系统平稳运行过程中</li><li>数据库连接量<strong>瞬间激增</strong></li><li>Redis服务器<strong>无大量key过期</strong></li><li>Redis内存平稳，无波动</li><li>Redis服务器CPU正常</li><li><strong>数据库崩溃</strong></li></ol><h3 id="问题排查-2"><a href="#问题排查-2" class="headerlink" title="问题排查"></a>问题排查</h3><ol><li>Redis中<strong>某个key过期，该key访问量巨大</strong></li><li>多个数据请求从服务器直接压到Redis后，均未命中</li><li>Redis在短时间内发起了大量对数据库中同一数据的访问</li></ol><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>单个key高热数据</li><li>key过期</li></ul><h3 id="解决方案（操作层面）-1"><a href="#解决方案（操作层面）-1" class="headerlink" title="解决方案（操作层面）"></a>解决方案（操作层面）</h3><ol><li><p>预先设定</p><p>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，<strong>加大</strong>此类信息key的<strong>过期时长</strong></p><p>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p></li><li><p>现场调整</p><ul><li>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li></ul></li><li><p>后台刷新数据</p><ul><li>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li></ul></li><li><p>二级缓存</p><ul><li>设置不同的失效时间，保障不会被同时淘汰就行</li></ul></li><li><p>加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，<strong>慎重！</strong></p></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>缓存击穿就是<strong>单个高热数据过期的瞬间</strong>，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可</p><h2 id="13-4-缓存穿透"><a href="#13-4-缓存穿透" class="headerlink" title="13.4 缓存穿透"></a>13.4 缓存穿透</h2><h3 id="问题现象-3"><a href="#问题现象-3" class="headerlink" title="问题现象"></a>问题现象</h3><h4 id="数据库服务器崩溃（3）"><a href="#数据库服务器崩溃（3）" class="headerlink" title="数据库服务器崩溃（3）"></a>数据库服务器崩溃（3）</h4><ol><li>系统平稳运行过程中</li><li>应用服务器流量随时间增量较大</li><li>Redis服务器命中率随时间逐步降低</li><li>Redis内存平稳，内存无压力</li><li>Redis服务器CPU占用激增</li><li>数据库服务器压力激增</li><li>数据库崩溃</li></ol><h3 id="问题排查-3"><a href="#问题排查-3" class="headerlink" title="问题排查"></a>问题排查</h3><ul><li>Redis中大面积出现<strong>未命中</strong></li><li>出现<strong>非正常URL</strong>访问</li></ul><h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li><li>Redis获取到null数据未进行持久化，直接返回</li><li>下次此类数据到达重复上述过程</li><li>可能出现黑客攻击服务器</li></ul><h3 id="解决方案（操作层面）-2"><a href="#解决方案（操作层面）-2" class="headerlink" title="解决方案（操作层面）"></a>解决方案（操作层面）</h3><ol><li><p>缓存null 对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</p></li><li><p>白名单策略</p><ul><li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）</li><li>使用<strong>布隆过滤器</strong></li></ul></li><li><p>实施监控</p><p>  实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比</p><ul><li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</li><li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象 根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li></ul></li><li><p>key加密</p><p>  问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验 例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</p></li></ol><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>缓存击穿<strong>访问了不存在的数据</strong>，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，应当及时报警。<br>无论是黑名单还是白名单，都是对整体系统的压力，问题解决后尽快移除。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E5%9F%BA%E7%A1%80/mysql%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E5%9F%BA%E7%A1%80/mysql%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Mysql介绍"><a href="#一、Mysql介绍" class="headerlink" title="一、Mysql介绍"></a>一、Mysql介绍</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><strong>数据库</strong></p><ul><li>存储数据的仓库</li><li>本质上是一个文件系统，还是以文件的方式存在服务器的电脑上的。</li><li>所有的关系型数据库都可以使用通用的SQL语句进行管理</li></ul><h2 id="1-2-基本操作"><a href="#1-2-基本操作" class="headerlink" title="1.2 基本操作"></a>1.2 基本操作</h2><ul><li>MySQL服务启动<ol><li>手动。</li><li>cmd–&gt; services.msc 打开服务的窗口</li><li>使用管理员打开cmd<ul><li>net start mysql : 启动mysql的服务</li><li>net stop mysql:关闭mysql服务</li></ul></li></ol></li><li>MySQL登录<ol><li>mysql -uroot -p密码</li><li>mysql -hip -uroot -p连接目标的密码</li><li>mysql –host=ip –user=root –password=连接目标的密码</li></ol></li><li>MySQL退出<ol><li>exit</li><li>quit</li></ol></li></ul><h1 id="二、SQL介绍"><a href="#二、SQL介绍" class="headerlink" title="二、SQL介绍"></a>二、SQL介绍</h1><h2 id="2-1-SQL概述"><a href="#2-1-SQL概述" class="headerlink" title="2.1 SQL概述"></a>2.1 SQL概述</h2><p><strong>Structured Query Language</strong>：结构化查询语言<br>定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。</p><h3 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h3><ul><li>SQL 语句可以单行或多行书写，以分号结尾。</li><li>可使用空格和缩进来增强语句的可读性。</li><li>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</li><li>包括3种注释<ul><li>单行注释: – 注释内容 或 # 注释内容(mysql 特有) </li><li>多行注释: /* 注释 */</li></ul></li></ul><h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><ul><li><strong>DDL</strong>(Data Definition Language)数据定义语言<br>用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等</li><li><strong>DML</strong>(Data Manipulation Language)数据操作语言<br>用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等</li><li><strong>DQL</strong>(Data Query Language)数据查询语言<br>用来查询数据库中表的记录(数据)。关键字：select, where 等</li><li><strong>DCL</strong>(Data Control Language)数据控制语言(了解)<br>用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</li></ul><h2 id="2-2-DDL"><a href="#2-2-DDL" class="headerlink" title="2.2 DDL"></a>2.2 DDL</h2><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><h4 id="C-Create-创建"><a href="#C-Create-创建" class="headerlink" title="C(Create):创建"></a>C(Create):创建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建数据库：<br>create database 数据库名称;<br>#创建数据库，判断不存在，再创建：<br>create database if not exists 数据库名称;<br>#创建数据库，并指定字符集<br>create database 数据库名称 character set 字符集名;<br></code></pre></td></tr></table></figure><h4 id="R-Retrieve-：查询"><a href="#R-Retrieve-：查询" class="headerlink" title="R(Retrieve)：查询"></a>R(Retrieve)：查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询所有数据库的名称:<br>show databases;<br>#查询某个数据库的字符集:查询某个数据库的创建语句<br>show create database 数据库名称;<br></code></pre></td></tr></table></figure><h4 id="U-Update-修改"><a href="#U-Update-修改" class="headerlink" title="U(Update):修改"></a>U(Update):修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#修改数据库的字符集<br>alter database 数据库名称 character set 字符集名称;<br></code></pre></td></tr></table></figure><h4 id="D-Delete-删除"><a href="#D-Delete-删除" class="headerlink" title="D(Delete):删除"></a>D(Delete):删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#删除数据库<br>drop database 数据库名称;<br>#判断数据库存在，存在再删除<br>drop database if exists 数据库名称;<br></code></pre></td></tr></table></figure><h4 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询当前正在使用的数据库名称<br>select database();<br>#使用数据库<br>use 数据库名称;<br></code></pre></td></tr></table></figure><hr><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><h4 id="C-Create-创建-1"><a href="#C-Create-创建-1" class="headerlink" title="C(Create):创建"></a>C(Create):创建</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名(<br>    列名1 数据类型1,<br>    列名2 数据类型2,<br>    ....<br>    列名n 数据类型n<br>);<br></code></pre></td></tr></table></figure><blockquote><p>最后一列，不需要加逗号（,）</p></blockquote><p><strong>数据类型</strong></p><ul><li><p>int：整数类型</p></li><li><p>double:小数类型</p></li><li><p>date:日期，只包含年月日，yyyy-MM-dd</p></li><li><p>datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss</p></li><li><p>timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss    </p><ul><li>如果不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</li></ul></li><li><p>varchar：字符串</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建表<br>create table student(<br>    id int,<br>    name varchar(32),<br>    age int ,<br>    score double(4,1),<br>    birthday date,<br>    insert_time timestamp<br>);<br># 复制表：<br>create table 表名 like 被复制的表名;<br></code></pre></td></tr></table></figure><h4 id="R-Retrieve-：查询-1"><a href="#R-Retrieve-：查询-1" class="headerlink" title="R(Retrieve)：查询"></a>R(Retrieve)：查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询某个数据库中所有的表名称<br>show tables;<br>#查询表结构<br>desc 表名;<br></code></pre></td></tr></table></figure><h4 id="U-Update-修改-1"><a href="#U-Update-修改-1" class="headerlink" title="U(Update):修改"></a>U(Update):修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#修改表名<br>alter table 表名 rename to 新的表名;<br>#修改表的字符集<br>alter table 表名 character set 字符集名称;<br>#添加一列<br>alter table 表名 add 列名 数据类型;<br>#修改列名称 类型<br>alter table 表名 change 列名 新列别 新数据类型;<br>alter table 表名 modify 列名 新数据类型;<br>#删除列<br>alter table 表名 drop 列名;<br></code></pre></td></tr></table></figure><h4 id="D-Delete-删除-1"><a href="#D-Delete-删除-1" class="headerlink" title="D(Delete):删除"></a>D(Delete):删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop table 表名;<br>drop table  if exists 表名 ;<br></code></pre></td></tr></table></figure><h2 id="2-3-DML"><a href="#2-3-DML" class="headerlink" title="2.3 DML"></a>2.3 DML</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>列名和值要一一对应</li><li>如果表名后，不定义列名，则默认给所有列添加值<ul><li><code>insert into 表名 values(值1,值2,...值n);</code></li></ul></li><li>除了数字类型，其他类型需要使用引号(单双都可以)引起来</li></ul><hr><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from 表名 [where 条件]<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><p> <strong>如果不加条件，则删除表中所有记录</strong></p></li><li><p>如果要删除所有记录</p><ul><li>```mysql<br> delete from 表名; – 不推荐使用。有多少条记录就会执行多少次删除操作<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- ```mysql<br>  <span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名; <span class="hljs-comment">-- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><strong>如果不加任何条件，则修改表中所有记录</strong></li></ul><h2 id="2-4-DQL"><a href="#2-4-DQL" class="headerlink" title="2.4 DQL"></a>2.4 DQL</h2><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>字段列表<br>from<br>表名列表<br>where<br>条件列表<br>    group by<br>    分组字段<br>having<br>    分组之后的条件<br>order by<br>    排序<br>limit<br>    分页限定<br></code></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><h4 id="多字段的查询"><a href="#多字段的查询" class="headerlink" title="多字段的查询"></a>多字段的查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 字段名1，字段名2... from 表名；<br></code></pre></td></tr></table></figure><h4 id="去除重复"><a href="#去除重复" class="headerlink" title="去除重复"></a>去除重复</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">distinct<br></code></pre></td></tr></table></figure><h4 id="计算列"><a href="#计算列" class="headerlink" title="计算列"></a>计算列</h4><ul><li> 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</li><li>ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null<ul><li>表达式1：哪个字段需要判断是否为null</li><li>如果该字段为null后的替换值。</li></ul></li></ul><h4 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">as #as可以省略<br></code></pre></td></tr></table></figure><hr><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ul><li>where子句后跟条件</li><li>运算符<ul><li><code>&gt;</code> <code>&lt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>=</code> <code>&lt;&gt;</code></li><li><code>BETWEEN...AND</code></li><li><code>IN( 集合) </code></li><li><code>LIKE</code>：模糊查询<ul><li>占位符:<ul><li> _:单个任意字符</li><li>%：多个任意字符</li></ul></li></ul></li><li><code>IS NULL</code></li><li><code>AND  </code>或 <code>&amp;&amp;</code></li><li><code>OR  </code>或 <code>||</code> </li><li><code>NOT</code>或 <code>!</code></li></ul></li></ul><hr><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">order by 子句<br>#order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...<br></code></pre></td></tr></table></figure><p><strong>排序方式</strong></p><ul><li>ASC：升序，默认的</li><li>DESC：降序</li></ul><blockquote><p>如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件</p></blockquote><hr><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><strong>含义</strong></p><p>将一列数据作为一个整体，进行纵向的计算</p><p><strong>常用函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#计算个数<br>count<br>#一般选择非空的列：主键<br>#count(*)<br><br>#计算最大值<br>max<br><br>#计算最小值<br>min<br><br>#计算和<br>sum<br><br>#计算平均值<br>avg<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>聚合函数的计算，注意排除null值</p><p><strong>解决方法</strong></p><ul><li>选择不包含非空的列进行计算</li><li><code>IFNULL</code>函数</li></ul><hr><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">group by 分组字段；<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>分组之后查询的字段：分组字段、聚合函数-</li><li>where 和 having 的区别<ul><li><strong>where在分组之前</strong>进行限定，如果不满足条件，则不参与分组。<strong>having在分组之后</strong>进行限定，如果不满足结果，则不会被查询出来</li><li>where后不可以跟聚合函数，having可以进行聚合函数的判断。</li></ul></li></ul><hr><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">limit 开始的索引,每页查询的条数;<br></code></pre></td></tr></table></figure><p><strong>公式</strong></p><p>开始的索引 = （当前的页码 - 1） * 每页显示的条数</p><p><strong>注意</strong></p><blockquote><p>limit 是一个MySQL”方言”</p></blockquote><hr><h2 id="2-5-DCL"><a href="#2-5-DCL" class="headerlink" title="2.5 DCL"></a>2.5 DCL</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#添加用户：<br>CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;<br><br>#删除用户：<br>DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br><br>#修改用户密码：<br>UPDATE USER SET PASSWORD = PASSWORD(&#x27;新密码&#x27;) WHERE USER = &#x27;用户名&#x27;;<br>UPDATE USER SET PASSWORD = PASSWORD(&#x27;abc&#x27;) WHERE USER = &#x27;lisi&#x27;;<br><br>SET PASSWORD FOR &#x27;用户名&#x27;@&#x27;主机名&#x27; = PASSWORD(&#x27;新密码&#x27;);<br>SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;123&#x27;);<br><br>#查询用户<br>#1. 切换到mysql数据库<br>USE myql;<br>#2. 查询user表<br>SELECT * FROM USER;<br></code></pre></td></tr></table></figure><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询权限<br>SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br>SHOW GRANTS FOR &#x27;lisi&#x27;@&#x27;%&#x27;;<br><br>#授予权限<br>grant 权限列表 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br>-- 给张三用户授予所有权限，在任意数据库任意表上<br>GRANT ALL ON *.* TO &#x27;zhangsan&#x27;@&#x27;localhost&#x27;;<br><br>#撤销权限<br>revoke 权限列表 on 数据库名.表名 from &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br>REVOKE UPDATE ON db3.`account` FROM &#x27;lisi&#x27;@&#x27;%&#x27;;<br></code></pre></td></tr></table></figure><h1 id="三、约束"><a href="#三、约束" class="headerlink" title="三、约束"></a>三、约束</h1><p><strong>作用</strong></p><p>对表中的数据进行限定，保证数据的正确性、有效性和完整性</p><h2 id="3-1-主键约束"><a href="#3-1-主键约束" class="headerlink" title="3.1 主键约束"></a>3.1 主键约束</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>主键约束（primary key），能够唯一确定表中的一条记录。我们通过给某个字段添加该约束，就可以使得该字段不重复且不为空。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#在创建表时，添加主键约束<br>create table stu(<br>    id INT primary key,-- 给id添加主键约束<br>    name VARCHAR(20)<br>);<br><br>#联合主键<br>CREATE TABLE stu (<br>id INT,<br>name VARCHAR(20),<br>    PRIMARY KEY(id, name) -- 此处字段id和name一同作为主键，联合主键要求每个字段加起来不同即可（无需每个字段都不同）<br>);<br><br>#删除主键<br>ALTER TABLE stu DROP PRIMARY KEY;<br><br>#创建完表后，添加主键<br>ALERT TABLE stu ADD PRIMARY KEY (id);<br>#或<br>ALTER TABLE stu MODIFY id INT PRIMARY KEY;<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>主键非空且唯一</li><li>主键就是表中记录的唯一标识</li></ul><hr><h2 id="3-2-自增约束"><a href="#3-2-自增约束" class="headerlink" title="3.2 自增约束"></a>3.2 自增约束</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#在创建表时，添加主键约束，并且完成主键自增长<br>create table stu(<br>    id int primary key auto_increment,-- 给id添加主键约束,自增约束<br>    name varchar(20)<br>);<br><br>#删除自动增长<br>ALTER TABLE stu MODIFY id INT;<br><br>#添加自动增长<br>ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;<br></code></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>自增约束一般<strong>与主键搭配使用</strong></p><hr><h2 id="3-3-唯一约束"><a href="#3-3-唯一约束" class="headerlink" title="3.3 唯一约束"></a>3.3 唯一约束</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>唯一约束修饰的字段不可以重复</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#在创建表时，添加主键约束，并且完成主键自增长,唯一约束<br>create table stu(<br>    id int primary key auto_increment UNIQUE,-- 给id添加主键约束,自增约束，唯一约束<br>    name varchar(20)<br>);<br><br>#或<br>CREATE TABLE stu (<br>id int primary key auto_increment，<br>name VARCHAR(20),<br>    UNIQUE(id, name)<br>);<br><br>#删除唯一约束<br>ALTER TABLE stu DROP INDEX phone_number;<br><br>#在创建表后，添加唯一约束<br>ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;<br></code></pre></td></tr></table></figure><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul><li>mysql中，唯一约束限定的列的值可以有多个null</li><li>sqlserver中，唯一约束限定的列的只能有一个null</li></ul><hr><h2 id="3-4-非空约束"><a href="#3-4-非空约束" class="headerlink" title="3.4 非空约束"></a>3.4 非空约束</h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><p>非空约束（not null）约束的字段，值不能为null</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建表时添加约束<br>CREATE TABLE stu(<br>    id INT,<br>    NAME VARCHAR(20) NOT NULL -- name为非空<br>);<br><br>#删除name的非空约束<br>ALTER TABLE stu MODIFY NAME VARCHAR(20);<br><br>#创建表完后，添加非空约束<br>ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;<br></code></pre></td></tr></table></figure><hr><h2 id="3-5-默认约束"><a href="#3-5-默认约束" class="headerlink" title="3.5 默认约束"></a>3.5 默认约束</h2><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><p>我们插入字段时没有传值，就会<strong>使用默认值</strong></p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建表时添加约束<br>CREATE TABLE stu (<br>id INT DEFAULT 10,<br>name VARCHAR(20),<br>);<br></code></pre></td></tr></table></figure><hr><h2 id="3-6-外键约束"><a href="#3-6-外键约束" class="headerlink" title="3.6 外键约束"></a>3.6 外键约束</h2><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><p>外键约束（foreign key）让表于表产生关系，从而保证数据的正确性。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#在创建表时，可以添加外键<br>create table 表名(<br>    ....<br>    外键列<br>    constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)<br>);<br><br>#删除外键<br>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;<br><br>#创建表之后，添加外键<br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);<br></code></pre></td></tr></table></figure><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ul><li>主表中没有的数据，在副表中是不可以使用的</li><li>主表中的数据被副表引用时，是不可以删除的</li></ul><hr><h2 id="3-7-级联操作"><a href="#3-7-级联操作" class="headerlink" title="3.7 级联操作"></a>3.7 级联操作</h2><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#添加级联操作<br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 <br>FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;<br><br>#分类：<br>#级联更新<br>ON UPDATE CASCADE <br>#级联删除<br>ON DELETE CASCADE <br></code></pre></td></tr></table></figure><h1 id="四、范式"><a href="#四、范式" class="headerlink" title="四、范式"></a>四、范式</h1><p><strong>概念</strong></p><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p><blockquote><p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</p></blockquote><h2 id="4-1-第一范式"><a href="#4-1-第一范式" class="headerlink" title="4.1 第一范式"></a>4.1 第一范式</h2><p>第一范式（1NF）：每一列都是<strong>不可分割</strong>的<strong>原子</strong>数据项。即，<strong>字段还可以拆分的，就不满足第一范式</strong></p><h2 id="4-2-第二范式"><a href="#4-2-第二范式" class="headerlink" title="4.2 第二范式"></a>4.2 第二范式</h2><p>第二范式（2NF）：在1NF的基础上，非码属性必须<strong>完全依赖</strong>于码（在1NF基础上消除非主属性对主码的部分函数依赖）。即，<strong>除主键外的每一列，都必须完全依赖于主键</strong>，如果出现不完全依赖，则只可能发生在<strong>联合主键</strong>的情况下</p><ul><li><strong>不满足第二范式的例子</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE order(<br>product_id INT,<br>customer_id INT,<br>product_name VARCHAR(20),<br>customer_name VARCHAR(20),<br>    PRIMARY KEY(product_id, customer_id)<br>);<br></code></pre></td></tr></table></figure><ul><li><strong>满足第二范式的例子</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE order(<br>id INT PRIMARY KEY,<br>product_id INT,<br>customer_id INT<br>);<br><br>CREATE TABLE product(<br>id INT PRIMARY KEY,<br>name VARCHAR(20)<br>);<br><br>CREATE TABLE customer(<br>id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br></code></pre></td></tr></table></figure><p><strong>几个概念</strong></p><blockquote><ol><li>函数依赖：A–&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A<br>   例如：学号–&gt;姓名。  （学号，课程名称） –&gt; 分数</li><li>完全函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。<br>   例如：（学号，课程名称） –&gt; 分数（同时用学号，课程名称才能确定分数）</li><li>部分函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。<br>   例如：（学号，课程名称） – &gt; 姓名（只用学号就确定了姓名）</li><li>传递函数依赖：A–&gt;B, B – &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A<br>   例如：学号–&gt;系名，系名–&gt;系主任</li><li>码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码<br>   例如：该表中码为：（学号，课程名称）<ul><li>主属性：码属性组中的所有属性</li><li>非主属性：除过码属性组的属性</li></ul></li></ol></blockquote><h2 id="4-3-第三范式"><a href="#4-3-第三范式" class="headerlink" title="4.3 第三范式"></a>4.3 第三范式</h2><p>第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖），即除主键外的其他列之间不能有传递依赖关系</p><ul><li><strong>不满足第三范式的例子</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE order(<br>id INT PRIMARY KEY,<br>product_id INT,<br>customer_id INT,<br>customer_phone INT<br>);<br>#此处customer_phone又依赖于customer_id，存在传递依赖关系，不满足第三范式<br></code></pre></td></tr></table></figure><ul><li><strong>满足第三范式的例子</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE order(<br>id INT PRIMARY KEY,<br>product_id INT,<br>customer_id INT<br>);<br><br>CREATE TABLE customer(<br>id INT PRIMARY KEY,<br>    name VARCHAR(20),<br>    phone INT<br>);<br></code></pre></td></tr></table></figure><hr><h1 id="五、多表查询"><a href="#五、多表查询" class="headerlink" title="五、多表查询"></a>五、多表查询</h1><h2 id="5-1-概览"><a href="#5-1-概览" class="headerlink" title="5.1 概览"></a>5.1 概览</h2><p><img src="/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E5%9F%BA%E7%A1%80/mysql%E5%9F%BA%E7%A1%80/5.1.png"></p><blockquote><p>最下面两种语句MySQL中不适用，改为分别左右查询之后进行union操作</p></blockquote><h2 id="5-2-实际操作"><a href="#5-2-实际操作" class="headerlink" title="5.2 实际操作"></a>5.2 实际操作</h2><h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t_dept` (<br>`id` INT(11) NOT NULL AUTO_INCREMENT, `deptName` VARCHAR(30) DEFAULT NULL, `address` VARCHAR(40) DEFAULT NULL, PRIMARY KEY (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br>CREATE TABLE `t_emp` (<br>`id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT NULL, `age` INT(3) DEFAULT NULL, `deptId` INT(11) DEFAULT NULL, empno INT NOT NULL, PRIMARY KEY (`id`), KEY `idx_dept_id` (`deptId`)<br>#CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;华山&#x27;,&#x27;华山&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;丐帮&#x27;,&#x27;洛阳&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;峨眉&#x27;,&#x27;峨眉山&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;武当&#x27;,&#x27;武当山&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;明教&#x27;,&#x27;光明顶&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;少林&#x27;,&#x27;少林寺&#x27;);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;风清扬&#x27;,90,1,100001);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;岳不群&#x27;,50,1,100002);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;令狐冲&#x27;,24,1,100003);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;洪七公&#x27;,70,2,100004);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;乔峰&#x27;,35,2,100005);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;灭绝师太&#x27;,70,3,100006);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;周芷若&#x27;,20,3,100007);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;张三丰&#x27;,100,4,100008);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;张无忌&#x27;,25,5,100009);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;韦小宝&#x27;,18,NULL,100010);<br></code></pre></td></tr></table></figure><h3 id="JOIN查询"><a href="#JOIN查询" class="headerlink" title="JOIN查询"></a>JOIN查询</h3><h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_dept, t_emp;<br></code></pre></td></tr></table></figure><p>t_dept共10条记录，t_emp共6条记录。两表共同查询后共60条记录</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a INNER JOIN t_dept b ON  a.deptId = b.id;<br></code></pre></td></tr></table></figure><p><img src="/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E5%9F%BA%E7%A1%80/mysql%E5%9F%BA%E7%A1%80/5.2.png"></p><blockquote><p>隐式内连接：使用where条件消除无用数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a , t_dept b WHERE  a.deptId = b.id;<br></code></pre></td></tr></table></figure></blockquote><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a LEFT JOIN t_dept b ON  a.deptId = b.id;<br></code></pre></td></tr></table></figure><p><img src="/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E5%9F%BA%E7%A1%80/mysql%E5%9F%BA%E7%A1%80/5.3.png"></p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a RIGHT JOIN t_dept b ON  a.deptId = b.id;<br></code></pre></td></tr></table></figure><p><img src="/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E5%9F%BA%E7%A1%80/mysql%E5%9F%BA%E7%A1%80/5.4.png"></p><h4 id="左外连接取左表的独有部分（即，查询没有门派的人）"><a href="#左外连接取左表的独有部分（即，查询没有门派的人）" class="headerlink" title="左外连接取左表的独有部分（即，查询没有门派的人）"></a>左外连接<strong>取左表的独有部分</strong>（即，查询没有门派的人）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a LEFT JOIN t_dept b ON  a.deptId = b.id WHERE a.deptId IS NULL;<br></code></pre></td></tr></table></figure><p><img src="/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E5%9F%BA%E7%A1%80/mysql%E5%9F%BA%E7%A1%80/5.5.png"></p><h4 id="右外连接取右表的独有部分（即，查询没有人的门派）"><a href="#右外连接取右表的独有部分（即，查询没有人的门派）" class="headerlink" title="右外连接取右表的独有部分（即，查询没有人的门派）"></a>右外连接<strong>取右表的独有部分</strong>（即，查询没有人的门派）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a RIGHT JOIN t_dept b ON a.deptId = b.id WHERE a.deptId IS NULL;<br></code></pre></td></tr></table></figure><p><img src="/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E5%9F%BA%E7%A1%80/mysql%E5%9F%BA%E7%A1%80/5.6.png"></p><blockquote><p>注意：判断字段是否为NULL时，<strong>不能使用’=’</strong></p><p>因为<code>= NULL</code>的结果不会报错，但是<strong>结果永远为false</strong>。所以必须使用<code>IS NULL</code>来进行判空</p></blockquote><h4 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h4><blockquote><p>MySQL不支持全外连接，要查询两个表的全集，需要合并两个查询结果，所以要使用 <strong>UNION</strong> 关键字</p></blockquote><p><img src="/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E5%9F%BA%E7%A1%80/mysql%E5%9F%BA%E7%A1%80/5.7.png"></p><h4 id="查询两表独有"><a href="#查询两表独有" class="headerlink" title="查询两表独有"></a>查询两表独有</h4><p><img src="/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/Mysql%E5%9F%BA%E7%A1%80/mysql%E5%9F%BA%E7%A1%80/5.8.png"></p><hr><h2 id="5-3-子查询"><a href="#5-3-子查询" class="headerlink" title="5.3 子查询"></a>5.3 子查询</h2><p><strong>概念</strong></p><p>查询中嵌套查询，称嵌套查询为子查询。</p><p><strong>子查询不同情况</strong></p><ul><li><p>子查询的结果是单行单列的</p><ul><li><p>查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询员工工资小于平均工资的人<br>SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>子查询的结果是多行单列的</p><ul><li><p>子查询可以作为条件，使用运算符in来判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询&#x27;财务部&#x27;和&#x27;市场部&#x27;所有的员工信息<br>SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#x27;财务部&#x27; OR NAME = &#x27;市场部&#x27;);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>子查询的结果是多行多列的</p><ul><li><p>子查询可以作为一张虚拟表参与查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询员工入职日期是2011-11-11日之后的员工信息和部门信息<br>SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#x27;2011-11-11&#x27;) t2 WHERE t1.id = t2.dept_id;<br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><h1 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h1><p><strong>概念</strong></p><p>事务是一个最小的不可分割的单元，事务能够保证一个业务的完整性</p><p>多条sql语句<strong>要么同时成功，要么同时失败</strong>，这时就要用到事务</p><h2 id="6-1-操作"><a href="#6-1-操作" class="headerlink" title="6.1 操作"></a>6.1 操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#开启事务<br>start transaction;<br><br>#回滚<br>rollback;<br><br>#提交<br>commit;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>MySQL数据库中事务默认自动提交， Oracle数据库默认是手动提交事务</li><li>事务提交的两种方式<ul><li>自动提交，一条DML(增删改)语句会自动提交一次事务</li><li>手动提交，需要先开启事务，再提交</li></ul></li><li>修改事务的默认提交方式<ul><li>查看事务的默认提交方式：SELECT @@autocommit; – 1 代表自动提交  0 代表手动提交</li><li>修改默认提交方式： set @@autocommit = 0;</li></ul></li></ul><h2 id="6-2-事务的特征"><a href="#6-2-事务的特征" class="headerlink" title="6.2 事务的特征"></a>6.2 事务的特征</h2><ul><li>原子性（atomicity）：事务是最小操作的单位，<strong>不可再分</strong>，同一事务中的sql语句<strong>要么同时成功，要么同时失败</strong></li><li>一致性（consistency）：事务操作前后，数据总量不变。</li><li>隔离性（isolation）：多个事务之间。相互独立。</li><li>持久性（durability）：事物<strong>一旦结束</strong>（commit），就<strong>不可返回</strong>（rollback），即持久化</li></ul><h2 id="6-2-事务的隔离级别"><a href="#6-2-事务的隔离级别" class="headerlink" title="6.2 事务的隔离级别"></a>6.2 事务的隔离级别</h2><p> <strong>概念</strong>：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题</p><h3 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h3><ul><li><p>脏读：：一个事务，读取到另一个事务中没有提交的数据</p><blockquote><p>事务A读取到了事务B没有Commit的数据，然后<strong>B回滚操作</strong>，那么<strong>A读取到的数据是脏数据</strong></p></blockquote></li><li><p>不可重复读：在同一个事务中，两次读取到的数据不一样。</p><blockquote><p>事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了<strong>更新并提交</strong>，<strong>导致事务A多次读取同一数据时，结果不一致</strong></p></blockquote></li><li><p>幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，第一个事务查询批量处理之后，查询到了另一个事务新增的数据。</p><blockquote><p>系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样</p></blockquote></li></ul><blockquote><p>注：<strong>不可重复读侧重于修改，幻读侧重于新增或删除</strong></p></blockquote><hr><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>读未提交 read uncommitted</li><li>读已提交 read committed</li><li>可以重复读 repeatable read</li><li>串行化 serializable</li></ul><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read uncommitted）</td><td>未解决</td><td>未解决</td><td>未解决</td></tr><tr><td>读已提交 （read committed）</td><td>解决</td><td>未解决</td><td>未解决</td></tr><tr><td>可以重复读 （repeatable read）</td><td>解决</td><td>解决</td><td>未解决</td></tr><tr><td>串行化 （serializable）</td><td>解决</td><td>解决</td><td>解决</td></tr></tbody></table><blockquote><p>注：</p><ul><li><p>隔离级别从小到大安全性越来越高，但是效率越来越低</p></li><li><p>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p></li></ul></blockquote><p><strong>操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#数据库查询隔离级别,版本 5.x<br>select @@tx_isolation;<br>#数据库查询隔离级别,版本 8.0<br>SELECT @@global.transaction_isolation;<br><br>#数据库设置隔离级别：<br>set global transaction isolation level  级别字符串;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2020/03/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/Git%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/03/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/Git%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-Git历史"><a href="#1-1-Git历史" class="headerlink" title="1.1 Git历史"></a>1.1 Git历史</h2><p>Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 </p><p>他们对新的系统制订了若干目标：</p><ul><li><p>速度</p></li><li><p> 简单的设计</p></li><li><p>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</p></li><li><p>完全分布式</p></li><li><p>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p></li></ul><h2 id="1-2-Git-与-SVN-区别"><a href="#1-2-Git-与-SVN-区别" class="headerlink" title="1.2 Git 与 SVN 区别"></a>1.2 Git 与 SVN 区别</h2><p><strong>SVN是集中式版本控制系统</strong>，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，所以首先要从<strong>中央服务器</strong>下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。</p><p>集中式版本控制工具缺点：</p><ul><li><p>服务器单点故障</p></li><li><p>容错性差</p></li></ul><p><strong>Git是分布式版本控制系统</strong>（Distributed Version Control System，简称 DVCS） ，分为两种类型的仓库：</p><p>本地仓库和远程仓库</p><ul><li><p>本地仓库：是在开发人员自己电脑上的Git仓库        </p></li><li><p>远程仓库：是在远程服务器上的Git仓库</p></li></ul><p><img src="/2020/03/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/Git%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/1.1.png"></p><p>Git 与 SVN 区别点：</p><ul><li><strong>Git 是分布式的，SVN 不是</strong>：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</li><li><strong>Git 把内容按元数据方式存储，而 SVN 是按文件：</strong>所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。</li><li><strong>Git 分支和 SVN 的分支不同：</strong>分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。</li><li><strong>Git 没有一个全局的版本号，而 SVN 有：</strong>目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</li><li><strong>Git 的内容完整性要优于 SVN：</strong>Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</li></ul><h2 id="1-3-基本概念"><a href="#1-3-基本概念" class="headerlink" title="1.3 基本概念"></a>1.3 基本概念</h2><ul><li><strong>工作区：</strong>就是电脑里能看到的目录，包含.git文件夹的目录，主要用于存放开发的代码。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 <strong>index文件</strong>（.git/index）中，所以我们把暂存区有时也叫作索引（index）。暂存区是一个临时保存修改文件的地方</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。版本库中存储了很多配置信息、日志信息和文件版本信息等。</li></ul><p><img src="/2020/03/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/Git%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/1.2.png"></p><ul><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</li><li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li><li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</li><li>当对工作区修改（或新增）的文件执行 <strong>git add</strong> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作（<strong>git commit</strong>）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li><li>当执行 <strong>git reset HEAD</strong> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行 <strong>git rm –cached <file></file></strong> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行 <strong>git checkout .</strong> 或者 <strong>git checkout – <file></file></strong> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li><li>当执行 <strong>git checkout HEAD .</strong> 或者 <strong>git checkout HEAD <file></file></strong> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li></ul><p><strong>Git工作目录下的文件存在两种状态：</strong></p><ul><li><p>untracked 未跟踪（未被纳入版本控制）</p></li><li><p>tracked 已跟踪（被纳入版本控制）</p><ul><li>Unmodified 未修改状态</li><li> Modified 已修改状态</li><li>Staged 已暂存状态</li></ul></li></ul><p>这些文件的状态会随着我们执行Git的命令发生变化</p><h2 id="1-4-Git工作流程"><a href="#1-4-Git工作流程" class="headerlink" title="1.4 Git工作流程"></a>1.4 Git工作流程</h2><ul><li>从远程仓库中克隆代码到本地仓库</li><li>从本地仓库中checkout代码然后进行代码修改</li><li>在提交前先将代码提交到暂存区</li><li>提交到本地仓库。本地仓库中保存修改的各个历史版本</li><li>修改完成后，需要和团队成员共享代码时，将代码push到远程仓库</li></ul><p><img src="/2020/03/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/Git%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/1.3.png"></p><p><img src="/2020/03/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/Git%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/1.4.png"></p><hr><h1 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h1><h2 id="2-1-环境配置"><a href="#2-1-环境配置" class="headerlink" title="2.1 环境配置"></a>2.1 环境配置</h2><p>当安装Git后首先要做的事情是设置用户名称和email地址。因为每次Git提交都会使用该用户信息</p><ul><li>设置用户信息 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name “Gotcha”<br><br>git config --global user.email “XXX@163.com”<br></code></pre></td></tr></table></figure><p>查看配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --list<br><br>git config user.name<br></code></pre></td></tr></table></figure><p>通过上面的命令设置的信息会保存在~/.gitconfig文件中</p><h2 id="2-2-获取Git仓库"><a href="#2-2-获取Git仓库" class="headerlink" title="2.2 获取Git仓库"></a>2.2 获取Git仓库</h2><p>获取Git仓库通常有两种方式：</p><ul><li><p>在本地初始化一个Git仓库</p></li><li><p>从远程仓库克隆</p></li></ul><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库。</td></tr></tbody></table><h3 id="2-2-1-在本地初始化一个Git仓库，git-init"><a href="#2-2-1-在本地初始化一个Git仓库，git-init" class="headerlink" title="2.2.1 在本地初始化一个Git仓库，git init"></a>2.2.1 在本地初始化一个Git仓库，git init</h3><p>执行步骤如下：</p><ol><li><p>在电脑的任意位置创建一个空目录，作为本地Git仓库</p></li><li><p>进入这个目录中，点击右键打开Git bash窗口</p></li><li><p>执行命令<code>git init</code>，该命令执行完后会在当前目录生成一个 .git 目录。</p></li></ol><p><img src="/2020/03/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/Git%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/2.1.png"></p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 <code>git add </code>命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add *.c<br>git add README<br>git commit -m &#x27;初始化项目版本&#x27;<br></code></pre></td></tr></table></figure><blockquote><p>要删除Git仓库，删除.git文件夹即可</p></blockquote><h3 id="2-2-2-从远程仓库克隆，git-clone"><a href="#2-2-2-从远程仓库克隆，git-clone" class="headerlink" title="2.2.2 从远程仓库克隆，git clone"></a>2.2.2 从远程仓库克隆，git clone</h3><p>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地，克隆仓库的命令格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone &lt;repo&gt;<br></code></pre></td></tr></table></figure><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone &lt;repo&gt; &lt;directory&gt;<br></code></pre></td></tr></table></figure><blockquote><p>repo：Git 仓库地址。</p><p>directory：本地目录。</p></blockquote><p><img src="/2020/03/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/Git%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/2.2.png"></p><h2 id="2-3-提交与修改"><a href="#2-3-提交与修改" class="headerlink" title="2.3 提交与修改"></a>2.3 提交与修改</h2><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到仓库<strong>暂存区</strong></td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本，可以指定退回某一次提交的版本。也可以将暂存区的文件取消暂存。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">删除工作区文件。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr></tbody></table><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p><strong>git add</strong> 命令可将该文件添加到暂存区。</p><p>添加一个或多个文件到暂存区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add [file1] [file2] ...<br></code></pre></td></tr></table></figure><p>添加指定目录到暂存区，包括子目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add [dir]<br></code></pre></td></tr></table></figure><p>添加当前目录下的所有文件到暂存区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br></code></pre></td></tr></table></figure><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>git status 命令用于查看在上次提交之后是否有对文件进行再次修改</p><p>通常使用 <strong>-s</strong> 参数来获得简短的输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git status -s<br></code></pre></td></tr></table></figure><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p><strong>git diff</strong> 命令比较文件的不同，即比较文件在暂存区和工作区的差异。</p><p>git diff 命令显示已写入暂存区和已经被修改但尚未写入暂存区文件对区别。</p><p>git diff 有两个主要的应用场景。</p><ul><li>尚未缓存的改动：<strong>git diff</strong></li><li>查看已缓存的改动： <strong>git diff –cached</strong></li><li>查看已缓存的与未缓存的所有改动：<strong>git diff HEAD</strong></li><li>显示摘要而非整个 diff：<strong>git diff –stat</strong></li></ul><p>显示暂存区和工作区的差异:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff [file]<br></code></pre></td></tr></table></figure><p>显示暂存区和上一次提交(commit)的差异:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff --cached [file]<br>或<br>git diff --staged [file]<br></code></pre></td></tr></table></figure><p>显示两次提交之间的差异:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff [first-branch]...[second-branch]<br></code></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p><strong>git commit</strong> 命令将暂存区内容添加到本地仓库中。</p><p>提交暂存区到本地仓库中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m [message]<br></code></pre></td></tr></table></figure><p>[message] 可以是一些备注信息。</p><p>提交暂存区的指定文件到仓库区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit [file1] [file2] ... -m [message]<br></code></pre></td></tr></table></figure><p><strong>-a</strong> 参数设置修改文件后不需要执行 git add 命令，直接来提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -a<br></code></pre></td></tr></table></figure><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><strong>git reset</strong> 命令用于回退版本，可以指定退回某一次提交的版本。</p><p>git reset 命令语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset [--soft | --mixed | --hard] [HEAD]<br></code></pre></td></tr></table></figure><p><strong>–mixed</strong> 为默认，可以不用带该参数，用于<strong>重置暂存区的文件</strong>与上一次的提交(commit)保持一致，<strong>工作区文件内容保持不变</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset  [HEAD] <br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset HEAD^            # 回退所有内容到上一个版本  <br>git reset HEAD^ hello.php  # 回退 hello.php 文件的版本到上一个版本  <br>git  reset  052e           # 回退到指定版本<br></code></pre></td></tr></table></figure><p><strong>–soft</strong> 参数用于回退到某个版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --soft HEAD<br></code></pre></td></tr></table></figure><p><strong>–hard</strong> 参数撤销工作区中所有未提交的修改内容，将<strong>暂存区与工作区都回到上一次版本</strong>，并删除之前的所有信息提交：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD</span><br></code></pre></td></tr></table></figure><blockquote><p>HEAD 表示当前版本</p><p>HEAD^ 上一个版本</p><p>HEAD^^ 上上一个版本</p><p>HEAD^^^ 上上上一个版本</p><p>以此类推…</p></blockquote><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p><strong>git rm</strong> 命令用于删除文件。</p><p>如果只是简单地从工作目录中手工删除文件，运行 <strong>git status</strong> 时就会在 <strong>Changes not staged for commit</strong> 的提示。</p><p>git rm 删除文件有以下几种形式：</p><ol><li>将文件从暂存区和工作区中删除：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rm &lt;file&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <strong>-f</strong>。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rm -f &lt;file&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <strong>–cached</strong> 选项即可：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rm --cached &lt;file&gt;<br></code></pre></td></tr></table></figure><ol start="4"><li>递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rm –r * <br></code></pre></td></tr></table></figure><h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p>**git mv **命令用于移动或重命名一个文件、目录或软连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git mv [file] [newfile]<br></code></pre></td></tr></table></figure><p>如果新但文件名已经存在，但还是要重命名它，可以使用 <strong>-f</strong> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git mv -f [file] [newfile]<br></code></pre></td></tr></table></figure><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>可以用 <strong>git tag -a 标签内容</strong> 命令给最新一次提交打上标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -a v1.0 <br></code></pre></td></tr></table></figure><blockquote><p>-a 选项意为”创建一个带注解的标签</p></blockquote><p>查看所有标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag<br></code></pre></td></tr></table></figure><p>根据标签名查询</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git show [tag]<br></code></pre></td></tr></table></figure><p>将标签推送至远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push [remote] [tag]<br></code></pre></td></tr></table></figure><p>新建一个分支，指向某个标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b [branch] [tag]<br></code></pre></td></tr></table></figure><p>删除本地标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -d[tag]<br></code></pre></td></tr></table></figure><p>删除远程标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin :refs/tags/[tag]<br></code></pre></td></tr></table></figure><h2 id="2-4-提交日志"><a href="#2-4-提交日志" class="headerlink" title="2.4 提交日志"></a>2.4 提交日志</h2><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录</td></tr><tr><td align="left"><code>git blame &lt;file&gt;</code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><p>Git 提交历史一般常用两个命令：</p><ul><li><strong>git log</strong> - 查看历史提交记录。</li><li><strong>git blame <file></file></strong> - 以列表形式查看指定文件的历史修改记录。</li></ul><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><ul><li>在使用 Git 提交了若干更新之后，或者克隆了某个项目，想回顾下提交历史，我们可以使用 <strong>git log</strong> 命令查看。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log<br></code></pre></td></tr></table></figure><ul><li>可以用 <strong>–oneline</strong> 选项来查看历史记录的简洁的版本。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git log --oneline<br></code></pre></td></tr></table></figure><ul><li>可以用 <strong>–graph</strong> 选项，开启了拓扑图，查看历史中什么时候出现了分支、合并。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --graph --oneline<br></code></pre></td></tr></table></figure><ul><li>可以用 <strong>–reverse</strong> 参数来逆向显示所有日志。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --reverse --oneline<br></code></pre></td></tr></table></figure><ul><li>可以用**–author**参数来查找指定用户的提交日志</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --author=Gotcha --oneline<br></code></pre></td></tr></table></figure><ul><li>可以用**-数字**来指定显示的日志条数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --author=Gotcha --oneline -5<br></code></pre></td></tr></table></figure><h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git blame &lt;file&gt;<br></code></pre></td></tr></table></figure><h2 id="2-5-远程操作"><a href="#2-5-远程操作" class="headerlink" title="2.5 远程操作"></a>2.5 远程操作</h2><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr></tbody></table><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p><strong>git remote</strong> 命用于在远程仓库的操作。</p><p>显示所有远程仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote -v<br></code></pre></td></tr></table></figure><p><img src="/2020/03/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/Git%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/2.3.png"></p><blockquote><p>origin 为远程地址的别名。</p></blockquote><p>显示某个远程仓库的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote show [remote]<br></code></pre></td></tr></table></figure><p>添加远程版本库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add [shortname] [url]<br></code></pre></td></tr></table></figure><blockquote><p>shortname 为本地的版本库</p></blockquote><p>删除远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote rm name  <br></code></pre></td></tr></table></figure><blockquote><p>此命令只是从本地移除远程仓库的记录，并不会真正影响到远程仓库</p></blockquote><p>修改仓库名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote rename old_name new_name  <br></code></pre></td></tr></table></figure><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p><strong>git fetch</strong> 命令用于从远程获取代码库。git fetch 是从远程仓库获取最新版本到本地仓库，不会自动merge</p><p>该命令执行完后需要执行<code> git merge</code> 远程分支到当前的分支。</p><p>从远端仓库提取数据并尝试合并到当前分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge<br></code></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><strong>git pull</strong> 命令用于从远程获取代码并合并本地的版本。</p><p><strong>git pull</strong> 其实就是 <strong>git fetch</strong> 和 <strong>git merge FETCH_HEAD</strong> 的简写。 命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ），解决此问题可以在git pull命令后加入参数–allow-unrelated-histories</p><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; –allow-unrelated-histories</p></blockquote><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><strong>git push</strong> 命用于从将本地的分支版本上传到远程并合并。</p><p>命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push &lt;远程主机名&gt; &lt;本地分支名&gt;<br></code></pre></td></tr></table></figure><p>如果本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push --force origin master<br></code></pre></td></tr></table></figure><p>删除主机但分支可以使用 –delete 参数，以下命令表示删除 origin 主机的 master 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin --delete master<br></code></pre></td></tr></table></figure><h2 id="2-6-分支管理"><a href="#2-6-分支管理" class="headerlink" title="2.6 分支管理"></a>2.6 分支管理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><p>Git 的master分支并不是一个特殊分支。 它跟其它分支没有区别。 之所以几乎每一个仓库都有 master 分支，是因为git init 命令默认创建它，并且大多数人都懒得去改动它。</p><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><ul><li>列出所有本地分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch<br></code></pre></td></tr></table></figure><ul><li>列出所有远程分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -r<br></code></pre></td></tr></table></figure><ul><li>列出所有本地分支和远程分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -a<br></code></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch 分支名称<br></code></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout 分支名称<br></code></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -d 分支名称<br></code></pre></td></tr></table></figure><p>如果要删除的分支中进行了一些开发动作，此时执行上面的删除命令并不会删除分支，如果坚持要删除此分支，可以将命令中的-d参数改为-D</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -D 分支名称<br></code></pre></td></tr></table></figure><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>可以使用以下命令将任何分支合并到当前分支中去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge<br></code></pre></td></tr></table></figure><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没办法合并它们，同时会提示<strong>文件冲突</strong>。此时需要打开冲突的文件并修复冲突内容，最后执行git add命令来标识冲突已解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add 冲突文件名<br></code></pre></td></tr></table></figure><h2 id="2-7-忽略列表"><a href="#2-7-忽略列表" class="headerlink" title="2.7 忽略列表"></a>2.7 忽略列表</h2><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 .gitignore 的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> no .a files,以.a结尾的所有文件忽略</span><br>*.a<br><span class="hljs-meta">#</span><span class="bash"> but <span class="hljs-keyword">do</span> track lib.a, even though you<span class="hljs-string">&#x27;re ignoring .a files above，lib.a需要git进行管理，!的含义是取反</span></span><br>!lib.a<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-string"> only ignore the TODO file in the current directory, not subdir/TODO，当前路径下，TODO文件忽略</span></span><br>/TODO<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-string"> ignore all files in the build/ directory，当前路径下，build目录下所有文件忽略</span></span><br>build/<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-string"> ignore doc/notes.txt, but not doc/server/arch.txt，当前路径下，doc目录下所有以.txt结尾文件忽略</span></span><br>doc/*.txt<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-string"> ignore all .pdf files in the doc/ directory，当前路径下，doc目录及其子目录下所有以.pdf结尾文件忽略,**表示包含子目录</span></span><br>doc/**/*.pdf<br></code></pre></td></tr></table></figure><hr><h1 id="三、远程仓库配置"><a href="#三、远程仓库配置" class="headerlink" title="三、远程仓库配置"></a>三、远程仓库配置</h1><h2 id="3-1-Git支持的传输协议"><a href="#3-1-Git支持的传输协议" class="headerlink" title="3.1 Git支持的传输协议"></a>3.1 Git支持的传输协议</h2><p>由于Git的远程仓库并不在本地，当在使用远程仓库的时候（例如克隆、拉取、推送）就会涉及到数据的网络传输，Git支持多种数据传输协议</p><ul><li>本地协议（Local）</li><li>HTTPS 协议</li><li>SSH（Secure Shell）协议</li><li>Git 协议</li></ul><blockquote><p>前面的操作都是基于HTTPS协议进行的</p></blockquote><h2 id="3-2-ssh协议配置"><a href="#3-2-ssh协议配置" class="headerlink" title="3.2 ssh协议配置"></a>3.2 ssh协议配置</h2><p>可以使用Git提供的命令行工具Git Bash生成公钥和私钥，具体操作过程如下：</p><ul><li>使用命令<code>ssh-keygen –t rsa</code>生成公钥和私钥，执行完成后在window本地用户.ssh目录C:\Users\用户名.ssh下面生成如下名称的公钥和私钥</li><li>复制公钥文件内容至码云服务器</li></ul><p><img src="/2020/03/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/Git%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.1.png"></p>]]></content>
    
    
    <categories>
      
      <category>版本控制</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE</title>
    <link href="/2019/10/17/Java/JavaSE/JavaSE/"/>
    <url>/2019/10/17/Java/JavaSE/JavaSE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>该笔记为，《Java核心技术卷（第十版）》阅读笔记</p></blockquote><h1 id="第1章-Java程序设计概述"><a href="#第1章-Java程序设计概述" class="headerlink" title="第1章 Java程序设计概述"></a>第1章 Java程序设计概述</h1><h2 id="1-1-Java白皮书的关键术语"><a href="#1-1-Java白皮书的关键术语" class="headerlink" title="1.1 Java白皮书的关键术语"></a>1.1 Java白皮书的关键术语</h2><ul><li><input checked disabled type="checkbox"> 简单性</li><li><input checked disabled type="checkbox"> 面向对象</li><li><input checked disabled type="checkbox"> 分布式</li><li><input checked disabled type="checkbox"> 健壮性</li><li><input checked disabled type="checkbox"> 安全性</li><li><input checked disabled type="checkbox"> 体系结构中立</li><li><input checked disabled type="checkbox"> 可移植性</li><li><input checked disabled type="checkbox"> 解释型</li><li><input checked disabled type="checkbox"> 高性能</li><li><input checked disabled type="checkbox"> 多线程</li><li><input checked disabled type="checkbox"> 动态性</li></ul><hr><p><strong>解释型语言：先翻译成中间代码，再由解释器运行。每执行一次都要翻译一次<br>编译型语言：第一次使用时需要编译，之后运行不需要编译。运行效率高</strong></p><hr><p><em>Java和JavaScript的区别，就像雷锋和雷峰塔的区别</em></p><hr><h1 id="第2章-Java程序设计环境"><a href="#第2章-Java程序设计环境" class="headerlink" title="第2章 Java程序设计环境"></a>第2章 Java程序设计环境</h1><h2 id="2-1-Java术语"><a href="#2-1-Java术语" class="headerlink" title="2.1 Java术语"></a>2.1 Java术语</h2><hr><table><thead><tr><th align="center">术语名</th><th align="center">缩写</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">Java Development Kit</td><td align="center">JDK</td><td align="center">Java开发工具</td></tr><tr><td align="center">Java RunTime Environment</td><td align="center">JRE</td><td align="center">Java运行环境</td></tr><tr><td align="center">Standard Edition</td><td align="center">SE</td><td align="center">标准版</td></tr><tr><td align="center">Enterprise Edition</td><td align="center">EE</td><td align="center">企业版</td></tr><tr><td align="center">Micro Edition</td><td align="center">ME</td><td align="center">用于小型设备版</td></tr></tbody></table><p><img src="/2019/10/17/Java/JavaSE/JavaSE/2.1.png" alt="pic"></p><hr><h2 id="2-2-命令行工具"><a href="#2-2-命令行工具" class="headerlink" title="2.2 命令行工具"></a>2.2 命令行工具</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>Welcome.<span class="hljs-keyword">java</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">java </span>Welcome<br></code></pre></td></tr></table></figure><p><strong>编译器需要完整文件名(带后缀)，而运行程序时只需要指定类名，不带扩展名</strong></p><hr><h1 id="第3章-Java的基本程序设计结构"><a href="#第3章-Java的基本程序设计结构" class="headerlink" title="第3章 Java的基本程序设计结构"></a>第3章 Java的基本程序设计结构</h1><h2 id="3-1-基本"><a href="#3-1-基本" class="headerlink" title="3.1 基本"></a>3.1 基本</h2><p>类名命名一般使用大驼峰</p><p>Java通用语法  <em><strong>object.method(parameters)</strong></em></p><p>等价于函数调用</p><hr><h2 id="3-2-注释"><a href="#3-2-注释" class="headerlink" title="3.2 注释"></a>3.2 注释</h2><ul><li><code>//</code>：注释内容从//开始到本行结尾</li><li><code>/* */</code>：用此种注释将注释内容括起来</li><li><code>/** */</code>：可以用来自动的生成文档</li></ul><hr><h2 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h2><p>Java数据类型分为两大类</p><ul><li><strong>基本数据类型</strong>：四类八种（整型、浮点型、字符型、布尔型）</li><li><strong>引用数据类型</strong>：类、数组、接口</li></ul><p>**Java中的默认类型：整数类型是int 、浮点类型是double **</p><h3 id="3-3-1-整型"><a href="#3-3-1-整型" class="headerlink" title="3.3.1 整型"></a>3.3.1 整型</h3><p><strong>在Java中，整型的范围与运行Java的机器无关</strong></p><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">存储需求</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">整型</td><td align="center">4字节</td><td align="center">-2 147 483 648 ~ 2 147 483 647（正好超过20亿）即-2的31次方 ~ 2的31次方-1</td></tr><tr><td align="center">short</td><td align="center">短整型</td><td align="center">2字节</td><td align="center">-32 768 ~ 32 767</td></tr><tr><td align="center">long</td><td align="center">长整型</td><td align="center">8字节</td><td align="center">-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807</td></tr><tr><td align="center">byte</td><td align="center">字节型</td><td align="center">1字节</td><td align="center">-128 ~ 127</td></tr></tbody></table><p>长整型数值有一个后缀L或l</p><p>十六进制数值前缀有一个<code>0x</code>或<code>0X</code></p><p>八进制数值前缀有一个<code>0</code></p><p>二进制数值前缀有一个<code>0b</code>或<code>0B</code></p><h3 id="3-3-2-浮点型"><a href="#3-3-2-浮点型" class="headerlink" title="3.3.2 浮点型"></a>3.3.2 浮点型</h3><p><strong>绝大部分程序使用double类型</strong></p><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">存储需求</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">float</td><td align="center">单精度浮点型</td><td align="center">4字节</td><td align="center">大约±3.402 823 47E + 38F（有效位数6~7位）</td></tr><tr><td align="center">double</td><td align="center">双精度浮点型</td><td align="center">8字节</td><td align="center">大约±1.797 693 134 862 315 70E + 308（有效位数15位）</td></tr></tbody></table><p>单精度浮点型数值有一个后缀<code>F</code>或<code>f</code></p><p>双精度浮点型数值有一个后缀<code>D</code>或<code>d</code>（可省略）</p><p><strong>浮点数不适用于无法接受舍入误差的金融计算中</strong></p><h3 id="3-3-3-字符型"><a href="#3-3-3-字符型" class="headerlink" title="3.3.3 字符型"></a>3.3.3 字符型</h3><p>char类型原本用于表示单个字符，但是现在有的字符需要用一个char值描述，有的字符需要用两个个char值描述</p><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">存储需求</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">字符型</td><td align="center">2字节</td><td align="center">0 ~ 65535</td></tr></tbody></table><h3 id="3-3-4-布尔型"><a href="#3-3-4-布尔型" class="headerlink" title="3.3.4 布尔型"></a>3.3.4 布尔型</h3><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">存储需求</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">布尔型</td><td align="center">1字节</td><td align="center">true,false</td></tr></tbody></table><hr><h2 id="3-4-变量"><a href="#3-4-变量" class="headerlink" title="3.4 变量"></a>3.4 变量</h2><p><em><strong>变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。</strong></em></p><p>Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。</p><p>格式:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">数据类型 变量名 = 数据值<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">数据类型 变量名<span class="hljs-comment">;</span><br><br>变量名 = 数据值<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>声明一个变量后，必须用赋值语句的变量进行显式的初始化</strong></p><hr><h2 id="3-5-常量"><a href="#3-5-常量" class="headerlink" title="3.5 常量"></a>3.5 常量</h2><p><strong>常量：是指在Java程序中固定不变的数据</strong></p><p>在Java中，利用final关键字指示常量，习惯上常量名使用全大写</p><hr><h2 id="3-6-运算符"><a href="#3-6-运算符" class="headerlink" title="3.6 运算符"></a>3.6 运算符</h2><h3 id="3-6-1-算数运算符"><a href="#3-6-1-算数运算符" class="headerlink" title="3.6.1 算数运算符"></a>3.6.1 算数运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td align="center">加法运算，字符串连接运算</td></tr><tr><td align="center"><code>-</code></td><td align="center">减法运算</td></tr><tr><td align="center"><code>*</code></td><td align="center">乘法运算</td></tr><tr><td align="center"><code>/</code></td><td align="center">除法运算</td></tr><tr><td align="center"><code>%</code></td><td align="center">取模运算（两个数字相除取余数）</td></tr><tr><td align="center"><code>++</code></td><td align="center">自增运算</td></tr><tr><td align="center"><code>--</code></td><td align="center">自减运算</td></tr></tbody></table><h3 id="3-6-2-赋值运算符"><a href="#3-6-2-赋值运算符" class="headerlink" title="3.6.2 赋值运算符"></a>3.6.2 赋值运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>=</code></td><td align="center">赋值</td></tr><tr><td align="center"><code>+=</code></td><td align="center">先加后赋值</td></tr><tr><td align="center"><code>-+</code></td><td align="center">先减后赋值</td></tr><tr><td align="center"><code>*=</code></td><td align="center">先乘后赋值</td></tr><tr><td align="center"><code>/=</code></td><td align="center">先除后赋值</td></tr><tr><td align="center"><code>%=</code></td><td align="center">先取模后赋值</td></tr></tbody></table><h3 id="3-6-3-比较运算符"><a href="#3-6-3-比较运算符" class="headerlink" title="3.6.3 比较运算符"></a>3.6.3 比较运算符</h3><p>**比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值true 或者false **</p><table><thead><tr><th align="center">运算符</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>==</code></td><td align="center">比较符号两边数据是否相等，相等结果是<code>true</code></td></tr><tr><td align="center"><code>&lt;</code></td><td align="center">比较符号左边的数据是否小于右边的数据，如果小于结果是<code>true</code></td></tr><tr><td align="center"><code>&gt;</code></td><td align="center">比较符号左边的数据是否大于右边的数据，如果大于结果是<code>true</code></td></tr><tr><td align="center"><code>&lt;=</code></td><td align="center">比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是<code>true</code></td></tr><tr><td align="center"><code>&gt;=</code></td><td align="center">比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是<code>true</code></td></tr><tr><td align="center"><code>!=</code></td><td align="center">不等于符号 ，如果符号两边的数据不相等，结果是<code>true</code></td></tr></tbody></table><h3 id="3-6-4-逻辑运算符"><a href="#3-6-4-逻辑运算符" class="headerlink" title="3.6.4 逻辑运算符"></a>3.6.4 逻辑运算符</h3><p><strong>逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值true 或者false</strong></p><table><thead><tr><th align="center">运算符</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>&amp;&amp;</code></td><td align="center">1. 两边都是<code>true</code>，结果是<code>true</code><br>2. 一边是<code>false</code>，结果是<code>false</code><br>短路特点：符号左边是false，右边不再运算</td></tr><tr><td align="center">`</td><td align="center"></td></tr><tr><td align="center"><code>！</code></td><td align="center">1. <code>! true</code> 结果是<code>false</code><br>2.<code> ! false</code>结果是<code>true</code></td></tr></tbody></table><h3 id="3-6-5-三元运算符"><a href="#3-6-5-三元运算符" class="headerlink" title="3.6.5 三元运算符"></a>3.6.5 三元运算符</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型 变量名 = 布尔类型表达式？结果<span class="hljs-number">1</span>：结果<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="3-6-6-位运算"><a href="#3-6-6-位运算" class="headerlink" title="3.6.6 位运算"></a>3.6.6 位运算</h3><p>这个下次一定</p><hr><h2 id="3-7-运算级别"><a href="#3-7-运算级别" class="headerlink" title="3.7 运算级别"></a>3.7 运算级别</h2><table><thead><tr><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center"><code>[]</code>  <code>.</code> <code>()</code>(方法调用)</td><td align="center">从左向右</td></tr><tr><td align="center"><code>!</code> <code>~</code> <code>++</code> <code>--</code> <code>+</code> <code>-</code> <code>()</code>(强制类型转换) <code>new</code></td><td align="center"><strong>从右向左</strong></td></tr><tr><td align="center"><code>*</code> <code>/</code> <code>%</code></td><td align="center">从左向右</td></tr><tr><td align="center"><code>+</code> <code>-</code></td><td align="center">从左向右</td></tr><tr><td align="center"><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></td><td align="center">从左向右</td></tr><tr><td align="center"><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> <code>instance of</code></td><td align="center">从左向右</td></tr><tr><td align="center"><code>==</code> <code>!=</code></td><td align="center">从左向右</td></tr><tr><td align="center"><code>&amp;</code></td><td align="center">从左向右</td></tr><tr><td align="center"><code>^</code></td><td align="center">从左向右</td></tr><tr><td align="center">`</td><td align="center">`</td></tr><tr><td align="center"><code>&amp;&amp;</code></td><td align="center">从左向右</td></tr><tr><td align="center">`</td><td align="center"></td></tr><tr><td align="center"><code>?:</code></td><td align="center"><strong>从右向左</strong></td></tr><tr><td align="center"><code>=</code> <code>+=</code> <code>-+</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&amp;=</code> `</td><td align="center">=<code> </code>^=<code> </code>&lt;&lt;=<code> </code>&gt;&gt;=<code> </code>&gt;&gt;&gt;=`</td></tr></tbody></table><hr><h2 id="3-8-类型转换"><a href="#3-8-类型转换" class="headerlink" title="3.8 类型转换"></a>3.8 类型转换</h2><p>Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换。</p><h3 id="3-8-1-自动转换"><a href="#3-8-1-自动转换" class="headerlink" title="3.8.1 自动转换"></a>3.8.1 自动转换</h3><p><strong>将取值范围小的类型自动提升为取值范围大的类型 。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">byte</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// byte x = b + i; // 报错</span><br><span class="hljs-comment">//int类型和byte类型运算，结果是int类型</span><br><span class="hljs-keyword">int</span> j = b + i;<br>System.out.println(j);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="转换原理图解"><a href="#转换原理图解" class="headerlink" title="转换原理图解"></a>转换原理图解</h4><p><img src="/2019/10/17/Java/JavaSE/JavaSE/3.1.png" alt="pic"></p><p>同样道理，当一个int 类型变量和一个double 变量运算时， int 类型将会自动提升为double 类型进行运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">2.5</span>;<br><span class="hljs-comment">//int类型和double类型运算，结果是double类型</span><br><span class="hljs-comment">//int类型会提升为double类型</span><br><span class="hljs-keyword">double</span> e = d+i;<br>System.out.println(e);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为int 。</strong></p><p><code>byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double</code></p><h3 id="3-8-2-强制类型转换"><a href="#3-8-2-强制类型转换" class="headerlink" title="3.8.2 强制类型转换"></a>3.8.2 强制类型转换</h3><ul><li><strong>强制类型转换</strong>：将<code>取值范围大的类型</code>强制转换成<code>取值范围小的类型</code>。</li></ul><p><strong>转换格式</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">数据类型 变量名 </span>=<span class="hljs-string"> （数据类型）被转数据值；</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//short类型变量，内存中2个字节</span><br><span class="hljs-keyword">short</span> s = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  出现编译失败</span><br><span class="hljs-comment">    s和1做运算的时候，1是int类型，s会被提升为int类型</span><br><span class="hljs-comment">  s+1后的结果是int类型，将结果在赋值会short类型时发生错误</span><br><span class="hljs-comment">  short内存2个字节，int类型4个字节</span><br><span class="hljs-comment">  必须将int强制转成short才能完成赋值</span><br><span class="hljs-comment">*/</span><br>s = s + <span class="hljs-number">1</span>；<span class="hljs-comment">//编译失败</span><br>s = (<span class="hljs-keyword">short</span>)(s+<span class="hljs-number">1</span>);<span class="hljs-comment">//编译成功</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="转换原理图解-1"><a href="#转换原理图解-1" class="headerlink" title="转换原理图解"></a>转换原理图解</h5><p><img src="/2019/10/17/Java/JavaSE/JavaSE/3.2.png" alt="pic"></p><p><em><strong>浮点转成整数，直接取消小数点，可能造成数据损失精度。</strong></em></p><hr><h2 id="3-9-String类"><a href="#3-9-String类" class="headerlink" title="3.9 String类"></a>3.9 String类</h2><h3 id="3-9-1-概述"><a href="#3-9-1-概述" class="headerlink" title="3.9.1 概述"></a>3.9.1 概述</h3><p><code>java.lang.String</code> 类代表字符串。Java程序中所有的字符串文字（例如<code>&quot;abc&quot;</code> ）都可以被看作是实现此类的实例。<br>类 <code>String</code> 中包括用于检查各个字符串的方法，比如用于<strong>比较</strong>字符串，<strong>搜索</strong>字符串，<strong>提取</strong>子字符串以及创建具有翻译为<strong>大写</strong>或<strong>小写</strong>的所有字符的字符串的副本。</p><h3 id="3-9-2-特点"><a href="#3-9-2-特点" class="headerlink" title="3.9.2 特点"></a>3.9.2 特点</h3><ol><li>字符串不变：字符串的值在创建后不能被更改。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>s1 += <span class="hljs-string">&quot;d&quot;</span>;<br>System.out.println(s1); <span class="hljs-comment">// &quot;abcd&quot;</span><br><span class="hljs-comment">// 内存中有&quot;abc&quot;，&quot;abcd&quot;两个对象，s1从指向&quot;abc&quot;，改变指向，指向了&quot;abcd&quot;。</span><br></code></pre></td></tr></table></figure><ol start="2"><li>因为String对象是不可变的，所以它们可以被共享。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-comment">// 内存中只有一个&quot;abc&quot;对象被创建，同时被s1和s2共享。</span><br></code></pre></td></tr></table></figure><ol start="3"><li><code>&quot;abc&quot;</code> 等效于 <code>char[] data=&#123; &#39;a&#39; , &#39;b&#39; , &#39;c&#39; &#125; </code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">例如：<br>String str = <span class="hljs-string">&quot;abc&quot;</span>;<br>相当于：<br><span class="hljs-keyword">char</span> data[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>String str = <span class="hljs-keyword">new</span> String(data);<br><span class="hljs-comment">// String底层是靠字符数组实现的。</span><br></code></pre></td></tr></table></figure><ol start="4"><li><p>使用equals方法检测两个字符串是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">s.equals(t)<br></code></pre></td></tr></table></figure><p><strong>一定不要使用==运算符检测两个字符串是否相等</strong>，这个运算符只能够确定两个字符串是否放置在同一个位置上，但是有可能将内容相同的多个字符串的拷贝放置在不同位置上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">例如：<br>String str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">if</span> (str == <span class="hljs-string">&quot;Hello&quot;</span>)&#123;<br>    <span class="hljs-comment">//可能是正确</span><br>&#125;<br><span class="hljs-keyword">if</span> (str.substring(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) == <span class="hljs-string">&quot;Hel&quot;</span>)&#123;<br>    <span class="hljs-comment">//可能是错误</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>程序内直接写上双引号的字符串，保存在字符串常量池中</p></li></ol><h3 id="3-9-3-构造方法"><a href="#3-9-3-构造方法" class="headerlink" title="3.9.3 构造方法"></a>3.9.3 构造方法</h3><ul><li><p><code>public String()</code>：初始化新创建的 String对象，以使其表示空字符序列。</p></li><li><p><code>public String(char[] value)</code>：通过当前参数中的字符数组来构造新的String。</p></li><li><p><code>public String(byte[] bytes)</code>：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的<br>String。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无参构造</span><br>String str = <span class="hljs-keyword">new</span> String（）；<br><span class="hljs-comment">// 通过字符数组构造</span><br><span class="hljs-keyword">char</span> chars[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>String str2 = <span class="hljs-keyword">new</span> String(chars);<br><span class="hljs-comment">// 通过字节数组构造</span><br><span class="hljs-keyword">byte</span> bytes[] = &#123; <span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span> &#125;;<br>String str3 = <span class="hljs-keyword">new</span> String(bytes);<br></code></pre></td></tr></table></figure><h3 id="3-9-4-判断功能"><a href="#3-9-4-判断功能" class="headerlink" title="3.9.4 判断功能"></a>3.9.4 判断功能</h3><ul><li><p><code>public boolean equals (Object anObject)</code>：将此字符串与指定对象进行比较。</p></li><li><p><code>public boolean equalsIgnoreCase (String anotherString)</code>：将此字符串与指定对象进行比较，忽略大小<br>写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String_Demo01</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">// 创建字符串对象</span><br>String s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;hello&quot;</span>;<br>String s3 = <span class="hljs-string">&quot;HELLO&quot;</span>;<br><span class="hljs-comment">// boolean equals(Object obj):比较字符串的内容是否相同</span><br>System.out.println(s1.equals(s2)); <span class="hljs-comment">// true</span><br>System.out.println(s1.equals(s3)); <span class="hljs-comment">// false</span><br>System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span><br>System.out.println(s1.equalsIgnoreCase(s2)); <span class="hljs-comment">// true</span><br>System.out.println(s1.equalsIgnoreCase(s3)); <span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-9-5-获取功能"><a href="#3-9-5-获取功能" class="headerlink" title="3.9.5 获取功能"></a>3.9.5 获取功能</h3><ul><li><code>public int length ()</code> ：返回此字符串的长度。</li><li><code>public String concat (String str)</code> ：将指定的字符串连接到该字符串的末尾。</li><li><code>public char charAt (int index) </code>：返回指定索引处的 char值。</li><li><code>public int indexOf (String str)</code> ：返回指定子字符串第一次出现在该字符串内的索引。</li><li><code>public String substring (int beginIndex)</code> ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</li><li><code>public String substring (int beginIndex, int endIndex)</code> ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String_Demo02</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建字符串对象</span><br>String s = <span class="hljs-string">&quot;helloworld&quot;</span>;<br><span class="hljs-comment">// int length():获取字符串的长度，其实也就是字符个数</span><br>System.out.println(s.length());<br>System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">// String concat (String str):将将指定的字符串连接到该字符串的末尾.</span><br>String s = <span class="hljs-string">&quot;helloworld&quot;</span>;<br>String s2 = s.concat(<span class="hljs-string">&quot;**hello itheima&quot;</span>);<br>System.out.println(s2);<span class="hljs-comment">// helloworld**hello itheima</span><br><span class="hljs-comment">// char charAt(int index):获取指定索引处的字符</span><br>System.out.println(s.charAt(<span class="hljs-number">0</span>));<br>System.out.println(s.charAt(<span class="hljs-number">1</span>));<br>System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1</span><br>System.out.println(s.indexOf(<span class="hljs-string">&quot;l&quot;</span>));<br>System.out.println(s.indexOf(<span class="hljs-string">&quot;owo&quot;</span>));<br>System.out.println(s.indexOf(<span class="hljs-string">&quot;ak&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">// String substring(int start):从start开始截取字符串到字符串结尾</span><br>System.out.println(s.substring(<span class="hljs-number">0</span>));<br>System.out.println(s.substring(<span class="hljs-number">5</span>));<br>System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">// String substring(int start,int end):从start到end截取字符串。含start，不含end。</span><br>System.out.println(s.substring(<span class="hljs-number">0</span>, s.length()));<br>System.out.println(s.substring(<span class="hljs-number">3</span>,<span class="hljs-number">8</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-9-6-转换功能"><a href="#3-9-6-转换功能" class="headerlink" title="3.9.6 转换功能"></a>3.9.6 转换功能</h3><ul><li><code>public char[] toCharArray ()</code> ：将此字符串转换为新的字符数组。</li><li><code>public byte[] getBytes ()</code> ：使用平台的默认字符集将该 String编码转换为新的字节数组。</li><li><code>public String replace (CharSequence target, CharSequence replacement)</code> ：将与target匹配的字符串使用replacement字符串替换。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String_Demo03</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建字符串对象</span><br>String s = <span class="hljs-string">&quot;abcde&quot;</span>;<br><span class="hljs-comment">// char[] toCharArray():把字符串转换为字符数组</span><br><span class="hljs-keyword">char</span>[] chs = s.toCharArray();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; chs.length; x++) &#123;<br>System.out.println(chs[x]);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">// byte[] getBytes ():把字符串转换为字节数组</span><br><span class="hljs-keyword">byte</span>[] bytes = s.getBytes();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; bytes.length; x++) &#123;<br>System.out.println(bytes[x]);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br><span class="hljs-comment">// 替换字母it为大写IT</span><br>        String str = <span class="hljs-string">&quot;itcast itheima&quot;</span>;<br>String replace = str.replace(<span class="hljs-string">&quot;it&quot;</span>, <span class="hljs-string">&quot;IT&quot;</span>);<br>System.out.println(replace); <span class="hljs-comment">// ITcast ITheima</span><br>System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>CharSequence</code> 是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中。</p></blockquote><h3 id="3-9-7-分割功能"><a href="#3-9-7-分割功能" class="headerlink" title="3.9.7 分割功能"></a>3.9.7 分割功能</h3><ul><li><code>public String[] split(String regex)</code>：将此字符串按照给定的regex（规则）拆分为字符串数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String_Demo03</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建字符串对象</span><br>String s = <span class="hljs-string">&quot;aa|bb|cc&quot;</span>;<br>String[] strArray = s.split(<span class="hljs-string">&quot;|&quot;</span>); <span class="hljs-comment">// [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; strArray.length; x++) &#123;<br>System.out.println(strArray[x]); <span class="hljs-comment">// aa bb cc</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-10-Scanner类"><a href="#3-10-Scanner类" class="headerlink" title="3.10 Scanner类"></a>3.10 Scanner类</h2><h3 id="3-10-1-概述"><a href="#3-10-1-概述" class="headerlink" title="3.10.1 概述"></a>3.10.1 概述</h3><p>一个可以解析基本类型和字符串的简单文本扫描器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br><span class="hljs-keyword">int</span> i = sc.nextInt();<br></code></pre></td></tr></table></figure><blockquote><p>备注：System.in 系统输入指的是通过键盘录入数据</p></blockquote><h3 id="3-10-2-构造方法"><a href="#3-10-2-构造方法" class="headerlink" title="3.10.2 构造方法"></a>3.10.2 构造方法</h3><ul><li><code>public Scanner(InputStream source)</code> : 构造一个新的<code> Scanner</code> ，它生成的值是从指定的输入流扫描的。</li></ul><h3 id="3-10-3-成员方法"><a href="#3-10-3-成员方法" class="headerlink" title="3.10.3 成员方法"></a>3.10.3 成员方法</h3><ul><li><p><code>public String nextLine()</code>：读取下一行内容。</p></li><li><p><code>public String next()</code>：读取下一个单词（以空格为分隔符）。</p></li><li><p><code>public int nextInt()</code>：</p></li><li><p><code>public double nextDouble()</code>：</p><p>读取并转换下一个表示整数或浮点数的字符序列</p></li><li><p><code>public boolean hasNext()</code>：检测输入中是否还有其他单词。</p></li><li><p><code>public boolean hasNextInt()</code>：</p></li><li><p><code>public boolean hasNextDouble()</code>：</p><p> 检测输入中是否还有表示整数或浮点数的下一个字符序列。</p></li></ul><hr><h2 id="3-11-Printf格式化输出"><a href="#3-11-Printf格式化输出" class="headerlink" title="3.11 Printf格式化输出"></a>3.11 Printf格式化输出</h2><hr><h2 id="3-12-控制流程"><a href="#3-12-控制流程" class="headerlink" title="3.12 控制流程"></a>3.12 控制流程</h2><h3 id="3-12-1-块"><a href="#3-12-1-块" class="headerlink" title="3.12.1 块"></a>3.12.1 块</h3><p>块（即复合语句）是指由一对大括号括起来的若干条简单的Java语句。</p><p>块确定了变量的作用域。</p><p>一个块可以嵌套在另一个块中。</p><p><strong>不能在嵌套的两个块中声明同名的变量</strong></p><h3 id="3-12-2-条件语句"><a href="#3-12-2-条件语句" class="headerlink" title="3.12.2 条件语句"></a>3.12.2 条件语句</h3><p><strong>基本格式</strong></p><p><code>if (condition) statement</code></p><ul><li>if语句第一种格式： <code>if</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(关系表达式)｛<br>语句体;<br>｝<br></code></pre></td></tr></table></figure><ul><li>if语句第二种格式： <code>if...else</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(关系表达式) &#123;<br>语句体<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>语句体<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>if语句第三种格式： <code>if...else if ...else</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (判断条件<span class="hljs-number">1</span>) &#123;<br>执行语句<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (判断条件<span class="hljs-number">2</span>) &#123;<br>执行语句<span class="hljs-number">2</span>;<br>&#125;<br>...<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (判断条件n) &#123;<br>执行语句n;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>执行语句n+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在某些简单的应用中，if语句是可以和三元运算符互换使用的。</p><p><strong>else子句与最邻近的if构成一组</strong></p><h3 id="3-12-3-循环语句"><a href="#3-12-3-循环语句" class="headerlink" title="3.12.3 循环语句"></a>3.12.3 循环语句</h3><p><strong>概述</strong></p><p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环</p><h4 id="循环语句1–for"><a href="#循环语句1–for" class="headerlink" title="循环语句1–for"></a>循环语句1–for</h4><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化表达式①; 布尔表达式②; 步进表达式④)&#123;<br>循环体③<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。<ul><li>①负责完成循环变量初始化</li><li>②负责判断是否满足循环条件，不满足则跳出循环</li><li>③具体执行的语句</li><li>④循环后，循环条件所涉及变量的变化情况</li></ul></li></ul><h4 id="循环语句2–while"><a href="#循环语句2–while" class="headerlink" title="循环语句2–while"></a>循环语句2–while</h4><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化表达式①<br><span class="hljs-keyword">while</span>(布尔表达式②)&#123;<br>循环体③<br>步进表达式④<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。<ul><li>①负责完成循环变量初始化</li><li>②负责判断是否满足循环条件，不满足则跳出循环</li><li>③具体执行的语句</li><li>④循环后，循环变量的变化情况</li></ul></li></ul><h4 id="循环语句3–do…while"><a href="#循环语句3–do…while" class="headerlink" title="循环语句3–do…while"></a>循环语句3–do…while</h4><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化表达式①<br><span class="hljs-keyword">do</span>&#123;<br>循环体③<br>步进表达式④<br>&#125;<span class="hljs-keyword">while</span>(布尔表达式②);<br></code></pre></td></tr></table></figure><p>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。</p><ul><li>①负责完成循环变量初始化</li><li>②负责判断是否满足循环条件，不满足则跳出循环</li><li>③具体执行的语句</li><li>④循环后，循环变量的变化情况</li></ul><h5 id="for-和-while-的小区别"><a href="#for-和-while-的小区别" class="headerlink" title="for 和 while 的小区别"></a>for 和 while 的小区别</h5><ol><li>控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失（除非在循环前先定义），能够提高内存的使用效率。</li><li>在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。</li></ol><h3 id="3-12-4-选择语句"><a href="#3-12-4-选择语句" class="headerlink" title="3.12.4 选择语句"></a>3.12.4 选择语句</h3><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(表达式) &#123;<br><span class="hljs-keyword">case</span> 常量值<span class="hljs-number">1</span>:<br>语句体<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 常量值<span class="hljs-number">2</span>:<br>语句体<span class="hljs-number">2</span>;<br><span class="hljs-keyword">break</span>;<br>...<br><span class="hljs-keyword">default</span>:<br>语句体n+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>执行流程<ul><li>首先计算出表达式的值</li><li>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结<br>束。</li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。</li></ul></li></ul><p><strong>switch语句中，表达式的数据类型，可以是byte，short，int，char，enum（枚举），JDK7后可以接收字符串。</strong></p><p><em><strong>case具有穿透性</strong></em>：在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运<br>行，直到遇到break，或者整体switch结束。</p><h3 id="3-12-5-中断语句"><a href="#3-12-5-中断语句" class="headerlink" title="3.12.5 中断语句"></a>3.12.5 中断语句</h3><h4 id="循环语句1–break"><a href="#循环语句1–break" class="headerlink" title="循环语句1–break"></a>循环语句1–break</h4><ul><li><strong>使用场景：终止switch或者循环</strong><ul><li>在选择结构switch语句中</li><li>在循环语句中</li><li>离开使用场景的存在是没有意义的</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-comment">//需求:打印完两次HelloWorld之后结束循环</span><br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>+i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="循环语句2–continue"><a href="#循环语句2–continue" class="headerlink" title="循环语句2–continue"></a>循环语句2–continue</h4><ul><li><strong>使用场景：结束本次循环，继续下一次的循环</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-comment">//需求:不打印第三次HelloWorld</span><br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>+i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-13-数组"><a href="#3-13-数组" class="headerlink" title="3.13 数组"></a>3.13 数组</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>数组是一种数据结构，用来存储同一类型值的集合。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>数组有定长特性，长度一旦指定，不可更改。</strong></p><p><strong>数组作为方法参数传递，传递的参数是数组内存的地址。</strong></p><p><strong>数组作为方法的返回值，返回的是数组的内存地址</strong></p><p>数字数组初始化时所有元素为0</p><p>布尔数组初始化时所有元素为false</p><p>对象数组初始化时所有元素为null</p><h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">数组存储的数据类型[] 数组名字 = <span class="hljs-keyword">new</span> 数组存储的数据类型[长度];<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名 = <span class="hljs-keyword">new</span> 数据类型[]&#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素<span class="hljs-number">3.</span>..&#125;;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure><h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名 = &#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素<span class="hljs-number">3.</span>..&#125;;<br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从<code>0</code>开始，这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。</p><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">变量=数组名[索引];<br><span class="hljs-keyword">int</span> i = arr[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol><li><p>fori循环</p></li><li><p>foreach循环</p><p><strong>格式</strong></p><p><code>for(variable : collection) staement</code></p></li></ol><h3 id="数组原理内存图"><a href="#数组原理内存图" class="headerlink" title="数组原理内存图"></a>数组原理内存图</h3><h4 id="Java虚拟机的内存划分"><a href="#Java虚拟机的内存划分" class="headerlink" title="Java虚拟机的内存划分"></a>Java虚拟机的内存划分</h4><p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。</p><ul><li>JVM的内存划分：</li></ul><table><thead><tr><th align="center">区域名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">寄存器</td><td align="center">给CPU使用，和我们开发无关。</td></tr><tr><td align="center">本地方法栈</td><td align="center">JVM在使用操作系统功能的时候使用，和我们开发无关。</td></tr><tr><td align="center">方法区</td><td align="center">存储可以运行的class文件。</td></tr><tr><td align="center">堆内存</td><td align="center">存储对象或者数组，凡是new来创建的，都存储在堆内存。</td></tr><tr><td align="center">方法栈</td><td align="center">方法运行时使用的内存（存储局部变量），比如main方法运行，进入方法栈中执行。</td></tr></tbody></table><h4 id="数组在内存中的存储"><a href="#数组在内存中的存储" class="headerlink" title="数组在内存中的存储"></a>数组在内存中的存储</h4><h6 id="一个数组内存图"><a href="#一个数组内存图" class="headerlink" title="一个数组内存图"></a>一个数组内存图</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>System.out.println(arr);<span class="hljs-comment">//[I@5f150435</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上方法执行，输出的结果是[I@5f150435，这个是数组在内存中的地址。new出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的地址。</p><p><strong>输出arr[0]，就会输出arr保存的内存地址中数组中0索引上的元素</strong></p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/3.3.png" alt="pic"></p><h5 id="两个数组内存图"><a href="#两个数组内存图" class="headerlink" title="两个数组内存图"></a>两个数组内存图</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>System.out.println(arr);<br>System.out.println(arr2);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/10/17/Java/JavaSE/JavaSE/3.4.png" alt="pic"></p><h5 id="两个变量指向一个数组"><a href="#两个变量指向一个数组" class="headerlink" title="两个变量指向一个数组"></a>两个变量指向一个数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 定义数组，存储3个元素</span><br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-comment">//数组索引进行赋值</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span>;<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">7</span>;<br><span class="hljs-comment">//输出3个索引上的元素值</span><br>System.out.println(arr[<span class="hljs-number">0</span>]);<br>System.out.println(arr[<span class="hljs-number">1</span>]);<br>System.out.println(arr[<span class="hljs-number">2</span>]);<br><span class="hljs-comment">//定义数组变量arr2，将arr的地址赋值给arr2</span><br><span class="hljs-keyword">int</span>[] arr2 = arr;<br>arr2[<span class="hljs-number">1</span>] = <span class="hljs-number">9</span>;<br>System.out.println(arr[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/10/17/Java/JavaSE/JavaSE/3.5.png" alt="pic"></p><h5 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h5><p>如果希望将一个数组的所有值拷贝到一个新数组中去，可以使用<code>Arrays.copyOf</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] newArr = Arrays.copyOf(OldArr,newLength);<br><br><span class="hljs-keyword">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <br><span class="hljs-keyword">int</span>[] arr2 = Arrays.copyOf(arr1,<span class="hljs-number">3</span>); <span class="hljs-comment">//arr2 = &#123;1,2,3&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>总结:<br>方法的参数为基本类型时，传递的是数据值。 方法的参数为引用类型时，传递的是地址值。</p></blockquote><h3 id="数组常用API"><a href="#数组常用API" class="headerlink" title="数组常用API"></a>数组常用API</h3><p><code>java.util.Arrays</code></p><ul><li><p><code>static String toString( type[] a )</code>：返回a中元素的字符串。这些元素被放在括号内，以逗号分隔</p></li><li><p><code>static type copyOf( type[] a , int length )</code></p></li><li><p><code>static type copyofRange( type[] a , int start , int end )</code> ：</p><p>返回一个与a类型相同的数组，其长度为length或end-start</p></li><li><p><code>static void sort( type[] a )</code>：使用优化后的快速排序算法对数组排序</p></li><li><p><code>static int binarySearch( type[] a , type v )</code></p></li><li><p><code>static int binarySearch( type[] a , int start , int end , type v )</code></p><p>采用二分搜索算法查找v的值。如果查找成功，则返回相应下标值。否则返回一个负数值r，-r-1是为保持a有序v应当插入的位置</p></li><li><p><code>static void fill ( type[] a , type v )</code>：将数组所有元素数据设置为v</p></li><li><p><code>static boolean equals ( type[] a , type[] b )</code>：如果两个数组<code>大小相同</code>，并且<code>下标相同的元素都对应相等</code>，则返回ture</p></li></ul><hr><h1 id="第4章-对象与类"><a href="#第4章-对象与类" class="headerlink" title="第4章 对象与类"></a>第4章 对象与类</h1><h2 id="4-1-面向对象思想概述"><a href="#4-1-面向对象思想概述" class="headerlink" title="4.1 面向对象思想概述"></a>4.1 面向对象思想概述</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Java语言是一种<code>面向对象</code>的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。 这里的<code>对象</code>泛指现实中一切事物，每种事物都具备自己的<code>属性</code>和<code>行为</code>。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。<br>面向对象的语言中，包含了三大基本特征，即<code>封装</code>、<code>继承</code>和<code>多态</code>。</p><h2 id="4-2-类和对象"><a href="#4-2-类和对象" class="headerlink" title="4.2 类和对象"></a>4.2 类和对象</h2><ul><li><strong>类</strong>：是一组相关<strong>属性</strong>和<strong>行为</strong>的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。<ul><li><strong>属性</strong>：就是该事物的状态信息。</li><li><strong>行为</strong>：就是该事物能够做什么。</li></ul></li><li><strong>对象</strong>：是一类事物的具体体现。对象是类的一个<strong>实例</strong>，必然具备该类事物的属性和行为。</li></ul><h3 id="4-2-1-类与对象的关系"><a href="#4-2-1-类与对象的关系" class="headerlink" title="4.2.1 类与对象的关系"></a>4.2.1 类与对象的关系</h3><ul><li>类是对一类事物的描述，是<strong>抽象</strong>的。</li><li>对象是一类事物的实例，是<strong>具体</strong>的。</li><li><strong>类是对象的模板，对象是类的实体。</strong></li></ul><p>由类构造对象的过程叫做创建类的<strong>实例</strong></p><p>对象中数据称为<strong>实例域</strong></p><p>操作数据的过程称为<strong>方法</strong></p><p>对于每个特定的类实例（对象）都有一组特定的实例域值，这些值的集合就是这个对象的当前<strong>状态</strong></p><p>作为一个类的实例，每个对象的表示永远是<strong>不同</strong>的</p><h3 id="4-2-2-类的定义格式"><a href="#4-2-2-类的定义格式" class="headerlink" title="4.2.2 类的定义格式"></a>4.2.2 类的定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span> </span>&#123;<br><span class="hljs-comment">//成员变量</span><br><span class="hljs-comment">//成员方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-对象的使用格式"><a href="#4-2-3-对象的使用格式" class="headerlink" title="4.2.3 对象的使用格式"></a>4.2.3 对象的使用格式</h3><p>创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名 对象名 = <span class="hljs-keyword">new</span> 类名();<br></code></pre></td></tr></table></figure><p>使用对象访问类中的成员:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">对象名.成员变量；<br>对象名.成员方法()；<br></code></pre></td></tr></table></figure><h3 id="4-2-4-成员变量的默认值"><a href="#4-2-4-成员变量的默认值" class="headerlink" title="4.2.4 成员变量的默认值"></a>4.2.4 成员变量的默认值</h3><table><thead><tr><th align="center"></th><th align="center">数据类型</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">基本类型</td><td align="center">整数（byte，short，int，long）</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">浮点数（float，double）</td><td align="center">0.0</td></tr><tr><td align="center"></td><td align="center">字符（char）</td><td align="center">‘\u0000’</td></tr><tr><td align="center"></td><td align="center">布尔（boolean）</td><td align="center">false</td></tr><tr><td align="center">引用类型</td><td align="center">数组，类，接口</td><td align="center">null</td></tr></tbody></table><h3 id="4-2-5-类之间的关系"><a href="#4-2-5-类之间的关系" class="headerlink" title="4.2.5 类之间的关系"></a>4.2.5 类之间的关系</h3><p>在类之间，最常见的关系有：</p><ul><li><strong>依赖</strong>（”users-a”）：如果一个类的方法操纵另一个类的对象，我们就说这个类依赖于另一个类</li><li><strong>聚合</strong>（”has-a”）：聚合意味着类A的对象包含着类B的对象</li><li><strong>继承</strong>（”is-a”）：是一种用于表示特殊与一般的关系的</li></ul><h3 id="4-2-6-更改器方法"><a href="#4-2-6-更改器方法" class="headerlink" title="4.2.6 更改器方法"></a>4.2.6 更改器方法</h3><p>会修改对象状态，如：setter方法</p><h3 id="4-3-7-修改器方法"><a href="#4-3-7-修改器方法" class="headerlink" title="4.3.7 修改器方法"></a>4.3.7 修改器方法</h3><p>只访问对象而不修改对象的方法，如：getter方法</p><h2 id="4-3-对象内存图"><a href="#4-3-对象内存图" class="headerlink" title="4.3 对象内存图"></a>4.3 对象内存图</h2><h3 id="4-3-1-一个对象，调用一个方法内存图"><a href="#4-3-1-一个对象，调用一个方法内存图" class="headerlink" title="4.3.1 一个对象，调用一个方法内存图"></a>4.3.1 一个对象，调用一个方法内存图</h3><p><img src="/2019/10/17/Java/JavaSE/JavaSE/4.1.png" alt="pic"></p><blockquote><p>通过上图，我们可以理解，在栈内存中运行的方法，遵循”先进后出，后进先出”的原则。变量p指向堆内存中的空间，寻找方法信息，去执行该方法。<br>但是，这里依然有问题存在。创建多个对象时，如果每个对象内部都保存一份方法信息，这就非常浪费内存了，因为所有对象的方法信息都是一样的。那么如何解决这个问题呢？请看如下图解。</p></blockquote><h3 id="4-3-2-两个对象，调用同一方法内存图"><a href="#4-3-2-两个对象，调用同一方法内存图" class="headerlink" title="4.3.2 两个对象，调用同一方法内存图"></a>4.3.2 两个对象，调用同一方法内存图</h3><p><img src="/2019/10/17/Java/JavaSE/JavaSE/4.2.png" alt="pic"></p><blockquote><p>对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息只保存一份，节约内存空间。</p></blockquote><h3 id="4-3-3-一个引用，作为参数传递到方法中内存图"><a href="#4-3-3-一个引用，作为参数传递到方法中内存图" class="headerlink" title="4.3.3 一个引用，作为参数传递到方法中内存图"></a>4.3.3 一个引用，作为参数传递到方法中内存图</h3><p><img src="/2019/10/17/Java/JavaSE/JavaSE/4.3.png" alt="pic"></p><blockquote><p>引用类型作为参数，传递的是<strong>地址值</strong>。</p></blockquote><h2 id="4-4-封装"><a href="#4-4-封装" class="headerlink" title="4.4 封装"></a>4.4 封装</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>将<strong>属性隐藏</strong>起来，若需要访问某个属性，<strong>提供公共方法</strong>对其访问。</p><h3 id="4-4-1-封装的步骤"><a href="#4-4-1-封装的步骤" class="headerlink" title="4.4.1 封装的步骤"></a>4.4.1 封装的步骤</h3><ul><li>使用 <code>private </code>关键字来修饰成员变量。</li><li>对需要访问的成员变量，提供对应的一对 <code>getXxx </code>方法 、<code>setXxx</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String n)</span> </span>&#123;<br>name = n;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>age = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>setName方法有两个参数。第一个参数称为<strong>隐式参数</strong>，是出现在方法名前的Student类对象。第二个参数位于方法名后面括号中的数值，这是一个显式参数。</p></blockquote><h3 id="4-4-2-封装优化1——this关键字"><a href="#4-4-2-封装优化1——this关键字" class="headerlink" title="4.4.2 封装优化1——this关键字"></a>4.4.2 封装优化1——this关键字</h3><p>this代表所在类的当前对象的引用（地址值），即对象自己的引用。（即，关键字<code>this</code>表示<strong>隐式参数</strong>）</p><blockquote><p>记住 ：方法被哪个对象调用，方法中的<code>this</code>就代表那个对象。即谁在调用，this就代表谁。（<code>lambda</code>表达式中this也不例外）</p></blockquote><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">this</span>.成员变量名；<br></code></pre></td></tr></table></figure><p>对上面代码改进如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-comment">//name = name;</span><br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-comment">//age = age;</span><br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> age;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备注：方法中只有一个变量名时，默认也是使用 this 修饰，可以省略不写。</p></blockquote><h3 id="4-4-3-封装优化2——构造方法"><a href="#4-4-3-封装优化2——构造方法" class="headerlink" title="4.4.3 封装优化2——构造方法"></a>4.4.3 封装优化2——构造方法</h3><p>当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。</p><blockquote><p>备注：无论是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。</p></blockquote><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 构造方法名(参数列表)&#123;<br><span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法的写法上，方法名与它<strong>所在的类名相同</strong>。它没有返回值，所以不需要返回值类型。使用构造方法后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><span class="hljs-comment">// 无参数构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-comment">// 有参数构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>如果你不提供构造方法，系统会给出无参数构造方法。</strong></li><li><strong>如果你提供了构造方法，系统将不再提供无参数构造方法。</strong></li><li><strong>构造方法是可以重载的，既可以定义参数，也可以不定义参数。</strong></li></ul><h3 id="4-4-4-标准代码——JavaBean"><a href="#4-4-4-标准代码——JavaBean" class="headerlink" title="4.4.4 标准代码——JavaBean"></a>4.4.4 标准代码——JavaBean</h3><p><code>JavaBean</code> 是 Java语言编写类的一种标准规范。符合JavaBean 的类，要求类必须是<code>具体</code>的和<code>公共</code>的，并且具有无<br>参数的构造方法，提供用来操作成员变量的<code>set </code>和<code>get </code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span></span>&#123;<br><span class="hljs-comment">//成员变量</span><br><span class="hljs-comment">//构造方法</span><br><span class="hljs-comment">//无参构造方法【必须】</span><br><span class="hljs-comment">//有参构造方法【建议】</span><br><span class="hljs-comment">//成员方法</span><br><span class="hljs-comment">//getXxx()</span><br><span class="hljs-comment">//setXxx()</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-5-方法"><a href="#4-5-方法" class="headerlink" title="4.5 方法"></a>4.5 方法</h2><h3 id="4-5-1-概述"><a href="#4-5-1-概述" class="headerlink" title="4.5.1 概述"></a>4.5.1 概述</h3><p><strong>方法：就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。</strong></p><p>当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。</p><h3 id="4-5-2-方法的定义"><a href="#4-5-2-方法的定义" class="headerlink" title="4.5.2 方法的定义"></a>4.5.2 方法的定义</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名 （参数列表）｛<br>代码...<br><span class="hljs-keyword">return</span> ;<br>｝<br></code></pre></td></tr></table></figure><h3 id="4-5-3-方法的调用"><a href="#4-5-3-方法的调用" class="headerlink" title="4.5.3 方法的调用"></a>4.5.3 方法的调用</h3><ul><li><strong>直接调用</strong>：直接写方法名调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>print();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;方法被调用&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>赋值调用</strong>：调用方法，在方法前面定义变量，接收方法返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> sum = getSum(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<br>System.out.println(sum);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>输出语句调用</strong>：</p><ul><li>在输出语句中调用方法， <code>System.out.println(方法名()) </code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>System.out.println(getSum(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>不能用输出语句调用<code>void </code>类型的方法。因为方法执行后没有结果，也就打印不出任何内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>System.out.println(printHello());<span class="hljs-comment">// 错误，不能输出语句调用void类型方法</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-5-4-方法重载"><a href="#4-5-4-方法重载" class="headerlink" title="4.5.4 方法重载"></a>4.5.4 方法重载</h3><p><strong>方法重载</strong>：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。<br>参数列表：个数不同，数据类型不同，顺序不同。<br>重载方法调用：JVM通过方法的参数列表，调用不同的方法。</p><blockquote><p>注：要完整地描述一个方法需要指出方法名以及参数类型，这叫做方法的签名。但<strong>返回值类型不是方法签名的一部分</strong></p></blockquote><h3 id="4-5-5-方法参数"><a href="#4-5-5-方法参数" class="headerlink" title="4.5.5 方法参数"></a>4.5.5 方法参数</h3><ul><li><p>Java语言对对象采用的不是引用调用，而是<strong>按值调用</strong></p><ul><li><strong>方法得到的是所有参数值的一个拷贝</strong></li></ul></li><li><p>Java中方法参数的使用情况</p><ul><li>一个方法不能修改一个基本数据类型的参数（即布尔型或数值型）</li><li>一个方法可以改变一个对象参数的状态</li><li>一个方法不能让对象参数引用一个新的对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>    test1(i);<br>    System.out.println(i);<span class="hljs-comment">//仍然是10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    i = <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>);<br>test2(student);<br>System.out.println(student.getId());<span class="hljs-comment">//变成6</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(Student student)</span></span>&#123;<br>    student.setId(student.getId()*<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>);<br>test3(student);<br>System.out.println(student.getId());<span class="hljs-comment">//仍然是3     </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">(Student student)</span></span>&#123;<br>student = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-6-final关键字"><a href="#4-6-final关键字" class="headerlink" title="4.6 final关键字"></a>4.6 final关键字</h2><h3 id="4-6-1-概述"><a href="#4-6-1-概述" class="headerlink" title="4.6.1 概述"></a>4.6.1 概述</h3><ul><li><code>final</code>： 不可改变。可以用于修饰类、方法和变量。<ul><li>类：被修饰的类，<strong>不能被继承</strong>。</li><li>方法：被修饰的方法，<strong>不能被重写</strong>。</li><li>变量：被修饰的变量，<strong>不能被重新赋值</strong>。</li></ul></li></ul><h3 id="4-6-2-使用方式"><a href="#4-6-2-使用方式" class="headerlink" title="4.6.2 使用方式"></a>4.6.2 使用方式</h3><ul><li><p><strong>修饰类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>修饰方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">final</span> 返回值类型 方法名(参数列表)&#123;<br><span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>重写被 final 修饰的方法，编译时就会报错。</p></blockquote><ul><li><p><strong>修饰变量</strong></p><ul><li><ol><li><p>局部变量——基本类型</p><p>基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalDemo1</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 声明变量，使用final修饰</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a;<br><span class="hljs-comment">// 第一次赋值</span><br>a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 第二次赋值</span><br>a = <span class="hljs-number">20</span>; <span class="hljs-comment">// 报错,不可重新赋值</span><br><span class="hljs-comment">// 声明变量，直接赋值，使用final修饰</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 第二次赋值</span><br>b = <span class="hljs-number">20</span>; <span class="hljs-comment">// 报错,不可重新赋值</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li><p>局部变量——引用类型</p><p>引用类型的局部变量，被final修饰后，只能指向一个对象，<strong>地址不能再更改</strong>。但是不影响对象内部的成员变量值的修改，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalDemo2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建 User 对象</span><br><span class="hljs-keyword">final</span> User u = <span class="hljs-keyword">new</span> User();<br><span class="hljs-comment">// 创建 另一个 User对象</span><br>u = <span class="hljs-keyword">new</span> User(); <span class="hljs-comment">// 报错，指向了新的对象，地址值改变。</span><br><span class="hljs-comment">// 调用setName方法</span><br>u.setName(<span class="hljs-string">&quot;张三&quot;</span>); <span class="hljs-comment">// 可以修改</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="3"><li>成员变量</li></ol></li></ul></li></ul><p> 成员变量涉及到初始化的问题，初始化方式有两种，只能二选一：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//显式初始化</span><br> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><span class="hljs-keyword">final</span> String USERNAME = <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br> &#125;<br> <br><span class="hljs-comment">//构造方法初始化</span><br> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><span class="hljs-keyword">final</span> String USERNAME ;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String username, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.USERNAME = username;<br>     <span class="hljs-keyword">this</span>.age = age;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​     </p><blockquote><p>被<code>final</code>修饰的常量名称，一般都有书写规范，所有字母都大写。</p></blockquote><h2 id="4-7-static关键字"><a href="#4-7-static关键字" class="headerlink" title="4.7 static关键字"></a>4.7 static关键字</h2><h3 id="4-7-1-概述"><a href="#4-7-1-概述" class="headerlink" title="4.7.1 概述"></a>4.7.1 概述</h3><p>关于<code>static</code>关键字的使用，它可以用来修饰的<code>成员变量</code>和<code>成员方法</code>，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。</p><h3 id="4-7-2-定义和使用格式"><a href="#4-7-2-定义和使用格式" class="headerlink" title="4.7.2 定义和使用格式"></a>4.7.2 定义和使用格式</h3><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><p>当<code>static</code>修饰成员变量时，该变量称为<strong>类变量</strong>。该类的每个对象都<strong>共享</strong>同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。</p><ul><li><strong>类变量</strong>：使用<code>static</code>关键字修饰的成员变量。</li></ul><p><strong>定义格式</strong>    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> 数据类型 变量名；<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numberID； <br></code></pre></td></tr></table></figure><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>当<code>static</code>修饰成员方法时，该方法称为<strong>类方法</strong> 。静态方法在声明中有<code>static</code>，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。</p><ul><li><strong>类方法</strong>：使用<code>static</code>关键字修饰的成员方法，习惯称为<code>静态方法</code>。</li></ul><p><strong>定义格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">static</span> 返回值类型 方法名 (参数列表)&#123;<br><span class="hljs-comment">// 执行语句</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>静态方法调用的注意事项：</strong><ul><li>静态方法可以直接访问<code>类变量</code>和<code>静态方法</code>。</li><li>静态方法<code>不能直接</code>访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。</li><li>静态方法中，不能使用<code>this</code>关键字。</li></ul></li></ul><h4 id="调用格式"><a href="#调用格式" class="headerlink" title="调用格式"></a>调用格式</h4><p>被<code>static</code>修饰的成员可以并且建议通过<code>类名直接访问</code>。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 访问类变量</span><br>类名.类变量名；<br><span class="hljs-comment">// 调用静态方法</span><br>类名.静态方法名(参数)；<br></code></pre></td></tr></table></figure><blockquote><p>静态方法不能调用隐式参数（对象）</p></blockquote><h3 id="4-7-3-静态原理图解"><a href="#4-7-3-静态原理图解" class="headerlink" title="4.7.3 静态原理图解"></a>4.7.3 静态原理图解</h3><p><strong>static</strong>修饰的内容：</p><ul><li>是随着类的加载而加载的，且只加载一次。</li><li>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。</li><li>它优先于对象存在，所以，可以被所有对象共享。</li></ul><p><img src="/2019/10/17/Java/JavaSE/JavaSE/4.4.png" alt="pic"></p><h3 id="4-7-4-静态代码块"><a href="#4-7-4-静态代码块" class="headerlink" title="4.7.4 静态代码块"></a>4.7.4 静态代码块</h3><ul><li><strong>静态代码块</strong>：定义在成员位置，使用static修饰的代码块{ }。<ul><li>位置：类中方法外。</li><li>执行：随着<code>类的加载</code>而执行且执行一次，优先于main方法和构造方法的执行。</li></ul></li></ul><p><strong>定义格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span></span>&#123;<br><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-comment">// 执行语句</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：给类变量进行初始化赋值。用法演示，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> number;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; list;<br><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-comment">// 给类变量赋值</span><br>number = <span class="hljs-number">2</span>;<br>list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><span class="hljs-comment">// 添加元素到集合中</span><br>list.add(<span class="hljs-string">&quot;张三&quot;</span>);<br>list.add(<span class="hljs-string">&quot;李四&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>static </code>关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的是在<strong>不创建对象的情况下，去调用方法</strong>。</p></blockquote><h3 id="4-7-5-构造代码块"><a href="#4-7-5-构造代码块" class="headerlink" title="4.7.5 构造代码块"></a>4.7.5 构造代码块</h3><p>构造块在创建对象时会被调用，每次创建对象 时都会被调用，并且优先于类构造函数执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//第一次加载此类时执行</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化父类静态代码块&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化父类&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Father method01&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Father method02&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造块在创建对象时会被调用，每次创建对象 时都会被调用，并且优先于类构造函数执行</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类构造块&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">88</span>;<br><br>    <span class="hljs-comment">//第一次加载此类时执行</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化子类静态代码块&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化子类&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造块在创建对象时会被调用，每次创建对象 时都会被调用，并且优先于类构造函数执行</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类构造块&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Son method01&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Father father = <span class="hljs-keyword">new</span> Son();<br><br>        father.method1();<br>        father.method2();<br>        System.out.println(father.num1);<br>        System.out.println(<span class="hljs-string">&quot;=================&quot;</span>);<br>        Son son = <span class="hljs-keyword">new</span> Son();<br>        System.out.println(((Father)son).num1);<br>        System.out.println(son.num1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><ul><li>属性不存在重写，只有方法(非私有方法、非静态方法、非final方法) 才存在重写，才能发生多态</li></ul><p><img src="/2019/10/17/Java/JavaSE/JavaSE/image-20210412170347420.png" alt="image-20210412170347420"></p><p><strong>static关键字不可修饰外部类，但可修饰内部类。</strong></p><blockquote><p>如果使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此使用static修饰的内部类被称为类内部类，有的地方也称为静态内部类。</p><p>static关键字的作用是把类的成员变成类相关，而不是实例相关，即static修饰的成员属于整个类，而不属于单个对象。外部类的上一级程序单元是包，所以不可使用static修饰；而内部类的上一级程序单元是外部类，使用static修饰可以将内部类变成外部类相关，而不是外部类实例相关。因此static关键字不可修饰外部类，但可修饰内部类。</p></blockquote><p>静态内部类需满足如下规则：</p><ol><li><p>静态内部类可以包含静态成员，也可以包含非静态成员；</p></li><li><p>静态内部类不能访问外部类的实例成员，只能访问它的静态成员；</p></li><li><p>外部类的所有方法、初始化块都能访问其内部定义的静态内部类；</p></li><li><p>在外部类的外部，也可以实例化静态内部类，语法如下：</p><p><code>外部类.内部类 变量名 = new 外部类.内部类构造方法();</code></p></li></ol><h2 id="4-8-权限修饰符"><a href="#4-8-权限修饰符" class="headerlink" title="4.8 权限修饰符"></a>4.8 权限修饰符</h2><h3 id="4-8-1-概述"><a href="#4-8-1-概述" class="headerlink" title="4.8.1 概述"></a>4.8.1 概述</h3><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限。</p><ul><li>public：公共的</li><li>protected：受保护的</li><li>default：默认的</li><li>private：私有的</li></ul><h3 id="4-8-2-不同权限的访问能力"><a href="#4-8-2-不同权限的访问能力" class="headerlink" title="4.8.2 不同权限的访问能力"></a>4.8.2 不同权限的访问能力</h3><table><thead><tr><th align="center"></th><th align="center">public</th><th align="center">protected</th><th align="center">default（空的）</th><th align="center">private</th></tr></thead><tbody><tr><td align="center">同一类中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">同一包中(子类与无关类)</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="center">不同包的子类</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">不同包中的无关类</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><p>小贴士：不加权限修饰符，其访问能力与<code>default</code>修饰符相同</p></blockquote><h2 id="4-9-文档注释"><a href="#4-9-文档注释" class="headerlink" title="4.9 文档注释"></a>4.9 文档注释</h2><h3 id="4-9-1-类注释"><a href="#4-9-1-类注释" class="headerlink" title="4.9.1 类注释"></a>4.9.1 类注释</h3><blockquote><p>类注释必须放在<code>import</code>语句之后，类定义之前</p></blockquote><h3 id="4-9-2-方法注释"><a href="#4-9-2-方法注释" class="headerlink" title="4.9.2 方法注释"></a>4.9.2 方法注释</h3><ul><li><code>@param</code>：变量描述</li><li><code>@return</code>：返回描述</li><li><code>@throws</code>：异常描述</li></ul><h3 id="4-9-3-域注释"><a href="#4-9-3-域注释" class="headerlink" title="4.9.3 域注释"></a>4.9.3 域注释</h3><p>通常只对公有域（静态常量）用<code>/** */</code>进行描述</p><h3 id="4-9-4-通用注释"><a href="#4-9-4-通用注释" class="headerlink" title="4.9.4 通用注释"></a>4.9.4 通用注释</h3><ul><li><code>@author</code>：作者姓名</li><li><code>@version</code>：版本信息</li><li><code>@since</code>：始于信息</li><li><code>@deprecated</code>：弃用信息</li><li><code>@see</code>：引用信息</li></ul><h3 id="4-9-5-注释的抽取"><a href="#4-9-5-注释的抽取" class="headerlink" title="4.9.5 注释的抽取"></a>4.9.5 注释的抽取</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javadoc -d docDirectory nameOfPackage<br></code></pre></td></tr></table></figure><hr><h1 id="第5章-继承"><a href="#第5章-继承" class="headerlink" title="第5章 继承"></a>第5章 继承</h1><h2 id="5-1-继承"><a href="#5-1-继承" class="headerlink" title="5.1 继承"></a>5.1 继承</h2><h3 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h3><p>继承描述的是事物之间的所属关系，这种关系是： <code>is-a</code>的关系。</p><p>多个类中存在相同<strong>属性</strong>和<strong>行为</strong>时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可</p><h3 id="5-1-2-定义"><a href="#5-1-2-定义" class="headerlink" title="5.1.2 定义"></a>5.1.2 定义</h3><p><strong>继承</strong>：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。</p><p><strong>优点</strong></p><ul><li>提高代码的<strong>复用性</strong>。</li><li>类与类之间产生了关系，是<strong>多态的前提</strong>。</li></ul><h3 id="5-1-3-格式"><a href="#5-1-3-格式" class="headerlink" title="5.1.3 格式"></a>5.1.3 格式</h3><p>通过<code>extends</code>关键字，可以声明一个子类继承另外一个父类，定义格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 父类 </span>&#123;<br>...<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> 子类 <span class="hljs-keyword">extends</span> 父类 </span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-1-4-继承后的特点——成员变量"><a href="#5-1-4-继承后的特点——成员变量" class="headerlink" title="5.1.4 继承后的特点——成员变量"></a>5.1.4 继承后的特点——成员变量</h3><h4 id="成员变量不重名"><a href="#成员变量不重名" class="headerlink" title="成员变量不重名"></a>成员变量不重名</h4><ul><li>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<em><strong>没有影响</strong></em>的。</li></ul><h4 id="成员变量重名"><a href="#成员变量重名" class="headerlink" title="成员变量重名"></a>成员变量重名</h4><ul><li><p>如果子类父类中出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响</strong>的</p><ul><li><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code>关键字，修饰父类成员变量，类似于之前学过的 <code>this</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">super</span>.父类成员变量名<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-1-5-继承后的特点——成员方法"><a href="#5-1-5-继承后的特点——成员方法" class="headerlink" title="5.1.5 继承后的特点——成员方法"></a>5.1.5 继承后的特点——成员方法</h3><h4 id="成员方法不重名"><a href="#成员方法不重名" class="headerlink" title="成员方法不重名"></a>成员方法不重名</h4><ul><li>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响</strong>的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法</li></ul><h4 id="成员方法重名——重写-Override"><a href="#成员方法重名——重写-Override" class="headerlink" title="成员方法重名——重写(Override)"></a>成员方法重名——重写(Override)</h4><ul><li>如果子类父类中出现<strong>重名</strong>的成员方法，这是的访问是一种特殊情况，叫做<strong>方法重写</strong> (Override)。</li><li>方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Fu show&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;<br><span class="hljs-comment">//子类重写了父类的show方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Zi show&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendsDemo05</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Zi z = <span class="hljs-keyword">new</span> Zi();<br><span class="hljs-comment">// 子类中有show方法，只执行重写后的show方法</span><br>z.show(); <span class="hljs-comment">// Zi show</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过使用<code>super.父类成员方法</code>，对父类成员方法进行调用。</li></ul><blockquote><p>注意</p><p>1.子类方法覆盖父类方法，必须要保证访问权限大于等于父类权限。</p><p>2.子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</p></blockquote><h3 id="5-1-6-继承后的特点——构造方法"><a href="#5-1-6-继承后的特点——构造方法" class="headerlink" title="5.1.6 继承后的特点——构造方法"></a>5.1.6 继承后的特点——构造方法</h3><blockquote><p>1.构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</p><p>2.构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br>Fu()&#123;<br>System.out.println(<span class="hljs-string">&quot;Fu()&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;<br>Zi()&#123;<br><span class="hljs-comment">// super（），调用父类构造方法</span><br><span class="hljs-keyword">super</span>();<br>System.out.println(<span class="hljs-string">&quot;Zi（）&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendsDemo07</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String args[])</span></span>&#123;<br>Zi zi = <span class="hljs-keyword">new</span> Zi();<br>&#125;<br>&#125;<br>输出结果：<br>Fu（）<br>Zi（）<br></code></pre></td></tr></table></figure><h3 id="5-1-7-super和this"><a href="#5-1-7-super和this" class="headerlink" title="5.1.7 super和this"></a>5.1.7 super和this</h3><h4 id="父类空间优先于子类对象产生"><a href="#父类空间优先于子类对象产生" class="headerlink" title="父类空间优先于子类对象产生"></a>父类空间优先于子类对象产生</h4><p>在每次创建子类对象时，<strong>先初始化父类空间，再创建其子类对象本身</strong>。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。理解图解如下：</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/5.1.png" alt="pic"></p><h4 id="super和this的含义"><a href="#super和this的含义" class="headerlink" title="super和this的含义"></a>super和this的含义</h4><ul><li><strong>super</strong>：代表父类的存储空间标识(可以理解为父亲的引用)。</li><li><strong>this</strong>：代表当前对象的引用(谁调用就代表谁)。</li></ul><h4 id="super和this的用法"><a href="#super和this的用法" class="headerlink" title="super和this的用法"></a>super和this的用法</h4><ol><li>访问成员</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">this</span>.成员变量 ‐‐ 本类的<br><span class="hljs-keyword">super</span>.成员变量 ‐‐ 父类的<br><span class="hljs-keyword">this</span>.成员方法名() ‐‐ 本类的<br><span class="hljs-keyword">super</span>.成员方法名() ‐‐ 父类的<br></code></pre></td></tr></table></figure><ol start="2"><li>访问构造方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">this</span>(...) ‐‐ 本类的构造方法<br><span class="hljs-keyword">super</span>(...) ‐‐ 父类的构造方法<br></code></pre></td></tr></table></figure><blockquote><p>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。<br>super() 和 this() 都必须是在构造方法的<strong>第一行</strong>，所以不能同时出现。</p></blockquote><h3 id="5-1-8-继承的特点"><a href="#5-1-8-继承的特点" class="headerlink" title="5.1.8 继承的特点"></a>5.1.8 继承的特点</h3><ol><li>Java只支持单继承，不支持多继承。</li><li>Java支持多层继承(继承体系)。</li></ol><blockquote><p>顶层父类是Object类。所有的类默认继承Object，作为父类。</p></blockquote><ol start="3"><li>子类和父类是一种相对的概念。</li></ol><hr><h2 id="5-2-多态"><a href="#5-2-多态" class="headerlink" title="5.2 多态"></a>5.2 多态</h2><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h3><p><strong>多态</strong>是继<strong>封装</strong>、<strong>继承</strong>之后，面向对象的第三大特性。</p><p><code>is-a</code>规则的另一种表述法就是<strong>置换法则</strong>，表明程序中出现超类对象的任何地方都可以用子类对象置换。</p><h3 id="5-2-2-定义"><a href="#5-2-2-定义" class="headerlink" title="5.2.2 定义"></a>5.2.2 定义</h3><p><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。</p><h3 id="5-2-3-前提"><a href="#5-2-3-前提" class="headerlink" title="5.2.3 前提"></a>5.2.3 前提</h3><ol><li>继承或者实现【二选一】</li><li>方法的重写【意义体现：不重写，无意义】</li><li><strong>父类变量指向子类对象</strong>【格式体现】</li></ol><h3 id="5-2-4-体现形式"><a href="#5-2-4-体现形式" class="headerlink" title="5.2.4 体现形式"></a>5.2.4 体现形式</h3><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型 变量名 = <span class="hljs-keyword">new</span> 子类对象；<br>变量名.方法名();<br></code></pre></td></tr></table></figure><blockquote><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Fu f = <span class="hljs-keyword">new</span> Zi();<br>f.method();<br></code></pre></td></tr></table></figure><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。</p><p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。</strong></p><p>代码示例</p><p>定义父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 多态形式，创建对象</span><br>Cat c = <span class="hljs-keyword">new</span> Cat();<br>Dog d = <span class="hljs-keyword">new</span> Dog();<br><span class="hljs-comment">// 调用showCatEat</span><br>showCatEat(c);<br><span class="hljs-comment">// 调用showDogEat</span><br>    showDogEat(d);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代而执行效果一致</span><br><span class="hljs-comment">*/</span><br>showAnimalEat(c);<br>showAnimalEat(d);<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showCatEat</span> <span class="hljs-params">(Cat c)</span></span>&#123;<br>c.eat();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showDogEat</span> <span class="hljs-params">(Dog d)</span></span>&#123;<br>d.eat();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showAnimalEat</span> <span class="hljs-params">(Animal a)</span></span>&#123;<br>a.eat();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。<br>当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。<br>所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。</p><h3 id="5-2-5-引用类型转换"><a href="#5-2-5-引用类型转换" class="headerlink" title="5.2.5 引用类型转换"></a>5.2.5 引用类型转换</h3><p>多态的转型分为向上转型与向下转型两种</p><h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><p><strong>多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的</strong>。</p><p>当父类引用指向一个子类对象时，便是向上转型。</p><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型 变量名 = <span class="hljs-keyword">new</span> 子类类型();<br>如：Animal a = <span class="hljs-keyword">new</span> Cat();<br></code></pre></td></tr></table></figure><h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><p>父类类型向子类类型向下转换的过程，这个过程是<strong>强制的</strong>。</p><p>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。<br>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">子类类型 变量名 = (子类类型) 父类变量名;<br>如:Cat c =(Cat) a;<br></code></pre></td></tr></table></figure><h4 id="转型的异常"><a href="#转型的异常" class="headerlink" title="转型的异常"></a>转型的异常</h4><p>转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 向上转型</span><br>Animal a = <span class="hljs-keyword">new</span> Cat();<br>a.eat(); <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br><span class="hljs-comment">// 向下转型</span><br>Dog d = (Dog)a;<br>d.watchHouse(); <span class="hljs-comment">// 调用的是 Dog 的 watchHouse 【运行报错】</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码可以通过编译，但是运行时，却报出了 <code>ClassCastException</code>，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。<br>为了避免ClassCastException的发生，Java提供了<code>instanceof</code>关键字，给引用变量做类型的校验，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">变量名 <span class="hljs-keyword">instanceof</span> 数据类型<br>如果变量属于该数据类型，返回<span class="hljs-keyword">true</span>。<br>如果变量不属于该数据类型，返回<span class="hljs-keyword">false</span>。<br></code></pre></td></tr></table></figure><p>所以，转换前，最好先做一个判断，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 向上转型</span><br>Animal a = <span class="hljs-keyword">new</span> Cat();<br>a.eat(); <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br><span class="hljs-comment">// 向下转型</span><br><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Cat)&#123;<br>Cat c = (Cat)a;<br>c.catchMouse(); <span class="hljs-comment">// 调用的是 Cat 的 catchMouse</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Dog)&#123;<br>Dog d = (Dog)a;<br>d.watchHouse(); <span class="hljs-comment">// 调用的是 Dog 的 watchHouse</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-3-抽象类"><a href="#5-3-抽象类" class="headerlink" title="5.3 抽象类"></a>5.3 抽象类</h2><h3 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h3><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为<code>抽象方法</code>。Java语法规定，<strong>包含抽象方法的类就是抽象类</strong>。</p><h3 id="5-3-2-定义"><a href="#5-3-2-定义" class="headerlink" title="5.3.2 定义"></a>5.3.2 定义</h3><ul><li>抽象方法 ： 没有方法体的方法</li><li>抽象类：包含抽象方法的类</li></ul><h3 id="5-3-3-格式"><a href="#5-3-3-格式" class="headerlink" title="5.3.3 格式"></a>5.3.3 格式</h3><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>使用<code>abstract</code>关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">abstract</span> 返回值类型 方法名 (参数列表)；<br>如：<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>； </span><br></code></pre></td></tr></table></figure><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>如果一个类包含抽象方法，那么该类必须是抽象类。</p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名字 </span>&#123;<br>    <br>&#125;<br>如：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>；</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-3-4-抽象的使用"><a href="#5-3-4-抽象的使用" class="headerlink" title="5.3.4 抽象的使用"></a>5.3.4 抽象的使用</h3><p>继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;小猫在墙头走~~~&quot;</span>)；<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CatTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建子类对象</span><br>Cat c = <span class="hljs-keyword">new</span> Cat();<br><span class="hljs-comment">// 调用run方法</span><br>c.run();<br>&#125;<br>&#125;<br>输出结果：<br>小猫在墙头走~~~<br></code></pre></td></tr></table></figure><p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p><h3 id="5-3-5-注意事项"><a href="#5-3-5-注意事项" class="headerlink" title="5.3.5 注意事项"></a>5.3.5 注意事项</h3><ul><li><p>抽象类不能被实例化（创建对象），如果实例化，编译无法通过而报错。只能创建其非抽象子类的对象。</p></li><li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p><ul><li>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</li></ul></li><li><p>除了抽象方法之外，抽象类还可以包含具体数据和具体方法。</p></li><li><p>类即使不含抽象方法，也可以将类声明为抽象类。</p><ul><li>理解：抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li></ul></li><li><p>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</p></li></ul><hr><h2 id="5-4-Object类"><a href="#5-4-Object类" class="headerlink" title="5.4 Object类"></a>5.4 Object类</h2><h3 id="5-4-1-概述"><a href="#5-4-1-概述" class="headerlink" title="5.4.1 概述"></a>5.4.1 概述</h3><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>如果一个类没有特别指定父类， 那么默认则继承自Object类。</p><h3 id="5-4-2-equals方法"><a href="#5-4-2-equals方法" class="headerlink" title="5.4.2 equals方法"></a>5.4.2 equals方法</h3><h4 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h4><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><ol><li>默认地址比较</li></ol><p>如果没有覆盖重写equals方法，那么Object类中默认进行== 运算符的<strong>对象地址</strong>比较，只要不是同一个对象，结果必然为false。</p><ol start="2"><li>对象内容比较</li></ol><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br><span class="hljs-comment">// 如果对象地址一样，则认为相同</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">// 如果参数为空，或者类型信息不一样，则认为不同(getClass方法将返回一个对象所属的类)</span><br><span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass())<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 转换为当前类型</span><br>Person person = (Person) o;<br><span class="hljs-comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span><br>        <span class="hljs-comment">// 如果两个参数都为null,Objects.equals(a, b)将返回ture，如果一个参数为null，将返回false</span><br><span class="hljs-keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。</p><p>Objects.equals（）源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object a, Object b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-keyword">null</span> &amp;&amp; a.equals(b));<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><code>instance </code>of 与 <code>getClass</code>的区别</p><p><strong>instance of</strong>：检查类是否是本类或派生类（子类）</p><p><strong>getClass</strong>：严格判断是否属于同一个类，不考虑继承方面。</p><h4 id="子类调用"><a href="#子类调用" class="headerlink" title="子类调用"></a>子类调用</h4><p>在子类中定义equals方法时，首先调用父类中equals。如果检测失败，对象就不可能相等。如果父类中所要检测的域都相等，在比较子类中的扩展的实例域。</p><p>但也可以在子类中全部重写equal所要比较域。</p><h3 id="5-4-3-hashCode方法"><a href="#5-4-3-hashCode方法" class="headerlink" title="5.4.3 hashCode方法"></a>5.4.3 hashCode方法</h3><h4 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h4><ul><li><code>public native int hashCode();</code>：返回对象的一个哈希值。</li></ul><p><strong>如果两个对象进行equals比较返回True,那么这两个对象的hashcode()方法必须返回同样的值。</strong></p><h3 id="5-3-4-toString方法"><a href="#5-3-4-toString方法" class="headerlink" title="5.3.4 toString方法"></a>5.3.4 toString方法</h3><h4 id="方法摘要-2"><a href="#方法摘要-2" class="headerlink" title="方法摘要"></a>方法摘要</h4><ul><li><code>public String toString()</code> ：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的<strong>类型</strong>+<strong>@</strong>+<strong>内存地址值</strong>。<br>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><hr><h2 id="5-5-泛型"><a href="#5-5-泛型" class="headerlink" title="5.5 泛型"></a>5.5 泛型</h2><h3 id="5-5-1-概述"><a href="#5-5-1-概述" class="headerlink" title="5.5.1 概述"></a>5.5.1 概述</h3><p>泛型：可以在类或方法中预支地使用未知的类型。</p><ul><li>泛型的类型参数<strong>不允许是基本类型</strong></li></ul><p>泛型在<strong>编译期</strong>间的两个特性</p><ul><li>可读性：去除了大量的类型强转代码</li><li>安全性：容器中出现其他类型元素，报错</li></ul><h3 id="5-5-2-含有泛型的类"><a href="#5-5-2-含有泛型的类" class="headerlink" title="5.5.2 含有泛型的类"></a>5.5.2 含有泛型的类</h3><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 类名&lt;代表泛型的变量&gt; </span>&#123; &#125;<br></code></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123; &#125;<br>....<br>&#125;<br></code></pre></td></tr></table></figure><p>使用格式：</p><p><strong>在创建对象的时候确定泛型</strong></p><p>例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>举例自定义泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">MVP</span>&gt; </span>&#123;<br><span class="hljs-comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span><br><span class="hljs-keyword">private</span> MVP mvp;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMVP</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.mvp = mvp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> MVP <span class="hljs-title">getMVP</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> mvp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericClassDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建一个泛型为String的类</span><br>MyGenericClass&lt;String&gt; my = <span class="hljs-keyword">new</span> MyGenericClass&lt;String&gt;();<br><span class="hljs-comment">// 调用setMVP</span><br>my.setMVP(<span class="hljs-string">&quot;大胡子登登&quot;</span>);<br><span class="hljs-comment">// 调用getMVP</span><br>String mvp = my.getMVP();<br>System.out.println(mvp);<br><span class="hljs-comment">//创建一个泛型为Integer的类</span><br>MyGenericClass&lt;Integer&gt; my2 = <span class="hljs-keyword">new</span> MyGenericClass&lt;Integer&gt;();<br>my2.setMVP(<span class="hljs-number">123</span>);<br>Integer mvp2 = my2.getMVP();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5-3-含有泛型的方法"><a href="#5-5-3-含有泛型的方法" class="headerlink" title="5.5.3 含有泛型的方法"></a>5.5.3 含有泛型的方法</h3><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericMethod</span> </span>&#123;<br><span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>System.out.println(mvp.getClass());<br>&#125;<br><span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-function">MVP <span class="hljs-title">show2</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br><span class="hljs-keyword">return</span> mvp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用格式：</p><p><strong>调用方法时，确定泛型的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericMethodDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建对象</span><br>MyGenericMethod mm = <span class="hljs-keyword">new</span> MyGenericMethod();<br><span class="hljs-comment">// 演示看方法提示</span><br>mm.show(<span class="hljs-string">&quot;aaa&quot;</span>);<br>mm.show(<span class="hljs-number">123</span>);<br>mm.show(<span class="hljs-number">12.45</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5-4-含有泛型的接口"><a href="#5-5-4-含有泛型的接口" class="headerlink" title="5.5.4 含有泛型的接口"></a>5.5.4 含有泛型的接口</h3><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名&lt;代表泛型的变量&gt; </span>&#123; &#125;<br></code></pre></td></tr></table></figure><p>例如： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">getE</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用格式：</p><ol><li><strong>定义类时确定泛型的类型</strong></li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImp1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span> </span>&#123;<br><span class="hljs-comment">// 省略...</span><br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getE</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImp2</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br><span class="hljs-comment">// 省略...</span><br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getE</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用时再确定</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericInterface</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>MyImp2&lt;String&gt; my = <span class="hljs-keyword">new</span> MyImp2&lt;String&gt;();<br>my.add(<span class="hljs-string">&quot;aa&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5-5-泛型通配符"><a href="#5-5-5-泛型通配符" class="headerlink" title="5.5.5 泛型通配符"></a>5.5.5 泛型通配符</h3><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="5-5-5-1-通配符基本使用"><a href="#5-5-5-1-通配符基本使用" class="headerlink" title="5.5.5.1 通配符基本使用"></a>5.5.5.1 通配符基本使用</h4><p>泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用<code>?</code>,<strong><code>?</code>表示未知通配符</strong>。<br>此时只能接受数据,不能往该集合中存储数据。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection&lt;Intger&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>getElement(list1);<br>Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>getElement(list2);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement</span><span class="hljs-params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">//？代表可以接收任意类型</span><br></code></pre></td></tr></table></figure><h4 id="5-5-5-2-通配符高级使用—-受限泛型"><a href="#5-5-5-2-通配符高级使用—-受限泛型" class="headerlink" title="5.5.5.2 通配符高级使用—-受限泛型"></a>5.5.5.2 通配符高级使用—-受限泛型</h4><p>在JAVA的泛型中可以指定一个泛型的上限和下限。</p><ol><li><strong>泛型的上限</strong>：</li></ol><ul><li><strong>格式</strong>： 类型名称<code> &lt;? extends 类 &gt;</code>对象名称</li><li><strong>意义</strong>：只能接收该类型及其子类</li></ul><ol start="2"><li><strong>泛型的下限</strong>：</li></ol><ul><li><strong>格式</strong>：类型名称<code> &lt;? super 类 &gt;</code>对象名称</li><li><strong>意义</strong>：只能接收该类型及其父类型</li></ul><blockquote><p>注：</p><p>一个类型变量或通配符可以有多个限定，例如：<code>T extends Comparable &amp; Serializable</code></p><p>限定类型用<code>&amp;</code>分隔，类型变量用<code>,</code>分隔</p></blockquote><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>getElement1(list1);<br>getElement1(list2);<span class="hljs-comment">//报错</span><br>getElement1(list3);<br>getElement1(list4);<span class="hljs-comment">//报错</span><br>getElement2(list1);<span class="hljs-comment">//报错</span><br>getElement2(list2);<span class="hljs-comment">//报错</span><br>getElement2(list3);<br>getElement2(list4);<br>&#125;<br><span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5-6-泛型擦除"><a href="#5-5-6-泛型擦除" class="headerlink" title="5.5.6 泛型擦除"></a>5.5.6 泛型擦除</h3><p>Java的泛型是<strong>伪泛型</strong>，这是因为Java在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为<strong>类型擦除</strong>。</p><p><strong>泛型擦除的表现-原始类型相等</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    System.out.println(list1.getClass().getName());<br>    System.out.println(list2.getClass().getName());<br>    System.out.println(list1.getClass()==list2.getClass());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/image-20210822202748202.png" alt="image-20210822202748202"></p><p><strong>泛型擦除的表现-通过反射添加其它类型元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">998</span>);<br>    list.getClass().getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="hljs-string">&quot;asd&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>        System.out.println(list.get(i));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>程序中定义了一个<code>ArrayList</code>泛型类型实例化为<code>Integer</code>对象，如果直接调用<code>add()</code>方法，那么只能存储整数数据，不过当我们利用反射调用<code>add()</code>方法的时候，却可以存储字符串，这说明了<code>Integer</code>泛型实例在编译之后被擦除掉了，只保留了原始类型。</p></blockquote><p><img src="/2019/10/17/Java/JavaSE/JavaSE/image-20210822203445233.png" alt="image-20210822203445233"></p><p><strong>其中的问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br><br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();  <br>    list.add(<span class="hljs-string">&quot;123&quot;</span>);  <br>    list.add(<span class="hljs-number">123</span>);<span class="hljs-comment">//编译错误  </span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在上面的程序中，使用<code>add</code>方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为<code>Object</code>，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br><br>    ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList();  <br>    list1.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>    list1.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译错误  </span><br>    String str1 = list1.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br><br>    ArrayList list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();  <br>    list2.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>    list2.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译通过  </span><br>    Object object = list2.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是Object  </span><br><br>    <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;().add(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>    <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;().add(<span class="hljs-number">22</span>); <span class="hljs-comment">//编译错误  </span><br><br>    String str2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;().get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br>&#125;  <br></code></pre></td></tr></table></figure><blockquote><p><strong>类型检查就是针对引用的</strong>，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Object&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();  <br>list1.add(<span class="hljs-keyword">new</span> Object());  <br>list1.add(<span class="hljs-keyword">new</span> Object());  <br>ArrayList&lt;String&gt; list2 = list1; <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure><p>在第4行代码的时候，会有编译错误。</p><p>先假设它编译没错。那么当我们使用<code>list2</code>引用用<code>get()</code>方法取值的时候，返回的都是<code>String</code>类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了<code>Object</code>类型的对象，这样就会有<code>ClassCastException</code>了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();  <br>list1.add(<span class="hljs-keyword">new</span> String());  <br>list1.add(<span class="hljs-keyword">new</span> String());<br>ArrayList&lt;Object&gt; list2 = list1; <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure><p>这样的情况比上一种情况好的多，最起码，在用<code>list2</code>取值的时候不会出现<code>ClassCastException</code>，因为是从<code>String</code>转换为<code>Object</code>。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用<code>list2</code>往里面<code>add()</code>新的对象，那么到时候取得时候，我怎么知道我取出来的到底是<code>String</code>类型的，还是<code>Object</code>类型的呢？</p><p><strong>为什么不能创建泛型数组</strong></p><p>因为这样做会破坏类型安全。</p><p>泛型在<strong>编译期</strong>间的两个特性</p><ul><li>可读性：去除了大量的类型强转代码</li><li>安全性：容器中出现其他类型元素，报错</li></ul><p>Java中对普通数组的安全性验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strs = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>Object[] objs = strs;   <span class="hljs-comment">//编译通过，运行通过</span><br>objs[<span class="hljs-number">0</span>] = <span class="hljs-number">123</span> <span class="hljs-comment">//编译通过，运行报错</span><br></code></pre></td></tr></table></figure><blockquote><p>将String数据转Object数组， objs里面记忆的是String元素， 第三行我们给objs赋值了一个int元素，运行时会报出ArrayStoreException。<br>问题：<br>在Java中，数组不能保证安全性（在编译期间不暴露问题，在运行时抛出异常）。假设允许创建泛型数组，同样会出现上述问题，则不能保证泛型的安全性特性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设存在泛型类 Pair&lt;T&gt;</span><br>Pair&lt;String&gt;[] pairs = <span class="hljs-keyword">new</span> Pair&lt;String&gt;[<span class="hljs-number">10</span>];<br>Object[] objs = pairs;<br>pairs[<span class="hljs-number">0</span>] = <span class="hljs-number">123</span>;   <span class="hljs-comment">//这里在编译期间不会暴露元素123不是String类型问题</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;Manager&gt;[] pairs = <span class="hljs-keyword">new</span> Pair&lt;Manager&gt;[<span class="hljs-number">10</span>];<br>pairs[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;Employee&gt;;<br><br><span class="hljs-comment">//这段代码中，Pair&lt;Manager&gt;[], Pair&lt;Employee&gt;发生类型擦除后变成Pair[], Pair。 将Pair放入Pair[]数组，显然是合理的。但是违反了泛型的安全性特性</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-6-包装类"><a href="#5-6-包装类" class="headerlink" title="5.6 包装类"></a>5.6 包装类</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h3><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th align="center">基本类型</th><th align="center">对应的包装类</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr></tbody></table><h3 id="5-6-2-装箱与拆箱"><a href="#5-6-2-装箱与拆箱" class="headerlink" title="5.6.2 装箱与拆箱"></a>5.6.2 装箱与拆箱</h3><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</li><li><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基本数值----&gt;包装对象</span><br>Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用构造函数函数</span><br>Integer iii = Integer.valueOf(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用包装类中的valueOf方法</span><br><span class="hljs-comment">//包装对象----&gt;基本数值</span><br><span class="hljs-keyword">int</span> num = i.intValue();<br></code></pre></td></tr></table></figure><h3 id="5-6-3-自动装箱与自动拆箱"><a href="#5-6-3-自动装箱与自动拆箱" class="headerlink" title="5.6.3 自动装箱与自动拆箱"></a>5.6.3 自动装箱与自动拆箱</h3><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-number">4</span>;<span class="hljs-comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span><br>i = i + <span class="hljs-number">5</span>;<span class="hljs-comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span><br><span class="hljs-comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span><br></code></pre></td></tr></table></figure><h3 id="5-6-4-包装类对象比较"><a href="#5-6-4-包装类对象比较" class="headerlink" title="5.6.4 包装类对象比较"></a>5.6.4 包装类对象比较</h3><p>两个包装类对象进行比较时，不要用<code>==</code>，应当使用<code>equals</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer a = <span class="hljs-number">1</span>;<br>    Integer b = <span class="hljs-number">1</span>;<br>    Integer c = <span class="hljs-number">128</span>;<br>    Integer d = <span class="hljs-number">128</span>;<br>    System.out.println(a == b); <span class="hljs-comment">//输出ture</span><br>    System.out.println(c == d); <span class="hljs-comment">//输出false</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>自动装箱规范要求boolean、byte、char&lt;=127，介于-128~127之前的short和int被包装到固定的对象中（被一个名为cache的数组中<strong>缓存</strong>起来）</p><p>double、float是没有缓存机制的</p></blockquote><h3 id="5-6-5-基本类型与字符串之间的转换"><a href="#5-6-5-基本类型与字符串之间的转换" class="headerlink" title="5.6.5 基本类型与字符串之间的转换"></a>5.6.5 基本类型与字符串之间的转换</h3><h4 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h4><p>有三种方法</p><ol><li>使用包装类的toString()方法</li><li>使用String类的valueOf()方法</li><li>基本类型直接与””直接连接，如：34+””</li></ol><h4 id="String转换成对应的基本类型"><a href="#String转换成对应的基本类型" class="headerlink" title="String转换成对应的基本类型"></a>String转换成对应的基本类型</h4><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基<br>本类型。</li></ul><blockquote><p>注:</p><ol><li><p>parseXxx(String s)，调用parseXxx(String s, int radix)。并将radix设置为10。radix为给定字符串的进制    </p></li><li><p>如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。 </p></li></ol></blockquote><hr><h2 id="5-7-可变参数"><a href="#5-7-可变参数" class="headerlink" title="5.7 可变参数"></a>5.7 可变参数</h2><h3 id="5-7-1-概述"><a href="#5-7-1-概述" class="headerlink" title="5.7.1 概述"></a>5.7.1 概述</h3><p><strong>适用于参数个数不确定，类型确定的情况，java把可变参数当做数组处理。</strong></p><h3 id="5-7-2-特点"><a href="#5-7-2-特点" class="headerlink" title="5.7.2 特点"></a>5.7.2 特点</h3><ul><li>只能出现在参数列表的最后； </li><li><code>...</code>位于变量类型和变量名之间，前后有无空格都可以；</li><li>调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用可变参数求多个数的和</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Varable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br>        System.out.println(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span>... args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>            sum += args[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-8-枚举类"><a href="#5-8-枚举类" class="headerlink" title="5.8 枚举类"></a>5.8 枚举类</h2><h3 id="5-8-1-概述"><a href="#5-8-1-概述" class="headerlink" title="5.8.1 概述"></a>5.8.1 概述</h3><p>枚举是多例，一个类有多个实例，但实例的个数不是无穷的，是有限个数的。</p><p><code>enum</code>的全称为enumeration，是 JDK 1.5 中引入的新特性。在Java中，被 <code>enum</code> 关键字修饰的类型就是枚举类型。</p><h3 id="5-8-2-定义枚举类"><a href="#5-8-2-定义枚举类" class="headerlink" title="5.8.2 定义枚举类"></a>5.8.2 定义枚举类</h3><p>定义枚举类型需要使用<code>enum</code>关键字，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123; <br>    RED, GREEN, BLUE <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>所有枚举类都默认是Enum类的子类，无需我们使用extends来继承。这说明Enum中的方法所有枚举类都拥有。</li></ul><p>如果枚举不添加任何方法，<strong>枚举值默认为从0开始的有序数值</strong>。以 Color 枚举类型举例，它的枚举常量依次为 <code>RED：0，GREEN：1，BLUE：2</code>。</p><p><strong>Java 不允许使用<code>=</code>为枚举常量赋值</strong></p><ul><li>比较两个枚举类型的值时，不需要调用<code>equals</code>，直接使用<code>==</code>就可以</li></ul><h3 id="5-8-3-常用方法"><a href="#5-8-3-常用方法" class="headerlink" title="5.8.3 常用方法"></a>5.8.3 常用方法</h3><p><code>java.lang.Enum&lt;E&gt;</code></p><ul><li><code>public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name)</code>：返回指定名字、给定类的枚举常量</li><li><code>public String toString()</code>：返回枚举常量名</li><li><code>public final int ordinal()</code>：返回枚举常量在enum声明中的位置，位置从0开始计数</li><li><code>public final int compareTo(E o)</code>：如果枚举常量出现在o之前，则返回一个负值；如果<code>this==o</code>，返回0；反着返回正值</li></ul><h3 id="5-8-4-枚举类的使用"><a href="#5-8-4-枚举类的使用" class="headerlink" title="5.8.4 枚举类的使用"></a>5.8.4 枚举类的使用</h3><p><strong>枚举可以添加普通方法、静态方法、抽象方法、构造方法</strong>**</p><p><strong>注意一个细节：如果要为enum定义方法，那么必须在enum的最后一个实例尾部添加一个分号。此外，在enum中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。</strong></p><p>例：全面展示如何在枚举中定义普通方法、静态方法、抽象方法、构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ErrorCode</span> </span>&#123;<br>    OK(<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功&quot;</span>;<br>        &#125;<br>    &#125;,<br>    ERROR_A(<span class="hljs-number">100</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;错误A&quot;</span>;<br>        &#125;<br>    &#125;,<br>    ERROR_B(<span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;错误B&quot;</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> code;<br><br>    <span class="hljs-comment">// 构造方法：enum的构造方法只能被声明为private权限或不声明权限</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ErrorCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123; <span class="hljs-comment">// 构造方法</span><br>        <span class="hljs-keyword">this</span>.code = number;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 普通方法</span><br>        <span class="hljs-keyword">return</span> code;<br>    &#125; <span class="hljs-comment">// 普通方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123; <span class="hljs-comment">// 静态方法</span><br>        <span class="hljs-keyword">for</span> (ErrorCode s : ErrorCode.values()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;code: &quot;</span> + s.getCode() + <span class="hljs-string">&quot;, description: &quot;</span> + s.getDescription());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：上面的例子并不可取，仅仅是为了展示枚举支持定义各种方法。下面是一个简化的例子</p><p>本例和上例的执行结果完全相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ErrorCodeEn</span> </span>&#123;<br>    OK(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;成功&quot;</span>),<br>    ERROR_A(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;错误A&quot;</span>),<br>    ERROR_B(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;错误B&quot;</span>);<br><br>    ErrorCodeEn(<span class="hljs-keyword">int</span> number, String description) &#123;<br>        <span class="hljs-keyword">this</span>.code = number;<br>        <span class="hljs-keyword">this</span>.description = description;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> code;<br>    <span class="hljs-keyword">private</span> String description;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123; <span class="hljs-comment">// 静态方法</span><br>        <span class="hljs-keyword">for</span> (ErrorCodeEn s : ErrorCodeEn.values()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;code: &quot;</span> + s.getCode() + <span class="hljs-string">&quot;, description: &quot;</span> + s.getDescription());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-9-反射"><a href="#5-9-反射" class="headerlink" title="5.9 反射"></a>5.9 反射</h2><h3 id="5-9-1-概述"><a href="#5-9-1-概述" class="headerlink" title="5.9.1 概述"></a>5.9.1 概述</h3><p>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意方法和属性。这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><h3 id="5-9-2-反射机制的相关类"><a href="#5-9-2-反射机制的相关类" class="headerlink" title="5.9.2 反射机制的相关类"></a>5.9.2 反射机制的相关类</h3><table><thead><tr><th align="center">类名</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">Class类</td><td align="center">代表类的实体，在运行的Java应用程序中表示类和接口</td></tr><tr><td align="center">Field类</td><td align="center">代表类的成员变量（成员变量也称为类的属性）</td></tr><tr><td align="center">Method类</td><td align="center">代表类的方法</td></tr><tr><td align="center">Constructor类</td><td align="center">代表类的构造方法</td></tr></tbody></table><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>Class代表类的实体，在运行的Java应用程序中表示类和接口。</p><ul><li><strong>获得类相关的方法</strong></li></ul><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">asSubclass(Class<U> clazz)</U></td><td align="center">把传递的类的对象转换成代表其子类的对象</td></tr><tr><td align="center">Cast</td><td align="center">把对象转换成代表类或是接口的对象</td></tr><tr><td align="center">getClassLoader()</td><td align="center">获得类的加载器</td></tr><tr><td align="center">getClasses()</td><td align="center">返回一个数组，数组中包含该类中所有公共类和接口类的对象</td></tr><tr><td align="center">getDeclaredClasses()</td><td align="center">返回一个数组，数组中包含该类中所有类和接口类的对象</td></tr><tr><td align="center">forName(String className)</td><td align="center">根据类名返回类的对象</td></tr><tr><td align="center">getName()</td><td align="center">获得类的完整路径名字</td></tr><tr><td align="center">newInstance()</td><td align="center">创建类的实例</td></tr><tr><td align="center">getPackage()</td><td align="center">获得类的包</td></tr><tr><td align="center">getSimpleName()</td><td align="center">获得类的名字</td></tr><tr><td align="center">getSuperclass()</td><td align="center">获得当前类继承的父类的名字</td></tr><tr><td align="center">getInterfaces()</td><td align="center">获得当前类实现的类或是接口</td></tr></tbody></table><ul><li><strong>获得类中属性相关的方法</strong></li></ul><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">getField(String name)</td><td align="center">获得某个公有的属性对象</td></tr><tr><td align="center">getFields()</td><td align="center">获得所有公有的属性对象</td></tr><tr><td align="center">getDeclaredField(String name)</td><td align="center">获得某个属性对象</td></tr><tr><td align="center">getDeclaredFields()</td><td align="center">获得所有属性对象</td></tr></tbody></table><ul><li><strong>获得类中注解相关的方法</strong></li></ul><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">getAnnotation(Class<A> annotationClass)</A></td><td align="center">返回该类中与参数类型匹配的公有注解对象</td></tr><tr><td align="center">getAnnotations()</td><td align="center">返回该类所有的公有注解对象</td></tr><tr><td align="center">getDeclaredAnnotation(Class<A> annotationClass)</A></td><td align="center">返回该类中与参数类型匹配的所有注解对象</td></tr><tr><td align="center">getDeclaredAnnotations()</td><td align="center">返回该类所有的注解对象</td></tr></tbody></table><ul><li><strong>获得类中构造器相关的方法</strong></li></ul><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">getConstructor(Class…&lt;?&gt; parameterTypes)</td><td align="center">获得该类中与参数类型匹配的公有构造方法</td></tr><tr><td align="center">getConstructors()</td><td align="center">获得该类的所有公有构造方法</td></tr><tr><td align="center">getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td><td align="center">获得该类中与参数类型匹配的构造方法</td></tr><tr><td align="center">getDeclaredConstructors()</td><td align="center">获得该类所有构造方法</td></tr></tbody></table><ul><li><strong>获得类中方法相关的方法</strong></li></ul><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">getMethod(String name, Class…&lt;?&gt; parameterTypes)</td><td align="center">获得该类某个公有的方法</td></tr><tr><td align="center">getMethods()</td><td align="center">获得该类所有公有的方法</td></tr><tr><td align="center">getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td><td align="center">获得该类某个方法</td></tr><tr><td align="center">getDeclaredMethods()</td><td align="center">获得该类所有方法</td></tr></tbody></table><ul><li><strong>类中其他重要的方法</strong></li></ul><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">isAnnotation()</td><td align="center">如果是注解类型则返回true</td></tr><tr><td align="center">isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td><td align="center">如果是指定类型注解类型则返回true</td></tr><tr><td align="center">isAnonymousClass()</td><td align="center">如果是匿名类则返回true</td></tr><tr><td align="center">isArray()</td><td align="center">如果是一个数组类则返回true</td></tr><tr><td align="center">isEnum()</td><td align="center">如果是枚举类则返回true</td></tr><tr><td align="center">isInstance(Object obj)</td><td align="center">如果obj是该类的实例则返回true</td></tr><tr><td align="center">isInterface()</td><td align="center">如果是接口类则返回true</td></tr><tr><td align="center">isLocalClass()</td><td align="center">如果是局部类则返回true</td></tr><tr><td align="center">isMemberClass()</td><td align="center">如果是内部类则返回true</td></tr></tbody></table><h4 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h4><p>Field类代表类的成员变量（成员变量也称为类的属性）。</p><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">equals(Object obj)</td><td align="center">属性与obj相等则返回true</td></tr><tr><td align="center">get(Object obj)</td><td align="center">获得obj中对应的属性值</td></tr><tr><td align="center">set(Object obj, Object value)</td><td align="center">设置obj中对应属性值</td></tr></tbody></table><h4 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h4><p>Method代表类的方法。</p><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">invoke(Object obj, Object… args)</td><td align="center">传递object对象及参数调用该对象对应的方法</td></tr></tbody></table><h4 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h4><p>Constructo代表类的构造方法。</p><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">newInstance(Object… initargs)</td><td align="center">根据传递的参数创建类的对象</td></tr></tbody></table><ul><li>被反射类Book.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String TAG = <span class="hljs-string">&quot;BookTag&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String author;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Book&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, author=&#x27;&quot;</span> + author + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Book</span><span class="hljs-params">(String name, String author)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.author = author;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> author;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(String author)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.author = author;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">declaredMethod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        String string = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">switch</span> (index) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                string = <span class="hljs-string">&quot;I am declaredMethod 1 !&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                string = <span class="hljs-string">&quot;I am declaredMethod 2 !&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                string = <span class="hljs-string">&quot;I am declaredMethod 1 !&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> string;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>反射逻辑封装在ReflectClass.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectClass</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String TAG = <span class="hljs-string">&quot;peter.log.ReflectClass&quot;</span>;<br><br>    <span class="hljs-comment">// 创建对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflectNewInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; classBook = Class.forName(<span class="hljs-string">&quot;com.android.peter.reflectdemo.Book&quot;</span>);<br>            Object objectBook = classBook.newInstance();<br>            Book book = (Book) objectBook;<br>            book.setName(<span class="hljs-string">&quot;Android进阶之光&quot;</span>);<br>            book.setAuthor(<span class="hljs-string">&quot;刘望舒&quot;</span>);<br>            Log.d(TAG,<span class="hljs-string">&quot;reflectNewInstance book = &quot;</span> + book.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 反射私有的构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflectPrivateConstructor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; classBook = Class.forName(<span class="hljs-string">&quot;com.android.peter.reflectdemo.Book&quot;</span>);<br>            Constructor&lt;?&gt; declaredConstructorBook = classBook.getDeclaredConstructor(String.class,String.class);<br>            declaredConstructorBook.setAccessible(<span class="hljs-keyword">true</span>);<br>            Object objectBook = declaredConstructorBook.newInstance(<span class="hljs-string">&quot;Android开发艺术探索&quot;</span>,<span class="hljs-string">&quot;任玉刚&quot;</span>);<br>            Book book = (Book) objectBook;<br>            Log.d(TAG,<span class="hljs-string">&quot;reflectPrivateConstructor book = &quot;</span> + book.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 反射私有属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflectPrivateField</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; classBook = Class.forName(<span class="hljs-string">&quot;com.android.peter.reflectdemo.Book&quot;</span>);<br>            Object objectBook = classBook.newInstance();<br>            Field fieldTag = classBook.getDeclaredField(<span class="hljs-string">&quot;TAG&quot;</span>);<br>            fieldTag.setAccessible(<span class="hljs-keyword">true</span>);<br>            String tag = (String) fieldTag.get(objectBook);<br>            Log.d(TAG,<span class="hljs-string">&quot;reflectPrivateField tag = &quot;</span> + tag);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 反射私有方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflectPrivateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; classBook = Class.forName(<span class="hljs-string">&quot;com.android.peter.reflectdemo.Book&quot;</span>);<br>            Method methodBook = classBook.getDeclaredMethod(<span class="hljs-string">&quot;declaredMethod&quot;</span>,<span class="hljs-keyword">int</span>.class);<br>            methodBook.setAccessible(<span class="hljs-keyword">true</span>);<br>            Object objectBook = classBook.newInstance();<br>            String string = (String) methodBook.invoke(objectBook,<span class="hljs-number">0</span>);<br><br>            Log.d(TAG,<span class="hljs-string">&quot;reflectPrivateMethod string = &quot;</span> + string);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获得系统Zenmode值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getZenMode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> zenMode = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; cServiceManager = Class.forName(<span class="hljs-string">&quot;android.os.ServiceManager&quot;</span>);<br>            Method mGetService = cServiceManager.getMethod(<span class="hljs-string">&quot;getService&quot;</span>, String.class);<br>            Object oNotificationManagerService = mGetService.invoke(<span class="hljs-keyword">null</span>, Context.NOTIFICATION_SERVICE);<br>            Class&lt;?&gt; cINotificationManagerStub = Class.forName(<span class="hljs-string">&quot;android.app.INotificationManager$Stub&quot;</span>);<br>            Method mAsInterface = cINotificationManagerStub.getMethod(<span class="hljs-string">&quot;asInterface&quot;</span>,IBinder.class);<br>            Object oINotificationManager = mAsInterface.invoke(<span class="hljs-keyword">null</span>,oNotificationManagerService);<br>            Method mGetZenMode = cINotificationManagerStub.getMethod(<span class="hljs-string">&quot;getZenMode&quot;</span>);<br>            zenMode = (<span class="hljs-keyword">int</span>) mGetZenMode.invoke(oINotificationManager);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> zenMode;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭手机</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutDown</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; cServiceManager = Class.forName(<span class="hljs-string">&quot;android.os.ServiceManager&quot;</span>);<br>            Method mGetService = cServiceManager.getMethod(<span class="hljs-string">&quot;getService&quot;</span>,String.class);<br>            Object oPowerManagerService = mGetService.invoke(<span class="hljs-keyword">null</span>,Context.POWER_SERVICE);<br>            Class&lt;?&gt; cIPowerManagerStub = Class.forName(<span class="hljs-string">&quot;android.os.IPowerManager$Stub&quot;</span>);<br>            Method mShutdown = cIPowerManagerStub.getMethod(<span class="hljs-string">&quot;shutdown&quot;</span>,<span class="hljs-keyword">boolean</span>.class,String.class,<span class="hljs-keyword">boolean</span>.class);<br>            Method mAsInterface = cIPowerManagerStub.getMethod(<span class="hljs-string">&quot;asInterface&quot;</span>,IBinder.class);<br>            Object oIPowerManager = mAsInterface.invoke(<span class="hljs-keyword">null</span>,oPowerManagerService);<br>            mShutdown.invoke(oIPowerManager,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">true</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdownOrReboot</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> shutdown, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> confirm)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; ServiceManager = Class.forName(<span class="hljs-string">&quot;android.os.ServiceManager&quot;</span>);<br>            <span class="hljs-comment">// 获得ServiceManager的getService方法</span><br>            Method getService = ServiceManager.getMethod(<span class="hljs-string">&quot;getService&quot;</span>, java.lang.String.class);<br>            <span class="hljs-comment">// 调用getService获取RemoteService</span><br>            Object oRemoteService = getService.invoke(<span class="hljs-keyword">null</span>, Context.POWER_SERVICE);<br>            <span class="hljs-comment">// 获得IPowerManager.Stub类</span><br>            Class&lt;?&gt; cStub = Class.forName(<span class="hljs-string">&quot;android.os.IPowerManager$Stub&quot;</span>);<br>            <span class="hljs-comment">// 获得asInterface方法</span><br>            Method asInterface = cStub.getMethod(<span class="hljs-string">&quot;asInterface&quot;</span>, android.os.IBinder.class);<br>            <span class="hljs-comment">// 调用asInterface方法获取IPowerManager对象</span><br>            Object oIPowerManager = asInterface.invoke(<span class="hljs-keyword">null</span>, oRemoteService);<br>            <span class="hljs-keyword">if</span> (shutdown) &#123;<br>                <span class="hljs-comment">// 获得shutdown()方法</span><br>                Method shutdownMethod = oIPowerManager.getClass().getMethod(<br>                        <span class="hljs-string">&quot;shutdown&quot;</span>, <span class="hljs-keyword">boolean</span>.class, String.class, <span class="hljs-keyword">boolean</span>.class);<br>                <span class="hljs-comment">// 调用shutdown()方法</span><br>                shutdownMethod.invoke(oIPowerManager, confirm, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 获得reboot()方法</span><br>                Method rebootMethod = oIPowerManager.getClass().getMethod(<span class="hljs-string">&quot;reboot&quot;</span>,<br>                        <span class="hljs-keyword">boolean</span>.class, String.class, <span class="hljs-keyword">boolean</span>.class);<br>                <span class="hljs-comment">// 调用reboot()方法</span><br>                rebootMethod.invoke(oIPowerManager, confirm, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>调用相应反射逻辑方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 创建对象</span><br>    ReflectClass.reflectNewInstance();<br><br>    <span class="hljs-comment">// 反射私有的构造方法</span><br>    ReflectClass.reflectPrivateConstructor();<br><br>    <span class="hljs-comment">// 反射私有属性</span><br>    ReflectClass.reflectPrivateField();<br><br>    <span class="hljs-comment">// 反射私有方法</span><br>    ReflectClass.reflectPrivateMethod();<br>&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    ex.printStackTrace();<br>&#125;<br><br>Log.d(TAG,<span class="hljs-string">&quot; zenmode = &quot;</span> + ReflectClass.getZenMode());<br></code></pre></td></tr></table></figure><ul><li>Log输出结果如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">08-<span class="hljs-number">27</span> <span class="hljs-number">15</span>:<span class="hljs-number">11</span>:<span class="hljs-number">37.999</span> <span class="hljs-number">11987</span>-<span class="hljs-number">11987</span>/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectNewInstance book = Book&#123;name=<span class="hljs-string">&#x27;Android进阶之光&#x27;</span>, author=<span class="hljs-string">&#x27;刘望舒&#x27;</span>&#125;<br>08-<span class="hljs-number">27</span> <span class="hljs-number">15</span>:<span class="hljs-number">11</span>:<span class="hljs-number">38.000</span> <span class="hljs-number">11987</span>-<span class="hljs-number">11987</span>/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateConstructor book = Book&#123;name=<span class="hljs-string">&#x27;Android开发艺术探索&#x27;</span>, author=<span class="hljs-string">&#x27;任玉刚&#x27;</span>&#125;<br>08-<span class="hljs-number">27</span> <span class="hljs-number">15</span>:<span class="hljs-number">11</span>:<span class="hljs-number">38.000</span> <span class="hljs-number">11987</span>-<span class="hljs-number">11987</span>/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateField tag = BookTag<br>08-<span class="hljs-number">27</span> <span class="hljs-number">15</span>:<span class="hljs-number">11</span>:<span class="hljs-number">38.000</span> <span class="hljs-number">11987</span>-<span class="hljs-number">11987</span>/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateMethod string = I am declaredMethod <span class="hljs-number">1</span> !<br>08-<span class="hljs-number">27</span> <span class="hljs-number">15</span>:<span class="hljs-number">11</span>:<span class="hljs-number">38.004</span> <span class="hljs-number">11987</span>-<span class="hljs-number">11987</span>/com.android.peter.reflectdemo D/peter.log.ReflectDemo:  zenmode = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><hr><h1 id="第6章-接口、lambad表达式与内部类"><a href="#第6章-接口、lambad表达式与内部类" class="headerlink" title="第6章 接口、lambad表达式与内部类"></a>第6章 接口、lambad表达式与内部类</h1><h2 id="6-1-接口"><a href="#6-1-接口" class="headerlink" title="6.1 接口"></a>6.1 接口</h2><h3 id="6-1-1-概述"><a href="#6-1-1-概述" class="headerlink" title="6.1.1 概述"></a>6.1.1 概述</h3><p>接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。</p><p>接口的定义，它与定义类方式相似，但是使用 <code>interface</code>关键字。它也会被编译成**.class<strong>文件，但一定要明确它并</strong>不是类<strong>，而是另外一种</strong>引用数据类型**。</p><blockquote><p>引用数据类型：数组，类，接口。</p></blockquote><p>接口的使用，它<strong>不能创建对象</strong>，但是<strong>可以被实现</strong>（<code> implements</code>，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p><h3 id="6-1-2-定义"><a href="#6-1-2-定义" class="headerlink" title="6.1.2 定义"></a>6.1.2 定义</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名称 </span>&#123;<br><span class="hljs-comment">// 抽象方法</span><br><span class="hljs-comment">// 默认方法</span><br><span class="hljs-comment">// 静态方法</span><br><span class="hljs-comment">// 私有方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="含有抽象方法"><a href="#含有抽象方法" class="headerlink" title="含有抽象方法"></a>含有抽象方法</h4><ul><li><strong>抽象方法</strong>：使用<code>abstract</code>关键字修饰，可以省略，没有方法体。该方法供子类实现使用。</li></ul><h4 id="含有默认方法和静态方法"><a href="#含有默认方法和静态方法" class="headerlink" title="含有默认方法和静态方法"></a>含有默认方法和静态方法</h4><ul><li><strong>默认方法</strong>：使用<code>default</code>修饰，不可省略，供子类调用或者子类重写。</li><li><strong>静态方法</strong>：使用<code>static</code>修饰，供接口直接调用。</li></ul><h4 id="含有私有方法和私有静态方法"><a href="#含有私有方法和私有静态方法" class="headerlink" title="含有私有方法和私有静态方法"></a>含有私有方法和私有静态方法</h4><ul><li><strong>私有方法</strong>：使用<code>private</code>修饰，供接口中的默认方法或者静态方法调用。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterFaceName</span> </span>&#123;<br>    <span class="hljs-comment">// 抽象方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 默认方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 执行语句</span><br>&#125;<br>    <span class="hljs-comment">// 静态方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 执行语句</span><br>&#125;<br>    <span class="hljs-comment">// 私有方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method4</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 执行语句</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-1-3-接口的基本实现"><a href="#6-1-3-接口的基本实现" class="headerlink" title="6.1.3 接口的基本实现"></a>6.1.3 接口的基本实现</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code>implements</code>关键字。</p><p><strong>非抽象子类实现接口</strong></p><ul><li>必须<strong>重写接口中所有抽象方法</strong>。</li></ul><ol start="2"><li>继承了接口的默认方法，即可以直接调用，也可以重写。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 <span class="hljs-keyword">implements</span> 接口名 </span>&#123;<br><span class="hljs-comment">// 重写接口中抽象方法【必须】</span><br><span class="hljs-comment">// 重写接口中默认方法【可选】</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="抽象方法的使用"><a href="#抽象方法的使用" class="headerlink" title="抽象方法的使用"></a>抽象方法的使用</h4><p><strong>必须全部实现</strong>，代码如下：</p><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br><span class="hljs-comment">// 定义抽象方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;吃东西&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;晚上睡&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建子类对象</span><br>Animal a = <span class="hljs-keyword">new</span> Animal();<br><span class="hljs-comment">// 调用实现后的方法</span><br>a.eat();<br>a.sleep();<br>&#125;<br>&#125;<br>输出结果：<br>吃东西<br>晚上睡<br></code></pre></td></tr></table></figure><h4 id="默认方法的使用"><a href="#默认方法的使用" class="headerlink" title="默认方法的使用"></a>默认方法的使用</h4><p><strong>可以继承，可以重写</strong>，二选一，但是只能通过实现类的对象来调用。</p><ol><li>继承默认方法，代码如下：</li></ol><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;天上飞&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br><span class="hljs-comment">// 继承，什么都不用写，直接调用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建子类对象</span><br>Animal a = <span class="hljs-keyword">new</span> Animal();<br><span class="hljs-comment">// 调用默认方法</span><br>a.fly();<br>&#125;<br>&#125;<br>输出结果：<br>天上飞<br></code></pre></td></tr></table></figure><ol start="2"><li>重写默认方法，代码如下：</li></ol><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;天上飞&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;自由自在的飞&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建子类对象</span><br>Animal a = <span class="hljs-keyword">new</span> Animal();<br><span class="hljs-comment">// 调用重写方法</span><br>a.fly();<br>&#125;<br>&#125;<br>输出结果：<br>自由自在的飞<br></code></pre></td></tr></table></figure><h4 id="静态方法的使用"><a href="#静态方法的使用" class="headerlink" title="静态方法的使用"></a>静态方法的使用</h4><p>静态与.class 文件相关，<strong>只能使用接口名调用</strong>，不可以通过实现类的类名或者实现类的对象调用，代码如下：</p><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;跑起来~~~&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br><span class="hljs-comment">// 无法重写静态方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// Animal.run(); // 【错误】无法继承方法,也无法调用</span><br>LiveAble.run(); <span class="hljs-comment">//</span><br>&#125;<br>&#125;<br>输出结果：<br>跑起来~~~<br></code></pre></td></tr></table></figure><h4 id="私有方法的使用"><a href="#私有方法的使用" class="headerlink" title="私有方法的使用"></a>私有方法的使用</h4><ul><li>私有方法：只有默认方法可以调用。</li><li>私有静态方法：默认方法和静态方法可以调用。</li></ul><p>如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。</p><p>从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。</p><h3 id="6-1-4-接口的多实现"><a href="#6-1-4-接口的多实现" class="headerlink" title="6.1.4 接口的多实现"></a>6.1.4 接口的多实现</h3><p>在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做<strong>接口的多实现</strong>。并且，一个类能继承一个父类，同时实现多个接口。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 [<span class="hljs-keyword">extends</span> 父类名] <span class="hljs-keyword">implements</span> 接口名1,接口名2,接口名3... </span>&#123;<br><span class="hljs-comment">// 重写接口中抽象方法【必须】</span><br><span class="hljs-comment">// 重写接口中默认方法【不重名时可选】</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="抽象方法-1"><a href="#抽象方法-1" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>接口中，有多个抽象方法时，实现类必须<strong>重写所有抽象方法</strong>。如果抽象方法有重名的，只需要重写一次。</p><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>接口中，有多个默认方法时，实现类都可继承使用。<strong>如果默认方法有重名的，必须重写一次</strong>。</p><h4 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h4><p>接口中，存在同名的静态方法并不会冲突，原因是<strong>只能通过各自接口名访问静态方法</strong>。</p><h4 id="优先级的问题"><a href="#优先级的问题" class="headerlink" title="优先级的问题"></a>优先级的问题</h4><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类选择<strong>执行父类的成员方法</strong></p><blockquote><p>继承优先于接口实现</p></blockquote><h3 id="6-1-5-接口的多继承"><a href="#6-1-5-接口的多继承" class="headerlink" title="6.1.5 接口的多继承"></a>6.1.5 接口的多继承</h3><p>一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用<code>extends</code>关键字，子接口继承父接口的方法。<strong>如果父接口中的默认方法有重名的，那么子接口需要重写一次</strong>。</p><blockquote><p>子接口重写默认方法时，default关键字可以保留。<br>子类重写默认方法时，default关键字不可以保留。</p></blockquote><h3 id="6-1-6-接口作为参数或返回值"><a href="#6-1-6-接口作为参数或返回值" class="headerlink" title="6.1.6 接口作为参数或返回值"></a>6.1.6 接口作为参数或返回值</h3><ul><li>接口作为参数时，传递它的子类对象。</li><li>接口作为返回值类型时，返回它的子类对象</li></ul><h3 id="6-1-7-接口中的属性"><a href="#6-1-7-接口中的属性" class="headerlink" title="6.1.7 接口中的属性"></a>6.1.7 接口中的属性</h3><ul><li>接口中不能定义普通的属性</li><li>接口属性只可以<code>public static final 数据类型 属性名 = 值;</code>其中<code>public static final </code>可以省略</li><li>接口属性定义的时候必须初始化。</li></ul><p>原因如下</p><blockquote><p>接口就是提供一种统一的”协议”，而接口中的属性也属于 “协议”中的成员。它们是公共的，静态的，最终的常量。相当于全局常量。抽象类是不“完全”的类，相当于是接口和具体类的一个中间层。即满足接口的抽象，也满足具体的实现。如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。有的人会说了，没有关系，可以通过实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况。如果接口 A 中有一个public 访问权限的静态变量 a。按照 Java 的语义，我们可以不通过实现接口的对象来访问变量 a，通过 A.a = xxx; 就可以改变接口中的变量 a 的值了。正如抽象类中是可以这样做的，那么实现接口 A 的所有对象也都会自动拥有这一改变后的 a的值了，也就是说一个地方改变了 a，所有这些对象中 a 的值也都跟着变了。这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。 所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统一的属性。通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。</p></blockquote><hr><h2 id="6-2-lambda表达式"><a href="#6-2-lambda表达式" class="headerlink" title="6.2 lambda表达式"></a>6.2 lambda表达式</h2><h3 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h3><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。也可称为闭包，</p><h3 id="6-2-2-标准格式"><a href="#6-2-2-标准格式" class="headerlink" title="6.2.2 标准格式"></a>6.2.2 标准格式</h3><p>Lambda省去面向对象的条条框框，格式由3个部分组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul><p>Lambda表达式的标准格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(参数类型 参数名称) ‐&gt; &#123; 代码语句 &#125;<br></code></pre></td></tr></table></figure><p>格式说明：</p><ul><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul><h3 id="6-2-3-省略规则"><a href="#6-2-3-省略规则" class="headerlink" title="6.2.3 省略规则"></a>6.2.3 省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ul><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参数</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ul><h3 id="6-2-4-使用前提"><a href="#6-2-4-使用前提" class="headerlink" title="6.2.4 使用前提"></a>6.2.4 使用前提</h3><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用Lambda必须具有接口，且要求接口中<strong>有且仅有一个抽象方法</strong>。<br>无论是JDK内置的Runnable 、Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote><h3 id="6-2-5-Lambda作用域"><a href="#6-2-5-Lambda作用域" class="headerlink" title="6.2.5 Lambda作用域"></a>6.2.5 Lambda作用域</h3><p>在 Lambda 表达式中， 访问外层作用域和以前版本的匿名对象中的方式类似。 可以直接访问标记了<code>final</code>的外层局部变量、 对象的字段与静态变量。</p><h4 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h4><p>在 Lambda 表达式中， 直接访问外层的局部变量。与匿名对象不同的是， 变量 number 可以不声明为 final。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lambda</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> number = <span class="hljs-number">6</span>;<br>InterNew&lt;Integer,String&gt;inn = (t) -&gt; String.valueOf(t + number);<br>System.out.println(<span class="hljs-string">&quot;访问局部变量：&quot;</span>+inn.InterNew(<span class="hljs-number">7</span>));<span class="hljs-comment">//13</span><br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterNew</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;<br><span class="hljs-function">Integer <span class="hljs-title">InterNew</span><span class="hljs-params">(String string)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="访问对象字段与静态变量"><a href="#访问对象字段与静态变量" class="headerlink" title="访问对象字段与静态变量"></a>访问对象字段与静态变量</h4><hr><h2 id="6-3-函数式接口"><a href="#6-3-函数式接口" class="headerlink" title="6.3 函数式接口"></a>6.3 函数式接口</h2><h3 id="6-3-1-概述"><a href="#6-3-1-概述" class="headerlink" title="6.3.1 概述"></a>6.3.1 概述</h3><p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong>。<br>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p><blockquote><p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。</p></blockquote><h3 id="6-3-2-格式"><a href="#6-3-2-格式" class="headerlink" title="6.3.2 格式"></a>6.3.2 格式</h3><p>只要确保接口中<strong>有且仅有一个抽象方法</strong>即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名称 </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> 返回值类型 方法名称(可选参数信息);<br><span class="hljs-comment">// 其他非抽象方法内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于接口当中抽象方法的<code>public abstract</code>是可以省略的，所以定义一个函数式接口很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFunctionalInterface</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-4-FunctionalInterface注解"><a href="#6-3-4-FunctionalInterface注解" class="headerlink" title="6.3.4 @FunctionalInterface注解"></a>6.3.4 @FunctionalInterface注解</h3><p>与<code>@Override</code>注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： <code>@FunctionalInterface</code>。该注解可用于一个接口的定义上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFunctionalInterface</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p></blockquote><h3 id="6-3-5-自定义函数式接口"><a href="#6-3-5-自定义函数式接口" class="headerlink" title="6.3.5 自定义函数式接口"></a>6.3.5 自定义函数式接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09FunctionalInterface</span> </span>&#123;<br><span class="hljs-comment">// 使用自定义的函数式接口作为方法参数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(MyFunctionalInterface inter)</span> </span>&#123;<br>inter.myMethod(); <span class="hljs-comment">// 调用自定义的函数式接口方法</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 调用使用函数式接口的方法</span><br>doSomething(() ‐&gt; System.out.println(<span class="hljs-string">&quot;Lambda执行啦！&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-6-Lambda的延迟执行"><a href="#6-3-6-Lambda的延迟执行" class="headerlink" title="6.3.6 Lambda的延迟执行"></a>6.3.6 Lambda的延迟执行</h3><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而<strong>Lambda表达式是延迟执行的</strong>，这正好可以作为解决方案，提升性能。</p><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MessageBuilder</span> </span>&#123;<br><span class="hljs-function">String <span class="hljs-title">buildMessage</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03LoggerDelay</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, MessageBuilder builder)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) &#123;<br>System.out.println(builder.buildMessage());<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>String msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>String msgC = <span class="hljs-string">&quot;Java&quot;</span>;<br>        <br>log(<span class="hljs-number">2</span>, () ‐&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;Lambda执行！&quot;</span>);<br><span class="hljs-keyword">return</span> msgA + msgB + msgC;<br>&#125;);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从结果（什么都输出）中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。</p><blockquote><p>注：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的</p></blockquote><hr><h2 id="6-4-常用函数式接口"><a href="#6-4-常用函数式接口" class="headerlink" title="6.4 常用函数式接口"></a>6.4 常用函数式接口</h2><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在<code>java.util.function</code>包中被提供。</p><h3 id="6-4-1-Supplier接口"><a href="#6-4-1-Supplier接口" class="headerlink" title="6.4.1 Supplier接口"></a>6.4.1 Supplier接口</h3><p><code>java.util.function.Supplier&lt;T&gt;</code>接口仅包含一个无参的方法：<code>T get()</code>。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02Test</span> </span>&#123;<br><span class="hljs-comment">//定一个方法,方法的参数传递Supplier,泛型使用Integer</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;<br><span class="hljs-keyword">return</span> sup.get();<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">52</span>,<span class="hljs-number">333</span>,<span class="hljs-number">23</span>&#125;;<br><span class="hljs-comment">//调用getMax方法,参数传递Lambda</span><br><span class="hljs-keyword">int</span> maxNum = getMax(()‐&gt;&#123;<br><span class="hljs-comment">//计算数组的最大值</span><br><span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr)&#123;<br><span class="hljs-keyword">if</span>(i&gt;max)&#123;<br>max = i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> max;<br>&#125;);<br>System.out.println(maxNum);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-4-2-Consumer接口"><a href="#6-4-2-Consumer接口" class="headerlink" title="6.4.2 Consumer接口"></a>6.4.2 Consumer接口</h3><p><code>java.util.function.Consumer&lt;T&gt;</code>接口则正好与<code>Supplier</code>接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。</p><h4 id="抽象方法：accept"><a href="#抽象方法：accept" class="headerlink" title="抽象方法：accept"></a>抽象方法：accept</h4><p><code>Consumer</code>接口中包含抽象方法<code>void accept(T t)</code>，意为消费一个指定泛型的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09Consumer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeString</span><span class="hljs-params">(Consumer&lt;String&gt; function)</span> </span>&#123;<br>        function.accept(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        consumeString((s)-&gt; System.out.println(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，更好的写法是使用方法引用。</p><h4 id="默认方法：andThen"><a href="#默认方法：andThen" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h4><p>如果一个方法的参数和返回值全都是<code>Consumer</code>类型，那么就可以实现效果：消费数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是Consumer接口中的default方法andThen。下面是JDK的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; after)</span> </span>&#123;<br>Objects.requireNonNull(after);<br><span class="hljs-keyword">return</span> (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：<code>java.util.Objects</code>的<code>requireNonNull</code>静态方法将会在参数为null时主动抛出<code>NullPointerException</code>异常。这省去了重复编写if语句和抛出空指针异常的麻烦。</p></blockquote><p>要想实现组合，需要两个或多个Lambda表达式即可，而<code>andThen</code>的语义正是“一步接一步”操作。例如两个步骤组合的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10ConsumerAndThen</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeString</span><span class="hljs-params">(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two)</span> </span>&#123;<br>        one.andThen(two).accept(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        consumeString(<br>                s -&gt; System.out.println(s.toUpperCase()),<br>                s -&gt; System.out.println(s.toLowerCase()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-4-3-Predicate接口"><a href="#6-4-3-Predicate接口" class="headerlink" title="6.4.3 Predicate接口"></a>6.4.3 Predicate接口</h3><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用<code>java.util.function.Predicate&lt;T&gt;</code>接口。</p><h4 id="抽象方法：test"><a href="#抽象方法：test" class="headerlink" title="抽象方法：test"></a>抽象方法：test</h4><p><code>Predicate</code>接口中包含一个抽象方法：<code>boolean test(T t)</code>。用于条件判断的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo15PredicateTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;String&gt; predicate)</span> </span>&#123;<br><span class="hljs-keyword">boolean</span> veryLong = predicate.test(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;字符串很长吗：&quot;</span> + veryLong);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method(s ‐&gt; s.length() &gt; <span class="hljs-number">5</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。</p><h4 id="默认方法：and"><a href="#默认方法：and" class="headerlink" title="默认方法：and"></a>默认方法：and</h4><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个<code>Predicate</code>条件使用“与”逻辑连接起来实现“<strong>并且</strong>”的效果时，可以使用default方法<code>and</code>。其JDK源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;<br>Objects.requireNonNull(other);<br><span class="hljs-keyword">return</span> (t) ‐&gt; test(t) &amp;&amp; other.test(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16PredicateAnd</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> </span>&#123;<br><span class="hljs-keyword">boolean</span> isValid = one.and(two).test(<span class="hljs-string">&quot;Helloworld&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;字符串符合要求吗：&quot;</span> + isValid);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method(s ‐&gt; s.contains(<span class="hljs-string">&quot;H&quot;</span>), s ‐&gt; s.contains(<span class="hljs-string">&quot;W&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="默认方法：or"><a href="#默认方法：or" class="headerlink" title="默认方法：or"></a>默认方法：or</h4><p>与<code>and</code>的“与”类似，默认方法<code>or</code>实现逻辑关系中的“<strong>或</strong>”。JDK源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;<br>Objects.requireNonNull(other);<br><span class="hljs-keyword">return</span> (t) ‐&gt; test(t) || other.test(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称即可，其他都不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16PredicateAnd</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> </span>&#123;<br><span class="hljs-keyword">boolean</span> isValid = one.or(two).test(<span class="hljs-string">&quot;Helloworld&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;字符串符合要求吗：&quot;</span> + isValid);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method(s ‐&gt; s.contains(<span class="hljs-string">&quot;H&quot;</span>), s ‐&gt; s.contains(<span class="hljs-string">&quot;W&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="默认方法：negate"><a href="#默认方法：negate" class="headerlink" title="默认方法：negate"></a>默认方法：negate</h4><p>默认方法<code>negate</code>的含义为的“非”（取反）。JDK源代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">negate</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> (t) ‐&gt; !test(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>从实现中容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在test 方法调用之前调用<code>negate</code>方法，正如<code>and</code>和<code>or</code>方法一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo17PredicateNegate</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;String&gt; predicate)</span> </span>&#123;<br><span class="hljs-keyword">boolean</span> veryLong = predicate.negate().test(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;字符串很长吗：&quot;</span> + veryLong);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method(s ‐&gt; s.length() &lt; <span class="hljs-number">5</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-4-4-Function接口"><a href="#6-4-4-Function接口" class="headerlink" title="6.4.4 Function接口"></a>6.4.4 Function接口</h3><p><code>java.util.function.Function&lt;T,R&gt;</code>接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p><h4 id="抽象方法：apply"><a href="#抽象方法：apply" class="headerlink" title="抽象方法：apply"></a>抽象方法：apply</h4><p><code>Function</code>接口中最主要的抽象方法为：<code> R apply(T t)</code>，根据类型T的参数获取类型R的结果。使用的场景例如：将<code>String</code>类型转换为<code>Integer</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11FunctionApply</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Function&lt;String, Integer&gt; function)</span> </span>&#123;<br><span class="hljs-keyword">int</span> num = function.apply(<span class="hljs-string">&quot;10&quot;</span>);<br>System.out.println(num + <span class="hljs-number">20</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method(s ‐&gt; Integer.parseInt(s));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，最好是通过方法引用的写法。</p><h4 id="默认方法：andThen-1"><a href="#默认方法：andThen-1" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h4><p><code>Function</code>接口中有一个默认的<code>andThen</code>方法，用来进行组合操作。JDK源代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;<br>Objects.requireNonNull(after);<br><span class="hljs-keyword">return</span> (T t) ‐&gt; after.apply(apply(t));<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法同样用于“先做什么，再做什么”的场景，和<code>Consumer</code>中的<code>andThen</code>差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12FunctionAndThen</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two)</span> </span>&#123;<br><span class="hljs-keyword">int</span> num = one.andThen(two).apply(<span class="hljs-string">&quot;10&quot;</span>);<br>System.out.println(num + <span class="hljs-number">20</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method(str‐&gt;Integer.parseInt(str)+<span class="hljs-number">10</span>, i ‐&gt; i *= <span class="hljs-number">10</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过<code>andThen</code>按照前后顺序组合到了一起。</p><blockquote><p>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p></blockquote><hr><h2 id="6-5-Stream流"><a href="#6-5-Stream流" class="headerlink" title="6.5 Stream流"></a>6.5 Stream流</h2><p>在Java 8中，得益于Lambda所带来的函数式编程，引入了一个<strong>全新的Stream概念</strong>，用于解决已有集合类库既有的弊端。</p><h3 id="6-5-1-概述"><a href="#6-5-1-概述" class="headerlink" title="6.5.1 概述"></a>6.5.1 概述</h3><p>Stream（流）是一个来自数据源的元素队列</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li><strong>数据源</strong>流的来源。 可以是集合，数组 等</li></ul><blockquote><p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p></blockquote><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><ul><li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluentstyle）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li><li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li></ul><h3 id="6-5-2-获取流"><a href="#6-5-2-获取流" class="headerlink" title="6.5.2 获取流"></a>6.5.2 获取流</h3><p><code>java.util.stream.Stream&lt;T&gt;</code>是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）<br>获取一个流有以下几种常用的方式：</p><ul><li><p>所有的Collection 集合都可以通过stream 默认方法获取流；</p></li><li><p>Stream 接口的静态方法of可以获取数组对应的流。</p></li></ul><h4 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h4><p><code>java.util.Collection</code>接口中加入了<code>default</code>方法<code>stream</code>用来获取流，所以其所有实现类均可获取流。</p><h4 id="根据Map获取流"><a href="#根据Map获取流" class="headerlink" title="根据Map获取流"></a>根据Map获取流</h4><p><code>java.util.Map</code>接口不是<code>Collection</code>的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05GetStream</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-comment">// ...</span><br>Stream&lt;String&gt; keyStream = map.keySet().stream();<br>Stream&lt;String&gt; valueStream = map.values().stream();<br>Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h4><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以<code>Stream</code>接口中提供了静态方法<code>of</code>：</p><blockquote><p>注： of方法的参数其实是一个可变参数，所以支持数组。</p></blockquote><h3 id="6-5-3-常用方法"><a href="#6-5-3-常用方法" class="headerlink" title="6.5.3 常用方法"></a>6.5.3 常用方法</h3><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p><ul><li>延迟方法：返回值类型仍然是<code>Stream</code>接口自身类型的方法，因此<strong>支持链式调用</strong>。（除了终结方法外，其余方<br>法均为延迟方法。）</li><li>终结方法：返回值类型不再是<code>Stream</code>接口自身类型的方法，因此不再支持类似StringBuilder那样的链式调<br>用。包括<code>count</code>和<code>forEach</code>方法。</li></ul><h4 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h4><p>虽然方法名字叫<code>forEach</code>，但是与for循环中的“for-each”昵称不同。</p><p><code>void forEach(Consumer&lt;? super T&gt; action);</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12StreamForEach</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>stream.forEach(name‐&gt; System.out.println(name));<br>      <span class="hljs-comment">//  stream.forEach(System.out::println);</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h4><p>可以通过<code>filter</code>方法将一个流转换成另一个子集流。</p><p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo07StreamFilter</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。</p><h4 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h4><p>如果需要将流中的元素映射到另一个流中，可以使用<code>map</code>方法</p><p><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08StreamMap</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;18&quot;</span>);<br>Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中， <code>map</code>方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为<code>Integer</code>类对象）。</p><h4 id="统计个数：count"><a href="#统计个数：count" class="headerlink" title="统计个数：count"></a>统计个数：count</h4><p>正如旧集合Collection当中的size方法一样，流提供count 方法来统计其中的元素个数</p><p><code>long count();</code></p><p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09StreamCount</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>System.out.println(result.count()); <span class="hljs-comment">// 2</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h4><p><code>limit</code>方法可以对流进行截取，只取用前n个。</p><p><code>Stream&lt;T&gt; limit(long maxSize);</code></p><p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10StreamLimit</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>Stream&lt;String&gt; result = original.limit(<span class="hljs-number">2</span>);<br>System.out.println(result.count()); <span class="hljs-comment">// 2</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h4><p>如果希望跳过前几个元素，可以使用skip 方法获取一个截取之后的新流：</p><p><code>Stream&lt;T&gt; skip(long n);</code></p><p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11StreamSkip</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>Stream&lt;String&gt; result = original.skip(<span class="hljs-number">2</span>);<br>System.out.println(result.count()); <span class="hljs-comment">// 1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h4><p>如果有两个流，希望合并成为一个流，那么可以使用<code>Stream</code>接口的静态方法<code>concat</code>：</p><p><code>static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code></p><blockquote><p>注：这是一个静态方法，与<code>java.lang.String</code>当中的<code>concat</code>方法是不同的。</p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12StreamConcat</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Stream&lt;String&gt; streamA = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>Stream&lt;String&gt; streamB = Stream.of(<span class="hljs-string">&quot;张翠山&quot;</span>);<br>Stream&lt;String&gt; result = Stream.concat(streamA, streamB);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-6-方法引用"><a href="#6-6-方法引用" class="headerlink" title="6.6 方法引用"></a>6.6 方法引用</h2><h3 id="6-6-1-概述"><a href="#6-6-1-概述" class="headerlink" title="6.6.1 概述"></a>6.6.1 概述</h3><p>双冒号<code>::</code>为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p><p>例如：</p><p>函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Printable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>lambda表达式调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01PrintSimple</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(Printable data)</span> </span>&#123;<br>data.print(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>printString(s ‐&gt; System.out.println(s));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02PrintRef</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(Printable data)</span> </span>&#123;<br>data.print(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>printString(System.out::println);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>System.out</code>对象中有一个重载的<code>println(String)</code>方法，下面两种写法，完全等效：</p><ul><li>Lambda表达式写法：<code> s -&gt; System.out.println(s);</code></li><li>方法引用写法： <code>System.out::println</code></li></ul><p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给<code>System.out.println</code>方法去处理。<br>第二种等效写法的语义是指：直接让<code>System.out</code>中的<code>println</code>方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。</p><blockquote><p>注:Lambda 中<strong>传递的参数</strong> 一定是<strong>方法引用中</strong>的那个方法可以接收的类型,否则会抛出异常</p></blockquote><h3 id="6-6-2-通过对象名引用成员方法"><a href="#6-6-2-通过对象名引用成员方法" class="headerlink" title="6.6.2 通过对象名引用成员方法"></a>6.6.2 通过对象名引用成员方法</h3><p>如果一个类中已经存在了一个成员方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodRefObject</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printUpperCase</span><span class="hljs-params">(String str)</span> </span>&#123;<br>System.out.println(str.toUpperCase());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数式接口仍然定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Printable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么当需要使用这个<code>printUpperCase</code>成员方法来替代<code>Printable</code>接口的Lambda的时候，已经具有了<code>MethodRefObject</code>类的对象实例，则可以通过对象名引用成员方法，代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04MethodRef</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(Printable lambda)</span> </span>&#123;<br>lambda.print(<span class="hljs-string">&quot;Hello&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>MethodRefObject obj = <span class="hljs-keyword">new</span> MethodRefObject();<br>printString(obj::printUpperCase);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-6-3-通过类名称引用静态方法"><a href="#6-6-3-通过类名称引用静态方法" class="headerlink" title="6.6.3 通过类名称引用静态方法"></a>6.6.3 通过类名称引用静态方法</h3><p>由于在<code>java.lang.Math</code>类中已经存在了静态方法<code>abs</code>，所以当我们需要通过Lambda来调用该方法时，有两种写法。</p><p>首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Calcable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一种写法是使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05Lambda</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, Calcable lambda)</span> </span>&#123;<br>System.out.println(lambda.calc(num));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method(‐<span class="hljs-number">10</span>, n ‐&gt; Math.abs(n));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法引用的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06MethodRef</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, Calcable lambda)</span> </span>&#123;<br>System.out.println(lambda.calc(num));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method(‐<span class="hljs-number">10</span>, Math::abs);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： <code>n -&gt; Math.abs(n)</code></li><li>方法引用： <code>Math::abs</code></li></ul><h3 id="6-6-4-通过super引用成员方法"><a href="#6-6-4-通过super引用成员方法" class="headerlink" title="6.6.4 通过super引用成员方法"></a>6.6.4 通过super引用成员方法</h3><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Greetable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是父类Human的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个子类Man的内容，其中使用了Lambda的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;大家好,我是Man!&quot;</span>);<br>&#125;<br><span class="hljs-comment">//定义方法method,参数传递Greetable接口</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Greetable g)</span></span>&#123;<br>g.greet();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//调用method方法,使用Lambda表达式</span><br>method(()‐&gt;&#123;<br><span class="hljs-comment">//创建Human对象,调用sayHello方法</span><br><span class="hljs-keyword">new</span> Human().sayHello();<br>&#125;);<br><span class="hljs-comment">//简化Lambda</span><br>method(()‐&gt;<span class="hljs-keyword">new</span> Human().sayHello());<br><span class="hljs-comment">//使用super关键字代替父类对象</span><br>method(()‐&gt;<span class="hljs-keyword">super</span>.sayHello());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用方法引用来调用父类中的<code>sayHello</code>方法会更好，例如另一个子类Woman ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;大家好,我是Man!&quot;</span>);<br>&#125;<br><span class="hljs-comment">//定义方法method,参数传递Greetable接口</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Greetable g)</span></span>&#123;<br>g.greet();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>method(<span class="hljs-keyword">super</span>::sayHello);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式：<code> () -&gt; super.sayHello()</code></li><li>方法引用：<code> super::sayHello</code></li></ul><h3 id="6-6-5-通过this引用成员方法"><a href="#6-6-5-通过this引用成员方法" class="headerlink" title="6.6.5 通过this引用成员方法"></a>6.6.5 通过this引用成员方法</h3><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“<strong>this::成员方法</strong>”的格式来使用方法引用。</p><p>首先是简单的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Richable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个丈夫Husband类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">marry</span><span class="hljs-params">(Richable lambda)</span> </span>&#123;<br>lambda.buy();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beHappy</span><span class="hljs-params">()</span> </span>&#123;<br>marry(() ‐&gt; System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>开心方法<code>beHappy</code>调用了结婚方法<code>marry</code>，后者的参数为函数式接口<code>Richable</code>，所以需要一个Lambda表达式。但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对Husband 丈夫类进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buyHouse</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">marry</span><span class="hljs-params">(Richable lambda)</span> </span>&#123;<br>lambda.buy();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beHappy</span><span class="hljs-params">()</span> </span>&#123;<br>marry(() ‐&gt; <span class="hljs-keyword">this</span>.buyHouse());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buyHouse</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">marry</span><span class="hljs-params">(Richable lambda)</span> </span>&#123;<br>lambda.buy();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beHappy</span><span class="hljs-params">()</span> </span>&#123;<br>marry(<span class="hljs-keyword">this</span>::buyHouse);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： <code>() -&gt; this.buyHouse()</code></li><li>方法引用：<code> this::buyHouse</code></li></ul><h3 id="6-6-6-类的构造器引用"><a href="#6-6-6-类的构造器引用" class="headerlink" title="6.6.6 类的构造器引用"></a>6.6.6 类的构造器引用</h3><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用<strong>类名称::new</strong>的格式表示。</p><p>首先是一个简单的Person 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用来创建Person 对象的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><span class="hljs-function">Person <span class="hljs-title">buildPerson</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用这个函数式接口，可以通过Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09Lambda</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printName</span><span class="hljs-params">(String name, PersonBuilder builder)</span> </span>&#123;<br>System.out.println(builder.buildPerson(name).getName());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>printName(<span class="hljs-string">&quot;张三&quot;</span>, name ‐&gt; <span class="hljs-keyword">new</span> Person(name));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过构造器引用，有更好的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10ConstructorRef</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printName</span><span class="hljs-params">(String name, PersonBuilder builder)</span> </span>&#123;<br>System.out.println(builder.buildPerson(name).getName());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>printName(<span class="hljs-string">&quot;张三&quot;</span>, Person::<span class="hljs-keyword">new</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： <code>name -&gt; new Person(name)</code></li><li>方法引用： <code>Person::new</code></li></ul><h3 id="6-6-7-数组的构造器引用"><a href="#6-6-7-数组的构造器引用" class="headerlink" title="6.6.7 数组的构造器引用"></a>6.6.7 数组的构造器引用</h3><p>数组也是<code>Object</code>的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，需要一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ArrayBuilder</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] buildArray(<span class="hljs-keyword">int</span> length);<br>&#125;<br></code></pre></td></tr></table></figure><p>在应用该接口的时候，可以通过Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11ArrayInitRef</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] initArray(<span class="hljs-keyword">int</span> length, ArrayBuilder builder) &#123;<br><span class="hljs-keyword">return</span> builder.buildArray(length);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] array = initArray(<span class="hljs-number">10</span>, length ‐&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更好的写法是使用数组的构造器引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12ArrayInitRef</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] initArray(<span class="hljs-keyword">int</span> length, ArrayBuilder builder) &#123;<br><span class="hljs-keyword">return</span> builder.buildArray(length);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] array = initArray(<span class="hljs-number">10</span>, <span class="hljs-keyword">int</span>[]::<span class="hljs-keyword">new</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式：<code> length -&gt; new int[length]</code></li><li>方法引用： <code>int[]::new</code></li></ul><hr><h2 id="6-7-内部类"><a href="#6-7-内部类" class="headerlink" title="6.7 内部类"></a>6.7 内部类</h2><h3 id="6-7-1-概述"><a href="#6-7-1-概述" class="headerlink" title="6.7.1 概述"></a>6.7.1 概述</h3><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为外部类。</p><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul><li>成员内部类：定义在类中方法外的类</li></ul><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 外部类 </span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">class</span> 内部类</span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="访问特点"><a href="#访问特点" class="headerlink" title="访问特点"></a>访问特点</h5><ul><li>内部类可以直接访问外部类的成员，<strong>包括私有成员</strong>。</li><li>外部类要访问内部类的成员，必须要<strong>建立内部类的对象</strong>。</li></ul><p>创建内部类对象格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类名.内部类名 对象名 = <span class="hljs-keyword">new</span> 外部类型().new 内部类型()；<br></code></pre></td></tr></table></figure><blockquote><p>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。</p></blockquote><blockquote><p>内部类中声明的所有静态域都必须是final</p><p>内部类不能有static方法</p></blockquote><h3 id="6-7-2-匿名内部类"><a href="#6-7-2-匿名内部类" class="headerlink" title="6.7.2 匿名内部类"></a>6.7.2 匿名内部类</h3><ul><li><strong>匿名内部类</strong>：是内部类的简化写法。它的本质是一个<strong>带具体实现的父类</strong>或者<strong>父接口的匿名的子类对象</strong>。开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作</li></ul><ol><li>定义子类</li><li>重写接口中的方法</li><li>创建子类对象</li><li>调用重写后的方法</li></ol><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 父类名或者接口名()&#123;<br><span class="hljs-comment">// 方法重写</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 执行语句</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyAble</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建匿名内部类，并调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.等号右边:是匿名内部类，定义并创建该接口的子类对象</span><br><span class="hljs-comment">2.等号左边:是多态赋值,接口类型引用指向子类对象</span><br><span class="hljs-comment">*/</span><br>FlyAble f = <span class="hljs-keyword">new</span> FlyAble()&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>&#125;<br>&#125;;<br><span class="hljs-comment">//调用 fly方法,执行重写后的方法</span><br>f.fly();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerDemo2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.等号右边:定义并创建该接口的子类对象</span><br><span class="hljs-comment">2.等号左边:是多态,接口类型引用指向子类对象</span><br><span class="hljs-comment">*/</span><br>FlyAble f = <span class="hljs-keyword">new</span> FlyAble()&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>&#125;<br>    &#125;;<br><span class="hljs-comment">// 将f传递给showFly方法中</span><br>showFly(f);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showFly</span><span class="hljs-params">(FlyAble f)</span> </span>&#123;<br>f.fly();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上两步，也可以简化为一步，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerDemo3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">创建匿名内部类,直接传递给showFly(FlyAble f)</span><br><span class="hljs-comment">*/</span><br>showFly( <span class="hljs-keyword">new</span> FlyAble()&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>&#125;<br>&#125;);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showFly</span><span class="hljs-params">(FlyAble f)</span> </span>&#123;<br>f.fly();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="第7章-异常、断言和日志"><a href="#第7章-异常、断言和日志" class="headerlink" title="第7章 异常、断言和日志"></a>第7章 异常、断言和日志</h1><h2 id="7-1-异常"><a href="#7-1-异常" class="headerlink" title="7.1 异常"></a>7.1 异常</h2><h3 id="7-1-1-概述"><a href="#7-1-1-概述" class="headerlink" title="7.1.1 概述"></a>7.1.1 概述</h3><ul><li><strong>异常</strong>：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li></ul><p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p><blockquote><p>异常指的并不是语法错误,语法错了，编译不通过，不会产生字节码文件,根本不能运行。</p></blockquote><h3 id="7-1-2-异常体系"><a href="#7-1-2-异常体系" class="headerlink" title="7.1.2 异常体系"></a>7.1.2 异常体系</h3><p>在Java程序设计语言中，异常对象都是派生于<code>java.lang.Throwable</code>。其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/7.1.png" alt="pic"></p><h4 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h4><p>Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。Error类是无法通过处理的错误，只能事先避免。</p><h4 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h4><p>Exception类表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。</p><h3 id="7-1-3-异常分类"><a href="#7-1-3-异常分类" class="headerlink" title="7.1.3 异常分类"></a>7.1.3 异常分类</h3><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p><p><strong>异常(Exception)的分类:根据在编译时期还是运行时期去检查异常。</strong></p><h4 id="编译时期异常"><a href="#编译时期异常" class="headerlink" title="编译时期异常"></a>编译时期异常</h4><p><strong>checked（受查）异常</strong>。在编译时期，就会检查，如果没有处理异常，则编译失败。(如日期格式化异常)</p><h4 id="运行时期异常"><a href="#运行时期异常" class="headerlink" title="运行时期异常"></a>运行时期异常</h4><p><strong>runtime+Error（unchecked非受查）异常</strong>。在运行时期，检查异常。在编译时期，运行异常不会编译器检测(不报错)。(如数学异常)</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/7.2.png" alt="pic"></p><p><em><strong>如果出现RuntimeException异常，那一定是自己的问题</strong></em></p><h3 id="7-1-4-异常的产生过程解析"><a href="#7-1-4-异常的产生过程解析" class="headerlink" title="7.1.4 异常的产生过程解析"></a>7.1.4 异常的产生过程解析</h3><p>先运行下面的程序，程序会产生一个数组索引越界异常<code>ArrayIndexOfBoundsException</code>。</p><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayTools</span> </span>&#123;<br><span class="hljs-comment">// 对给定的数组通过给定的角标获取元素。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br><span class="hljs-keyword">int</span> element = arr[index];<br><span class="hljs-keyword">return</span> element;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">67</span> &#125;;<br>intnum = ArrayTools.getElement(arr, <span class="hljs-number">4</span>)<br>System.out.println(<span class="hljs-string">&quot;num=&quot;</span> + num);<br>System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述程序执行过程图解：</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/7.3.png" alt="pic"></p><h3 id="7-1-5-Throwable中的常用方法"><a href="#7-1-5-Throwable中的常用方法" class="headerlink" title="7.1.5 Throwable中的常用方法"></a>7.1.5 Throwable中的常用方法</h3><ul><li><code>public void printStackTrace()</code>:打印异常的详细信息。<br>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用<code>printStackTrace</code>。</li><li><code>public String getMessage()</code>:获取发生异常的原因。<br>提示给用户的时候,就提示错误原因。</li><li><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</li></ul><hr><h2 id="7-2-异常的处理"><a href="#7-2-异常的处理" class="headerlink" title="7.2 异常的处理"></a>7.2 异常的处理</h2><p>Java异常处理的五个关键字：try、catch、finally、throw、throws</p><h3 id="7-2-1-抛出异常throw"><a href="#7-2-1-抛出异常throw" class="headerlink" title="7.2.1 抛出异常throw"></a>7.2.1 抛出异常throw</h3><p>在java中，提供了一个<code>throw</code>关键字，它用来抛出一个指定的异常对象。</p><p><strong>使用步骤：</strong></p><ol><li>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</li><li>需要将这个异常对象告知给调用者。通过关键字throw就可以完成。throw 异常对象。<br>throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</li></ol><p><strong>使用格式：</strong></p><p><code>throw new 异常类名(参数);</code></p><p>throw代码参考如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建一个数组</span><br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">52</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-comment">//根据索引找对应的元素</span><br><span class="hljs-keyword">int</span> index = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> element = getElement(arr, index);<br>System.out.println(element);<br>System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 根据 索引找到数组中对应的元素</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> index)</span></span>&#123;<br><span class="hljs-comment">//判断 索引是否越界</span><br><span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;arr.length‐<span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span><br><span class="hljs-comment">这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(<span class="hljs-string">&quot;哥们，角标越界了~~~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">int</span> element = arr[index];<br><span class="hljs-keyword">return</span> element;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/10/17/Java/JavaSE/JavaSE/7.4.png" alt="pic"></p><h3 id="7-2-2-声明异常throws"><a href="#7-2-2-声明异常throws" class="headerlink" title="7.2.2 声明异常throws"></a>7.2.2 声明异常throws</h3><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过<code>throw</code>抛出了编译时异常，而没有捕获处理，那么必须通过<code>throws</code>进行声明，让调用者去处理。</p><p>关键字<code>throws</code>运用于<strong>方法声明</strong>之上，用于表示<strong>当前方法不处理异常</strong>，而是提醒该方法的调用者来处理异常(抛出异常)。</p><p><strong>使用格式：</strong></p><p><code>修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125;</code></p><p>throws代码参考如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowsDemo2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span><span class="hljs-keyword">throws</span> FileNotFoundException, IOException </span>&#123;<br><span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;b.txt&quot;</span>)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-3-捕获异常try…catch"><a href="#7-2-3-捕获异常try…catch" class="headerlink" title="7.2.3 捕获异常try…catch"></a>7.2.3 捕获异常try…catch</h3><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p><ol><li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li><li>在方法中使用try-catch的语句块来处理异常。</li></ol><p><strong>try-catch</strong>的方式就是捕获异常。</p><ul><li>捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li></ul><p><strong>使用格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型 e)&#123;<br>处理异常的代码<br><span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>try</strong>：该代码块中编写可能产生异常的代码。</p><p><strong>catch</strong>：用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><blockquote><p>注:try和catch都不能单独使用，必须连用。</p></blockquote><p>try-catch参考代码在finally部分。</p><h3 id="7-2-4-finally-代码块"><a href="#7-2-4-finally-代码块" class="headerlink" title="7.2.4 finally 代码块"></a>7.2.4 finally 代码块</h3><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><p><strong>使用格式：</strong></p><p><code>try...catch....finally</code>:自身需要处理异常,最终还得关闭资源。</p><blockquote><p>注：finally不能单独使用。</p></blockquote><p>finally代码参考如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryCatchDemo4</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br><span class="hljs-comment">//抓取到的是编译期异常 抛出去的是运行期</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;不管程序怎样，这里都将会被执行。&quot;</span>);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 我们 当前的这个方法中 有异常 有编译期异常</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br><span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally<strong>永远会执行</strong>。</p></blockquote><h3 id="7-2-5-异常注意事项"><a href="#7-2-5-异常注意事项" class="headerlink" title="7.2.5 异常注意事项"></a>7.2.5 异常注意事项</h3><p>多个异常使用捕获，如何处理</p><ol><li>多个异常分别处理。</li><li>多个异常一次捕获，多次处理。</li><li>多个异常一次捕获一次处理。</li></ol><p>一般我们是使用一次捕获多次处理方式，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型A e)&#123; 当<span class="hljs-keyword">try</span>中出现A类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>处理异常的代码<br><span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型B e)&#123; 当<span class="hljs-keyword">try</span>中出现B类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>处理异常的代码<br><span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p></blockquote><ul><li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p></li><li><p>如果finally有return语句,永远返回finally中的结果,避免该情况。</p></li><li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p></li><li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p></li></ul><hr><h2 id="7-3-自定义异常"><a href="#7-3-自定义异常" class="headerlink" title="7.3 自定义异常"></a>7.3 自定义异常</h2><h3 id="7-3-1-概述"><a href="#7-3-1-概述" class="headerlink" title="7.3.1 概述"></a>7.3.1 概述</h3><p><strong>自定义异常类</strong>：在开发中根据自己业务的异常情况来定义异常类。</p><p><strong>异常类如何定义：</strong></p><ul><li>自定义一个<strong>编译期异常</strong>：自定义类，并继承于<code>java.lang.Exception</code>。</li></ul><ol start="2"><li>自定义一个<strong>运行时期的异常类</strong>：自定义类，并继承于`java.lang.RuntimeException。</li></ol><h3 id="7-3-2-举例"><a href="#7-3-2-举例" class="headerlink" title="7.3.2 举例"></a>7.3.2 举例</h3><p>首先定义一个登陆异常类RegisterException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 业务逻辑异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br><span class="hljs-comment">// 空参构造</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegisterException</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> message 表示异常提示</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegisterException</span><span class="hljs-params">(String message)</span> </span>&#123;<br><span class="hljs-keyword">super</span>(message);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-comment">// 模拟数据库中已存在账号</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String[] names = &#123;<span class="hljs-string">&quot;bill&quot;</span>,<span class="hljs-string">&quot;hill&quot;</span>,<span class="hljs-string">&quot;jill&quot;</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//调用方法</span><br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// 可能出现异常的代码</span><br>checkUsername(<span class="hljs-string">&quot;bill&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;注册成功&quot;</span>);<span class="hljs-comment">//如果没有异常就是注册成功</span><br>&#125;<span class="hljs-keyword">catch</span>(RegisterException e)&#123;<br><span class="hljs-comment">//处理异常</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-comment">//判断当前注册账号是否存在</span><br><span class="hljs-comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkUsername</span><span class="hljs-params">(String uname)</span> <span class="hljs-keyword">throws</span> LoginException</span>&#123;<br><span class="hljs-keyword">for</span> (String name : names) &#123;<br><span class="hljs-keyword">if</span>(name.equals(uname))&#123;<span class="hljs-comment">//如果名字在这里面 就抛出登陆异常</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RegisterException(<span class="hljs-string">&quot;亲&quot;</span>+name+<span class="hljs-string">&quot;已经被注册了！&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/7.5.png" alt="pic"></p><hr><h2 id="7-4-断言"><a href="#7-4-断言" class="headerlink" title="7.4 断言"></a>7.4 断言</h2><h3 id="7-4-1-概述"><a href="#7-4-1-概述" class="headerlink" title="7.4.1 概述"></a>7.4.1 概述</h3><p>编写代码时，我们总是会做出一些假设，断言就是用于在代码中捕捉这些假设。程序员相信在程序中的某个特定点该表达式值为真，可以在任何时候启用和禁用断言验证，因此<strong>可以在测试时启用断言而在部署时禁用断言</strong>。同样，程序投入运行后，在遇到问题时可以重新启用断言。</p><p>断言机制允许在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句将会被自动地移走。</p><p>Java语言引入了关键字<code>assert</code>，进行断言。</p><h3 id="7-4-2-IDE配置"><a href="#7-4-2-IDE配置" class="headerlink" title="7.4.2 IDE配置"></a>7.4.2 IDE配置</h3><p><img src="/2019/10/17/Java/JavaSE/JavaSE/7.6.png" alt="pic"></p><h3 id="7-4-3-使用方法"><a href="#7-4-3-使用方法" class="headerlink" title="7.4.3 使用方法"></a>7.4.3 使用方法</h3><p>有两种使用方法</p><ol><li><p><code>assert 条件;</code></p></li><li><p><code>assert 条件 : 表达式;</code></p></li></ol><p>使用第一种格式，当布尔类型表达式为false时，抛出AssertionError异常；如果是第二种格式，则输出错误消息。</p><hr><h2 id="7-5-日志"><a href="#7-5-日志" class="headerlink" title="7.5 日志"></a>7.5 日志</h2><hr><h1 id="第9章-集合"><a href="#第9章-集合" class="headerlink" title="第9章 集合"></a>第9章 集合</h1><h2 id="9-1-Collection集合"><a href="#9-1-Collection集合" class="headerlink" title="9.1 Collection集合"></a>9.1 Collection集合</h2><h3 id="9-1-1-概述"><a href="#9-1-1-概述" class="headerlink" title="9.1.1 概述"></a>9.1.1 概述</h3><ul><li>集合：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有什么区别</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><blockquote><p>Java集合类库将<em><strong>接口</strong></em>与<em><strong>实现</strong></em>进行分离</p><p>Collection集合取出元素的方式可以采用：迭代器、增强for</p></blockquote><h3 id="9-1-2-集合框架"><a href="#9-1-2-集合框架" class="headerlink" title="9.1.2 集合框架"></a>9.1.2 集合框架</h3><p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>。</p><p>Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。</p><p>其中，<code>List</code>的特点是元素<strong>有序</strong>、元素<strong>可重复</strong>。</p><p><code>Set</code>的特点是元素<strong>无序</strong>，而且<strong>不可重复</strong>。</p><p>List 接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/9.1.png" alt="pic"></p><h3 id="9-1-3-Collection常用API"><a href="#9-1-3-Collection常用API" class="headerlink" title="9.1.3 Collection常用API"></a>9.1.3 Collection常用API</h3><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>： 把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code>:清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><hr><h2 id="9-2-Iterator迭代器"><a href="#9-2-Iterator迭代器" class="headerlink" title="9.2 Iterator迭代器"></a>9.2 Iterator迭代器</h2><h3 id="9-2-1-概述"><a href="#9-2-1-概述" class="headerlink" title="9.2.1 概述"></a>9.2.1 概述</h3><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code> 。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同， Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection 中的元素，因此Iterator 对象也被称为<strong>迭代器</strong>。</p><h3 id="9-2-2-获取方法"><a href="#9-2-2-获取方法" class="headerlink" title="9.2.2 获取方法"></a>9.2.2 获取方法</h3><p><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</p><h3 id="9-2-3-迭代器常用API"><a href="#9-2-3-迭代器常用API" class="headerlink" title="9.2.3 迭代器常用API"></a>9.2.3 迭代器常用API</h3><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li><li><code>public void remove()</code>:移除iterator.next()方法最后访问的元素。</li><li><code>default void forEachRemaining(Consumer&lt;? super E&gt; action)</code>:对集合中剩余的元素进行操作。</li></ul><h3 id="9-2-4-迭代器的实现原理"><a href="#9-2-4-迭代器的实现原理" class="headerlink" title="9.2.4 迭代器的实现原理"></a>9.2.4 迭代器的实现原理</h3><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素。</p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><hr><h2 id="9-3-List集合"><a href="#9-3-List集合" class="headerlink" title="9.3 List集合"></a>9.3 List集合</h2><h3 id="9-3-1-概述"><a href="#9-3-1-概述" class="headerlink" title="9.3.1 概述"></a>9.3.1 概述</h3><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中<strong>允许出现重复的元素</strong>，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是<strong>元素有序</strong>，即元素的存入顺序和取出顺序一致。</p><h3 id="9-3-2-特点"><a href="#9-3-2-特点" class="headerlink" title="9.3.2 特点"></a>9.3.2 特点</h3><ul><li><p>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</p></li><li><p>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</p></li><li><p>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</p></li></ul><h3 id="9-3-3-List接口中常用方法"><a href="#9-3-3-List接口中常用方法" class="headerlink" title="9.3.3 List接口中常用方法"></a>9.3.3 List接口中常用方法</h3><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><p><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</p></li><li><p><code>public E get(int index)</code>:返回集合中指定位置的元素。</p></li><li><p><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</p></li><li><p><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</p></li></ul><blockquote><p>List集合特有的方法都是跟<strong>索引</strong>相关</p><p>List接口的实现类包括：ArrayList，LinkedList</p></blockquote><h3 id="9-3-4-ArrayList集合"><a href="#9-3-4-ArrayList集合" class="headerlink" title="9.3.4 ArrayList集合"></a>9.3.4 ArrayList集合</h3><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。</p><h3 id="9-3-4-LinkedList集合"><a href="#9-3-4-LinkedList集合" class="headerlink" title="9.3.4 LinkedList集合"></a>9.3.4 LinkedList集合</h3><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表。（在Java中，所有链表都是双向链接的）</p></blockquote><p><img src="/2019/10/17/Java/JavaSE/JavaSE/9.2.png" alt="pic"></p><h4 id="LinkedList集合中常用方法"><a href="#LinkedList集合中常用方法" class="headerlink" title="LinkedList集合中常用方法"></a>LinkedList集合中常用方法</h4><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><blockquote><p>在开发时，LinkedList集合可以作为堆栈，队列的结构使用。</p></blockquote><hr><h2 id="9-4-Set集合"><a href="#9-4-Set集合" class="headerlink" title="9.4 Set集合"></a>9.4 Set集合</h2><h3 id="9-4-1-概述"><a href="#9-4-1-概述" class="headerlink" title="9.4.1 概述"></a>9.4.1 概述</h3><p><code>java.util.Set</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，它与<code>Collection</code>接口中的方法基本一致，并没有对Collection 接口进行功能上的扩充，只是比Collection 接口更加严格了。<code>Set</code>接口中元素<strong>无序</strong>，并且都会以某种规则保证存入的<strong>元素不出现重复</strong>。</p><h3 id="9-4-2-特点"><a href="#9-4-2-特点" class="headerlink" title="9.4.2 特点"></a>9.4.2 特点</h3><ul><li>元素无序</li><li>元素不能重复</li></ul><blockquote><p>Set接口的实现类包括：HashSet，LinkedHashSet</p></blockquote><h3 id="9-4-3-HashSet集合"><a href="#9-4-3-HashSet集合" class="headerlink" title="9.4.3 HashSet集合"></a>9.4.3 HashSet集合</h3><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持。</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><h4 id="HashSet集合存储数据的结构（哈希表）"><a href="#HashSet集合存储数据的结构（哈希表）" class="headerlink" title="HashSet集合存储数据的结构（哈希表）"></a>HashSet集合存储数据的结构（哈希表）</h4><p>在JDK1.8之前，哈希表底层采用<strong>数组+链表</strong>实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用<strong>数组+链表+红黑树</strong>实现，当链表长度超过阈值（<strong>8</strong>）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/9.3.png" alt="pic"></p><p>存储流程：</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/9.4.png" alt="pic"></p><blockquote><p>如果往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p></blockquote><h3 id="9-4-4-LinkedHashSet集合"><a href="#9-4-4-LinkedHashSet集合" class="headerlink" title="9.4.4 LinkedHashSet集合"></a>9.4.4 LinkedHashSet集合</h3><p><code>java.util.LinkedHashSet</code>是HashSet子类，它是链表和哈希表组合的一个数据存储结构。保证元素唯一时，记录存储顺序。</p><hr><h2 id="9-5-Collections类"><a href="#9-5-Collections类" class="headerlink" title="9.5 Collections类"></a>9.5 Collections类</h2><h3 id="9-5-1-概述"><a href="#9-5-1-概述" class="headerlink" title="9.5.1 概述"></a>9.5.1 概述</h3><p>此类完全由在collection上进行操作或返回collection的静态方法组成。</p><p><code>java.utils.Collections</code>是集合工具类</p><h3 id="9-5-2-常用API"><a href="#9-5-2-常用API" class="headerlink" title="9.5.2 常用API"></a>9.5.2 常用API</h3><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list)</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><h3 id="9-5-3-Comparator比较器"><a href="#9-5-3-Comparator比较器" class="headerlink" title="9.5.3 Comparator比较器"></a>9.5.3 Comparator比较器</h3><p>两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p><ul><li><code>public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</li></ul><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。<br>如果要按照升序排序， 则o1小于o2，返回（负数），相等返回0，o1大于o2返回（正数）。 如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，o1大于o2返回（负数）</p></blockquote><p>Comparable和Comparator的区别。</p><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>：强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><hr><h2 id="9-6-Map集合"><a href="#9-6-Map集合" class="headerlink" title="9.6 Map集合"></a>9.6 Map集合</h2><h3 id="9-6-1-概述"><a href="#9-6-1-概述" class="headerlink" title="9.6.1 概述"></a>9.6.1 概述</h3><p>Java提供了<code>java.util.Map</code>接口用来存放具有映射关系的对象。</p><ul><li><p><code>Collection</code>中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。</p></li><li><p><code>Map</code>中的集合，元素是成对存在的。每个元素由键与值两部分组成，通过键可以找对所对应的值。</p></li><li><p><code>Collection</code>中的集合称为单列集合， <code>Map</code>中的集合称为双列集合。</p></li><li><p><strong>Map 中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</strong></p></li></ul><h3 id="9-6-2-Map常用子类"><a href="#9-6-2-Map常用子类" class="headerlink" title="9.6.2 Map常用子类"></a>9.6.2 Map常用子类</h3><p>Map有多个子类，常用的有HashMap集合、LinkedHashMap集合。</p><ul><li><p><strong>HashMap</strong>：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</p></li><li><p><strong>LinkedHashMap</strong>：<code>HashMap</code>下有个子类<code>LinkedHashMap</code>，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</p></li></ul><h3 id="9-6-3-Map常用API"><a href="#9-6-3-Map常用API" class="headerlink" title="9.6.3 Map常用API"></a>9.6.3 Map常用API</h3><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>: 把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code>:根据指定的键，在Map集合中获取对应的值。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():</code> 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><blockquote><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中；<br>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</p></blockquote><h3 id="9-6-4-Entry键值对对象"><a href="#9-6-4-Entry键值对对象" class="headerlink" title="9.6.4 Entry键值对对象"></a>9.6.4 Entry键值对对象</h3><p><code>Map</code>中存放的是两种对象，一种称为<code>key</code>(键)，一种称为<code>value</code>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry</code>(项) 。<code>Entry</code>将键值对的对应关系封装成了对象。即<strong>键值对对象</strong>，在遍历Map 集合时，可以从每一个键值对（ <code>Entry</code> ）对象中获取对应的键与对应的值。</p><p>在Map集合中获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>Entry对象的方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值</li></ul><hr><h2 id="9-7-HashMap集合"><a href="#9-7-HashMap集合" class="headerlink" title="9.7 HashMap集合"></a>9.7 HashMap集合</h2><p>见集合源码</p><hr><h2 id="9-8-LinkedHashMap集合"><a href="#9-8-LinkedHashMap集合" class="headerlink" title="9.8 LinkedHashMap集合"></a>9.8 LinkedHashMap集合</h2><p>在<code>HashMap</code>下面有一个子类<code>LinkedHashMap</code>，它是链表和哈希表组合的一个数据存储结构。保证成对元素唯一，并且有序。</p><hr><h1 id="第14章-并发"><a href="#第14章-并发" class="headerlink" title="第14章 并发"></a>第14章 并发</h1><h2 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h2><h3 id="14-1-1-并发与并行"><a href="#14-1-1-并发与并行" class="headerlink" title="14.1.1 并发与并行"></a>14.1.1 并发与并行</h3><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li></ul><h3 id="14-1-2-线程与进程"><a href="#14-1-2-线程与进程" class="headerlink" title="14.1.2 线程与进程"></a>14.1.2 线程与进程</h3><ul><li><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个<strong>独立的内存空间</strong>，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是<strong>系统运行程序的基本单位</strong>；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li><li><strong>线程</strong>：线程是<strong>进程中的一个执行单元</strong>，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</li></ul><h2 id="14-2-线程"><a href="#14-2-线程" class="headerlink" title="14.2 线程"></a>14.2 线程</h2><h3 id="14-2-1-多线程原理"><a href="#14-2-1-多线程原理" class="headerlink" title="14.2.1 多线程原理"></a>14.2.1 多线程原理</h3><p>代码如下：</p><p>自定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><span class="hljs-comment">// 继承Thread类,将线程名称传递，进行设置</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span></span>&#123;<br><span class="hljs-keyword">super</span>(name);<br>&#125;<br><span class="hljs-comment">//重写run方法，定义线程要执行的代码</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br><span class="hljs-comment">//getName()方法 来自父亲</span><br>System.out.println(getName()+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;这里是main线程&quot;</span>);<br>MyThread mt = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;小强&quot;</span>);<br>mt.start();<span class="hljs-comment">//开启了一个新的线程</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;旺财:&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程图：</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/14.1.png" alt="pic"></p><p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。</p><p><strong>多线程在内存中运行原理：</strong></p><p>多线程执行时，在栈内存中，其实<strong>每一个执行线程都有一片自己所属的栈内存空间</strong>。进行方法的压栈和弹栈。</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/14.2.png" alt="pic"></p><p>当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p><h3 id="14-2-2-创建线程的方式1——继承Thread类"><a href="#14-2-2-创建线程的方式1——继承Thread类" class="headerlink" title="14.2.2 创建线程的方式1——继承Thread类"></a>14.2.2 创建线程的方式1——继承Thread类</h3><p><code>java.lang.Thread</code>类的API中定义了有关线程的一些方法，具体如下：</p><p><strong>构造方法：</strong></p><ul><li><code>public Thread()</code>:分配一个新的线程对象。</li><li><code>public Thread(String name)</code>:分配一个指定名字的新的线程对象。</li><li><code>public Thread(Runnable target)</code>:分配一个带有指定目标新的线程对象。</li><li><code>public Thread(Runnable target,String name)</code>:分配一个带有指定目标新的线程对象并指定名字。</li></ul><p><strong>常用方法：</strong></p><ul><li><code>public String getName()</code>:获取当前线程名称。</li><li><code>public void start()</code>:导致此线程开始执行; Java虚拟机调用此线程的run方法。</li><li><code>public void run()</code>:此线程要执行的任务在此处定义代码。</li><li><code>public static void sleep(long millis)</code>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li><li><code>public static Thread currentThread()</code>:返回对当前正在执行的线程对象的引用。</li></ul><h3 id="14-2-3-创建线程的方式2——实现Runnable接口"><a href="#14-2-3-创建线程的方式2——实现Runnable接口" class="headerlink" title="14.2.3 创建线程的方式2——实现Runnable接口"></a>14.2.3 创建线程的方式2——实现Runnable接口</h3><p>实现<code>java.lang.Runnable</code>接口，重写run方法</p><p><strong>步骤</strong></p><ol><li>定义Runnable接口的实现类，并重写该接口的<code>run()</code>方法，该<code>run()</code>方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li><li>调用线程对象的start()方法来启动线程。</li></ol><p>通过实现Runnable接口，使得该类有了多线程类的特征。<code>run()</code>方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。<strong>Thread类实际上也是实现了Runnable接口的类。</strong></p><p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的<code>start()</code>方法来运行多线程代码。<br>实际上所有的多线程代码都是通过运行Thread的<code>start()</code>方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的。</p><blockquote><p>注：Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的<code>run()</code>方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的<code>run()</code>方法。</p></blockquote><h3 id="14-2-4-Thread和Runnable的区别"><a href="#14-2-4-Thread和Runnable的区别" class="headerlink" title="14.2.4 Thread和Runnable的区别"></a>14.2.4 Thread和Runnable的区别</h3><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p><p>实现Runnable接口比继承Thread类所具有的优势：</p><ol><li>适合多个相同的程序代码的线程去<strong>共享同一个资源</strong>。</li><li>可以避免java中的单继承的局限性。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li><li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li></ol><blockquote><p>注：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</p></blockquote><h3 id="14-2-5-匿名内部类方式实现线程的创建"><a href="#14-2-5-匿名内部类方式实现线程的创建" class="headerlink" title="14.2.5 匿名内部类方式实现线程的创建"></a>14.2.5 匿名内部类方式实现线程的创建</h3><p>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。</p><h3 id="14-2-6-线程中断"><a href="#14-2-6-线程中断" class="headerlink" title="14.2.6 线程中断"></a>14.2.6 线程中断</h3><p>没有可以强制线程终止的方法。interrupt方法可以用来请求终止线程。</p><p>当对一个线程调用interrupt方法时，线程的<em><strong>中断状态</strong></em>将被置位。这是每一个线程都具有的boolean标志。每个线程都应该不时检查这个标志，以判断线程是否被中断。但是如果线程被阻塞，就无法检测中断状态。这是产生InterruptedException异常的地方</p><h3 id="14-2-7-线程状态"><a href="#14-2-7-线程状态" class="headerlink" title="14.2.7 线程状态"></a>14.2.7 线程状态</h3><p>线程可以有如下6种状态：</p><ol><li>New（新创建）</li><li>Runnable（可运行）</li><li>Blocked（被阻塞）</li><li>Waiting（等待）</li><li>Timed waiting（计时等待）</li><li>Terminated（被终止）</li></ol><h4 id="新创建线程（New）"><a href="#新创建线程（New）" class="headerlink" title="新创建线程（New）"></a>新创建线程（New）</h4><p>当我们使用new操作符来创建了一个线程时，如使用<code>new Thread（r）</code>时，线程还未开始运行，线程中的代码也没有开始执行，此时就成为<strong>New状态</strong></p><h4 id="可运行线程（Runnable）"><a href="#可运行线程（Runnable）" class="headerlink" title="可运行线程（Runnable）"></a>可运行线程（Runnable）</h4><p>当我们对一个线程执行<strong>start()方法</strong>后，就会启动该线程。但是注意，<strong>一个处于可运行状态的线程可能正在运行也可能没有运行，这时取决于操作系统的时间片调度</strong>。抢占式调度系统会给每一个线程分配一个时间片来运行，在时间片使用完后，操作系统就会剥夺它运行的权力，并更根据优先级选择下一个要运行的线程。</p><h4 id="被阻塞、等待状态（Blocked、waiting、Timed-waiting）"><a href="#被阻塞、等待状态（Blocked、waiting、Timed-waiting）" class="headerlink" title="被阻塞、等待状态（Blocked、waiting、Timed waiting）"></a>被阻塞、等待状态（Blocked、waiting、Timed waiting）</h4><p>当一个线程处于阻塞和等待状态时，它不做任何工作，也不执行任何代码。直到操作系统重新激活它。</p><ul><li>当一个线程试图获取一个内部对象锁，而这个锁又被其它线程持有时，<strong>该线程就进入阻塞状态</strong>，当其它线程释放这个锁后，并且线程调度器允许该线程持有它时，该线程将会变成非阻塞状态。</li><li>当线程等待另一个线程通知调度器一个条件时，它自己就<strong>进入等待状态</strong>，再调用Object.wait方法或者Thread.join方法时，就会出现这种情况。<strong>被阻塞状态和等待状态是有大有不同的</strong>。</li><li>有几个方法有一个超时参数。调用它们导致线程进入<strong>计时等待状态</strong>这一状态将一直保存到超时期满或者接收到适当的通知。带有超时参数的方法有：Thread.sleep 和 Object.wait、Thread.join、 Lock,tryLock 以及 Condition.await 的计时版</li></ul><h4 id="被终止的线程（Terminated）"><a href="#被终止的线程（Terminated）" class="headerlink" title="被终止的线程（Terminated）"></a>被终止的线程（Terminated）</h4><p>线程终止有两种原因：</p><ul><li>因为<code>run()</code>方法执行完毕正常退出</li><li>因为一个没有捕获的异常而终止了<code>run</code>方法导致意外死亡</li></ul><h4 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h4><p><img src="/2019/10/17/Java/JavaSE/JavaSE/14.3.png" alt="pic"></p><blockquote><p>可以通过调用<code>t.setDaemon(true);</code>将线程转换为守护线程。守护线程用来服务于用户线程，不需要上层逻辑介入。</p><p>当线程只剩下守护线程的时候，JVM就会退出。</p></blockquote><p>总结：</p><table><thead><tr><th align="center">线程状态</th><th align="left">线程状态导致状态发生条件</th></tr></thead><tbody><tr><td align="center">NEW(新建)</td><td align="left">线程刚被创建，但是并未启动。还没调用start方法。</td></tr><tr><td align="center">Runnable(可运行)</td><td align="left">线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</td></tr><tr><td align="center">Blocked(锁阻塞)</td><td align="left">当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td></tr><tr><td align="center">Waiting(无限等待)</td><td align="left">一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</td></tr><tr><td align="center">TimedWaiting(计时等待)</td><td align="left">同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td></tr><tr><td align="center">Teminated(被终止)</td><td align="left">因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td></tr></tbody></table><blockquote><p>sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证线程睡眠到期后就开始立刻执行。</p></blockquote><p><img src="/2019/10/17/Java/JavaSE/JavaSE/14.5.png" alt="pic"></p><hr><h2 id="14-3-线程安全"><a href="#14-3-线程安全" class="headerlink" title="14.3 线程安全"></a>14.3 线程安全</h2><h3 id="14-3-1-概述"><a href="#14-3-1-概述" class="headerlink" title="14.3.1 概述"></a>14.3.1 概述</h3><p>如果有多个线程在同时运行，而这些线程可能会同时运行一段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p>举例：模拟电影院的售票窗口，实现多个窗口同时卖一场电影票(多个窗口一起卖这100张票)。需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟。</p><p>模拟票：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br><span class="hljs-comment">//执行卖票操作</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//每个窗口卖票的操作</span><br><span class="hljs-comment">//窗口 永远开启</span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有票 可以卖</span><br><span class="hljs-comment">//出票操作</span><br><span class="hljs-comment">//使用sleep模拟一下出票时间</span><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">100</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto‐generated catch block</span><br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//获取当前线程对象的名字</span><br>String name = Thread.currentThread().getName();<br>System.out.println(name + <span class="hljs-string">&quot;正在卖:&quot;</span> + ticket‐‐);<br>            &#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建线程任务对象</span><br>Ticket ticket = <span class="hljs-keyword">new</span> Ticket();<br><span class="hljs-comment">//创建三个窗口对象</span><br>Thread t1 = <span class="hljs-keyword">new</span> Thread(ticket, <span class="hljs-string">&quot;窗口1&quot;</span>);<br>Thread t2 = <span class="hljs-keyword">new</span> Thread(ticket, <span class="hljs-string">&quot;窗口2&quot;</span>);<br>Thread t3 = <span class="hljs-keyword">new</span> Thread(ticket, <span class="hljs-string">&quot;窗口3&quot;</span>);<br><span class="hljs-comment">//同时卖票</span><br>t1.start();<br>t2.start();<br>t3.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/14.4.png" alt="pic"></p><p>发现程序出现了两个问题：</p><ol><li>相同的票数,比如3这张票被卖了两回。</li><li>不存在的票，比如0票与-1票，是不存在的。</li></ol><p>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</p><blockquote><p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p></blockquote><h3 id="14-3-2-线程同步"><a href="#14-3-2-线程同步" class="headerlink" title="14.3.2 线程同步"></a>14.3.2 线程同步</h3><p>当使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。要解决多线程并发访问一个资源的安全性问题：也就是解决重复票与不存在票问题，Java中提供了同步机制(<code>synchronized</code>)来解决。</p><p>为了保证每个线程都能正常执行原子操作，Java引入了线程同步机制。有三种方式完成同步操作：</p><ol><li><strong>同步代码块</strong>。</li><li><strong>同步方法</strong>。</li><li><strong>锁机制</strong>。</li></ol><h3 id="14-3-3-同步代码块"><a href="#14-3-3-同步代码块" class="headerlink" title="14.3.3 同步代码块"></a>14.3.3 同步代码块</h3><ul><li><strong>同步代码块</strong>： <code>synchronized </code>关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li></ul><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁)&#123;<br>需要同步操作的代码<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>同步锁</strong>：</p><p>对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。</p><ol><li>锁对象，可以是任意类型。</li><li>多个线程对象，要使用同一把锁。</li></ol><blockquote><p>在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。</p></blockquote><p>使用同步代码块解决代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">//同步锁</span><br>    Object lock = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-comment">//执行卖票操作</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//每个窗口卖票的操作</span><br><span class="hljs-comment">//窗口 永远开启</span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br><span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有票 可以卖</span><br><span class="hljs-comment">//出票操作</span><br><span class="hljs-comment">//使用sleep模拟一下出票时间</span><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">100</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto‐generated catch block</span><br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//获取当前线程对象的名字</span><br>String name = Thread.currentThread().getName();<br>System.out.println(name + <span class="hljs-string">&quot;正在卖:&quot;</span> + ticket‐‐);<br>            &#125;<br>            &#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-3-4-同步方法"><a href="#14-3-4-同步方法" class="headerlink" title="14.3.4 同步方法"></a>14.3.4 同步方法</h3><ul><li><strong>同步方法</strong>：使用<code>synchronized</code>修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</li></ul><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>可能会产生线程安全问题的代码<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>同步锁是谁?<br>对于非static方法，同步锁就是this。<br>对于static方法，我们使用当前方法所在类的字节码对象(类名.class)。</p></blockquote><p>使用同步方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br><span class="hljs-comment">//执行卖票操作</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//每个窗口卖票的操作</span><br><span class="hljs-comment">//窗口 永远开启</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>sellTicket();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//锁对象 是 谁调用这个方法 就是谁, 隐含 锁对象 就是 this</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sellTicket</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br><span class="hljs-comment">//出票操作</span><br><span class="hljs-comment">//使用sleep模拟一下出票时间</span><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">100</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto‐generated</span><br>           e.printStackTrace();<br>    &#125;<br><span class="hljs-comment">//获取当前线程对象的名字</span><br>String name = Thread.currentThread().getName();<br>            System.out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-3-5-Lock锁"><a href="#14-3-5-Lock锁" class="headerlink" title="14.3.5 Lock锁"></a>14.3.5 Lock锁</h3><p><code>java.util.concurrent.locks.Lock</code>机制提供了比<code>synchronized</code>代码块和<code>synchronized</code>方法更广泛的锁定操作，同步代码块/同步方法具有的功能<code>Lock</code>都有,除此之外更强大,更体现面向对象。</p><p>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p><ul><li><code>public void lock()</code>：加同步锁。</li><li><code>public void unlock()</code>：释放同步锁。</li></ul><p>使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br>Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">//执行卖票操作</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//每个窗口卖票的操作</span><br><span class="hljs-comment">//窗口 永远开启</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>lock.lock();<br><span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br><span class="hljs-comment">//出票操作</span><br><span class="hljs-comment">//使用sleep模拟一下出票时间</span><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">50</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto‐generated catch block</span><br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//获取当前线程对象的名字</span><br>String name = Thread.currentThread().getName();<br>System.out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>&#125;<br>lock.unlock();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="14-4-等待唤醒机制"><a href="#14-4-等待唤醒机制" class="headerlink" title="14.4 等待唤醒机制"></a>14.4 等待唤醒机制</h2><h3 id="14-4-1-线程间通信"><a href="#14-4-1-线程间通信" class="headerlink" title="14.4.1 线程间通信"></a>14.4.1 线程间通信</h3><p><strong>概念</strong>：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p><p><strong>为什么要处理线程间通信：</strong></p><p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p><p><strong>如何保证线程间通信有效利用资源：</strong></p><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即——<strong>等待唤醒机制</strong>。</p><h3 id="14-4-2-等待唤醒机制"><a href="#14-4-2-等待唤醒机制" class="headerlink" title="14.4.2 等待唤醒机制"></a>14.4.2 等待唤醒机制</h3><p><strong>什么是等待唤醒机制：</strong></p><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是全部，线程间也会有协作机制。</p><p>就是在一个线程进行了规定操作后，就进入等待状态（<code>wait()</code>）， 等待其他线程执行完他们的指定代码过后再将其唤醒（<code>notify()</code>）;在有多个线程进行等待时， 如果需要，可以使用<code>notifyAll()</code>来唤醒所有的等待线程。<br><strong>wait/notify</strong>就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法：</strong></p><p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p><ol><li><strong>wait</strong>：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是WAITING。它还要等着别的线程执行一个特别的动作，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中。</li><li><strong>notify</strong>：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li><li><strong>notifyAll</strong>：则释放所通知对象的 wait set 上的全部线程。</li></ol><blockquote><p>注：</p><p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p><p>总结如下：</p><ul><li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态。</li><li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态。</li></ul></blockquote><p><strong>调用wait和notify方法需要注意的细节</strong></p><ol><li>wait方法与notify方法必须要由同一个锁对象调用。</li></ol><p>  因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</p><ol start="2"><li>wait方法与notify方法是属于Object类的方法的。</li></ol><p>  因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</p><ol start="3"><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。</li></ol><p>  因为：必须要通过锁对象调用这2个方法。</p><p>代码演示：</p><p>包子资源类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZi</span> </span>&#123;<br>String pier ;<br>String xianer ;<br><span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span> ;<span class="hljs-comment">//包子资源 是否存在 包子资源状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p>吃货线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChiHuo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><span class="hljs-keyword">private</span> BaoZi bz;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChiHuo</span><span class="hljs-params">(String name,BaoZi bz)</span></span>&#123;<br><span class="hljs-keyword">super</span>(name);<br><span class="hljs-keyword">this</span>.bz = bz;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br><span class="hljs-keyword">synchronized</span> (bz)&#123;<br><span class="hljs-keyword">if</span>(bz.flag == <span class="hljs-keyword">false</span>)&#123;<span class="hljs-comment">//没包子</span><br><span class="hljs-keyword">try</span> &#123;<br>bz.wait();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;吃货正在吃&quot;</span>+bz.pier+bz.xianer+<span class="hljs-string">&quot;包子&quot;</span>);<br>bz.flag = <span class="hljs-keyword">false</span>;<br>bz.notify();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>包子铺线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZiPu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><span class="hljs-keyword">private</span> BaoZi bz;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaoZiPu</span><span class="hljs-params">(String name,BaoZi bz)</span></span>&#123;<br><span class="hljs-keyword">super</span>(name);<br><span class="hljs-keyword">this</span>.bz = bz;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//造包子</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br><span class="hljs-comment">//同步</span><br><span class="hljs-keyword">synchronized</span> (bz)&#123;<br><span class="hljs-keyword">if</span>(bz.flag == <span class="hljs-keyword">true</span>)&#123;<span class="hljs-comment">//包子资源 存在</span><br><span class="hljs-keyword">try</span> &#123;<br>bz.wait();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-comment">// 没有包子 造包子</span><br>System.out.println(<span class="hljs-string">&quot;包子铺开始做包子&quot;</span>);<br><span class="hljs-keyword">if</span>(count%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">// 冰皮 五仁</span><br>bz.pier = <span class="hljs-string">&quot;冰皮&quot;</span>;<br>bz.xianer = <span class="hljs-string">&quot;五仁&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 薄皮 牛肉大葱</span><br>bz.pier = <span class="hljs-string">&quot;薄皮&quot;</span>;<br>bz.xianer = <span class="hljs-string">&quot;牛肉大葱&quot;</span>;<br>&#125;<br>count++;<br>bz.flag=<span class="hljs-keyword">true</span>;<br>System.out.println(<span class="hljs-string">&quot;包子造好了：&quot;</span>+bz.pier+bz.xianer);<br>System.out.println(<span class="hljs-string">&quot;吃货来吃吧&quot;</span>);<br><span class="hljs-comment">//唤醒等待线程 （吃货）</span><br>bz.notify();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//等待唤醒案例</span><br>BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br>ChiHuo ch = <span class="hljs-keyword">new</span> ChiHuo(<span class="hljs-string">&quot;吃货&quot;</span>,bz);<br>BaoZiPu bzp = <span class="hljs-keyword">new</span> BaoZiPu(<span class="hljs-string">&quot;包子铺&quot;</span>,bz);<br>ch.start();<br>bzp.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>IO（Input Output）用于实现对数据的输入与输出操作，Java把不同的输入/输出源（键盘、文件、网络等）抽象表述为流（Stream）。流是从起源到接收的有序数据，有了它程序就可以采用同一方式访问不同的输入/输出源。</p><ul><li>按照数据流向，可以将流分为<strong>输入流</strong>和<strong>输出流</strong>，其中输入流只能读取数据、不能写入数据，而输出流只能写入数据、不能读取数据。</li><li>按照数据类型，可以将流分为<strong>字节流</strong>和<strong>字符流</strong>，其中字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符。</li><li>按照处理功能，可以将流分为<strong>节点流</strong>和<strong>处理流</strong>，其中节点流可以直接从/向一个特定的IO设备（磁盘、网络等）读/写数据，也称为低级流，而处理流是对节点流的连接或封装，用于简化数据读/写功能或提高效率，也称为高级流。</li></ul><p>Java提供了大量的类来支持IO操作，下表整理了其中比较常用的一些类。其中，黑色字体的是抽象基类，其他所有的类都继承自它们。红色字体的是节点流，蓝色字体的是处理流。</p><p><img src="/2019/10/17/Java/JavaSE/JavaSE/image-20210823103502984.png" alt="image-20210823103502984"></p><p>根据命名很容易理解各个流的作用：</p><ul><li>以File开头的文件流用于访问文件；</li><li>以ByteArray/CharArray开头的流用于访问内存中的数组；</li><li>以Piped开头的管道流用于访问管道，实现进程之间的通信；</li><li>以String开头的流用于访问内存中的字符串；</li><li>以Buffered开头的缓冲流，用于在读写数据时对数据进行缓存，以减少IO次数；</li><li>InputStreamReader、InputStreamWriter是转换流，用于将字节流转换为字符流；</li><li>以Object开头的流是对象流，用于实现对象的序列化；</li><li>以Print开头的流是打印流，用于简化打印操作；</li><li>以Pushback开头的流是推回输入流，用于将已读入的数据推回到缓冲区，从而实现再次读取；</li><li>以Data开头的流是特殊流，用于读写Java基本类型的数据。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
