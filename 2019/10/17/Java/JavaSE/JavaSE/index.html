

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="懂一点点">
  <meta name="author" content="Gotcha">
  <meta name="keywords" content="">
  
  <title>JavaSE - Gotcha的笔记总结</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"cd190160b5401a029cee361d013e32a1","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"U8yaiFQ2fUef4ujWTig83mSL-gzGzoHsz","app_key":"akCMytdeJqrMuKP84F4oblqz","server_url":"https://u8yaifq2.lc-cn-n1-shared.com"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Gotcha的笔记总结</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/background/01.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JavaSE">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-10-17 00:00" pubdate>
        2019年10月17日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      42.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      1308
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JavaSE</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2019年12月5日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <blockquote>
<p>该笔记为，《Java核心技术卷（第十版）》阅读笔记</p>
</blockquote>
<h1 id="第1章-Java程序设计概述"><a href="#第1章-Java程序设计概述" class="headerlink" title="第1章 Java程序设计概述"></a>第1章 Java程序设计概述</h1><h2 id="1-1-Java白皮书的关键术语"><a href="#1-1-Java白皮书的关键术语" class="headerlink" title="1.1 Java白皮书的关键术语"></a>1.1 Java白皮书的关键术语</h2><ul>
<li><input checked disabled type="checkbox"> 简单性</li>
<li><input checked disabled type="checkbox"> 面向对象</li>
<li><input checked disabled type="checkbox"> 分布式</li>
<li><input checked disabled type="checkbox"> 健壮性</li>
<li><input checked disabled type="checkbox"> 安全性</li>
<li><input checked disabled type="checkbox"> 体系结构中立</li>
<li><input checked disabled type="checkbox"> 可移植性</li>
<li><input checked disabled type="checkbox"> 解释型</li>
<li><input checked disabled type="checkbox"> 高性能</li>
<li><input checked disabled type="checkbox"> 多线程</li>
<li><input checked disabled type="checkbox"> 动态性</li>
</ul>
<hr>
<p><strong>解释型语言：先翻译成中间代码，再由解释器运行。每执行一次都要翻译一次<br>编译型语言：第一次使用时需要编译，之后运行不需要编译。运行效率高</strong></p>
<hr>
<p><em>Java和JavaScript的区别，就像雷锋和雷峰塔的区别</em></p>
<hr>
<h1 id="第2章-Java程序设计环境"><a href="#第2章-Java程序设计环境" class="headerlink" title="第2章 Java程序设计环境"></a>第2章 Java程序设计环境</h1><h2 id="2-1-Java术语"><a href="#2-1-Java术语" class="headerlink" title="2.1 Java术语"></a>2.1 Java术语</h2><hr>
<table>
<thead>
<tr>
<th align="center">术语名</th>
<th align="center">缩写</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Java Development Kit</td>
<td align="center">JDK</td>
<td align="center">Java开发工具</td>
</tr>
<tr>
<td align="center">Java RunTime Environment</td>
<td align="center">JRE</td>
<td align="center">Java运行环境</td>
</tr>
<tr>
<td align="center">Standard Edition</td>
<td align="center">SE</td>
<td align="center">标准版</td>
</tr>
<tr>
<td align="center">Enterprise Edition</td>
<td align="center">EE</td>
<td align="center">企业版</td>
</tr>
<tr>
<td align="center">Micro Edition</td>
<td align="center">ME</td>
<td align="center">用于小型设备版</td>
</tr>
</tbody></table>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/2.1.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<hr>
<h2 id="2-2-命令行工具"><a href="#2-2-命令行工具" class="headerlink" title="2.2 命令行工具"></a>2.2 命令行工具</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>Welcome.<span class="hljs-keyword">java</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">java </span>Welcome<br></code></pre></td></tr></table></figure>

<p><strong>编译器需要完整文件名(带后缀)，而运行程序时只需要指定类名，不带扩展名</strong></p>
<hr>
<h1 id="第3章-Java的基本程序设计结构"><a href="#第3章-Java的基本程序设计结构" class="headerlink" title="第3章 Java的基本程序设计结构"></a>第3章 Java的基本程序设计结构</h1><h2 id="3-1-基本"><a href="#3-1-基本" class="headerlink" title="3.1 基本"></a>3.1 基本</h2><p>类名命名一般使用大驼峰</p>
<p>Java通用语法  <em><strong>object.method(parameters)</strong></em></p>
<p>等价于函数调用</p>
<hr>
<h2 id="3-2-注释"><a href="#3-2-注释" class="headerlink" title="3.2 注释"></a>3.2 注释</h2><ul>
<li><code>//</code>：注释内容从//开始到本行结尾</li>
<li><code>/* */</code>：用此种注释将注释内容括起来</li>
<li><code>/** */</code>：可以用来自动的生成文档</li>
</ul>
<hr>
<h2 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h2><p>Java数据类型分为两大类</p>
<ul>
<li><strong>基本数据类型</strong>：四类八种（整型、浮点型、字符型、布尔型）</li>
<li><strong>引用数据类型</strong>：类、数组、接口</li>
</ul>
<p>**Java中的默认类型：整数类型是int 、浮点类型是double **</p>
<h3 id="3-3-1-整型"><a href="#3-3-1-整型" class="headerlink" title="3.3.1 整型"></a>3.3.1 整型</h3><p><strong>在Java中，整型的范围与运行Java的机器无关</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">存储需求</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">整型</td>
<td align="center">4字节</td>
<td align="center">-2 147 483 648 ~ 2 147 483 647（正好超过20亿）即-2的31次方 ~ 2的31次方-1</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">短整型</td>
<td align="center">2字节</td>
<td align="center">-32 768 ~ 32 767</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">长整型</td>
<td align="center">8字节</td>
<td align="center">-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">字节型</td>
<td align="center">1字节</td>
<td align="center">-128 ~ 127</td>
</tr>
</tbody></table>
<p>长整型数值有一个后缀L或l</p>
<p>十六进制数值前缀有一个<code>0x</code>或<code>0X</code></p>
<p>八进制数值前缀有一个<code>0</code></p>
<p>二进制数值前缀有一个<code>0b</code>或<code>0B</code></p>
<h3 id="3-3-2-浮点型"><a href="#3-3-2-浮点型" class="headerlink" title="3.3.2 浮点型"></a>3.3.2 浮点型</h3><p><strong>绝大部分程序使用double类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">存储需求</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float</td>
<td align="center">单精度浮点型</td>
<td align="center">4字节</td>
<td align="center">大约±3.402 823 47E + 38F（有效位数6~7位）</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">双精度浮点型</td>
<td align="center">8字节</td>
<td align="center">大约±1.797 693 134 862 315 70E + 308（有效位数15位）</td>
</tr>
</tbody></table>
<p>单精度浮点型数值有一个后缀<code>F</code>或<code>f</code></p>
<p>双精度浮点型数值有一个后缀<code>D</code>或<code>d</code>（可省略）</p>
<p><strong>浮点数不适用于无法接受舍入误差的金融计算中</strong></p>
<h3 id="3-3-3-字符型"><a href="#3-3-3-字符型" class="headerlink" title="3.3.3 字符型"></a>3.3.3 字符型</h3><p>char类型原本用于表示单个字符，但是现在有的字符需要用一个char值描述，有的字符需要用两个个char值描述</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">存储需求</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">字符型</td>
<td align="center">2字节</td>
<td align="center">0 ~ 65535</td>
</tr>
</tbody></table>
<h3 id="3-3-4-布尔型"><a href="#3-3-4-布尔型" class="headerlink" title="3.3.4 布尔型"></a>3.3.4 布尔型</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">存储需求</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">布尔型</td>
<td align="center">1字节</td>
<td align="center">true,false</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-4-变量"><a href="#3-4-变量" class="headerlink" title="3.4 变量"></a>3.4 变量</h2><p><em><strong>变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。</strong></em></p>
<p>Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。</p>
<p>格式:</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">数据类型 变量名 = 数据值<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">数据类型 变量名<span class="hljs-comment">;</span><br><br>变量名 = 数据值<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><strong>声明一个变量后，必须用赋值语句的变量进行显式的初始化</strong></p>
<hr>
<h2 id="3-5-常量"><a href="#3-5-常量" class="headerlink" title="3.5 常量"></a>3.5 常量</h2><p><strong>常量：是指在Java程序中固定不变的数据</strong></p>
<p>在Java中，利用final关键字指示常量，习惯上常量名使用全大写</p>
<hr>
<h2 id="3-6-运算符"><a href="#3-6-运算符" class="headerlink" title="3.6 运算符"></a>3.6 运算符</h2><h3 id="3-6-1-算数运算符"><a href="#3-6-1-算数运算符" class="headerlink" title="3.6.1 算数运算符"></a>3.6.1 算数运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>+</code></td>
<td align="center">加法运算，字符串连接运算</td>
</tr>
<tr>
<td align="center"><code>-</code></td>
<td align="center">减法运算</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="center">乘法运算</td>
</tr>
<tr>
<td align="center"><code>/</code></td>
<td align="center">除法运算</td>
</tr>
<tr>
<td align="center"><code>%</code></td>
<td align="center">取模运算（两个数字相除取余数）</td>
</tr>
<tr>
<td align="center"><code>++</code></td>
<td align="center">自增运算</td>
</tr>
<tr>
<td align="center"><code>--</code></td>
<td align="center">自减运算</td>
</tr>
</tbody></table>
<h3 id="3-6-2-赋值运算符"><a href="#3-6-2-赋值运算符" class="headerlink" title="3.6.2 赋值运算符"></a>3.6.2 赋值运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>=</code></td>
<td align="center">赋值</td>
</tr>
<tr>
<td align="center"><code>+=</code></td>
<td align="center">先加后赋值</td>
</tr>
<tr>
<td align="center"><code>-+</code></td>
<td align="center">先减后赋值</td>
</tr>
<tr>
<td align="center"><code>*=</code></td>
<td align="center">先乘后赋值</td>
</tr>
<tr>
<td align="center"><code>/=</code></td>
<td align="center">先除后赋值</td>
</tr>
<tr>
<td align="center"><code>%=</code></td>
<td align="center">先取模后赋值</td>
</tr>
</tbody></table>
<h3 id="3-6-3-比较运算符"><a href="#3-6-3-比较运算符" class="headerlink" title="3.6.3 比较运算符"></a>3.6.3 比较运算符</h3><p>**比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值true 或者false **</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>==</code></td>
<td align="center">比较符号两边数据是否相等，相等结果是<code>true</code></td>
</tr>
<tr>
<td align="center"><code>&lt;</code></td>
<td align="center">比较符号左边的数据是否小于右边的数据，如果小于结果是<code>true</code></td>
</tr>
<tr>
<td align="center"><code>&gt;</code></td>
<td align="center">比较符号左边的数据是否大于右边的数据，如果大于结果是<code>true</code></td>
</tr>
<tr>
<td align="center"><code>&lt;=</code></td>
<td align="center">比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是<code>true</code></td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="center">比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是<code>true</code></td>
</tr>
<tr>
<td align="center"><code>!=</code></td>
<td align="center">不等于符号 ，如果符号两边的数据不相等，结果是<code>true</code></td>
</tr>
</tbody></table>
<h3 id="3-6-4-逻辑运算符"><a href="#3-6-4-逻辑运算符" class="headerlink" title="3.6.4 逻辑运算符"></a>3.6.4 逻辑运算符</h3><p><strong>逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值true 或者false</strong></p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;&amp;</code></td>
<td align="center">1. 两边都是<code>true</code>，结果是<code>true</code><br>2. 一边是<code>false</code>，结果是<code>false</code><br>短路特点：符号左边是false，右边不再运算</td>
</tr>
<tr>
<td align="center">`</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>！</code></td>
<td align="center">1. <code>! true</code> 结果是<code>false</code><br>2.<code> ! false</code>结果是<code>true</code></td>
</tr>
</tbody></table>
<h3 id="3-6-5-三元运算符"><a href="#3-6-5-三元运算符" class="headerlink" title="3.6.5 三元运算符"></a>3.6.5 三元运算符</h3><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型 变量名 = 布尔类型表达式？结果<span class="hljs-number">1</span>：结果<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>



<h3 id="3-6-6-位运算"><a href="#3-6-6-位运算" class="headerlink" title="3.6.6 位运算"></a>3.6.6 位运算</h3><p>这个下次一定</p>
<hr>
<h2 id="3-7-运算级别"><a href="#3-7-运算级别" class="headerlink" title="3.7 运算级别"></a>3.7 运算级别</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>[]</code>  <code>.</code> <code>()</code>(方法调用)</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center"><code>!</code> <code>~</code> <code>++</code> <code>--</code> <code>+</code> <code>-</code> <code>()</code>(强制类型转换) <code>new</code></td>
<td align="center"><strong>从右向左</strong></td>
</tr>
<tr>
<td align="center"><code>*</code> <code>/</code> <code>%</code></td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center"><code>+</code> <code>-</code></td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center"><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> <code>instance of</code></td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center"><code>==</code> <code>!=</code></td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center"><code>&amp;</code></td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">`</td>
<td align="center">`</td>
</tr>
<tr>
<td align="center"><code>&amp;&amp;</code></td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">`</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>?:</code></td>
<td align="center"><strong>从右向左</strong></td>
</tr>
<tr>
<td align="center"><code>=</code> <code>+=</code> <code>-+</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&amp;=</code> `</td>
<td align="center">=<code> </code>^=<code> </code>&lt;&lt;=<code> </code>&gt;&gt;=<code> </code>&gt;&gt;&gt;=`</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-8-类型转换"><a href="#3-8-类型转换" class="headerlink" title="3.8 类型转换"></a>3.8 类型转换</h2><p>Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换。</p>
<h3 id="3-8-1-自动转换"><a href="#3-8-1-自动转换" class="headerlink" title="3.8.1 自动转换"></a>3.8.1 自动转换</h3><p><strong>将取值范围小的类型自动提升为取值范围大的类型 。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">byte</span> b = <span class="hljs-number">2</span>;<br>	<span class="hljs-comment">// byte x = b + i; // 报错</span><br>	<span class="hljs-comment">//int类型和byte类型运算，结果是int类型</span><br>	<span class="hljs-keyword">int</span> j = b + i;<br>	System.out.println(j);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="转换原理图解"><a href="#转换原理图解" class="headerlink" title="转换原理图解"></a>转换原理图解</h4><p><img src="/2019/10/17/Java/JavaSE/JavaSE/3.1.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<p>同样道理，当一个int 类型变量和一个double 变量运算时， int 类型将会自动提升为double 类型进行运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">double</span> d = <span class="hljs-number">2.5</span>;<br>	<span class="hljs-comment">//int类型和double类型运算，结果是double类型</span><br>	<span class="hljs-comment">//int类型会提升为double类型</span><br>	<span class="hljs-keyword">double</span> e = d+i;<br>	System.out.println(e);<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为int 。</strong></p>
<p><code>byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double</code></p>
<h3 id="3-8-2-强制类型转换"><a href="#3-8-2-强制类型转换" class="headerlink" title="3.8.2 强制类型转换"></a>3.8.2 强制类型转换</h3><ul>
<li><strong>强制类型转换</strong>：将<code>取值范围大的类型</code>强制转换成<code>取值范围小的类型</code>。</li>
</ul>
<p><strong>转换格式</strong></p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">数据类型 变量名 </span>=<span class="hljs-string"> （数据类型）被转数据值；</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-comment">//short类型变量，内存中2个字节</span><br>	<span class="hljs-keyword">short</span> s = <span class="hljs-number">1</span>;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	  出现编译失败</span><br><span class="hljs-comment">  	  s和1做运算的时候，1是int类型，s会被提升为int类型</span><br><span class="hljs-comment">	  s+1后的结果是int类型，将结果在赋值会short类型时发生错误</span><br><span class="hljs-comment">	  short内存2个字节，int类型4个字节</span><br><span class="hljs-comment">	  必须将int强制转成short才能完成赋值</span><br><span class="hljs-comment">	*/</span><br>	s = s + <span class="hljs-number">1</span>；<span class="hljs-comment">//编译失败</span><br>	s = (<span class="hljs-keyword">short</span>)(s+<span class="hljs-number">1</span>);<span class="hljs-comment">//编译成功</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="转换原理图解-1"><a href="#转换原理图解-1" class="headerlink" title="转换原理图解"></a>转换原理图解</h5><p><img src="/2019/10/17/Java/JavaSE/JavaSE/3.2.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<p><em><strong>浮点转成整数，直接取消小数点，可能造成数据损失精度。</strong></em></p>
<hr>
<h2 id="3-9-String类"><a href="#3-9-String类" class="headerlink" title="3.9 String类"></a>3.9 String类</h2><h3 id="3-9-1-概述"><a href="#3-9-1-概述" class="headerlink" title="3.9.1 概述"></a>3.9.1 概述</h3><p><code>java.lang.String</code> 类代表字符串。Java程序中所有的字符串文字（例如<code>&quot;abc&quot;</code> ）都可以被看作是实现此类的实例。<br>类 <code>String</code> 中包括用于检查各个字符串的方法，比如用于<strong>比较</strong>字符串，<strong>搜索</strong>字符串，<strong>提取</strong>子字符串以及创建具有翻译为<strong>大写</strong>或<strong>小写</strong>的所有字符的字符串的副本。</p>
<h3 id="3-9-2-特点"><a href="#3-9-2-特点" class="headerlink" title="3.9.2 特点"></a>3.9.2 特点</h3><ol>
<li>字符串不变：字符串的值在创建后不能被更改。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>s1 += <span class="hljs-string">&quot;d&quot;</span>;<br>System.out.println(s1); <span class="hljs-comment">// &quot;abcd&quot;</span><br><span class="hljs-comment">// 内存中有&quot;abc&quot;，&quot;abcd&quot;两个对象，s1从指向&quot;abc&quot;，改变指向，指向了&quot;abcd&quot;。</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>因为String对象是不可变的，所以它们可以被共享。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-comment">// 内存中只有一个&quot;abc&quot;对象被创建，同时被s1和s2共享。</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li><code>&quot;abc&quot;</code> 等效于 <code>char[] data=&#123; &#39;a&#39; , &#39;b&#39; , &#39;c&#39; &#125; </code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">例如：<br>String str = <span class="hljs-string">&quot;abc&quot;</span>;<br>相当于：<br><span class="hljs-keyword">char</span> data[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>String str = <span class="hljs-keyword">new</span> String(data);<br><span class="hljs-comment">// String底层是靠字符数组实现的。</span><br></code></pre></td></tr></table></figure>

<ol start="4">
<li><p>使用equals方法检测两个字符串是否相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">s.equals(t)<br></code></pre></td></tr></table></figure>

<p><strong>一定不要使用==运算符检测两个字符串是否相等</strong>，这个运算符只能够确定两个字符串是否放置在同一个位置上，但是有可能将内容相同的多个字符串的拷贝放置在不同位置上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">例如：<br>String str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">if</span> (str == <span class="hljs-string">&quot;Hello&quot;</span>)&#123;<br>    <span class="hljs-comment">//可能是正确</span><br>&#125;<br><span class="hljs-keyword">if</span> (str.substring(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) == <span class="hljs-string">&quot;Hel&quot;</span>)&#123;<br>    <span class="hljs-comment">//可能是错误</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>程序内直接写上双引号的字符串，保存在字符串常量池中</p>
</li>
</ol>
<h3 id="3-9-3-构造方法"><a href="#3-9-3-构造方法" class="headerlink" title="3.9.3 构造方法"></a>3.9.3 构造方法</h3><ul>
<li><p><code>public String()</code>：初始化新创建的 String对象，以使其表示空字符序列。</p>
</li>
<li><p><code>public String(char[] value)</code>：通过当前参数中的字符数组来构造新的String。</p>
</li>
<li><p><code>public String(byte[] bytes)</code>：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的<br>String。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无参构造</span><br>String str = <span class="hljs-keyword">new</span> String（）；<br><span class="hljs-comment">// 通过字符数组构造</span><br><span class="hljs-keyword">char</span> chars[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>String str2 = <span class="hljs-keyword">new</span> String(chars);<br><span class="hljs-comment">// 通过字节数组构造</span><br><span class="hljs-keyword">byte</span> bytes[] = &#123; <span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span> &#125;;<br>String str3 = <span class="hljs-keyword">new</span> String(bytes);<br></code></pre></td></tr></table></figure>



<h3 id="3-9-4-判断功能"><a href="#3-9-4-判断功能" class="headerlink" title="3.9.4 判断功能"></a>3.9.4 判断功能</h3><ul>
<li><p><code>public boolean equals (Object anObject)</code>：将此字符串与指定对象进行比较。</p>
</li>
<li><p><code>public boolean equalsIgnoreCase (String anotherString)</code>：将此字符串与指定对象进行比较，忽略大小<br>写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String_Demo01</span> </span>&#123;<br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  		<span class="hljs-comment">// 创建字符串对象</span><br>		String s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>		String s2 = <span class="hljs-string">&quot;hello&quot;</span>;<br>		String s3 = <span class="hljs-string">&quot;HELLO&quot;</span>;<br>		<span class="hljs-comment">// boolean equals(Object obj):比较字符串的内容是否相同</span><br>		System.out.println(s1.equals(s2)); <span class="hljs-comment">// true</span><br>		System.out.println(s1.equals(s3)); <span class="hljs-comment">// false</span><br>		System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br>		<span class="hljs-comment">//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span><br>		System.out.println(s1.equalsIgnoreCase(s2)); <span class="hljs-comment">// true</span><br>		System.out.println(s1.equalsIgnoreCase(s3)); <span class="hljs-comment">// true</span><br>		System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-9-5-获取功能"><a href="#3-9-5-获取功能" class="headerlink" title="3.9.5 获取功能"></a>3.9.5 获取功能</h3><ul>
<li><code>public int length ()</code> ：返回此字符串的长度。</li>
<li><code>public String concat (String str)</code> ：将指定的字符串连接到该字符串的末尾。</li>
<li><code>public char charAt (int index) </code>：返回指定索引处的 char值。</li>
<li><code>public int indexOf (String str)</code> ：返回指定子字符串第一次出现在该字符串内的索引。</li>
<li><code>public String substring (int beginIndex)</code> ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</li>
<li><code>public String substring (int beginIndex, int endIndex)</code> ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String_Demo02</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">//创建字符串对象</span><br>		String s = <span class="hljs-string">&quot;helloworld&quot;</span>;<br>		<span class="hljs-comment">// int length():获取字符串的长度，其实也就是字符个数</span><br>		System.out.println(s.length());<br>		System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);<br>		<span class="hljs-comment">// String concat (String str):将将指定的字符串连接到该字符串的末尾.</span><br>		String s = <span class="hljs-string">&quot;helloworld&quot;</span>;<br>		String s2 = s.concat(<span class="hljs-string">&quot;**hello itheima&quot;</span>);<br>		System.out.println(s2);<span class="hljs-comment">// helloworld**hello itheima</span><br>		<span class="hljs-comment">// char charAt(int index):获取指定索引处的字符</span><br>		System.out.println(s.charAt(<span class="hljs-number">0</span>));<br>		System.out.println(s.charAt(<span class="hljs-number">1</span>));<br>		System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);<br>		<span class="hljs-comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1</span><br>		System.out.println(s.indexOf(<span class="hljs-string">&quot;l&quot;</span>));<br>		System.out.println(s.indexOf(<span class="hljs-string">&quot;owo&quot;</span>));<br>		System.out.println(s.indexOf(<span class="hljs-string">&quot;ak&quot;</span>));<br>		System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);<br>		<span class="hljs-comment">// String substring(int start):从start开始截取字符串到字符串结尾</span><br>		System.out.println(s.substring(<span class="hljs-number">0</span>));<br>		System.out.println(s.substring(<span class="hljs-number">5</span>));<br>		System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);<br>		<span class="hljs-comment">// String substring(int start,int end):从start到end截取字符串。含start，不含end。</span><br>		System.out.println(s.substring(<span class="hljs-number">0</span>, s.length()));<br>		System.out.println(s.substring(<span class="hljs-number">3</span>,<span class="hljs-number">8</span>));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-9-6-转换功能"><a href="#3-9-6-转换功能" class="headerlink" title="3.9.6 转换功能"></a>3.9.6 转换功能</h3><ul>
<li><code>public char[] toCharArray ()</code> ：将此字符串转换为新的字符数组。</li>
<li><code>public byte[] getBytes ()</code> ：使用平台的默认字符集将该 String编码转换为新的字节数组。</li>
<li><code>public String replace (CharSequence target, CharSequence replacement)</code> ：将与target匹配的字符串使用replacement字符串替换。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String_Demo03</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">//创建字符串对象</span><br>		String s = <span class="hljs-string">&quot;abcde&quot;</span>;<br>		<span class="hljs-comment">// char[] toCharArray():把字符串转换为字符数组</span><br>		<span class="hljs-keyword">char</span>[] chs = s.toCharArray();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; chs.length; x++) &#123;<br>			System.out.println(chs[x]);<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br>		<span class="hljs-comment">// byte[] getBytes ():把字符串转换为字节数组</span><br>		<span class="hljs-keyword">byte</span>[] bytes = s.getBytes();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; bytes.length; x++) &#123;<br>			System.out.println(bytes[x]);<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br>		<span class="hljs-comment">// 替换字母it为大写IT</span><br>        String str = <span class="hljs-string">&quot;itcast itheima&quot;</span>;<br>		String replace = str.replace(<span class="hljs-string">&quot;it&quot;</span>, <span class="hljs-string">&quot;IT&quot;</span>);<br>		System.out.println(replace); <span class="hljs-comment">// ITcast ITheima</span><br>		System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>CharSequence</code> 是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中。</p>
</blockquote>
<h3 id="3-9-7-分割功能"><a href="#3-9-7-分割功能" class="headerlink" title="3.9.7 分割功能"></a>3.9.7 分割功能</h3><ul>
<li><code>public String[] split(String regex)</code>：将此字符串按照给定的regex（规则）拆分为字符串数组。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String_Demo03</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">//创建字符串对象</span><br>		String s = <span class="hljs-string">&quot;aa|bb|cc&quot;</span>;<br>		String[] strArray = s.split(<span class="hljs-string">&quot;|&quot;</span>); <span class="hljs-comment">// [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; strArray.length; x++) &#123;<br>			System.out.println(strArray[x]); <span class="hljs-comment">// aa bb cc</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="3-10-Scanner类"><a href="#3-10-Scanner类" class="headerlink" title="3.10 Scanner类"></a>3.10 Scanner类</h2><h3 id="3-10-1-概述"><a href="#3-10-1-概述" class="headerlink" title="3.10.1 概述"></a>3.10.1 概述</h3><p>一个可以解析基本类型和字符串的简单文本扫描器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br><span class="hljs-keyword">int</span> i = sc.nextInt();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>备注：System.in 系统输入指的是通过键盘录入数据</p>
</blockquote>
<h3 id="3-10-2-构造方法"><a href="#3-10-2-构造方法" class="headerlink" title="3.10.2 构造方法"></a>3.10.2 构造方法</h3><ul>
<li><code>public Scanner(InputStream source)</code> : 构造一个新的<code> Scanner</code> ，它生成的值是从指定的输入流扫描的。</li>
</ul>
<h3 id="3-10-3-成员方法"><a href="#3-10-3-成员方法" class="headerlink" title="3.10.3 成员方法"></a>3.10.3 成员方法</h3><ul>
<li><p><code>public String nextLine()</code>：读取下一行内容。</p>
</li>
<li><p><code>public String next()</code>：读取下一个单词（以空格为分隔符）。</p>
</li>
<li><p><code>public int nextInt()</code>：</p>
</li>
<li><p><code>public double nextDouble()</code>：</p>
<p>读取并转换下一个表示整数或浮点数的字符序列</p>
</li>
<li><p><code>public boolean hasNext()</code>：检测输入中是否还有其他单词。</p>
</li>
<li><p><code>public boolean hasNextInt()</code>：</p>
</li>
<li><p><code>public boolean hasNextDouble()</code>：</p>
<p> 检测输入中是否还有表示整数或浮点数的下一个字符序列。</p>
</li>
</ul>
<hr>
<h2 id="3-11-Printf格式化输出"><a href="#3-11-Printf格式化输出" class="headerlink" title="3.11 Printf格式化输出"></a>3.11 Printf格式化输出</h2><hr>
<h2 id="3-12-控制流程"><a href="#3-12-控制流程" class="headerlink" title="3.12 控制流程"></a>3.12 控制流程</h2><h3 id="3-12-1-块"><a href="#3-12-1-块" class="headerlink" title="3.12.1 块"></a>3.12.1 块</h3><p>块（即复合语句）是指由一对大括号括起来的若干条简单的Java语句。</p>
<p>块确定了变量的作用域。</p>
<p>一个块可以嵌套在另一个块中。</p>
<p><strong>不能在嵌套的两个块中声明同名的变量</strong></p>
<h3 id="3-12-2-条件语句"><a href="#3-12-2-条件语句" class="headerlink" title="3.12.2 条件语句"></a>3.12.2 条件语句</h3><p><strong>基本格式</strong></p>
<p><code>if (condition) statement</code></p>
<ul>
<li>if语句第一种格式： <code>if</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(关系表达式)｛<br>	语句体;<br>｝<br></code></pre></td></tr></table></figure>

<ul>
<li>if语句第二种格式： <code>if...else</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(关系表达式) &#123;<br>	语句体<span class="hljs-number">1</span>;<br>	&#125;<span class="hljs-keyword">else</span> &#123;<br>	语句体<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>if语句第三种格式： <code>if...else if ...else</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (判断条件<span class="hljs-number">1</span>) &#123;<br>	执行语句<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (判断条件<span class="hljs-number">2</span>) &#123;<br>	执行语句<span class="hljs-number">2</span>;<br>&#125;<br>	...<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (判断条件n) &#123;<br>	执行语句n;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>	执行语句n+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在某些简单的应用中，if语句是可以和三元运算符互换使用的。</p>
<p><strong>else子句与最邻近的if构成一组</strong></p>
<h3 id="3-12-3-循环语句"><a href="#3-12-3-循环语句" class="headerlink" title="3.12.3 循环语句"></a>3.12.3 循环语句</h3><p><strong>概述</strong></p>
<p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环</p>
<h4 id="循环语句1–for"><a href="#循环语句1–for" class="headerlink" title="循环语句1–for"></a>循环语句1–for</h4><ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化表达式①; 布尔表达式②; 步进表达式④)&#123;<br>	循环体③<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。<ul>
<li>①负责完成循环变量初始化</li>
<li>②负责判断是否满足循环条件，不满足则跳出循环</li>
<li>③具体执行的语句</li>
<li>④循环后，循环条件所涉及变量的变化情况</li>
</ul>
</li>
</ul>
<h4 id="循环语句2–while"><a href="#循环语句2–while" class="headerlink" title="循环语句2–while"></a>循环语句2–while</h4><ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化表达式①<br><span class="hljs-keyword">while</span>(布尔表达式②)&#123;<br>	循环体③<br>	步进表达式④<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。<ul>
<li>①负责完成循环变量初始化</li>
<li>②负责判断是否满足循环条件，不满足则跳出循环</li>
<li>③具体执行的语句</li>
<li>④循环后，循环变量的变化情况</li>
</ul>
</li>
</ul>
<h4 id="循环语句3–do…while"><a href="#循环语句3–do…while" class="headerlink" title="循环语句3–do…while"></a>循环语句3–do…while</h4><ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化表达式①<br><span class="hljs-keyword">do</span>&#123;<br>	循环体③<br>	步进表达式④<br>&#125;<span class="hljs-keyword">while</span>(布尔表达式②);<br></code></pre></td></tr></table></figure>

<p>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。</p>
<ul>
<li>①负责完成循环变量初始化</li>
<li>②负责判断是否满足循环条件，不满足则跳出循环</li>
<li>③具体执行的语句</li>
<li>④循环后，循环变量的变化情况</li>
</ul>
<h5 id="for-和-while-的小区别"><a href="#for-和-while-的小区别" class="headerlink" title="for 和 while 的小区别"></a>for 和 while 的小区别</h5><ol>
<li>控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失（除非在循环前先定义），能够提高内存的使用效率。</li>
<li>在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。</li>
</ol>
<h3 id="3-12-4-选择语句"><a href="#3-12-4-选择语句" class="headerlink" title="3.12.4 选择语句"></a>3.12.4 选择语句</h3><ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(表达式) &#123;<br>	<span class="hljs-keyword">case</span> 常量值<span class="hljs-number">1</span>:<br>	语句体<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> 常量值<span class="hljs-number">2</span>:<br>	语句体<span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">break</span>;<br>	...<br>	<span class="hljs-keyword">default</span>:<br>	语句体n+<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>执行流程<ul>
<li>首先计算出表达式的值</li>
<li>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结<br>束。</li>
<li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。</li>
</ul>
</li>
</ul>
<p><strong>switch语句中，表达式的数据类型，可以是byte，short，int，char，enum（枚举），JDK7后可以接收字符串。</strong></p>
<p><em><strong>case具有穿透性</strong></em>：在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运<br>行，直到遇到break，或者整体switch结束。</p>
<h3 id="3-12-5-中断语句"><a href="#3-12-5-中断语句" class="headerlink" title="3.12.5 中断语句"></a>3.12.5 中断语句</h3><h4 id="循环语句1–break"><a href="#循环语句1–break" class="headerlink" title="循环语句1–break"></a>循环语句1–break</h4><ul>
<li><strong>使用场景：终止switch或者循环</strong><ul>
<li>在选择结构switch语句中</li>
<li>在循环语句中</li>
<li>离开使用场景的存在是没有意义的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">10</span>; i++) &#123;<br>		<span class="hljs-comment">//需求:打印完两次HelloWorld之后结束循环</span><br>		<span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)&#123;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>+i);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="循环语句2–continue"><a href="#循环语句2–continue" class="headerlink" title="循环语句2–continue"></a>循环语句2–continue</h4><ul>
<li><strong>使用场景：结束本次循环，继续下一次的循环</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>		<span class="hljs-comment">//需求:不打印第三次HelloWorld</span><br>		<span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)&#123;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>	System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>+i);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="3-13-数组"><a href="#3-13-数组" class="headerlink" title="3.13 数组"></a>3.13 数组</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>数组是一种数据结构，用来存储同一类型值的集合。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>数组有定长特性，长度一旦指定，不可更改。</strong></p>
<p><strong>数组作为方法参数传递，传递的参数是数组内存的地址。</strong></p>
<p><strong>数组作为方法的返回值，返回的是数组的内存地址</strong></p>
<p>数字数组初始化时所有元素为0</p>
<p>布尔数组初始化时所有元素为false</p>
<p>对象数组初始化时所有元素为null</p>
<h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">数组存储的数据类型[] 数组名字 = <span class="hljs-keyword">new</span> 数组存储的数据类型[长度];<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>



<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名 = <span class="hljs-keyword">new</span> 数据类型[]&#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素<span class="hljs-number">3.</span>..&#125;;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名 = &#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素<span class="hljs-number">3.</span>..&#125;;<br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从<code>0</code>开始，这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。</p>
<p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">变量=数组名[索引];<br><span class="hljs-keyword">int</span> i = arr[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>



<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol>
<li><p>fori循环</p>
</li>
<li><p>foreach循环</p>
<p><strong>格式</strong></p>
<p><code>for(variable : collection) staement</code></p>
</li>
</ol>
<h3 id="数组原理内存图"><a href="#数组原理内存图" class="headerlink" title="数组原理内存图"></a>数组原理内存图</h3><h4 id="Java虚拟机的内存划分"><a href="#Java虚拟机的内存划分" class="headerlink" title="Java虚拟机的内存划分"></a>Java虚拟机的内存划分</h4><p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。</p>
<ul>
<li>JVM的内存划分：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">区域名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寄存器</td>
<td align="center">给CPU使用，和我们开发无关。</td>
</tr>
<tr>
<td align="center">本地方法栈</td>
<td align="center">JVM在使用操作系统功能的时候使用，和我们开发无关。</td>
</tr>
<tr>
<td align="center">方法区</td>
<td align="center">存储可以运行的class文件。</td>
</tr>
<tr>
<td align="center">堆内存</td>
<td align="center">存储对象或者数组，凡是new来创建的，都存储在堆内存。</td>
</tr>
<tr>
<td align="center">方法栈</td>
<td align="center">方法运行时使用的内存（存储局部变量），比如main方法运行，进入方法栈中执行。</td>
</tr>
</tbody></table>
<h4 id="数组在内存中的存储"><a href="#数组在内存中的存储" class="headerlink" title="数组在内存中的存储"></a>数组在内存中的存储</h4><h6 id="一个数组内存图"><a href="#一个数组内存图" class="headerlink" title="一个数组内存图"></a>一个数组内存图</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>	System.out.println(arr);<span class="hljs-comment">//[I@5f150435</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上方法执行，输出的结果是[I@5f150435，这个是数组在内存中的地址。new出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的地址。</p>
<p><strong>输出arr[0]，就会输出arr保存的内存地址中数组中0索引上的元素</strong></p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/3.3.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<h5 id="两个数组内存图"><a href="#两个数组内存图" class="headerlink" title="两个数组内存图"></a>两个数组内存图</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>	<span class="hljs-keyword">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>	System.out.println(arr);<br>	System.out.println(arr2);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2019/10/17/Java/JavaSE/JavaSE/3.4.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<h5 id="两个变量指向一个数组"><a href="#两个变量指向一个数组" class="headerlink" title="两个变量指向一个数组"></a>两个变量指向一个数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-comment">// 定义数组，存储3个元素</span><br>	<span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>	<span class="hljs-comment">//数组索引进行赋值</span><br>	arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br>	arr[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span>;<br>	arr[<span class="hljs-number">2</span>] = <span class="hljs-number">7</span>;<br>	<span class="hljs-comment">//输出3个索引上的元素值</span><br>	System.out.println(arr[<span class="hljs-number">0</span>]);<br>	System.out.println(arr[<span class="hljs-number">1</span>]);<br>	System.out.println(arr[<span class="hljs-number">2</span>]);<br>	<span class="hljs-comment">//定义数组变量arr2，将arr的地址赋值给arr2</span><br>	<span class="hljs-keyword">int</span>[] arr2 = arr;<br>	arr2[<span class="hljs-number">1</span>] = <span class="hljs-number">9</span>;<br>	System.out.println(arr[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2019/10/17/Java/JavaSE/JavaSE/3.5.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<h5 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h5><p>如果希望将一个数组的所有值拷贝到一个新数组中去，可以使用<code>Arrays.copyOf</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] newArr = Arrays.copyOf(OldArr,newLength);<br><br><span class="hljs-keyword">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <br><span class="hljs-keyword">int</span>[] arr2 = Arrays.copyOf(arr1,<span class="hljs-number">3</span>); <span class="hljs-comment">//arr2 = &#123;1,2,3&#125;</span><br></code></pre></td></tr></table></figure>



<blockquote>
<p>总结:<br>方法的参数为基本类型时，传递的是数据值。 方法的参数为引用类型时，传递的是地址值。</p>
</blockquote>
<h3 id="数组常用API"><a href="#数组常用API" class="headerlink" title="数组常用API"></a>数组常用API</h3><p><code>java.util.Arrays</code></p>
<ul>
<li><p><code>static String toString( type[] a )</code>：返回a中元素的字符串。这些元素被放在括号内，以逗号分隔</p>
</li>
<li><p><code>static type copyOf( type[] a , int length )</code></p>
</li>
<li><p><code>static type copyofRange( type[] a , int start , int end )</code> ：</p>
<p>返回一个与a类型相同的数组，其长度为length或end-start</p>
</li>
<li><p><code>static void sort( type[] a )</code>：使用优化后的快速排序算法对数组排序</p>
</li>
<li><p><code>static int binarySearch( type[] a , type v )</code></p>
</li>
<li><p><code>static int binarySearch( type[] a , int start , int end , type v )</code></p>
<p>采用二分搜索算法查找v的值。如果查找成功，则返回相应下标值。否则返回一个负数值r，-r-1是为保持a有序v应当插入的位置</p>
</li>
<li><p><code>static void fill ( type[] a , type v )</code>：将数组所有元素数据设置为v</p>
</li>
<li><p><code>static boolean equals ( type[] a , type[] b )</code>：如果两个数组<code>大小相同</code>，并且<code>下标相同的元素都对应相等</code>，则返回ture</p>
</li>
</ul>
<hr>
<h1 id="第4章-对象与类"><a href="#第4章-对象与类" class="headerlink" title="第4章 对象与类"></a>第4章 对象与类</h1><h2 id="4-1-面向对象思想概述"><a href="#4-1-面向对象思想概述" class="headerlink" title="4.1 面向对象思想概述"></a>4.1 面向对象思想概述</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Java语言是一种<code>面向对象</code>的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。 这里的<code>对象</code>泛指现实中一切事物，每种事物都具备自己的<code>属性</code>和<code>行为</code>。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。<br>面向对象的语言中，包含了三大基本特征，即<code>封装</code>、<code>继承</code>和<code>多态</code>。</p>
<h2 id="4-2-类和对象"><a href="#4-2-类和对象" class="headerlink" title="4.2 类和对象"></a>4.2 类和对象</h2><ul>
<li><strong>类</strong>：是一组相关<strong>属性</strong>和<strong>行为</strong>的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。<ul>
<li><strong>属性</strong>：就是该事物的状态信息。</li>
<li><strong>行为</strong>：就是该事物能够做什么。</li>
</ul>
</li>
<li><strong>对象</strong>：是一类事物的具体体现。对象是类的一个<strong>实例</strong>，必然具备该类事物的属性和行为。</li>
</ul>
<h3 id="4-2-1-类与对象的关系"><a href="#4-2-1-类与对象的关系" class="headerlink" title="4.2.1 类与对象的关系"></a>4.2.1 类与对象的关系</h3><ul>
<li>类是对一类事物的描述，是<strong>抽象</strong>的。</li>
<li>对象是一类事物的实例，是<strong>具体</strong>的。</li>
<li><strong>类是对象的模板，对象是类的实体。</strong></li>
</ul>
<p>由类构造对象的过程叫做创建类的<strong>实例</strong></p>
<p>对象中数据称为<strong>实例域</strong></p>
<p>操作数据的过程称为<strong>方法</strong></p>
<p>对于每个特定的类实例（对象）都有一组特定的实例域值，这些值的集合就是这个对象的当前<strong>状态</strong></p>
<p>作为一个类的实例，每个对象的表示永远是<strong>不同</strong>的</p>
<h3 id="4-2-2-类的定义格式"><a href="#4-2-2-类的定义格式" class="headerlink" title="4.2.2 类的定义格式"></a>4.2.2 类的定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span> </span>&#123;<br>	<span class="hljs-comment">//成员变量</span><br>	<span class="hljs-comment">//成员方法</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="4-2-3-对象的使用格式"><a href="#4-2-3-对象的使用格式" class="headerlink" title="4.2.3 对象的使用格式"></a>4.2.3 对象的使用格式</h3><p>创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名 对象名 = <span class="hljs-keyword">new</span> 类名();<br></code></pre></td></tr></table></figure>

<p>使用对象访问类中的成员:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">对象名.成员变量；<br>对象名.成员方法()；<br></code></pre></td></tr></table></figure>



<h3 id="4-2-4-成员变量的默认值"><a href="#4-2-4-成员变量的默认值" class="headerlink" title="4.2.4 成员变量的默认值"></a>4.2.4 成员变量的默认值</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">数据类型</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基本类型</td>
<td align="center">整数（byte，short，int，long）</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">浮点数（float，double）</td>
<td align="center">0.0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">字符（char）</td>
<td align="center">‘\u0000’</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">布尔（boolean）</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">引用类型</td>
<td align="center">数组，类，接口</td>
<td align="center">null</td>
</tr>
</tbody></table>
<h3 id="4-2-5-类之间的关系"><a href="#4-2-5-类之间的关系" class="headerlink" title="4.2.5 类之间的关系"></a>4.2.5 类之间的关系</h3><p>在类之间，最常见的关系有：</p>
<ul>
<li><strong>依赖</strong>（”users-a”）：如果一个类的方法操纵另一个类的对象，我们就说这个类依赖于另一个类</li>
<li><strong>聚合</strong>（”has-a”）：聚合意味着类A的对象包含着类B的对象</li>
<li><strong>继承</strong>（”is-a”）：是一种用于表示特殊与一般的关系的</li>
</ul>
<h3 id="4-2-6-更改器方法"><a href="#4-2-6-更改器方法" class="headerlink" title="4.2.6 更改器方法"></a>4.2.6 更改器方法</h3><p>会修改对象状态，如：setter方法</p>
<h3 id="4-3-7-修改器方法"><a href="#4-3-7-修改器方法" class="headerlink" title="4.3.7 修改器方法"></a>4.3.7 修改器方法</h3><p>只访问对象而不修改对象的方法，如：getter方法</p>
<h2 id="4-3-对象内存图"><a href="#4-3-对象内存图" class="headerlink" title="4.3 对象内存图"></a>4.3 对象内存图</h2><h3 id="4-3-1-一个对象，调用一个方法内存图"><a href="#4-3-1-一个对象，调用一个方法内存图" class="headerlink" title="4.3.1 一个对象，调用一个方法内存图"></a>4.3.1 一个对象，调用一个方法内存图</h3><p><img src="/2019/10/17/Java/JavaSE/JavaSE/4.1.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<blockquote>
<p>通过上图，我们可以理解，在栈内存中运行的方法，遵循”先进后出，后进先出”的原则。变量p指向堆内存中的空间，寻找方法信息，去执行该方法。<br>但是，这里依然有问题存在。创建多个对象时，如果每个对象内部都保存一份方法信息，这就非常浪费内存了，因为所有对象的方法信息都是一样的。那么如何解决这个问题呢？请看如下图解。</p>
</blockquote>
<h3 id="4-3-2-两个对象，调用同一方法内存图"><a href="#4-3-2-两个对象，调用同一方法内存图" class="headerlink" title="4.3.2 两个对象，调用同一方法内存图"></a>4.3.2 两个对象，调用同一方法内存图</h3><p><img src="/2019/10/17/Java/JavaSE/JavaSE/4.2.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<blockquote>
<p>对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息只保存一份，节约内存空间。</p>
</blockquote>
<h3 id="4-3-3-一个引用，作为参数传递到方法中内存图"><a href="#4-3-3-一个引用，作为参数传递到方法中内存图" class="headerlink" title="4.3.3 一个引用，作为参数传递到方法中内存图"></a>4.3.3 一个引用，作为参数传递到方法中内存图</h3><p><img src="/2019/10/17/Java/JavaSE/JavaSE/4.3.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<blockquote>
<p>引用类型作为参数，传递的是<strong>地址值</strong>。</p>
</blockquote>
<h2 id="4-4-封装"><a href="#4-4-封装" class="headerlink" title="4.4 封装"></a>4.4 封装</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>将<strong>属性隐藏</strong>起来，若需要访问某个属性，<strong>提供公共方法</strong>对其访问。</p>
<h3 id="4-4-1-封装的步骤"><a href="#4-4-1-封装的步骤" class="headerlink" title="4.4.1 封装的步骤"></a>4.4.1 封装的步骤</h3><ul>
<li>使用 <code>private </code>关键字来修饰成员变量。</li>
<li>对需要访问的成员变量，提供对应的一对 <code>getXxx </code>方法 、<code>setXxx</code> 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String n)</span> </span>&#123;<br>		name = n;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>		age = a;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> age;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>setName方法有两个参数。第一个参数称为<strong>隐式参数</strong>，是出现在方法名前的Student类对象。第二个参数位于方法名后面括号中的数值，这是一个显式参数。</p>
</blockquote>
<h3 id="4-4-2-封装优化1——this关键字"><a href="#4-4-2-封装优化1——this关键字" class="headerlink" title="4.4.2 封装优化1——this关键字"></a>4.4.2 封装优化1——this关键字</h3><p>this代表所在类的当前对象的引用（地址值），即对象自己的引用。（即，关键字<code>this</code>表示<strong>隐式参数</strong>）</p>
<blockquote>
<p>记住 ：方法被哪个对象调用，方法中的<code>this</code>就代表那个对象。即谁在调用，this就代表谁。（<code>lambda</code>表达式中this也不例外）</p>
</blockquote>
<p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">this</span>.成员变量名；<br></code></pre></td></tr></table></figure>

<p>对上面代码改进如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-comment">//name = name;</span><br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>		<span class="hljs-comment">//age = age;</span><br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> age;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>备注：方法中只有一个变量名时，默认也是使用 this 修饰，可以省略不写。</p>
</blockquote>
<h3 id="4-4-3-封装优化2——构造方法"><a href="#4-4-3-封装优化2——构造方法" class="headerlink" title="4.4.3 封装优化2——构造方法"></a>4.4.3 封装优化2——构造方法</h3><p>当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。</p>
<blockquote>
<p>备注：无论是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。</p>
</blockquote>
<p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 构造方法名(参数列表)&#123;<br>	<span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>构造方法的写法上，方法名与它<strong>所在的类名相同</strong>。它没有返回值，所以不需要返回值类型。使用构造方法后，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>	<span class="hljs-comment">// 无参数构造方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>	<span class="hljs-comment">// 有参数构造方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><strong>如果你不提供构造方法，系统会给出无参数构造方法。</strong></li>
<li><strong>如果你提供了构造方法，系统将不再提供无参数构造方法。</strong></li>
<li><strong>构造方法是可以重载的，既可以定义参数，也可以不定义参数。</strong></li>
</ul>
<h3 id="4-4-4-标准代码——JavaBean"><a href="#4-4-4-标准代码——JavaBean" class="headerlink" title="4.4.4 标准代码——JavaBean"></a>4.4.4 标准代码——JavaBean</h3><p><code>JavaBean</code> 是 Java语言编写类的一种标准规范。符合JavaBean 的类，要求类必须是<code>具体</code>的和<code>公共</code>的，并且具有无<br>参数的构造方法，提供用来操作成员变量的<code>set </code>和<code>get </code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span></span>&#123;<br>	<span class="hljs-comment">//成员变量</span><br>	<span class="hljs-comment">//构造方法</span><br>	<span class="hljs-comment">//无参构造方法【必须】</span><br>	<span class="hljs-comment">//有参构造方法【建议】</span><br>	<span class="hljs-comment">//成员方法</span><br>	<span class="hljs-comment">//getXxx()</span><br>	<span class="hljs-comment">//setXxx()</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="4-5-方法"><a href="#4-5-方法" class="headerlink" title="4.5 方法"></a>4.5 方法</h2><h3 id="4-5-1-概述"><a href="#4-5-1-概述" class="headerlink" title="4.5.1 概述"></a>4.5.1 概述</h3><p><strong>方法：就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。</strong></p>
<p>当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。</p>
<h3 id="4-5-2-方法的定义"><a href="#4-5-2-方法的定义" class="headerlink" title="4.5.2 方法的定义"></a>4.5.2 方法的定义</h3><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名 （参数列表）｛<br>	代码...<br>	<span class="hljs-keyword">return</span> ;<br>｝<br></code></pre></td></tr></table></figure>

<h3 id="4-5-3-方法的调用"><a href="#4-5-3-方法的调用" class="headerlink" title="4.5.3 方法的调用"></a>4.5.3 方法的调用</h3><ul>
<li><strong>直接调用</strong>：直接写方法名调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	print();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>	System.out.println(<span class="hljs-string">&quot;方法被调用&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><strong>赋值调用</strong>：调用方法，在方法前面定义变量，接收方法返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> sum = getSum(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<br>	System.out.println(sum);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><p><strong>输出语句调用</strong>：</p>
<ul>
<li>在输出语句中调用方法， <code>System.out.println(方法名()) </code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	System.out.println(getSum(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>不能用输出语句调用<code>void </code>类型的方法。因为方法执行后没有结果，也就打印不出任何内容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	System.out.println(printHello());<span class="hljs-comment">// 错误，不能输出语句调用void类型方法</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span> </span>&#123;<br>	System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-5-4-方法重载"><a href="#4-5-4-方法重载" class="headerlink" title="4.5.4 方法重载"></a>4.5.4 方法重载</h3><p><strong>方法重载</strong>：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。<br>参数列表：个数不同，数据类型不同，顺序不同。<br>重载方法调用：JVM通过方法的参数列表，调用不同的方法。</p>
<blockquote>
<p>注：要完整地描述一个方法需要指出方法名以及参数类型，这叫做方法的签名。但<strong>返回值类型不是方法签名的一部分</strong></p>
</blockquote>
<h3 id="4-5-5-方法参数"><a href="#4-5-5-方法参数" class="headerlink" title="4.5.5 方法参数"></a>4.5.5 方法参数</h3><ul>
<li><p>Java语言对对象采用的不是引用调用，而是<strong>按值调用</strong></p>
<ul>
<li><strong>方法得到的是所有参数值的一个拷贝</strong></li>
</ul>
</li>
<li><p>Java中方法参数的使用情况</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即布尔型或数值型）</li>
<li>一个方法可以改变一个对象参数的状态</li>
<li>一个方法不能让对象参数引用一个新的对象</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>    test1(i);<br>    System.out.println(i);<span class="hljs-comment">//仍然是10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    i = <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>);<br>	test2(student);<br>	System.out.println(student.getId());<span class="hljs-comment">//变成6</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(Student student)</span></span>&#123;<br>    student.setId(student.getId()*<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>);<br>	test3(student);<br>	System.out.println(student.getId());<span class="hljs-comment">//仍然是3     </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">(Student student)</span></span>&#123;<br>	student = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="4-6-final关键字"><a href="#4-6-final关键字" class="headerlink" title="4.6 final关键字"></a>4.6 final关键字</h2><h3 id="4-6-1-概述"><a href="#4-6-1-概述" class="headerlink" title="4.6.1 概述"></a>4.6.1 概述</h3><ul>
<li><code>final</code>： 不可改变。可以用于修饰类、方法和变量。<ul>
<li>类：被修饰的类，<strong>不能被继承</strong>。</li>
<li>方法：被修饰的方法，<strong>不能被重写</strong>。</li>
<li>变量：被修饰的变量，<strong>不能被重新赋值</strong>。</li>
</ul>
</li>
</ul>
<h3 id="4-6-2-使用方式"><a href="#4-6-2-使用方式" class="headerlink" title="4.6.2 使用方式"></a>4.6.2 使用方式</h3><ul>
<li><p><strong>修饰类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>修饰方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">final</span> 返回值类型 方法名(参数列表)&#123;<br>	<span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>重写被 final 修饰的方法，编译时就会报错。</p>
</blockquote>
<ul>
<li><p><strong>修饰变量</strong></p>
<ul>
<li><ol>
<li><p>局部变量——基本类型</p>
<p>基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalDemo1</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 声明变量，使用final修饰</span><br>		<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a;<br>		<span class="hljs-comment">// 第一次赋值</span><br>		a = <span class="hljs-number">10</span>;<br>		<span class="hljs-comment">// 第二次赋值</span><br>		a = <span class="hljs-number">20</span>; <span class="hljs-comment">// 报错,不可重新赋值</span><br>		<span class="hljs-comment">// 声明变量，直接赋值，使用final修饰</span><br>		<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br>		<span class="hljs-comment">// 第二次赋值</span><br>		b = <span class="hljs-number">20</span>; <span class="hljs-comment">// 报错,不可重新赋值</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li><p>局部变量——引用类型</p>
<p>引用类型的局部变量，被final修饰后，只能指向一个对象，<strong>地址不能再更改</strong>。但是不影响对象内部的成员变量值的修改，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalDemo2</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建 User 对象</span><br>		<span class="hljs-keyword">final</span> User u = <span class="hljs-keyword">new</span> User();<br>		<span class="hljs-comment">// 创建 另一个 User对象</span><br>		u = <span class="hljs-keyword">new</span> User(); <span class="hljs-comment">// 报错，指向了新的对象，地址值改变。</span><br>		<span class="hljs-comment">// 调用setName方法</span><br>		u.setName(<span class="hljs-string">&quot;张三&quot;</span>); <span class="hljs-comment">// 可以修改</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="3">
<li>成员变量</li>
</ol>
</li>
</ul>
</li>
</ul>
<p> 成员变量涉及到初始化的问题，初始化方式有两种，只能二选一：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//显式初始化</span><br> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>	<span class="hljs-keyword">final</span> String USERNAME = <span class="hljs-string">&quot;张三&quot;</span>;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br> &#125;<br> <br><span class="hljs-comment">//构造方法初始化</span><br> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>	<span class="hljs-keyword">final</span> String USERNAME ;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String username, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.USERNAME = username;<br>     	<span class="hljs-keyword">this</span>.age = age;<br> 	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>​     </p>
<blockquote>
<p>被<code>final</code>修饰的常量名称，一般都有书写规范，所有字母都大写。</p>
</blockquote>
<h2 id="4-7-static关键字"><a href="#4-7-static关键字" class="headerlink" title="4.7 static关键字"></a>4.7 static关键字</h2><h3 id="4-7-1-概述"><a href="#4-7-1-概述" class="headerlink" title="4.7.1 概述"></a>4.7.1 概述</h3><p>关于<code>static</code>关键字的使用，它可以用来修饰的<code>成员变量</code>和<code>成员方法</code>，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。</p>
<h3 id="4-7-2-定义和使用格式"><a href="#4-7-2-定义和使用格式" class="headerlink" title="4.7.2 定义和使用格式"></a>4.7.2 定义和使用格式</h3><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><p>当<code>static</code>修饰成员变量时，该变量称为<strong>类变量</strong>。该类的每个对象都<strong>共享</strong>同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。</p>
<ul>
<li><strong>类变量</strong>：使用<code>static</code>关键字修饰的成员变量。</li>
</ul>
<p><strong>定义格式</strong>    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> 数据类型 变量名；<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numberID； <br></code></pre></td></tr></table></figure>



<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>当<code>static</code>修饰成员方法时，该方法称为<strong>类方法</strong> 。静态方法在声明中有<code>static</code>，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。</p>
<ul>
<li><strong>类方法</strong>：使用<code>static</code>关键字修饰的成员方法，习惯称为<code>静态方法</code>。</li>
</ul>
<p><strong>定义格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">static</span> 返回值类型 方法名 (参数列表)&#123;<br>	<span class="hljs-comment">// 执行语句</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>静态方法调用的注意事项：</strong><ul>
<li>静态方法可以直接访问<code>类变量</code>和<code>静态方法</code>。</li>
<li>静态方法<code>不能直接</code>访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。</li>
<li>静态方法中，不能使用<code>this</code>关键字。</li>
</ul>
</li>
</ul>
<h4 id="调用格式"><a href="#调用格式" class="headerlink" title="调用格式"></a>调用格式</h4><p>被<code>static</code>修饰的成员可以并且建议通过<code>类名直接访问</code>。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 访问类变量</span><br>类名.类变量名；<br><span class="hljs-comment">// 调用静态方法</span><br>类名.静态方法名(参数)；<br></code></pre></td></tr></table></figure>

<blockquote>
<p>静态方法不能调用隐式参数（对象）</p>
</blockquote>
<h3 id="4-7-3-静态原理图解"><a href="#4-7-3-静态原理图解" class="headerlink" title="4.7.3 静态原理图解"></a>4.7.3 静态原理图解</h3><p><strong>static</strong>修饰的内容：</p>
<ul>
<li>是随着类的加载而加载的，且只加载一次。</li>
<li>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。</li>
<li>它优先于对象存在，所以，可以被所有对象共享。</li>
</ul>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/4.4.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<h3 id="4-7-4-静态代码块"><a href="#4-7-4-静态代码块" class="headerlink" title="4.7.4 静态代码块"></a>4.7.4 静态代码块</h3><ul>
<li><strong>静态代码块</strong>：定义在成员位置，使用static修饰的代码块{ }。<ul>
<li>位置：类中方法外。</li>
<li>执行：随着<code>类的加载</code>而执行且执行一次，优先于main方法和构造方法的执行。</li>
</ul>
</li>
</ul>
<p><strong>定义格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span></span>&#123;<br>	<span class="hljs-keyword">static</span> &#123;<br>		<span class="hljs-comment">// 执行语句</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>作用</strong>：给类变量进行初始化赋值。用法演示，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span> </span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> number;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; list;<br>	<span class="hljs-keyword">static</span> &#123;<br>		<span class="hljs-comment">// 给类变量赋值</span><br>		number = <span class="hljs-number">2</span>;<br>		list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>		<span class="hljs-comment">// 添加元素到集合中</span><br>		list.add(<span class="hljs-string">&quot;张三&quot;</span>);<br>		list.add(<span class="hljs-string">&quot;李四&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>static </code>关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的是在<strong>不创建对象的情况下，去调用方法</strong>。</p>
</blockquote>
<h3 id="4-7-5-构造代码块"><a href="#4-7-5-构造代码块" class="headerlink" title="4.7.5 构造代码块"></a>4.7.5 构造代码块</h3><p>构造块在创建对象时会被调用，每次创建对象 时都会被调用，并且优先于类构造函数执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//第一次加载此类时执行</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化父类静态代码块&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化父类&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Father method01&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Father method02&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造块在创建对象时会被调用，每次创建对象 时都会被调用，并且优先于类构造函数执行</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类构造块&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">88</span>;<br><br>    <span class="hljs-comment">//第一次加载此类时执行</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化子类静态代码块&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化子类&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造块在创建对象时会被调用，每次创建对象 时都会被调用，并且优先于类构造函数执行</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类构造块&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Son method01&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Father father = <span class="hljs-keyword">new</span> Son();<br><br>        father.method1();<br>        father.method2();<br>        System.out.println(father.num1);<br>        System.out.println(<span class="hljs-string">&quot;=================&quot;</span>);<br>        Son son = <span class="hljs-keyword">new</span> Son();<br>        System.out.println(((Father)son).num1);<br>        System.out.println(son.num1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<ul>
<li>属性不存在重写，只有方法(非私有方法、非静态方法、非final方法) 才存在重写，才能发生多态</li>
</ul>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/image-20210412170347420.png" srcset="/img/loading.gif" lazyload alt="image-20210412170347420"></p>
<p><strong>static关键字不可修饰外部类，但可修饰内部类。</strong></p>
<blockquote>
<p>如果使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此使用static修饰的内部类被称为类内部类，有的地方也称为静态内部类。</p>
<p>static关键字的作用是把类的成员变成类相关，而不是实例相关，即static修饰的成员属于整个类，而不属于单个对象。外部类的上一级程序单元是包，所以不可使用static修饰；而内部类的上一级程序单元是外部类，使用static修饰可以将内部类变成外部类相关，而不是外部类实例相关。因此static关键字不可修饰外部类，但可修饰内部类。</p>
</blockquote>
<p>静态内部类需满足如下规则：</p>
<ol>
<li><p>静态内部类可以包含静态成员，也可以包含非静态成员；</p>
</li>
<li><p>静态内部类不能访问外部类的实例成员，只能访问它的静态成员；</p>
</li>
<li><p>外部类的所有方法、初始化块都能访问其内部定义的静态内部类；</p>
</li>
<li><p>在外部类的外部，也可以实例化静态内部类，语法如下：</p>
<p><code>外部类.内部类 变量名 = new 外部类.内部类构造方法();</code></p>
</li>
</ol>
<h2 id="4-8-权限修饰符"><a href="#4-8-权限修饰符" class="headerlink" title="4.8 权限修饰符"></a>4.8 权限修饰符</h2><h3 id="4-8-1-概述"><a href="#4-8-1-概述" class="headerlink" title="4.8.1 概述"></a>4.8.1 概述</h3><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限。</p>
<ul>
<li>public：公共的</li>
<li>protected：受保护的</li>
<li>default：默认的</li>
<li>private：私有的</li>
</ul>
<h3 id="4-8-2-不同权限的访问能力"><a href="#4-8-2-不同权限的访问能力" class="headerlink" title="4.8.2 不同权限的访问能力"></a>4.8.2 不同权限的访问能力</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">default（空的）</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一类中</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">同一包中(子类与无关类)</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包的子类</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包中的无关类</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>小贴士：不加权限修饰符，其访问能力与<code>default</code>修饰符相同</p>
</blockquote>
<h2 id="4-9-文档注释"><a href="#4-9-文档注释" class="headerlink" title="4.9 文档注释"></a>4.9 文档注释</h2><h3 id="4-9-1-类注释"><a href="#4-9-1-类注释" class="headerlink" title="4.9.1 类注释"></a>4.9.1 类注释</h3><blockquote>
<p>类注释必须放在<code>import</code>语句之后，类定义之前</p>
</blockquote>
<h3 id="4-9-2-方法注释"><a href="#4-9-2-方法注释" class="headerlink" title="4.9.2 方法注释"></a>4.9.2 方法注释</h3><ul>
<li><code>@param</code>：变量描述</li>
<li><code>@return</code>：返回描述</li>
<li><code>@throws</code>：异常描述</li>
</ul>
<h3 id="4-9-3-域注释"><a href="#4-9-3-域注释" class="headerlink" title="4.9.3 域注释"></a>4.9.3 域注释</h3><p>通常只对公有域（静态常量）用<code>/** */</code>进行描述</p>
<h3 id="4-9-4-通用注释"><a href="#4-9-4-通用注释" class="headerlink" title="4.9.4 通用注释"></a>4.9.4 通用注释</h3><ul>
<li><code>@author</code>：作者姓名</li>
<li><code>@version</code>：版本信息</li>
<li><code>@since</code>：始于信息</li>
<li><code>@deprecated</code>：弃用信息</li>
<li><code>@see</code>：引用信息</li>
</ul>
<h3 id="4-9-5-注释的抽取"><a href="#4-9-5-注释的抽取" class="headerlink" title="4.9.5 注释的抽取"></a>4.9.5 注释的抽取</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javadoc -d docDirectory nameOfPackage<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="第5章-继承"><a href="#第5章-继承" class="headerlink" title="第5章 继承"></a>第5章 继承</h1><h2 id="5-1-继承"><a href="#5-1-继承" class="headerlink" title="5.1 继承"></a>5.1 继承</h2><h3 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h3><p>继承描述的是事物之间的所属关系，这种关系是： <code>is-a</code>的关系。</p>
<p>多个类中存在相同<strong>属性</strong>和<strong>行为</strong>时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可</p>
<h3 id="5-1-2-定义"><a href="#5-1-2-定义" class="headerlink" title="5.1.2 定义"></a>5.1.2 定义</h3><p><strong>继承</strong>：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。</p>
<p><strong>优点</strong></p>
<ul>
<li>提高代码的<strong>复用性</strong>。</li>
<li>类与类之间产生了关系，是<strong>多态的前提</strong>。</li>
</ul>
<h3 id="5-1-3-格式"><a href="#5-1-3-格式" class="headerlink" title="5.1.3 格式"></a>5.1.3 格式</h3><p>通过<code>extends</code>关键字，可以声明一个子类继承另外一个父类，定义格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 父类 </span>&#123;<br>	...<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> 子类 <span class="hljs-keyword">extends</span> 父类 </span>&#123;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-1-4-继承后的特点——成员变量"><a href="#5-1-4-继承后的特点——成员变量" class="headerlink" title="5.1.4 继承后的特点——成员变量"></a>5.1.4 继承后的特点——成员变量</h3><h4 id="成员变量不重名"><a href="#成员变量不重名" class="headerlink" title="成员变量不重名"></a>成员变量不重名</h4><ul>
<li>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<em><strong>没有影响</strong></em>的。</li>
</ul>
<h4 id="成员变量重名"><a href="#成员变量重名" class="headerlink" title="成员变量重名"></a>成员变量重名</h4><ul>
<li><p>如果子类父类中出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响</strong>的</p>
<ul>
<li><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code>关键字，修饰父类成员变量，类似于之前学过的 <code>this</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">super</span>.父类成员变量名<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5-1-5-继承后的特点——成员方法"><a href="#5-1-5-继承后的特点——成员方法" class="headerlink" title="5.1.5 继承后的特点——成员方法"></a>5.1.5 继承后的特点——成员方法</h3><h4 id="成员方法不重名"><a href="#成员方法不重名" class="headerlink" title="成员方法不重名"></a>成员方法不重名</h4><ul>
<li>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响</strong>的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法</li>
</ul>
<h4 id="成员方法重名——重写-Override"><a href="#成员方法重名——重写-Override" class="headerlink" title="成员方法重名——重写(Override)"></a>成员方法重名——重写(Override)</h4><ul>
<li>如果子类父类中出现<strong>重名</strong>的成员方法，这是的访问是一种特殊情况，叫做<strong>方法重写</strong> (Override)。</li>
<li>方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;Fu show&quot;</span>);<br>	&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;<br>	<span class="hljs-comment">//子类重写了父类的show方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;Zi show&quot;</span>);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendsDemo05</span></span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Zi z = <span class="hljs-keyword">new</span> Zi();<br>		<span class="hljs-comment">// 子类中有show方法，只执行重写后的show方法</span><br>	z.show(); <span class="hljs-comment">// Zi show</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>通过使用<code>super.父类成员方法</code>，对父类成员方法进行调用。</li>
</ul>
<blockquote>
<p>注意</p>
<p>1.子类方法覆盖父类方法，必须要保证访问权限大于等于父类权限。</p>
<p>2.子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</p>
</blockquote>
<h3 id="5-1-6-继承后的特点——构造方法"><a href="#5-1-6-继承后的特点——构造方法" class="headerlink" title="5.1.6 继承后的特点——构造方法"></a>5.1.6 继承后的特点——构造方法</h3><blockquote>
<p>1.构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</p>
<p>2.构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br>	Fu()&#123;<br>		System.out.println(<span class="hljs-string">&quot;Fu()&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;<br>	Zi()&#123;<br>		<span class="hljs-comment">// super（），调用父类构造方法</span><br>		<span class="hljs-keyword">super</span>();<br>		System.out.println(<span class="hljs-string">&quot;Zi（）&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendsDemo07</span></span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String args[])</span></span>&#123;<br>		Zi zi = <span class="hljs-keyword">new</span> Zi();<br>	&#125;<br>&#125;<br>输出结果：<br>Fu（）<br>Zi（）<br></code></pre></td></tr></table></figure>

<h3 id="5-1-7-super和this"><a href="#5-1-7-super和this" class="headerlink" title="5.1.7 super和this"></a>5.1.7 super和this</h3><h4 id="父类空间优先于子类对象产生"><a href="#父类空间优先于子类对象产生" class="headerlink" title="父类空间优先于子类对象产生"></a>父类空间优先于子类对象产生</h4><p>在每次创建子类对象时，<strong>先初始化父类空间，再创建其子类对象本身</strong>。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。理解图解如下：</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/5.1.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<h4 id="super和this的含义"><a href="#super和this的含义" class="headerlink" title="super和this的含义"></a>super和this的含义</h4><ul>
<li><strong>super</strong>：代表父类的存储空间标识(可以理解为父亲的引用)。</li>
<li><strong>this</strong>：代表当前对象的引用(谁调用就代表谁)。</li>
</ul>
<h4 id="super和this的用法"><a href="#super和this的用法" class="headerlink" title="super和this的用法"></a>super和this的用法</h4><ol>
<li>访问成员</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">this</span>.成员变量 ‐‐ 本类的<br><span class="hljs-keyword">super</span>.成员变量 ‐‐ 父类的<br><span class="hljs-keyword">this</span>.成员方法名() ‐‐ 本类的<br><span class="hljs-keyword">super</span>.成员方法名() ‐‐ 父类的<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>访问构造方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">this</span>(...) ‐‐ 本类的构造方法<br><span class="hljs-keyword">super</span>(...) ‐‐ 父类的构造方法<br></code></pre></td></tr></table></figure>

<blockquote>
<p>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。<br>super() 和 this() 都必须是在构造方法的<strong>第一行</strong>，所以不能同时出现。</p>
</blockquote>
<h3 id="5-1-8-继承的特点"><a href="#5-1-8-继承的特点" class="headerlink" title="5.1.8 继承的特点"></a>5.1.8 继承的特点</h3><ol>
<li>Java只支持单继承，不支持多继承。</li>
<li>Java支持多层继承(继承体系)。</li>
</ol>
<blockquote>
<p>顶层父类是Object类。所有的类默认继承Object，作为父类。</p>
</blockquote>
<ol start="3">
<li>子类和父类是一种相对的概念。</li>
</ol>
<hr>
<h2 id="5-2-多态"><a href="#5-2-多态" class="headerlink" title="5.2 多态"></a>5.2 多态</h2><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h3><p><strong>多态</strong>是继<strong>封装</strong>、<strong>继承</strong>之后，面向对象的第三大特性。</p>
<p><code>is-a</code>规则的另一种表述法就是<strong>置换法则</strong>，表明程序中出现超类对象的任何地方都可以用子类对象置换。</p>
<h3 id="5-2-2-定义"><a href="#5-2-2-定义" class="headerlink" title="5.2.2 定义"></a>5.2.2 定义</h3><p><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。</p>
<h3 id="5-2-3-前提"><a href="#5-2-3-前提" class="headerlink" title="5.2.3 前提"></a>5.2.3 前提</h3><ol>
<li>继承或者实现【二选一】</li>
<li>方法的重写【意义体现：不重写，无意义】</li>
<li><strong>父类变量指向子类对象</strong>【格式体现】</li>
</ol>
<h3 id="5-2-4-体现形式"><a href="#5-2-4-体现形式" class="headerlink" title="5.2.4 体现形式"></a>5.2.4 体现形式</h3><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型 变量名 = <span class="hljs-keyword">new</span> 子类对象；<br>变量名.方法名();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Fu f = <span class="hljs-keyword">new</span> Zi();<br>f.method();<br></code></pre></td></tr></table></figure>

<p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。</p>
<p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。</strong></p>
<p>代码示例</p>
<p>定义父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 多态形式，创建对象</span><br>		Cat c = <span class="hljs-keyword">new</span> Cat();<br>		Dog d = <span class="hljs-keyword">new</span> Dog();<br>		<span class="hljs-comment">// 调用showCatEat</span><br>		showCatEat(c);<br>		<span class="hljs-comment">// 调用showDogEat</span><br>  	  	showDogEat(d);<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代而执行效果一致</span><br><span class="hljs-comment">		*/</span><br>		showAnimalEat(c);<br>		showAnimalEat(d);<br>	&#125;<br>    <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showCatEat</span> <span class="hljs-params">(Cat c)</span></span>&#123;<br>		c.eat();<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showDogEat</span> <span class="hljs-params">(Dog d)</span></span>&#123;<br>		d.eat();<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showAnimalEat</span> <span class="hljs-params">(Animal a)</span></span>&#123;<br>		a.eat();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。<br>当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。<br>所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。</p>
<h3 id="5-2-5-引用类型转换"><a href="#5-2-5-引用类型转换" class="headerlink" title="5.2.5 引用类型转换"></a>5.2.5 引用类型转换</h3><p>多态的转型分为向上转型与向下转型两种</p>
<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><p><strong>多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的</strong>。</p>
<p>当父类引用指向一个子类对象时，便是向上转型。</p>
<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型 变量名 = <span class="hljs-keyword">new</span> 子类类型();<br>如：Animal a = <span class="hljs-keyword">new</span> Cat();<br></code></pre></td></tr></table></figure>

<h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><p>父类类型向子类类型向下转换的过程，这个过程是<strong>强制的</strong>。</p>
<p>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。<br>使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">子类类型 变量名 = (子类类型) 父类变量名;<br>如:Cat c =(Cat) a;<br></code></pre></td></tr></table></figure>

<h4 id="转型的异常"><a href="#转型的异常" class="headerlink" title="转型的异常"></a>转型的异常</h4><p>转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 向上转型</span><br>		Animal a = <span class="hljs-keyword">new</span> Cat();<br>		a.eat(); <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br>		<span class="hljs-comment">// 向下转型</span><br>		Dog d = (Dog)a;<br>		d.watchHouse(); <span class="hljs-comment">// 调用的是 Dog 的 watchHouse 【运行报错】</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码可以通过编译，但是运行时，却报出了 <code>ClassCastException</code>，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。<br>为了避免ClassCastException的发生，Java提供了<code>instanceof</code>关键字，给引用变量做类型的校验，格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">变量名 <span class="hljs-keyword">instanceof</span> 数据类型<br>如果变量属于该数据类型，返回<span class="hljs-keyword">true</span>。<br>如果变量不属于该数据类型，返回<span class="hljs-keyword">false</span>。<br></code></pre></td></tr></table></figure>

<p>所以，转换前，最好先做一个判断，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 向上转型</span><br>		Animal a = <span class="hljs-keyword">new</span> Cat();<br>		a.eat(); <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br>		<span class="hljs-comment">// 向下转型</span><br>		<span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Cat)&#123;<br>			Cat c = (Cat)a;<br>			c.catchMouse(); <span class="hljs-comment">// 调用的是 Cat 的 catchMouse</span><br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Dog)&#123;<br>			Dog d = (Dog)a;<br>			d.watchHouse(); <span class="hljs-comment">// 调用的是 Dog 的 watchHouse</span><br>		&#125;<br>	&#125;<br>&#125;	<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="5-3-抽象类"><a href="#5-3-抽象类" class="headerlink" title="5.3 抽象类"></a>5.3 抽象类</h2><h3 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h3><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为<code>抽象方法</code>。Java语法规定，<strong>包含抽象方法的类就是抽象类</strong>。</p>
<h3 id="5-3-2-定义"><a href="#5-3-2-定义" class="headerlink" title="5.3.2 定义"></a>5.3.2 定义</h3><ul>
<li>抽象方法 ： 没有方法体的方法</li>
<li>抽象类：包含抽象方法的类</li>
</ul>
<h3 id="5-3-3-格式"><a href="#5-3-3-格式" class="headerlink" title="5.3.3 格式"></a>5.3.3 格式</h3><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>使用<code>abstract</code>关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">abstract</span> 返回值类型 方法名 (参数列表)；<br>如：<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>； </span><br></code></pre></td></tr></table></figure>

<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>如果一个类包含抽象方法，那么该类必须是抽象类。</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名字 </span>&#123;<br>    <br>&#125;<br>如：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>；</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="5-3-4-抽象的使用"><a href="#5-3-4-抽象的使用" class="headerlink" title="5.3.4 抽象的使用"></a>5.3.4 抽象的使用</h3><p>继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span></span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;小猫在墙头走~~~&quot;</span>)；<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CatTest</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建子类对象</span><br>		Cat c = <span class="hljs-keyword">new</span> Cat();<br>		<span class="hljs-comment">// 调用run方法</span><br>		c.run();<br>	&#125;<br>&#125;<br>输出结果：<br>小猫在墙头走~~~<br></code></pre></td></tr></table></figure>

<p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p>
<h3 id="5-3-5-注意事项"><a href="#5-3-5-注意事项" class="headerlink" title="5.3.5 注意事项"></a>5.3.5 注意事项</h3><ul>
<li><p>抽象类不能被实例化（创建对象），如果实例化，编译无法通过而报错。只能创建其非抽象子类的对象。</p>
</li>
<li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p>
<ul>
<li>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</li>
</ul>
</li>
<li><p>除了抽象方法之外，抽象类还可以包含具体数据和具体方法。</p>
</li>
<li><p>类即使不含抽象方法，也可以将类声明为抽象类。</p>
<ul>
<li>理解：抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
</ul>
</li>
<li><p>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</p>
</li>
</ul>
<hr>
<h2 id="5-4-Object类"><a href="#5-4-Object类" class="headerlink" title="5.4 Object类"></a>5.4 Object类</h2><h3 id="5-4-1-概述"><a href="#5-4-1-概述" class="headerlink" title="5.4.1 概述"></a>5.4.1 概述</h3><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p>
<p>如果一个类没有特别指定父类， 那么默认则继承自Object类。</p>
<h3 id="5-4-2-equals方法"><a href="#5-4-2-equals方法" class="headerlink" title="5.4.2 equals方法"></a>5.4.2 equals方法</h3><h4 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h4><ul>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p>
<ol>
<li>默认地址比较</li>
</ol>
<p>如果没有覆盖重写equals方法，那么Object类中默认进行== 运算符的<strong>对象地址</strong>比较，只要不是同一个对象，结果必然为false。</p>
<ol start="2">
<li>对象内容比较</li>
</ol>
<p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>		<span class="hljs-comment">// 如果对象地址一样，则认为相同</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o)<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		<span class="hljs-comment">// 如果参数为空，或者类型信息不一样，则认为不同(getClass方法将返回一个对象所属的类)</span><br>		<span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass())<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>		<span class="hljs-comment">// 转换为当前类型</span><br>		Person person = (Person) o;<br>		<span class="hljs-comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span><br>        <span class="hljs-comment">// 如果两个参数都为null,Objects.equals(a, b)将返回ture，如果一个参数为null，将返回false</span><br>		<span class="hljs-keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。</p>
<p>Objects.equals（）源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object a, Object b)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-keyword">null</span> &amp;&amp; a.equals(b));<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><code>instance </code>of 与 <code>getClass</code>的区别</p>
<p><strong>instance of</strong>：检查类是否是本类或派生类（子类）</p>
<p><strong>getClass</strong>：严格判断是否属于同一个类，不考虑继承方面。</p>
<h4 id="子类调用"><a href="#子类调用" class="headerlink" title="子类调用"></a>子类调用</h4><p>在子类中定义equals方法时，首先调用父类中equals。如果检测失败，对象就不可能相等。如果父类中所要检测的域都相等，在比较子类中的扩展的实例域。</p>
<p>但也可以在子类中全部重写equal所要比较域。</p>
<h3 id="5-4-3-hashCode方法"><a href="#5-4-3-hashCode方法" class="headerlink" title="5.4.3 hashCode方法"></a>5.4.3 hashCode方法</h3><h4 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h4><ul>
<li><code>public native int hashCode();</code>：返回对象的一个哈希值。</li>
</ul>
<p><strong>如果两个对象进行equals比较返回True,那么这两个对象的hashcode()方法必须返回同样的值。</strong></p>
<h3 id="5-3-4-toString方法"><a href="#5-3-4-toString方法" class="headerlink" title="5.3.4 toString方法"></a>5.3.4 toString方法</h3><h4 id="方法摘要-2"><a href="#方法摘要-2" class="headerlink" title="方法摘要"></a>方法摘要</h4><ul>
<li><code>public String toString()</code> ：返回该对象的字符串表示。</li>
</ul>
<p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的<strong>类型</strong>+<strong>@</strong>+<strong>内存地址值</strong>。<br>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p>
<hr>
<h2 id="5-5-泛型"><a href="#5-5-泛型" class="headerlink" title="5.5 泛型"></a>5.5 泛型</h2><h3 id="5-5-1-概述"><a href="#5-5-1-概述" class="headerlink" title="5.5.1 概述"></a>5.5.1 概述</h3><p>泛型：可以在类或方法中预支地使用未知的类型。</p>
<ul>
<li>泛型的类型参数<strong>不允许是基本类型</strong></li>
</ul>
<p>泛型在<strong>编译期</strong>间的两个特性</p>
<ul>
<li>可读性：去除了大量的类型强转代码</li>
<li>安全性：容器中出现其他类型元素，报错</li>
</ul>
<h3 id="5-5-2-含有泛型的类"><a href="#5-5-2-含有泛型的类" class="headerlink" title="5.5.2 含有泛型的类"></a>5.5.2 含有泛型的类</h3><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 类名&lt;代表泛型的变量&gt; </span>&#123; &#125;<br></code></pre></td></tr></table></figure>

<p>例如，API中的ArrayList集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123; &#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123; &#125;<br>	....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用格式：</p>
<p><strong>在创建对象的时候确定泛型</strong></p>
<p>例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p>
<p>举例自定义泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">MVP</span>&gt; </span>&#123;<br>	<span class="hljs-comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span><br>	<span class="hljs-keyword">private</span> MVP mvp;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMVP</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.mvp = mvp;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> MVP <span class="hljs-title">getMVP</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> mvp;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericClassDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建一个泛型为String的类</span><br>		MyGenericClass&lt;String&gt; my = <span class="hljs-keyword">new</span> MyGenericClass&lt;String&gt;();<br>		<span class="hljs-comment">// 调用setMVP</span><br>		my.setMVP(<span class="hljs-string">&quot;大胡子登登&quot;</span>);<br>		<span class="hljs-comment">// 调用getMVP</span><br>		String mvp = my.getMVP();<br>		System.out.println(mvp);<br>		<span class="hljs-comment">//创建一个泛型为Integer的类</span><br>		MyGenericClass&lt;Integer&gt; my2 = <span class="hljs-keyword">new</span> MyGenericClass&lt;Integer&gt;();<br>		my2.setMVP(<span class="hljs-number">123</span>);<br>		Integer mvp2 = my2.getMVP();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-5-3-含有泛型的方法"><a href="#5-5-3-含有泛型的方法" class="headerlink" title="5.5.3 含有泛型的方法"></a>5.5.3 含有泛型的方法</h3><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125;<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericMethod</span> </span>&#123;<br>	<span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>		System.out.println(mvp.getClass());<br>	&#125;<br>	<span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-function">MVP <span class="hljs-title">show2</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> mvp;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用格式：</p>
<p><strong>调用方法时，确定泛型的类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericMethodDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建对象</span><br>		MyGenericMethod mm = <span class="hljs-keyword">new</span> MyGenericMethod();<br>		<span class="hljs-comment">// 演示看方法提示</span><br>		mm.show(<span class="hljs-string">&quot;aaa&quot;</span>);<br>		mm.show(<span class="hljs-number">123</span>);<br>		mm.show(<span class="hljs-number">12.45</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-5-4-含有泛型的接口"><a href="#5-5-4-含有泛型的接口" class="headerlink" title="5.5.4 含有泛型的接口"></a>5.5.4 含有泛型的接口</h3><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名&lt;代表泛型的变量&gt; </span>&#123; &#125;<br></code></pre></td></tr></table></figure>

<p>例如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">getE</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用格式：</p>
<ol>
<li><strong>定义类时确定泛型的类型</strong></li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImp1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span> </span>&#123;<br>		<span class="hljs-comment">// 省略...</span><br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getE</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImp2</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>		<span class="hljs-comment">// 省略...</span><br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getE</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用时再确定</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericInterface</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		MyImp2&lt;String&gt; my = <span class="hljs-keyword">new</span> MyImp2&lt;String&gt;();<br>		my.add(<span class="hljs-string">&quot;aa&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-5-5-泛型通配符"><a href="#5-5-5-泛型通配符" class="headerlink" title="5.5.5 泛型通配符"></a>5.5.5 泛型通配符</h3><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h4 id="5-5-5-1-通配符基本使用"><a href="#5-5-5-1-通配符基本使用" class="headerlink" title="5.5.5.1 通配符基本使用"></a>5.5.5.1 通配符基本使用</h4><p>泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用<code>?</code>,<strong><code>?</code>表示未知通配符</strong>。<br>此时只能接受数据,不能往该集合中存储数据。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	Collection&lt;Intger&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>	getElement(list1);<br>	Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>	getElement(list2);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement</span><span class="hljs-params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">//？代表可以接收任意类型</span><br></code></pre></td></tr></table></figure>



<h4 id="5-5-5-2-通配符高级使用—-受限泛型"><a href="#5-5-5-2-通配符高级使用—-受限泛型" class="headerlink" title="5.5.5.2 通配符高级使用—-受限泛型"></a>5.5.5.2 通配符高级使用—-受限泛型</h4><p>在JAVA的泛型中可以指定一个泛型的上限和下限。</p>
<ol>
<li><strong>泛型的上限</strong>：</li>
</ol>
<ul>
<li><strong>格式</strong>： 类型名称<code> &lt;? extends 类 &gt;</code>对象名称</li>
<li><strong>意义</strong>：只能接收该类型及其子类</li>
</ul>
<ol start="2">
<li><strong>泛型的下限</strong>：</li>
</ol>
<ul>
<li><strong>格式</strong>：类型名称<code> &lt;? super 类 &gt;</code>对象名称</li>
<li><strong>意义</strong>：只能接收该类型及其父类型</li>
</ul>
<blockquote>
<p>注：</p>
<p>一个类型变量或通配符可以有多个限定，例如：<code>T extends Comparable &amp; Serializable</code></p>
<p>限定类型用<code>&amp;</code>分隔，类型变量用<code>,</code>分隔</p>
</blockquote>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>	Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>	Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>	Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>	getElement1(list1);<br>	getElement1(list2);<span class="hljs-comment">//报错</span><br>	getElement1(list3);<br>	getElement1(list4);<span class="hljs-comment">//报错</span><br>	getElement2(list1);<span class="hljs-comment">//报错</span><br>	getElement2(list2);<span class="hljs-comment">//报错</span><br>	getElement2(list3);<br>	getElement2(list4);<br>&#125;<br><span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-5-6-泛型擦除"><a href="#5-5-6-泛型擦除" class="headerlink" title="5.5.6 泛型擦除"></a>5.5.6 泛型擦除</h3><p>Java的泛型是<strong>伪泛型</strong>，这是因为Java在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为<strong>类型擦除</strong>。</p>
<p><strong>泛型擦除的表现-原始类型相等</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    System.out.println(list1.getClass().getName());<br>    System.out.println(list2.getClass().getName());<br>    System.out.println(list1.getClass()==list2.getClass());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/image-20210822202748202.png" srcset="/img/loading.gif" lazyload alt="image-20210822202748202"></p>
<p><strong>泛型擦除的表现-通过反射添加其它类型元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">998</span>);<br>    list.getClass().getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="hljs-string">&quot;asd&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>        System.out.println(list.get(i));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>程序中定义了一个<code>ArrayList</code>泛型类型实例化为<code>Integer</code>对象，如果直接调用<code>add()</code>方法，那么只能存储整数数据，不过当我们利用反射调用<code>add()</code>方法的时候，却可以存储字符串，这说明了<code>Integer</code>泛型实例在编译之后被擦除掉了，只保留了原始类型。</p>
</blockquote>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/image-20210822203445233.png" srcset="/img/loading.gif" lazyload alt="image-20210822203445233"></p>
<p><strong>其中的问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br><br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();  <br>    list.add(<span class="hljs-string">&quot;123&quot;</span>);  <br>    list.add(<span class="hljs-number">123</span>);<span class="hljs-comment">//编译错误  </span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在上面的程序中，使用<code>add</code>方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为<code>Object</code>，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br><br>    ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList();  <br>    list1.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>    list1.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译错误  </span><br>    String str1 = list1.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br><br>    ArrayList list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();  <br>    list2.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>    list2.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译通过  </span><br>    Object object = list2.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是Object  </span><br><br>    <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;().add(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>    <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;().add(<span class="hljs-number">22</span>); <span class="hljs-comment">//编译错误  </span><br><br>    String str2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;().get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br>&#125;  <br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>类型检查就是针对引用的</strong>，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Object&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();  <br>list1.add(<span class="hljs-keyword">new</span> Object());  <br>list1.add(<span class="hljs-keyword">new</span> Object());  <br>ArrayList&lt;String&gt; list2 = list1; <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure>

<p>在第4行代码的时候，会有编译错误。</p>
<p>先假设它编译没错。那么当我们使用<code>list2</code>引用用<code>get()</code>方法取值的时候，返回的都是<code>String</code>类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了<code>Object</code>类型的对象，这样就会有<code>ClassCastException</code>了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();  <br>list1.add(<span class="hljs-keyword">new</span> String());  <br>list1.add(<span class="hljs-keyword">new</span> String());<br>ArrayList&lt;Object&gt; list2 = list1; <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure>

<p>这样的情况比上一种情况好的多，最起码，在用<code>list2</code>取值的时候不会出现<code>ClassCastException</code>，因为是从<code>String</code>转换为<code>Object</code>。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用<code>list2</code>往里面<code>add()</code>新的对象，那么到时候取得时候，我怎么知道我取出来的到底是<code>String</code>类型的，还是<code>Object</code>类型的呢？</p>
<p><strong>为什么不能创建泛型数组</strong></p>
<p>因为这样做会破坏类型安全。</p>
<p>泛型在<strong>编译期</strong>间的两个特性</p>
<ul>
<li>可读性：去除了大量的类型强转代码</li>
<li>安全性：容器中出现其他类型元素，报错</li>
</ul>
<p>Java中对普通数组的安全性验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strs = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>Object[] objs = strs;   <span class="hljs-comment">//编译通过，运行通过</span><br>objs[<span class="hljs-number">0</span>] = <span class="hljs-number">123</span> <span class="hljs-comment">//编译通过，运行报错</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>将String数据转Object数组， objs里面记忆的是String元素， 第三行我们给objs赋值了一个int元素，运行时会报出ArrayStoreException。<br>问题：<br>在Java中，数组不能保证安全性（在编译期间不暴露问题，在运行时抛出异常）。假设允许创建泛型数组，同样会出现上述问题，则不能保证泛型的安全性特性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设存在泛型类 Pair&lt;T&gt;</span><br>Pair&lt;String&gt;[] pairs = <span class="hljs-keyword">new</span> Pair&lt;String&gt;[<span class="hljs-number">10</span>];<br>Object[] objs = pairs;<br>pairs[<span class="hljs-number">0</span>] = <span class="hljs-number">123</span>;   <span class="hljs-comment">//这里在编译期间不会暴露元素123不是String类型问题</span><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;Manager&gt;[] pairs = <span class="hljs-keyword">new</span> Pair&lt;Manager&gt;[<span class="hljs-number">10</span>];<br>pairs[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;Employee&gt;;<br><br><span class="hljs-comment">//这段代码中，Pair&lt;Manager&gt;[], Pair&lt;Employee&gt;发生类型擦除后变成Pair[], Pair。 将Pair放入Pair[]数组，显然是合理的。但是违反了泛型的安全性特性</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="5-6-包装类"><a href="#5-6-包装类" class="headerlink" title="5.6 包装类"></a>5.6 包装类</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h3><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">对应的包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<h3 id="5-6-2-装箱与拆箱"><a href="#5-6-2-装箱与拆箱" class="headerlink" title="5.6.2 装箱与拆箱"></a>5.6.2 装箱与拆箱</h3><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p>
<ul>
<li><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</li>
<li><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基本数值----&gt;包装对象</span><br>Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用构造函数函数</span><br>Integer iii = Integer.valueOf(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用包装类中的valueOf方法</span><br><span class="hljs-comment">//包装对象----&gt;基本数值</span><br><span class="hljs-keyword">int</span> num = i.intValue();<br></code></pre></td></tr></table></figure>



<h3 id="5-6-3-自动装箱与自动拆箱"><a href="#5-6-3-自动装箱与自动拆箱" class="headerlink" title="5.6.3 自动装箱与自动拆箱"></a>5.6.3 自动装箱与自动拆箱</h3><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-number">4</span>;<span class="hljs-comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span><br>i = i + <span class="hljs-number">5</span>;<span class="hljs-comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span><br><span class="hljs-comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span><br></code></pre></td></tr></table></figure>



<h3 id="5-6-4-包装类对象比较"><a href="#5-6-4-包装类对象比较" class="headerlink" title="5.6.4 包装类对象比较"></a>5.6.4 包装类对象比较</h3><p>两个包装类对象进行比较时，不要用<code>==</code>，应当使用<code>equals</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer a = <span class="hljs-number">1</span>;<br>    Integer b = <span class="hljs-number">1</span>;<br>    Integer c = <span class="hljs-number">128</span>;<br>    Integer d = <span class="hljs-number">128</span>;<br>    System.out.println(a == b); <span class="hljs-comment">//输出ture</span><br>    System.out.println(c == d); <span class="hljs-comment">//输出false</span><br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>自动装箱规范要求boolean、byte、char&lt;=127，介于-128~127之前的short和int被包装到固定的对象中（被一个名为cache的数组中<strong>缓存</strong>起来）</p>
<p>double、float是没有缓存机制的</p>
</blockquote>
<h3 id="5-6-5-基本类型与字符串之间的转换"><a href="#5-6-5-基本类型与字符串之间的转换" class="headerlink" title="5.6.5 基本类型与字符串之间的转换"></a>5.6.5 基本类型与字符串之间的转换</h3><h4 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h4><p>有三种方法</p>
<ol>
<li>使用包装类的toString()方法</li>
<li>使用String类的valueOf()方法</li>
<li>基本类型直接与””直接连接，如：34+””</li>
</ol>
<h4 id="String转换成对应的基本类型"><a href="#String转换成对应的基本类型" class="headerlink" title="String转换成对应的基本类型"></a>String转换成对应的基本类型</h4><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p>
<ul>
<li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li>
<li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
<li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基<br>本类型。</li>
</ul>
<blockquote>
<p>注:</p>
<ol>
<li><p>parseXxx(String s)，调用parseXxx(String s, int radix)。并将radix设置为10。radix为给定字符串的进制    </p>
</li>
<li><p>如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。 </p>
</li>
</ol>
</blockquote>
<hr>
<h2 id="5-7-可变参数"><a href="#5-7-可变参数" class="headerlink" title="5.7 可变参数"></a>5.7 可变参数</h2><h3 id="5-7-1-概述"><a href="#5-7-1-概述" class="headerlink" title="5.7.1 概述"></a>5.7.1 概述</h3><p><strong>适用于参数个数不确定，类型确定的情况，java把可变参数当做数组处理。</strong></p>
<h3 id="5-7-2-特点"><a href="#5-7-2-特点" class="headerlink" title="5.7.2 特点"></a>5.7.2 特点</h3><ul>
<li>只能出现在参数列表的最后； </li>
<li><code>...</code>位于变量类型和变量名之间，前后有无空格都可以；</li>
<li>调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用可变参数求多个数的和</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Varable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br>        System.out.println(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span>... args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>            sum += args[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="5-8-枚举类"><a href="#5-8-枚举类" class="headerlink" title="5.8 枚举类"></a>5.8 枚举类</h2><h3 id="5-8-1-概述"><a href="#5-8-1-概述" class="headerlink" title="5.8.1 概述"></a>5.8.1 概述</h3><p>枚举是多例，一个类有多个实例，但实例的个数不是无穷的，是有限个数的。</p>
<p><code>enum</code>的全称为enumeration，是 JDK 1.5 中引入的新特性。在Java中，被 <code>enum</code> 关键字修饰的类型就是枚举类型。</p>
<h3 id="5-8-2-定义枚举类"><a href="#5-8-2-定义枚举类" class="headerlink" title="5.8.2 定义枚举类"></a>5.8.2 定义枚举类</h3><p>定义枚举类型需要使用<code>enum</code>关键字，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123; <br>    RED, GREEN, BLUE <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>所有枚举类都默认是Enum类的子类，无需我们使用extends来继承。这说明Enum中的方法所有枚举类都拥有。</li>
</ul>
<p>如果枚举不添加任何方法，<strong>枚举值默认为从0开始的有序数值</strong>。以 Color 枚举类型举例，它的枚举常量依次为 <code>RED：0，GREEN：1，BLUE：2</code>。</p>
<p><strong>Java 不允许使用<code>=</code>为枚举常量赋值</strong></p>
<ul>
<li>比较两个枚举类型的值时，不需要调用<code>equals</code>，直接使用<code>==</code>就可以</li>
</ul>
<h3 id="5-8-3-常用方法"><a href="#5-8-3-常用方法" class="headerlink" title="5.8.3 常用方法"></a>5.8.3 常用方法</h3><p><code>java.lang.Enum&lt;E&gt;</code></p>
<ul>
<li><code>public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name)</code>：返回指定名字、给定类的枚举常量</li>
<li><code>public String toString()</code>：返回枚举常量名</li>
<li><code>public final int ordinal()</code>：返回枚举常量在enum声明中的位置，位置从0开始计数</li>
<li><code>public final int compareTo(E o)</code>：如果枚举常量出现在o之前，则返回一个负值；如果<code>this==o</code>，返回0；反着返回正值</li>
</ul>
<h3 id="5-8-4-枚举类的使用"><a href="#5-8-4-枚举类的使用" class="headerlink" title="5.8.4 枚举类的使用"></a>5.8.4 枚举类的使用</h3><p><strong>枚举可以添加普通方法、静态方法、抽象方法、构造方法</strong>**</p>
<p><strong>注意一个细节：如果要为enum定义方法，那么必须在enum的最后一个实例尾部添加一个分号。此外，在enum中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。</strong></p>
<p>例：全面展示如何在枚举中定义普通方法、静态方法、抽象方法、构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ErrorCode</span> </span>&#123;<br>    OK(<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功&quot;</span>;<br>        &#125;<br>    &#125;,<br>    ERROR_A(<span class="hljs-number">100</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;错误A&quot;</span>;<br>        &#125;<br>    &#125;,<br>    ERROR_B(<span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;错误B&quot;</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> code;<br><br>    <span class="hljs-comment">// 构造方法：enum的构造方法只能被声明为private权限或不声明权限</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ErrorCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123; <span class="hljs-comment">// 构造方法</span><br>        <span class="hljs-keyword">this</span>.code = number;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 普通方法</span><br>        <span class="hljs-keyword">return</span> code;<br>    &#125; <span class="hljs-comment">// 普通方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123; <span class="hljs-comment">// 静态方法</span><br>        <span class="hljs-keyword">for</span> (ErrorCode s : ErrorCode.values()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;code: &quot;</span> + s.getCode() + <span class="hljs-string">&quot;, description: &quot;</span> + s.getDescription());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注：上面的例子并不可取，仅仅是为了展示枚举支持定义各种方法。下面是一个简化的例子</p>
<p>本例和上例的执行结果完全相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ErrorCodeEn</span> </span>&#123;<br>    OK(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;成功&quot;</span>),<br>    ERROR_A(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;错误A&quot;</span>),<br>    ERROR_B(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;错误B&quot;</span>);<br><br>    ErrorCodeEn(<span class="hljs-keyword">int</span> number, String description) &#123;<br>        <span class="hljs-keyword">this</span>.code = number;<br>        <span class="hljs-keyword">this</span>.description = description;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> code;<br>    <span class="hljs-keyword">private</span> String description;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123; <span class="hljs-comment">// 静态方法</span><br>        <span class="hljs-keyword">for</span> (ErrorCodeEn s : ErrorCodeEn.values()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;code: &quot;</span> + s.getCode() + <span class="hljs-string">&quot;, description: &quot;</span> + s.getDescription());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="5-9-反射"><a href="#5-9-反射" class="headerlink" title="5.9 反射"></a>5.9 反射</h2><h3 id="5-9-1-概述"><a href="#5-9-1-概述" class="headerlink" title="5.9.1 概述"></a>5.9.1 概述</h3><p>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意方法和属性。这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
<h3 id="5-9-2-反射机制的相关类"><a href="#5-9-2-反射机制的相关类" class="headerlink" title="5.9.2 反射机制的相关类"></a>5.9.2 反射机制的相关类</h3><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Class类</td>
<td align="center">代表类的实体，在运行的Java应用程序中表示类和接口</td>
</tr>
<tr>
<td align="center">Field类</td>
<td align="center">代表类的成员变量（成员变量也称为类的属性）</td>
</tr>
<tr>
<td align="center">Method类</td>
<td align="center">代表类的方法</td>
</tr>
<tr>
<td align="center">Constructor类</td>
<td align="center">代表类的构造方法</td>
</tr>
</tbody></table>
<h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>Class代表类的实体，在运行的Java应用程序中表示类和接口。</p>
<ul>
<li><strong>获得类相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">asSubclass(Class<U> clazz)</U></td>
<td align="center">把传递的类的对象转换成代表其子类的对象</td>
</tr>
<tr>
<td align="center">Cast</td>
<td align="center">把对象转换成代表类或是接口的对象</td>
</tr>
<tr>
<td align="center">getClassLoader()</td>
<td align="center">获得类的加载器</td>
</tr>
<tr>
<td align="center">getClasses()</td>
<td align="center">返回一个数组，数组中包含该类中所有公共类和接口类的对象</td>
</tr>
<tr>
<td align="center">getDeclaredClasses()</td>
<td align="center">返回一个数组，数组中包含该类中所有类和接口类的对象</td>
</tr>
<tr>
<td align="center">forName(String className)</td>
<td align="center">根据类名返回类的对象</td>
</tr>
<tr>
<td align="center">getName()</td>
<td align="center">获得类的完整路径名字</td>
</tr>
<tr>
<td align="center">newInstance()</td>
<td align="center">创建类的实例</td>
</tr>
<tr>
<td align="center">getPackage()</td>
<td align="center">获得类的包</td>
</tr>
<tr>
<td align="center">getSimpleName()</td>
<td align="center">获得类的名字</td>
</tr>
<tr>
<td align="center">getSuperclass()</td>
<td align="center">获得当前类继承的父类的名字</td>
</tr>
<tr>
<td align="center">getInterfaces()</td>
<td align="center">获得当前类实现的类或是接口</td>
</tr>
</tbody></table>
<ul>
<li><strong>获得类中属性相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getField(String name)</td>
<td align="center">获得某个公有的属性对象</td>
</tr>
<tr>
<td align="center">getFields()</td>
<td align="center">获得所有公有的属性对象</td>
</tr>
<tr>
<td align="center">getDeclaredField(String name)</td>
<td align="center">获得某个属性对象</td>
</tr>
<tr>
<td align="center">getDeclaredFields()</td>
<td align="center">获得所有属性对象</td>
</tr>
</tbody></table>
<ul>
<li><strong>获得类中注解相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getAnnotation(Class<A> annotationClass)</A></td>
<td align="center">返回该类中与参数类型匹配的公有注解对象</td>
</tr>
<tr>
<td align="center">getAnnotations()</td>
<td align="center">返回该类所有的公有注解对象</td>
</tr>
<tr>
<td align="center">getDeclaredAnnotation(Class<A> annotationClass)</A></td>
<td align="center">返回该类中与参数类型匹配的所有注解对象</td>
</tr>
<tr>
<td align="center">getDeclaredAnnotations()</td>
<td align="center">返回该类所有的注解对象</td>
</tr>
</tbody></table>
<ul>
<li><strong>获得类中构造器相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getConstructor(Class…&lt;?&gt; parameterTypes)</td>
<td align="center">获得该类中与参数类型匹配的公有构造方法</td>
</tr>
<tr>
<td align="center">getConstructors()</td>
<td align="center">获得该类的所有公有构造方法</td>
</tr>
<tr>
<td align="center">getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td>
<td align="center">获得该类中与参数类型匹配的构造方法</td>
</tr>
<tr>
<td align="center">getDeclaredConstructors()</td>
<td align="center">获得该类所有构造方法</td>
</tr>
</tbody></table>
<ul>
<li><strong>获得类中方法相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getMethod(String name, Class…&lt;?&gt; parameterTypes)</td>
<td align="center">获得该类某个公有的方法</td>
</tr>
<tr>
<td align="center">getMethods()</td>
<td align="center">获得该类所有公有的方法</td>
</tr>
<tr>
<td align="center">getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td>
<td align="center">获得该类某个方法</td>
</tr>
<tr>
<td align="center">getDeclaredMethods()</td>
<td align="center">获得该类所有方法</td>
</tr>
</tbody></table>
<ul>
<li><strong>类中其他重要的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">isAnnotation()</td>
<td align="center">如果是注解类型则返回true</td>
</tr>
<tr>
<td align="center">isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td>
<td align="center">如果是指定类型注解类型则返回true</td>
</tr>
<tr>
<td align="center">isAnonymousClass()</td>
<td align="center">如果是匿名类则返回true</td>
</tr>
<tr>
<td align="center">isArray()</td>
<td align="center">如果是一个数组类则返回true</td>
</tr>
<tr>
<td align="center">isEnum()</td>
<td align="center">如果是枚举类则返回true</td>
</tr>
<tr>
<td align="center">isInstance(Object obj)</td>
<td align="center">如果obj是该类的实例则返回true</td>
</tr>
<tr>
<td align="center">isInterface()</td>
<td align="center">如果是接口类则返回true</td>
</tr>
<tr>
<td align="center">isLocalClass()</td>
<td align="center">如果是局部类则返回true</td>
</tr>
<tr>
<td align="center">isMemberClass()</td>
<td align="center">如果是内部类则返回true</td>
</tr>
</tbody></table>
<h4 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h4><p>Field类代表类的成员变量（成员变量也称为类的属性）。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">equals(Object obj)</td>
<td align="center">属性与obj相等则返回true</td>
</tr>
<tr>
<td align="center">get(Object obj)</td>
<td align="center">获得obj中对应的属性值</td>
</tr>
<tr>
<td align="center">set(Object obj, Object value)</td>
<td align="center">设置obj中对应属性值</td>
</tr>
</tbody></table>
<h4 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h4><p>Method代表类的方法。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">invoke(Object obj, Object… args)</td>
<td align="center">传递object对象及参数调用该对象对应的方法</td>
</tr>
</tbody></table>
<h4 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h4><p>Constructo代表类的构造方法。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">newInstance(Object… initargs)</td>
<td align="center">根据传递的参数创建类的对象</td>
</tr>
</tbody></table>
<ul>
<li>被反射类Book.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String TAG = <span class="hljs-string">&quot;BookTag&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String author;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Book&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, author=&#x27;&quot;</span> + author + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Book</span><span class="hljs-params">(String name, String author)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.author = author;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> author;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(String author)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.author = author;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">declaredMethod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        String string = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">switch</span> (index) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                string = <span class="hljs-string">&quot;I am declaredMethod 1 !&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                string = <span class="hljs-string">&quot;I am declaredMethod 2 !&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                string = <span class="hljs-string">&quot;I am declaredMethod 1 !&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> string;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>反射逻辑封装在ReflectClass.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectClass</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String TAG = <span class="hljs-string">&quot;peter.log.ReflectClass&quot;</span>;<br><br>    <span class="hljs-comment">// 创建对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflectNewInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; classBook = Class.forName(<span class="hljs-string">&quot;com.android.peter.reflectdemo.Book&quot;</span>);<br>            Object objectBook = classBook.newInstance();<br>            Book book = (Book) objectBook;<br>            book.setName(<span class="hljs-string">&quot;Android进阶之光&quot;</span>);<br>            book.setAuthor(<span class="hljs-string">&quot;刘望舒&quot;</span>);<br>            Log.d(TAG,<span class="hljs-string">&quot;reflectNewInstance book = &quot;</span> + book.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 反射私有的构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflectPrivateConstructor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; classBook = Class.forName(<span class="hljs-string">&quot;com.android.peter.reflectdemo.Book&quot;</span>);<br>            Constructor&lt;?&gt; declaredConstructorBook = classBook.getDeclaredConstructor(String.class,String.class);<br>            declaredConstructorBook.setAccessible(<span class="hljs-keyword">true</span>);<br>            Object objectBook = declaredConstructorBook.newInstance(<span class="hljs-string">&quot;Android开发艺术探索&quot;</span>,<span class="hljs-string">&quot;任玉刚&quot;</span>);<br>            Book book = (Book) objectBook;<br>            Log.d(TAG,<span class="hljs-string">&quot;reflectPrivateConstructor book = &quot;</span> + book.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 反射私有属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflectPrivateField</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; classBook = Class.forName(<span class="hljs-string">&quot;com.android.peter.reflectdemo.Book&quot;</span>);<br>            Object objectBook = classBook.newInstance();<br>            Field fieldTag = classBook.getDeclaredField(<span class="hljs-string">&quot;TAG&quot;</span>);<br>            fieldTag.setAccessible(<span class="hljs-keyword">true</span>);<br>            String tag = (String) fieldTag.get(objectBook);<br>            Log.d(TAG,<span class="hljs-string">&quot;reflectPrivateField tag = &quot;</span> + tag);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 反射私有方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflectPrivateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; classBook = Class.forName(<span class="hljs-string">&quot;com.android.peter.reflectdemo.Book&quot;</span>);<br>            Method methodBook = classBook.getDeclaredMethod(<span class="hljs-string">&quot;declaredMethod&quot;</span>,<span class="hljs-keyword">int</span>.class);<br>            methodBook.setAccessible(<span class="hljs-keyword">true</span>);<br>            Object objectBook = classBook.newInstance();<br>            String string = (String) methodBook.invoke(objectBook,<span class="hljs-number">0</span>);<br><br>            Log.d(TAG,<span class="hljs-string">&quot;reflectPrivateMethod string = &quot;</span> + string);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获得系统Zenmode值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getZenMode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> zenMode = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; cServiceManager = Class.forName(<span class="hljs-string">&quot;android.os.ServiceManager&quot;</span>);<br>            Method mGetService = cServiceManager.getMethod(<span class="hljs-string">&quot;getService&quot;</span>, String.class);<br>            Object oNotificationManagerService = mGetService.invoke(<span class="hljs-keyword">null</span>, Context.NOTIFICATION_SERVICE);<br>            Class&lt;?&gt; cINotificationManagerStub = Class.forName(<span class="hljs-string">&quot;android.app.INotificationManager$Stub&quot;</span>);<br>            Method mAsInterface = cINotificationManagerStub.getMethod(<span class="hljs-string">&quot;asInterface&quot;</span>,IBinder.class);<br>            Object oINotificationManager = mAsInterface.invoke(<span class="hljs-keyword">null</span>,oNotificationManagerService);<br>            Method mGetZenMode = cINotificationManagerStub.getMethod(<span class="hljs-string">&quot;getZenMode&quot;</span>);<br>            zenMode = (<span class="hljs-keyword">int</span>) mGetZenMode.invoke(oINotificationManager);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> zenMode;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭手机</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutDown</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; cServiceManager = Class.forName(<span class="hljs-string">&quot;android.os.ServiceManager&quot;</span>);<br>            Method mGetService = cServiceManager.getMethod(<span class="hljs-string">&quot;getService&quot;</span>,String.class);<br>            Object oPowerManagerService = mGetService.invoke(<span class="hljs-keyword">null</span>,Context.POWER_SERVICE);<br>            Class&lt;?&gt; cIPowerManagerStub = Class.forName(<span class="hljs-string">&quot;android.os.IPowerManager$Stub&quot;</span>);<br>            Method mShutdown = cIPowerManagerStub.getMethod(<span class="hljs-string">&quot;shutdown&quot;</span>,<span class="hljs-keyword">boolean</span>.class,String.class,<span class="hljs-keyword">boolean</span>.class);<br>            Method mAsInterface = cIPowerManagerStub.getMethod(<span class="hljs-string">&quot;asInterface&quot;</span>,IBinder.class);<br>            Object oIPowerManager = mAsInterface.invoke(<span class="hljs-keyword">null</span>,oPowerManagerService);<br>            mShutdown.invoke(oIPowerManager,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">true</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdownOrReboot</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> shutdown, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> confirm)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; ServiceManager = Class.forName(<span class="hljs-string">&quot;android.os.ServiceManager&quot;</span>);<br>            <span class="hljs-comment">// 获得ServiceManager的getService方法</span><br>            Method getService = ServiceManager.getMethod(<span class="hljs-string">&quot;getService&quot;</span>, java.lang.String.class);<br>            <span class="hljs-comment">// 调用getService获取RemoteService</span><br>            Object oRemoteService = getService.invoke(<span class="hljs-keyword">null</span>, Context.POWER_SERVICE);<br>            <span class="hljs-comment">// 获得IPowerManager.Stub类</span><br>            Class&lt;?&gt; cStub = Class.forName(<span class="hljs-string">&quot;android.os.IPowerManager$Stub&quot;</span>);<br>            <span class="hljs-comment">// 获得asInterface方法</span><br>            Method asInterface = cStub.getMethod(<span class="hljs-string">&quot;asInterface&quot;</span>, android.os.IBinder.class);<br>            <span class="hljs-comment">// 调用asInterface方法获取IPowerManager对象</span><br>            Object oIPowerManager = asInterface.invoke(<span class="hljs-keyword">null</span>, oRemoteService);<br>            <span class="hljs-keyword">if</span> (shutdown) &#123;<br>                <span class="hljs-comment">// 获得shutdown()方法</span><br>                Method shutdownMethod = oIPowerManager.getClass().getMethod(<br>                        <span class="hljs-string">&quot;shutdown&quot;</span>, <span class="hljs-keyword">boolean</span>.class, String.class, <span class="hljs-keyword">boolean</span>.class);<br>                <span class="hljs-comment">// 调用shutdown()方法</span><br>                shutdownMethod.invoke(oIPowerManager, confirm, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 获得reboot()方法</span><br>                Method rebootMethod = oIPowerManager.getClass().getMethod(<span class="hljs-string">&quot;reboot&quot;</span>,<br>                        <span class="hljs-keyword">boolean</span>.class, String.class, <span class="hljs-keyword">boolean</span>.class);<br>                <span class="hljs-comment">// 调用reboot()方法</span><br>                rebootMethod.invoke(oIPowerManager, confirm, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>调用相应反射逻辑方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 创建对象</span><br>    ReflectClass.reflectNewInstance();<br><br>    <span class="hljs-comment">// 反射私有的构造方法</span><br>    ReflectClass.reflectPrivateConstructor();<br><br>    <span class="hljs-comment">// 反射私有属性</span><br>    ReflectClass.reflectPrivateField();<br><br>    <span class="hljs-comment">// 反射私有方法</span><br>    ReflectClass.reflectPrivateMethod();<br>&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    ex.printStackTrace();<br>&#125;<br><br>Log.d(TAG,<span class="hljs-string">&quot; zenmode = &quot;</span> + ReflectClass.getZenMode());<br></code></pre></td></tr></table></figure>

<ul>
<li>Log输出结果如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">08-<span class="hljs-number">27</span> <span class="hljs-number">15</span>:<span class="hljs-number">11</span>:<span class="hljs-number">37.999</span> <span class="hljs-number">11987</span>-<span class="hljs-number">11987</span>/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectNewInstance book = Book&#123;name=<span class="hljs-string">&#x27;Android进阶之光&#x27;</span>, author=<span class="hljs-string">&#x27;刘望舒&#x27;</span>&#125;<br>08-<span class="hljs-number">27</span> <span class="hljs-number">15</span>:<span class="hljs-number">11</span>:<span class="hljs-number">38.000</span> <span class="hljs-number">11987</span>-<span class="hljs-number">11987</span>/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateConstructor book = Book&#123;name=<span class="hljs-string">&#x27;Android开发艺术探索&#x27;</span>, author=<span class="hljs-string">&#x27;任玉刚&#x27;</span>&#125;<br>08-<span class="hljs-number">27</span> <span class="hljs-number">15</span>:<span class="hljs-number">11</span>:<span class="hljs-number">38.000</span> <span class="hljs-number">11987</span>-<span class="hljs-number">11987</span>/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateField tag = BookTag<br>08-<span class="hljs-number">27</span> <span class="hljs-number">15</span>:<span class="hljs-number">11</span>:<span class="hljs-number">38.000</span> <span class="hljs-number">11987</span>-<span class="hljs-number">11987</span>/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateMethod string = I am declaredMethod <span class="hljs-number">1</span> !<br>08-<span class="hljs-number">27</span> <span class="hljs-number">15</span>:<span class="hljs-number">11</span>:<span class="hljs-number">38.004</span> <span class="hljs-number">11987</span>-<span class="hljs-number">11987</span>/com.android.peter.reflectdemo D/peter.log.ReflectDemo:  zenmode = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<hr>
<h1 id="第6章-接口、lambad表达式与内部类"><a href="#第6章-接口、lambad表达式与内部类" class="headerlink" title="第6章 接口、lambad表达式与内部类"></a>第6章 接口、lambad表达式与内部类</h1><h2 id="6-1-接口"><a href="#6-1-接口" class="headerlink" title="6.1 接口"></a>6.1 接口</h2><h3 id="6-1-1-概述"><a href="#6-1-1-概述" class="headerlink" title="6.1.1 概述"></a>6.1.1 概述</h3><p>接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。</p>
<p>接口的定义，它与定义类方式相似，但是使用 <code>interface</code>关键字。它也会被编译成**.class<strong>文件，但一定要明确它并</strong>不是类<strong>，而是另外一种</strong>引用数据类型**。</p>
<blockquote>
<p>引用数据类型：数组，类，接口。</p>
</blockquote>
<p>接口的使用，它<strong>不能创建对象</strong>，但是<strong>可以被实现</strong>（<code> implements</code>，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p>
<h3 id="6-1-2-定义"><a href="#6-1-2-定义" class="headerlink" title="6.1.2 定义"></a>6.1.2 定义</h3><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名称 </span>&#123;<br>	<span class="hljs-comment">// 抽象方法</span><br>	<span class="hljs-comment">// 默认方法</span><br>	<span class="hljs-comment">// 静态方法</span><br>	<span class="hljs-comment">// 私有方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="含有抽象方法"><a href="#含有抽象方法" class="headerlink" title="含有抽象方法"></a>含有抽象方法</h4><ul>
<li><strong>抽象方法</strong>：使用<code>abstract</code>关键字修饰，可以省略，没有方法体。该方法供子类实现使用。</li>
</ul>
<h4 id="含有默认方法和静态方法"><a href="#含有默认方法和静态方法" class="headerlink" title="含有默认方法和静态方法"></a>含有默认方法和静态方法</h4><ul>
<li><strong>默认方法</strong>：使用<code>default</code>修饰，不可省略，供子类调用或者子类重写。</li>
<li><strong>静态方法</strong>：使用<code>static</code>修饰，供接口直接调用。</li>
</ul>
<h4 id="含有私有方法和私有静态方法"><a href="#含有私有方法和私有静态方法" class="headerlink" title="含有私有方法和私有静态方法"></a>含有私有方法和私有静态方法</h4><ul>
<li><strong>私有方法</strong>：使用<code>private</code>修饰，供接口中的默认方法或者静态方法调用。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterFaceName</span> </span>&#123;<br>    <span class="hljs-comment">// 抽象方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 默认方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 执行语句</span><br>	&#125;<br>    <span class="hljs-comment">// 静态方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 执行语句</span><br>	&#125;<br>    <span class="hljs-comment">// 私有方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method4</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 执行语句</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-1-3-接口的基本实现"><a href="#6-1-3-接口的基本实现" class="headerlink" title="6.1.3 接口的基本实现"></a>6.1.3 接口的基本实现</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code>implements</code>关键字。</p>
<p><strong>非抽象子类实现接口</strong></p>
<ul>
<li>必须<strong>重写接口中所有抽象方法</strong>。</li>
</ul>
<ol start="2">
<li>继承了接口的默认方法，即可以直接调用，也可以重写。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 <span class="hljs-keyword">implements</span> 接口名 </span>&#123;<br>	<span class="hljs-comment">// 重写接口中抽象方法【必须】</span><br>	<span class="hljs-comment">// 重写接口中默认方法【可选】</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="抽象方法的使用"><a href="#抽象方法的使用" class="headerlink" title="抽象方法的使用"></a>抽象方法的使用</h4><p><strong>必须全部实现</strong>，代码如下：</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br>	<span class="hljs-comment">// 定义抽象方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;吃东西&quot;</span>);<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;晚上睡&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建子类对象</span><br>		Animal a = <span class="hljs-keyword">new</span> Animal();<br>		<span class="hljs-comment">// 调用实现后的方法</span><br>		a.eat();<br>		a.sleep();<br>	&#125;<br>&#125;<br>输出结果：<br>吃东西<br>晚上睡<br></code></pre></td></tr></table></figure>



<h4 id="默认方法的使用"><a href="#默认方法的使用" class="headerlink" title="默认方法的使用"></a>默认方法的使用</h4><p><strong>可以继承，可以重写</strong>，二选一，但是只能通过实现类的对象来调用。</p>
<ol>
<li>继承默认方法，代码如下：</li>
</ol>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;天上飞&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br>	<span class="hljs-comment">// 继承，什么都不用写，直接调用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建子类对象</span><br>		Animal a = <span class="hljs-keyword">new</span> Animal();<br>		<span class="hljs-comment">// 调用默认方法</span><br>		a.fly();<br>	&#125;<br>&#125;<br>输出结果：<br>天上飞<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>重写默认方法，代码如下：</li>
</ol>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;天上飞&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;自由自在的飞&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-comment">// 创建子类对象</span><br>	Animal a = <span class="hljs-keyword">new</span> Animal();<br>	<span class="hljs-comment">// 调用重写方法</span><br>	a.fly();<br>	&#125;<br>&#125;<br>输出结果：<br>自由自在的飞<br></code></pre></td></tr></table></figure>



<h4 id="静态方法的使用"><a href="#静态方法的使用" class="headerlink" title="静态方法的使用"></a>静态方法的使用</h4><p>静态与.class 文件相关，<strong>只能使用接口名调用</strong>，不可以通过实现类的类名或者实现类的对象调用，代码如下：</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;跑起来~~~&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LiveAble</span> </span>&#123;<br>	<span class="hljs-comment">// 无法重写静态方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// Animal.run(); // 【错误】无法继承方法,也无法调用</span><br>		LiveAble.run(); <span class="hljs-comment">//</span><br>	&#125;<br>&#125;<br>输出结果：<br>跑起来~~~<br></code></pre></td></tr></table></figure>



<h4 id="私有方法的使用"><a href="#私有方法的使用" class="headerlink" title="私有方法的使用"></a>私有方法的使用</h4><ul>
<li>私有方法：只有默认方法可以调用。</li>
<li>私有静态方法：默认方法和静态方法可以调用。</li>
</ul>
<p>如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。</p>
<p>从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。</p>
<h3 id="6-1-4-接口的多实现"><a href="#6-1-4-接口的多实现" class="headerlink" title="6.1.4 接口的多实现"></a>6.1.4 接口的多实现</h3><p>在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做<strong>接口的多实现</strong>。并且，一个类能继承一个父类，同时实现多个接口。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 [<span class="hljs-keyword">extends</span> 父类名] <span class="hljs-keyword">implements</span> 接口名1,接口名2,接口名3... </span>&#123;<br>	<span class="hljs-comment">// 重写接口中抽象方法【必须】</span><br>		<span class="hljs-comment">// 重写接口中默认方法【不重名时可选】</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="抽象方法-1"><a href="#抽象方法-1" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>接口中，有多个抽象方法时，实现类必须<strong>重写所有抽象方法</strong>。如果抽象方法有重名的，只需要重写一次。</p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>接口中，有多个默认方法时，实现类都可继承使用。<strong>如果默认方法有重名的，必须重写一次</strong>。</p>
<h4 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h4><p>接口中，存在同名的静态方法并不会冲突，原因是<strong>只能通过各自接口名访问静态方法</strong>。</p>
<h4 id="优先级的问题"><a href="#优先级的问题" class="headerlink" title="优先级的问题"></a>优先级的问题</h4><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类选择<strong>执行父类的成员方法</strong></p>
<blockquote>
<p>继承优先于接口实现</p>
</blockquote>
<h3 id="6-1-5-接口的多继承"><a href="#6-1-5-接口的多继承" class="headerlink" title="6.1.5 接口的多继承"></a>6.1.5 接口的多继承</h3><p>一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用<code>extends</code>关键字，子接口继承父接口的方法。<strong>如果父接口中的默认方法有重名的，那么子接口需要重写一次</strong>。</p>
<blockquote>
<p>子接口重写默认方法时，default关键字可以保留。<br>子类重写默认方法时，default关键字不可以保留。</p>
</blockquote>
<h3 id="6-1-6-接口作为参数或返回值"><a href="#6-1-6-接口作为参数或返回值" class="headerlink" title="6.1.6 接口作为参数或返回值"></a>6.1.6 接口作为参数或返回值</h3><ul>
<li>接口作为参数时，传递它的子类对象。</li>
<li>接口作为返回值类型时，返回它的子类对象</li>
</ul>
<h3 id="6-1-7-接口中的属性"><a href="#6-1-7-接口中的属性" class="headerlink" title="6.1.7 接口中的属性"></a>6.1.7 接口中的属性</h3><ul>
<li>接口中不能定义普通的属性</li>
<li>接口属性只可以<code>public static final 数据类型 属性名 = 值;</code>其中<code>public static final </code>可以省略</li>
<li>接口属性定义的时候必须初始化。</li>
</ul>
<p>原因如下</p>
<blockquote>
<p>接口就是提供一种统一的”协议”，而接口中的属性也属于 “协议”中的成员。它们是公共的，静态的，最终的常量。相当于全局常量。抽象类是不“完全”的类，相当于是接口和具体类的一个中间层。即满足接口的抽象，也满足具体的实现。如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。有的人会说了，没有关系，可以通过实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况。如果接口 A 中有一个public 访问权限的静态变量 a。按照 Java 的语义，我们可以不通过实现接口的对象来访问变量 a，通过 A.a = xxx; 就可以改变接口中的变量 a 的值了。正如抽象类中是可以这样做的，那么实现接口 A 的所有对象也都会自动拥有这一改变后的 a的值了，也就是说一个地方改变了 a，所有这些对象中 a 的值也都跟着变了。这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。 所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统一的属性。通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。</p>
</blockquote>
<hr>
<h2 id="6-2-lambda表达式"><a href="#6-2-lambda表达式" class="headerlink" title="6.2 lambda表达式"></a>6.2 lambda表达式</h2><h3 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h3><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。也可称为闭包，</p>
<h3 id="6-2-2-标准格式"><a href="#6-2-2-标准格式" class="headerlink" title="6.2.2 标准格式"></a>6.2.2 标准格式</h3><p>Lambda省去面向对象的条条框框，格式由3个部分组成：</p>
<ul>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ul>
<p>Lambda表达式的标准格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(参数类型 参数名称) ‐&gt; &#123; 代码语句 &#125;<br></code></pre></td></tr></table></figure>

<p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h3 id="6-2-3-省略规则"><a href="#6-2-3-省略规则" class="headerlink" title="6.2.3 省略规则"></a>6.2.3 省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ul>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参数</strong>，则小括号可以省略；</li>
<li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ul>
<h3 id="6-2-4-使用前提"><a href="#6-2-4-使用前提" class="headerlink" title="6.2.4 使用前提"></a>6.2.4 使用前提</h3><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求接口中<strong>有且仅有一个抽象方法</strong>。<br>无论是JDK内置的Runnable 、Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li>
<li>使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
</blockquote>
<h3 id="6-2-5-Lambda作用域"><a href="#6-2-5-Lambda作用域" class="headerlink" title="6.2.5 Lambda作用域"></a>6.2.5 Lambda作用域</h3><p>在 Lambda 表达式中， 访问外层作用域和以前版本的匿名对象中的方式类似。 可以直接访问标记了<code>final</code>的外层局部变量、 对象的字段与静态变量。</p>
<h4 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h4><p>在 Lambda 表达式中， 直接访问外层的局部变量。与匿名对象不同的是， 变量 number 可以不声明为 final。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lambda</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> number = <span class="hljs-number">6</span>;<br>		InterNew&lt;Integer,String&gt;inn = (t) -&gt; String.valueOf(t + number);<br>		System.out.println(<span class="hljs-string">&quot;访问局部变量：&quot;</span>+inn.InterNew(<span class="hljs-number">7</span>));<span class="hljs-comment">//13</span><br>	&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterNew</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;<br>	<span class="hljs-function">Integer <span class="hljs-title">InterNew</span><span class="hljs-params">(String string)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="访问对象字段与静态变量"><a href="#访问对象字段与静态变量" class="headerlink" title="访问对象字段与静态变量"></a>访问对象字段与静态变量</h4><hr>
<h2 id="6-3-函数式接口"><a href="#6-3-函数式接口" class="headerlink" title="6.3 函数式接口"></a>6.3 函数式接口</h2><h3 id="6-3-1-概述"><a href="#6-3-1-概述" class="headerlink" title="6.3.1 概述"></a>6.3.1 概述</h3><p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong>。<br>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p>
<blockquote>
<p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。</p>
</blockquote>
<h3 id="6-3-2-格式"><a href="#6-3-2-格式" class="headerlink" title="6.3.2 格式"></a>6.3.2 格式</h3><p>只要确保接口中<strong>有且仅有一个抽象方法</strong>即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名称 </span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> 返回值类型 方法名称(可选参数信息);<br>	<span class="hljs-comment">// 其他非抽象方法内容</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于接口当中抽象方法的<code>public abstract</code>是可以省略的，所以定义一个函数式接口很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFunctionalInterface</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-3-4-FunctionalInterface注解"><a href="#6-3-4-FunctionalInterface注解" class="headerlink" title="6.3.4 @FunctionalInterface注解"></a>6.3.4 @FunctionalInterface注解</h3><p>与<code>@Override</code>注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： <code>@FunctionalInterface</code>。该注解可用于一个接口的定义上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFunctionalInterface</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p>
</blockquote>
<h3 id="6-3-5-自定义函数式接口"><a href="#6-3-5-自定义函数式接口" class="headerlink" title="6.3.5 自定义函数式接口"></a>6.3.5 自定义函数式接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09FunctionalInterface</span> </span>&#123;<br>	<span class="hljs-comment">// 使用自定义的函数式接口作为方法参数</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(MyFunctionalInterface inter)</span> </span>&#123;<br>		inter.myMethod(); <span class="hljs-comment">// 调用自定义的函数式接口方法</span><br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 调用使用函数式接口的方法</span><br>		doSomething(() ‐&gt; System.out.println(<span class="hljs-string">&quot;Lambda执行啦！&quot;</span>));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-3-6-Lambda的延迟执行"><a href="#6-3-6-Lambda的延迟执行" class="headerlink" title="6.3.6 Lambda的延迟执行"></a>6.3.6 Lambda的延迟执行</h3><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而<strong>Lambda表达式是延迟执行的</strong>，这正好可以作为解决方案，提升性能。</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MessageBuilder</span> </span>&#123;<br>	<span class="hljs-function">String <span class="hljs-title">buildMessage</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03LoggerDelay</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, MessageBuilder builder)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) &#123;<br>			System.out.println(builder.buildMessage());<br>		&#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	String msgA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>	String msgB = <span class="hljs-string">&quot;World&quot;</span>;<br>	String msgC = <span class="hljs-string">&quot;Java&quot;</span>;<br>        <br>	log(<span class="hljs-number">2</span>, () ‐&gt; &#123;<br>			System.out.println(<span class="hljs-string">&quot;Lambda执行！&quot;</span>);<br>			<span class="hljs-keyword">return</span> msgA + msgB + msgC;<br>		&#125;);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从结果（什么都输出）中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。</p>
<blockquote>
<p>注：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的</p>
</blockquote>
<hr>
<h2 id="6-4-常用函数式接口"><a href="#6-4-常用函数式接口" class="headerlink" title="6.4 常用函数式接口"></a>6.4 常用函数式接口</h2><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在<code>java.util.function</code>包中被提供。</p>
<h3 id="6-4-1-Supplier接口"><a href="#6-4-1-Supplier接口" class="headerlink" title="6.4.1 Supplier接口"></a>6.4.1 Supplier接口</h3><p><code>java.util.function.Supplier&lt;T&gt;</code>接口仅包含一个无参的方法：<code>T get()</code>。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02Test</span> </span>&#123;<br>	<span class="hljs-comment">//定一个方法,方法的参数传递Supplier,泛型使用Integer</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;<br>		<span class="hljs-keyword">return</span> sup.get();<br>	&#125;<br>    <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">52</span>,<span class="hljs-number">333</span>,<span class="hljs-number">23</span>&#125;;<br>		<span class="hljs-comment">//调用getMax方法,参数传递Lambda</span><br>		<span class="hljs-keyword">int</span> maxNum = getMax(()‐&gt;&#123;<br>				<span class="hljs-comment">//计算数组的最大值</span><br>				<span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];<br>				<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr)&#123;<br>					<span class="hljs-keyword">if</span>(i&gt;max)&#123;<br>						max = i;<br>					&#125;<br>				&#125;<br>				<span class="hljs-keyword">return</span> max;<br>			&#125;);<br>		System.out.println(maxNum);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-2-Consumer接口"><a href="#6-4-2-Consumer接口" class="headerlink" title="6.4.2 Consumer接口"></a>6.4.2 Consumer接口</h3><p><code>java.util.function.Consumer&lt;T&gt;</code>接口则正好与<code>Supplier</code>接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。</p>
<h4 id="抽象方法：accept"><a href="#抽象方法：accept" class="headerlink" title="抽象方法：accept"></a>抽象方法：accept</h4><p><code>Consumer</code>接口中包含抽象方法<code>void accept(T t)</code>，意为消费一个指定泛型的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09Consumer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeString</span><span class="hljs-params">(Consumer&lt;String&gt; function)</span> </span>&#123;<br>        function.accept(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        consumeString((s)-&gt; System.out.println(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，更好的写法是使用方法引用。</p>
<h4 id="默认方法：andThen"><a href="#默认方法：andThen" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h4><p>如果一个方法的参数和返回值全都是<code>Consumer</code>类型，那么就可以实现效果：消费数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是Consumer接口中的default方法andThen。下面是JDK的源代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; after)</span> </span>&#123;<br>	Objects.requireNonNull(after);<br>	<span class="hljs-keyword">return</span> (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：<code>java.util.Objects</code>的<code>requireNonNull</code>静态方法将会在参数为null时主动抛出<code>NullPointerException</code>异常。这省去了重复编写if语句和抛出空指针异常的麻烦。</p>
</blockquote>
<p>要想实现组合，需要两个或多个Lambda表达式即可，而<code>andThen</code>的语义正是“一步接一步”操作。例如两个步骤组合的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10ConsumerAndThen</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeString</span><span class="hljs-params">(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two)</span> </span>&#123;<br>        one.andThen(two).accept(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        consumeString(<br>                s -&gt; System.out.println(s.toUpperCase()),<br>                s -&gt; System.out.println(s.toLowerCase()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-4-3-Predicate接口"><a href="#6-4-3-Predicate接口" class="headerlink" title="6.4.3 Predicate接口"></a>6.4.3 Predicate接口</h3><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用<code>java.util.function.Predicate&lt;T&gt;</code>接口。</p>
<h4 id="抽象方法：test"><a href="#抽象方法：test" class="headerlink" title="抽象方法：test"></a>抽象方法：test</h4><p><code>Predicate</code>接口中包含一个抽象方法：<code>boolean test(T t)</code>。用于条件判断的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo15PredicateTest</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;String&gt; predicate)</span> </span>&#123;<br>		<span class="hljs-keyword">boolean</span> veryLong = predicate.test(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;字符串很长吗：&quot;</span> + veryLong);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		method(s ‐&gt; s.length() &gt; <span class="hljs-number">5</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。</p>
<h4 id="默认方法：and"><a href="#默认方法：and" class="headerlink" title="默认方法：and"></a>默认方法：and</h4><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个<code>Predicate</code>条件使用“与”逻辑连接起来实现“<strong>并且</strong>”的效果时，可以使用default方法<code>and</code>。其JDK源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;<br>	Objects.requireNonNull(other);<br>	<span class="hljs-keyword">return</span> (t) ‐&gt; test(t) &amp;&amp; other.test(t);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16PredicateAnd</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> </span>&#123;<br>		<span class="hljs-keyword">boolean</span> isValid = one.and(two).test(<span class="hljs-string">&quot;Helloworld&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;字符串符合要求吗：&quot;</span> + isValid);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		method(s ‐&gt; s.contains(<span class="hljs-string">&quot;H&quot;</span>), s ‐&gt; s.contains(<span class="hljs-string">&quot;W&quot;</span>));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="默认方法：or"><a href="#默认方法：or" class="headerlink" title="默认方法：or"></a>默认方法：or</h4><p>与<code>and</code>的“与”类似，默认方法<code>or</code>实现逻辑关系中的“<strong>或</strong>”。JDK源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;<br>	Objects.requireNonNull(other);<br>	<span class="hljs-keyword">return</span> (t) ‐&gt; test(t) || other.test(t);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称即可，其他都不变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16PredicateAnd</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> </span>&#123;<br>		<span class="hljs-keyword">boolean</span> isValid = one.or(two).test(<span class="hljs-string">&quot;Helloworld&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;字符串符合要求吗：&quot;</span> + isValid);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		method(s ‐&gt; s.contains(<span class="hljs-string">&quot;H&quot;</span>), s ‐&gt; s.contains(<span class="hljs-string">&quot;W&quot;</span>));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="默认方法：negate"><a href="#默认方法：negate" class="headerlink" title="默认方法：negate"></a>默认方法：negate</h4><p>默认方法<code>negate</code>的含义为的“非”（取反）。JDK源代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">negate</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> (t) ‐&gt; !test(t);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从实现中容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在test 方法调用之前调用<code>negate</code>方法，正如<code>and</code>和<code>or</code>方法一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo17PredicateNegate</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Predicate&lt;String&gt; predicate)</span> </span>&#123;<br>		<span class="hljs-keyword">boolean</span> veryLong = predicate.negate().test(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;字符串很长吗：&quot;</span> + veryLong);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		method(s ‐&gt; s.length() &lt; <span class="hljs-number">5</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-4-4-Function接口"><a href="#6-4-4-Function接口" class="headerlink" title="6.4.4 Function接口"></a>6.4.4 Function接口</h3><p><code>java.util.function.Function&lt;T,R&gt;</code>接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p>
<h4 id="抽象方法：apply"><a href="#抽象方法：apply" class="headerlink" title="抽象方法：apply"></a>抽象方法：apply</h4><p><code>Function</code>接口中最主要的抽象方法为：<code> R apply(T t)</code>，根据类型T的参数获取类型R的结果。使用的场景例如：将<code>String</code>类型转换为<code>Integer</code>类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11FunctionApply</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Function&lt;String, Integer&gt; function)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> num = function.apply(<span class="hljs-string">&quot;10&quot;</span>);<br>		System.out.println(num + <span class="hljs-number">20</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		method(s ‐&gt; Integer.parseInt(s));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，最好是通过方法引用的写法。</p>
<h4 id="默认方法：andThen-1"><a href="#默认方法：andThen-1" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h4><p><code>Function</code>接口中有一个默认的<code>andThen</code>方法，用来进行组合操作。JDK源代码如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;<br>	Objects.requireNonNull(after);<br>	<span class="hljs-keyword">return</span> (T t) ‐&gt; after.apply(apply(t));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法同样用于“先做什么，再做什么”的场景，和<code>Consumer</code>中的<code>andThen</code>差不多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12FunctionAndThen</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> num = one.andThen(two).apply(<span class="hljs-string">&quot;10&quot;</span>);<br>		System.out.println(num + <span class="hljs-number">20</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		method(str‐&gt;Integer.parseInt(str)+<span class="hljs-number">10</span>, i ‐&gt; i *= <span class="hljs-number">10</span>);<br>	&#125;<br>&#125;	<br></code></pre></td></tr></table></figure>

<p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过<code>andThen</code>按照前后顺序组合到了一起。</p>
<blockquote>
<p>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p>
</blockquote>
<hr>
<h2 id="6-5-Stream流"><a href="#6-5-Stream流" class="headerlink" title="6.5 Stream流"></a>6.5 Stream流</h2><p>在Java 8中，得益于Lambda所带来的函数式编程，引入了一个<strong>全新的Stream概念</strong>，用于解决已有集合类库既有的弊端。</p>
<h3 id="6-5-1-概述"><a href="#6-5-1-概述" class="headerlink" title="6.5.1 概述"></a>6.5.1 概述</h3><p>Stream（流）是一个来自数据源的元素队列</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li><strong>数据源</strong>流的来源。 可以是集合，数组 等</li>
</ul>
<blockquote>
<p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p>
</blockquote>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluentstyle）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li>
</ul>
<h3 id="6-5-2-获取流"><a href="#6-5-2-获取流" class="headerlink" title="6.5.2 获取流"></a>6.5.2 获取流</h3><p><code>java.util.stream.Stream&lt;T&gt;</code>是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）<br>获取一个流有以下几种常用的方式：</p>
<ul>
<li><p>所有的Collection 集合都可以通过stream 默认方法获取流；</p>
</li>
<li><p>Stream 接口的静态方法of可以获取数组对应的流。</p>
</li>
</ul>
<h4 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h4><p><code>java.util.Collection</code>接口中加入了<code>default</code>方法<code>stream</code>用来获取流，所以其所有实现类均可获取流。</p>
<h4 id="根据Map获取流"><a href="#根据Map获取流" class="headerlink" title="根据Map获取流"></a>根据Map获取流</h4><p><code>java.util.Map</code>接口不是<code>Collection</code>的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05GetStream</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>		<span class="hljs-comment">// ...</span><br>		Stream&lt;String&gt; keyStream = map.keySet().stream();<br>		Stream&lt;String&gt; valueStream = map.values().stream();<br>		Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h4><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以<code>Stream</code>接口中提供了静态方法<code>of</code>：</p>
<blockquote>
<p>注： of方法的参数其实是一个可变参数，所以支持数组。</p>
</blockquote>
<h3 id="6-5-3-常用方法"><a href="#6-5-3-常用方法" class="headerlink" title="6.5.3 常用方法"></a>6.5.3 常用方法</h3><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p>
<ul>
<li>延迟方法：返回值类型仍然是<code>Stream</code>接口自身类型的方法，因此<strong>支持链式调用</strong>。（除了终结方法外，其余方<br>法均为延迟方法。）</li>
<li>终结方法：返回值类型不再是<code>Stream</code>接口自身类型的方法，因此不再支持类似StringBuilder那样的链式调<br>用。包括<code>count</code>和<code>forEach</code>方法。</li>
</ul>
<h4 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h4><p>虽然方法名字叫<code>forEach</code>，但是与for循环中的“for-each”昵称不同。</p>
<p><code>void forEach(Consumer&lt;? super T&gt; action);</code></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12StreamForEach</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>		stream.forEach(name‐&gt; System.out.println(name));<br>      <span class="hljs-comment">//  stream.forEach(System.out::println);</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h4><p>可以通过<code>filter</code>方法将一个流转换成另一个子集流。</p>
<p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</code></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo07StreamFilter</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>		Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。</p>
<h4 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h4><p>如果需要将流中的元素映射到另一个流中，可以使用<code>map</code>方法</p>
<p><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</code></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08StreamMap</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;18&quot;</span>);<br>		Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码中， <code>map</code>方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为<code>Integer</code>类对象）。</p>
<h4 id="统计个数：count"><a href="#统计个数：count" class="headerlink" title="统计个数：count"></a>统计个数：count</h4><p>正如旧集合Collection当中的size方法一样，流提供count 方法来统计其中的元素个数</p>
<p><code>long count();</code></p>
<p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09StreamCount</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>		Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>		System.out.println(result.count()); <span class="hljs-comment">// 2</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h4><p><code>limit</code>方法可以对流进行截取，只取用前n个。</p>
<p><code>Stream&lt;T&gt; limit(long maxSize);</code></p>
<p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10StreamLimit</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>		Stream&lt;String&gt; result = original.limit(<span class="hljs-number">2</span>);<br>		System.out.println(result.count()); <span class="hljs-comment">// 2</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h4><p>如果希望跳过前几个元素，可以使用skip 方法获取一个截取之后的新流：</p>
<p><code>Stream&lt;T&gt; skip(long n);</code></p>
<p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11StreamSkip</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>		Stream&lt;String&gt; result = original.skip(<span class="hljs-number">2</span>);<br>		System.out.println(result.count()); <span class="hljs-comment">// 1</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h4><p>如果有两个流，希望合并成为一个流，那么可以使用<code>Stream</code>接口的静态方法<code>concat</code>：</p>
<p><code>static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code></p>
<blockquote>
<p>注：这是一个静态方法，与<code>java.lang.String</code>当中的<code>concat</code>方法是不同的。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12StreamConcat</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Stream&lt;String&gt; streamA = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>		Stream&lt;String&gt; streamB = Stream.of(<span class="hljs-string">&quot;张翠山&quot;</span>);<br>		Stream&lt;String&gt; result = Stream.concat(streamA, streamB);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="6-6-方法引用"><a href="#6-6-方法引用" class="headerlink" title="6.6 方法引用"></a>6.6 方法引用</h2><h3 id="6-6-1-概述"><a href="#6-6-1-概述" class="headerlink" title="6.6.1 概述"></a>6.6.1 概述</h3><p>双冒号<code>::</code>为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p>
<p>例如：</p>
<p>函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Printable</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>lambda表达式调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01PrintSimple</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(Printable data)</span> </span>&#123;<br>		data.print(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		printString(s ‐&gt; System.out.println(s));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02PrintRef</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(Printable data)</span> </span>&#123;<br>		data.print(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		printString(System.out::println);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>System.out</code>对象中有一个重载的<code>println(String)</code>方法，下面两种写法，完全等效：</p>
<ul>
<li>Lambda表达式写法：<code> s -&gt; System.out.println(s);</code></li>
<li>方法引用写法： <code>System.out::println</code></li>
</ul>
<p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给<code>System.out.println</code>方法去处理。<br>第二种等效写法的语义是指：直接让<code>System.out</code>中的<code>println</code>方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。</p>
<blockquote>
<p>注:Lambda 中<strong>传递的参数</strong> 一定是<strong>方法引用中</strong>的那个方法可以接收的类型,否则会抛出异常</p>
</blockquote>
<h3 id="6-6-2-通过对象名引用成员方法"><a href="#6-6-2-通过对象名引用成员方法" class="headerlink" title="6.6.2 通过对象名引用成员方法"></a>6.6.2 通过对象名引用成员方法</h3><p>如果一个类中已经存在了一个成员方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodRefObject</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printUpperCase</span><span class="hljs-params">(String str)</span> </span>&#123;<br>		System.out.println(str.toUpperCase());<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数式接口仍然定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Printable</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么当需要使用这个<code>printUpperCase</code>成员方法来替代<code>Printable</code>接口的Lambda的时候，已经具有了<code>MethodRefObject</code>类的对象实例，则可以通过对象名引用成员方法，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04MethodRef</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(Printable lambda)</span> </span>&#123;<br>		lambda.print(<span class="hljs-string">&quot;Hello&quot;</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		MethodRefObject obj = <span class="hljs-keyword">new</span> MethodRefObject();<br>		printString(obj::printUpperCase);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-6-3-通过类名称引用静态方法"><a href="#6-6-3-通过类名称引用静态方法" class="headerlink" title="6.6.3 通过类名称引用静态方法"></a>6.6.3 通过类名称引用静态方法</h3><p>由于在<code>java.lang.Math</code>类中已经存在了静态方法<code>abs</code>，所以当我们需要通过Lambda来调用该方法时，有两种写法。</p>
<p>首先是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Calcable</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一种写法是使用Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05Lambda</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, Calcable lambda)</span> </span>&#123;<br>		System.out.println(lambda.calc(num));<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		method(‐<span class="hljs-number">10</span>, n ‐&gt; Math.abs(n));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用方法引用的写法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06MethodRef</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, Calcable lambda)</span> </span>&#123;<br>		System.out.println(lambda.calc(num));<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		method(‐<span class="hljs-number">10</span>, Math::abs);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： <code>n -&gt; Math.abs(n)</code></li>
<li>方法引用： <code>Math::abs</code></li>
</ul>
<h3 id="6-6-4-通过super引用成员方法"><a href="#6-6-4-通过super引用成员方法" class="headerlink" title="6.6.4 通过super引用成员方法"></a>6.6.4 通过super引用成员方法</h3><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Greetable</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后是父类Human的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个子类Man的内容，其中使用了Lambda的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;大家好,我是Man!&quot;</span>);<br>	&#125;<br>	<span class="hljs-comment">//定义方法method,参数传递Greetable接口</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Greetable g)</span></span>&#123;<br>		g.greet();<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-comment">//调用method方法,使用Lambda表达式</span><br>		method(()‐&gt;&#123;<br>			<span class="hljs-comment">//创建Human对象,调用sayHello方法</span><br>			<span class="hljs-keyword">new</span> Human().sayHello();<br>		&#125;);<br>		<span class="hljs-comment">//简化Lambda</span><br>		method(()‐&gt;<span class="hljs-keyword">new</span> Human().sayHello());<br>		<span class="hljs-comment">//使用super关键字代替父类对象</span><br>		method(()‐&gt;<span class="hljs-keyword">super</span>.sayHello());<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果使用方法引用来调用父类中的<code>sayHello</code>方法会更好，例如另一个子类Woman ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;大家好,我是Man!&quot;</span>);<br>	&#125;<br>	<span class="hljs-comment">//定义方法method,参数传递Greetable接口</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Greetable g)</span></span>&#123;<br>		g.greet();<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>		method(<span class="hljs-keyword">super</span>::sayHello);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式：<code> () -&gt; super.sayHello()</code></li>
<li>方法引用：<code> super::sayHello</code></li>
</ul>
<h3 id="6-6-5-通过this引用成员方法"><a href="#6-6-5-通过this引用成员方法" class="headerlink" title="6.6.5 通过this引用成员方法"></a>6.6.5 通过this引用成员方法</h3><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“<strong>this::成员方法</strong>”的格式来使用方法引用。</p>
<p>首先是简单的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Richable</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面是一个丈夫Husband类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">marry</span><span class="hljs-params">(Richable lambda)</span> </span>&#123;<br>		lambda.buy();<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beHappy</span><span class="hljs-params">()</span> </span>&#123;<br>		marry(() ‐&gt; System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>开心方法<code>beHappy</code>调用了结婚方法<code>marry</code>，后者的参数为函数式接口<code>Richable</code>，所以需要一个Lambda表达式。但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对Husband 丈夫类进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buyHouse</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">marry</span><span class="hljs-params">(Richable lambda)</span> </span>&#123;<br>		lambda.buy();<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beHappy</span><span class="hljs-params">()</span> </span>&#123;<br>		marry(() ‐&gt; <span class="hljs-keyword">this</span>.buyHouse());<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buyHouse</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">marry</span><span class="hljs-params">(Richable lambda)</span> </span>&#123;<br>		lambda.buy();<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beHappy</span><span class="hljs-params">()</span> </span>&#123;<br>		marry(<span class="hljs-keyword">this</span>::buyHouse);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： <code>() -&gt; this.buyHouse()</code></li>
<li>方法引用：<code> this::buyHouse</code></li>
</ul>
<h3 id="6-6-6-类的构造器引用"><a href="#6-6-6-类的构造器引用" class="headerlink" title="6.6.6 类的构造器引用"></a>6.6.6 类的构造器引用</h3><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用<strong>类名称::new</strong>的格式表示。</p>
<p>首先是一个简单的Person 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用来创建Person 对象的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br>	<span class="hljs-function">Person <span class="hljs-title">buildPerson</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>要使用这个函数式接口，可以通过Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09Lambda</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printName</span><span class="hljs-params">(String name, PersonBuilder builder)</span> </span>&#123;<br>		System.out.println(builder.buildPerson(name).getName());<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		printName(<span class="hljs-string">&quot;张三&quot;</span>, name ‐&gt; <span class="hljs-keyword">new</span> Person(name));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过构造器引用，有更好的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10ConstructorRef</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printName</span><span class="hljs-params">(String name, PersonBuilder builder)</span> </span>&#123;<br>		System.out.println(builder.buildPerson(name).getName());<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		printName(<span class="hljs-string">&quot;张三&quot;</span>, Person::<span class="hljs-keyword">new</span>);<br>	&#125;<br>&#125;	<br></code></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： <code>name -&gt; new Person(name)</code></li>
<li>方法引用： <code>Person::new</code></li>
</ul>
<h3 id="6-6-7-数组的构造器引用"><a href="#6-6-7-数组的构造器引用" class="headerlink" title="6.6.7 数组的构造器引用"></a>6.6.7 数组的构造器引用</h3><p>数组也是<code>Object</code>的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，需要一个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ArrayBuilder</span> </span>&#123;<br>	<span class="hljs-keyword">int</span>[] buildArray(<span class="hljs-keyword">int</span> length);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在应用该接口的时候，可以通过Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11ArrayInitRef</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] initArray(<span class="hljs-keyword">int</span> length, ArrayBuilder builder) &#123;<br>		<span class="hljs-keyword">return</span> builder.buildArray(length);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span>[] array = initArray(<span class="hljs-number">10</span>, length ‐&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length]);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>更好的写法是使用数组的构造器引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo12ArrayInitRef</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] initArray(<span class="hljs-keyword">int</span> length, ArrayBuilder builder) &#123;<br>		<span class="hljs-keyword">return</span> builder.buildArray(length);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span>[] array = initArray(<span class="hljs-number">10</span>, <span class="hljs-keyword">int</span>[]::<span class="hljs-keyword">new</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式：<code> length -&gt; new int[length]</code></li>
<li>方法引用： <code>int[]::new</code></li>
</ul>
<hr>
<h2 id="6-7-内部类"><a href="#6-7-内部类" class="headerlink" title="6.7 内部类"></a>6.7 内部类</h2><h3 id="6-7-1-概述"><a href="#6-7-1-概述" class="headerlink" title="6.7.1 概述"></a>6.7.1 概述</h3><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为外部类。</p>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul>
<li>成员内部类：定义在类中方法外的类</li>
</ul>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 外部类 </span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">class</span> 内部类</span>&#123;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="访问特点"><a href="#访问特点" class="headerlink" title="访问特点"></a>访问特点</h5><ul>
<li>内部类可以直接访问外部类的成员，<strong>包括私有成员</strong>。</li>
<li>外部类要访问内部类的成员，必须要<strong>建立内部类的对象</strong>。</li>
</ul>
<p>创建内部类对象格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类名.内部类名 对象名 = <span class="hljs-keyword">new</span> 外部类型().new 内部类型()；<br></code></pre></td></tr></table></figure>

<blockquote>
<p>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。</p>
</blockquote>
<blockquote>
<p>内部类中声明的所有静态域都必须是final</p>
<p>内部类不能有static方法</p>
</blockquote>
<h3 id="6-7-2-匿名内部类"><a href="#6-7-2-匿名内部类" class="headerlink" title="6.7.2 匿名内部类"></a>6.7.2 匿名内部类</h3><ul>
<li><strong>匿名内部类</strong>：是内部类的简化写法。它的本质是一个<strong>带具体实现的父类</strong>或者<strong>父接口的匿名的子类对象</strong>。开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作</li>
</ul>
<ol>
<li>定义子类</li>
<li>重写接口中的方法</li>
<li>创建子类对象</li>
<li>调用重写后的方法</li>
</ol>
<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 父类名或者接口名()&#123;<br>	<span class="hljs-comment">// 方法重写</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 执行语句</span><br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyAble</span></span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建匿名内部类，并调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		1.等号右边:是匿名内部类，定义并创建该接口的子类对象</span><br><span class="hljs-comment">		2.等号左边:是多态赋值,接口类型引用指向子类对象</span><br><span class="hljs-comment">		*/</span><br>		FlyAble f = <span class="hljs-keyword">new</span> FlyAble()&#123;<br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>				System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>			&#125;<br>		&#125;;<br>		<span class="hljs-comment">//调用 fly方法,执行重写后的方法</span><br>		f.fly();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerDemo2</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		1.等号右边:定义并创建该接口的子类对象</span><br><span class="hljs-comment">		2.等号左边:是多态,接口类型引用指向子类对象</span><br><span class="hljs-comment">		*/</span><br>		FlyAble f = <span class="hljs-keyword">new</span> FlyAble()&#123;<br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>				System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>			&#125;<br>    	&#125;;<br>		<span class="hljs-comment">// 将f传递给showFly方法中</span><br>		showFly(f);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showFly</span><span class="hljs-params">(FlyAble f)</span> </span>&#123;<br>		f.fly();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上两步，也可以简化为一步，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerDemo3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		创建匿名内部类,直接传递给showFly(FlyAble f)</span><br><span class="hljs-comment">		*/</span><br>		showFly( <span class="hljs-keyword">new</span> FlyAble()&#123;<br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>				System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>			&#125;<br>		&#125;);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showFly</span><span class="hljs-params">(FlyAble f)</span> </span>&#123;<br>		f.fly();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h1 id="第7章-异常、断言和日志"><a href="#第7章-异常、断言和日志" class="headerlink" title="第7章 异常、断言和日志"></a>第7章 异常、断言和日志</h1><h2 id="7-1-异常"><a href="#7-1-异常" class="headerlink" title="7.1 异常"></a>7.1 异常</h2><h3 id="7-1-1-概述"><a href="#7-1-1-概述" class="headerlink" title="7.1.1 概述"></a>7.1.1 概述</h3><ul>
<li><strong>异常</strong>：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li>
</ul>
<p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p>
<blockquote>
<p>异常指的并不是语法错误,语法错了，编译不通过，不会产生字节码文件,根本不能运行。</p>
</blockquote>
<h3 id="7-1-2-异常体系"><a href="#7-1-2-异常体系" class="headerlink" title="7.1.2 异常体系"></a>7.1.2 异常体系</h3><p>在Java程序设计语言中，异常对象都是派生于<code>java.lang.Throwable</code>。其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/7.1.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<h4 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h4><p>Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。Error类是无法通过处理的错误，只能事先避免。</p>
<h4 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h4><p>Exception类表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。</p>
<h3 id="7-1-3-异常分类"><a href="#7-1-3-异常分类" class="headerlink" title="7.1.3 异常分类"></a>7.1.3 异常分类</h3><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p>
<p><strong>异常(Exception)的分类:根据在编译时期还是运行时期去检查异常。</strong></p>
<h4 id="编译时期异常"><a href="#编译时期异常" class="headerlink" title="编译时期异常"></a>编译时期异常</h4><p><strong>checked（受查）异常</strong>。在编译时期，就会检查，如果没有处理异常，则编译失败。(如日期格式化异常)</p>
<h4 id="运行时期异常"><a href="#运行时期异常" class="headerlink" title="运行时期异常"></a>运行时期异常</h4><p><strong>runtime+Error（unchecked非受查）异常</strong>。在运行时期，检查异常。在编译时期，运行异常不会编译器检测(不报错)。(如数学异常)</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/7.2.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<p><em><strong>如果出现RuntimeException异常，那一定是自己的问题</strong></em></p>
<h3 id="7-1-4-异常的产生过程解析"><a href="#7-1-4-异常的产生过程解析" class="headerlink" title="7.1.4 异常的产生过程解析"></a>7.1.4 异常的产生过程解析</h3><p>先运行下面的程序，程序会产生一个数组索引越界异常<code>ArrayIndexOfBoundsException</code>。</p>
<p>工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayTools</span> </span>&#123;<br>	<span class="hljs-comment">// 对给定的数组通过给定的角标获取元素。</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> element = arr[index];<br>		<span class="hljs-keyword">return</span> element;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">67</span> &#125;;<br>		intnum = ArrayTools.getElement(arr, <span class="hljs-number">4</span>)<br>		System.out.println(<span class="hljs-string">&quot;num=&quot;</span> + num);<br>		System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述程序执行过程图解：</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/7.3.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<h3 id="7-1-5-Throwable中的常用方法"><a href="#7-1-5-Throwable中的常用方法" class="headerlink" title="7.1.5 Throwable中的常用方法"></a>7.1.5 Throwable中的常用方法</h3><ul>
<li><code>public void printStackTrace()</code>:打印异常的详细信息。<br>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用<code>printStackTrace</code>。</li>
<li><code>public String getMessage()</code>:获取发生异常的原因。<br>提示给用户的时候,就提示错误原因。</li>
<li><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</li>
</ul>
<hr>
<h2 id="7-2-异常的处理"><a href="#7-2-异常的处理" class="headerlink" title="7.2 异常的处理"></a>7.2 异常的处理</h2><p>Java异常处理的五个关键字：try、catch、finally、throw、throws</p>
<h3 id="7-2-1-抛出异常throw"><a href="#7-2-1-抛出异常throw" class="headerlink" title="7.2.1 抛出异常throw"></a>7.2.1 抛出异常throw</h3><p>在java中，提供了一个<code>throw</code>关键字，它用来抛出一个指定的异常对象。</p>
<p><strong>使用步骤：</strong></p>
<ol>
<li>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</li>
<li>需要将这个异常对象告知给调用者。通过关键字throw就可以完成。throw 异常对象。<br>throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</li>
</ol>
<p><strong>使用格式：</strong></p>
<p><code>throw new 异常类名(参数);</code></p>
<p>throw代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">//创建一个数组</span><br>		<span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">52</span>,<span class="hljs-number">2</span>&#125;;<br>		<span class="hljs-comment">//根据索引找对应的元素</span><br>		<span class="hljs-keyword">int</span> index = <span class="hljs-number">4</span>;<br>		<span class="hljs-keyword">int</span> element = getElement(arr, index);<br>		System.out.println(element);<br>		System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	* 根据 索引找到数组中对应的元素</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> index)</span></span>&#123;<br>		<span class="hljs-comment">//判断 索引是否越界</span><br>		<span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;arr.length‐<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span><br><span class="hljs-comment">			这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。</span><br><span class="hljs-comment">			*/</span><br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(<span class="hljs-string">&quot;哥们，角标越界了~~~&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">int</span> element = arr[index];<br>		<span class="hljs-keyword">return</span> element;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2019/10/17/Java/JavaSE/JavaSE/7.4.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<h3 id="7-2-2-声明异常throws"><a href="#7-2-2-声明异常throws" class="headerlink" title="7.2.2 声明异常throws"></a>7.2.2 声明异常throws</h3><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过<code>throw</code>抛出了编译时异常，而没有捕获处理，那么必须通过<code>throws</code>进行声明，让调用者去处理。</p>
<p>关键字<code>throws</code>运用于<strong>方法声明</strong>之上，用于表示<strong>当前方法不处理异常</strong>，而是提醒该方法的调用者来处理异常(抛出异常)。</p>
<p><strong>使用格式：</strong></p>
<p><code>修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125;</code></p>
<p>throws代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowsDemo2</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>		read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span><span class="hljs-keyword">throws</span> FileNotFoundException, IOException </span>&#123;<br>		<span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;b.txt&quot;</span>)) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-2-3-捕获异常try…catch"><a href="#7-2-3-捕获异常try…catch" class="headerlink" title="7.2.3 捕获异常try…catch"></a>7.2.3 捕获异常try…catch</h3><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ol>
<li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>在方法中使用try-catch的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常。</p>
<ul>
<li>捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li>
</ul>
<p><strong>使用格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>	编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型 e)&#123;<br>	处理异常的代码<br>	<span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>try</strong>：该代码块中编写可能产生异常的代码。</p>
<p><strong>catch</strong>：用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>
<blockquote>
<p>注:try和catch都不能单独使用，必须连用。</p>
</blockquote>
<p>try-catch参考代码在finally部分。</p>
<h3 id="7-2-4-finally-代码块"><a href="#7-2-4-finally-代码块" class="headerlink" title="7.2.4 finally 代码块"></a>7.2.4 finally 代码块</h3><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<p><strong>使用格式：</strong></p>
<p><code>try...catch....finally</code>:自身需要处理异常,最终还得关闭资源。</p>
<blockquote>
<p>注：finally不能单独使用。</p>
</blockquote>
<p>finally代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryCatchDemo4</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>			<span class="hljs-comment">//抓取到的是编译期异常 抛出去的是运行期</span><br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			System.out.println(<span class="hljs-string">&quot;不管程序怎样，这里都将会被执行。&quot;</span>);<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	* 我们 当前的这个方法中 有异常 有编译期异常</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>		<span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally<strong>永远会执行</strong>。</p>
</blockquote>
<h3 id="7-2-5-异常注意事项"><a href="#7-2-5-异常注意事项" class="headerlink" title="7.2.5 异常注意事项"></a>7.2.5 异常注意事项</h3><p>多个异常使用捕获，如何处理</p>
<ol>
<li>多个异常分别处理。</li>
<li>多个异常一次捕获，多次处理。</li>
<li>多个异常一次捕获一次处理。</li>
</ol>
<p>一般我们是使用一次捕获多次处理方式，格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>	编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型A e)&#123; 当<span class="hljs-keyword">try</span>中出现A类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>	处理异常的代码<br>	<span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型B e)&#123; 当<span class="hljs-keyword">try</span>中出现B类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>	处理异常的代码<br>	<span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p>
</blockquote>
<ul>
<li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p>
</li>
<li><p>如果finally有return语句,永远返回finally中的结果,避免该情况。</p>
</li>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
<hr>
<h2 id="7-3-自定义异常"><a href="#7-3-自定义异常" class="headerlink" title="7.3 自定义异常"></a>7.3 自定义异常</h2><h3 id="7-3-1-概述"><a href="#7-3-1-概述" class="headerlink" title="7.3.1 概述"></a>7.3.1 概述</h3><p><strong>自定义异常类</strong>：在开发中根据自己业务的异常情况来定义异常类。</p>
<p><strong>异常类如何定义：</strong></p>
<ul>
<li>自定义一个<strong>编译期异常</strong>：自定义类，并继承于<code>java.lang.Exception</code>。</li>
</ul>
<ol start="2">
<li>自定义一个<strong>运行时期的异常类</strong>：自定义类，并继承于`java.lang.RuntimeException。</li>
</ol>
<h3 id="7-3-2-举例"><a href="#7-3-2-举例" class="headerlink" title="7.3.2 举例"></a>7.3.2 举例</h3><p>首先定义一个登陆异常类RegisterException：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 业务逻辑异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br>	<span class="hljs-comment">// 空参构造</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegisterException</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	* <span class="hljs-doctag">@param</span> message 表示异常提示</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegisterException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>		<span class="hljs-keyword">super</span>(message);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>	<span class="hljs-comment">// 模拟数据库中已存在账号</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String[] names = &#123;<span class="hljs-string">&quot;bill&quot;</span>,<span class="hljs-string">&quot;hill&quot;</span>,<span class="hljs-string">&quot;jill&quot;</span>&#125;;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">//调用方法</span><br>		<span class="hljs-keyword">try</span>&#123;<br>			<span class="hljs-comment">// 可能出现异常的代码</span><br>			checkUsername(<span class="hljs-string">&quot;bill&quot;</span>);<br>			System.out.println(<span class="hljs-string">&quot;注册成功&quot;</span>);<span class="hljs-comment">//如果没有异常就是注册成功</span><br>		&#125;<span class="hljs-keyword">catch</span>(RegisterException e)&#123;<br>			<span class="hljs-comment">//处理异常</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//判断当前注册账号是否存在</span><br>	<span class="hljs-comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkUsername</span><span class="hljs-params">(String uname)</span> <span class="hljs-keyword">throws</span> LoginException</span>&#123;<br>		<span class="hljs-keyword">for</span> (String name : names) &#123;<br>			<span class="hljs-keyword">if</span>(name.equals(uname))&#123;<span class="hljs-comment">//如果名字在这里面 就抛出登陆异常</span><br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RegisterException(<span class="hljs-string">&quot;亲&quot;</span>+name+<span class="hljs-string">&quot;已经被注册了！&quot;</span>);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/7.5.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<hr>
<h2 id="7-4-断言"><a href="#7-4-断言" class="headerlink" title="7.4 断言"></a>7.4 断言</h2><h3 id="7-4-1-概述"><a href="#7-4-1-概述" class="headerlink" title="7.4.1 概述"></a>7.4.1 概述</h3><p>编写代码时，我们总是会做出一些假设，断言就是用于在代码中捕捉这些假设。程序员相信在程序中的某个特定点该表达式值为真，可以在任何时候启用和禁用断言验证，因此<strong>可以在测试时启用断言而在部署时禁用断言</strong>。同样，程序投入运行后，在遇到问题时可以重新启用断言。</p>
<p>断言机制允许在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句将会被自动地移走。</p>
<p>Java语言引入了关键字<code>assert</code>，进行断言。</p>
<h3 id="7-4-2-IDE配置"><a href="#7-4-2-IDE配置" class="headerlink" title="7.4.2 IDE配置"></a>7.4.2 IDE配置</h3><p><img src="/2019/10/17/Java/JavaSE/JavaSE/7.6.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<h3 id="7-4-3-使用方法"><a href="#7-4-3-使用方法" class="headerlink" title="7.4.3 使用方法"></a>7.4.3 使用方法</h3><p>有两种使用方法</p>
<ol>
<li><p><code>assert 条件;</code></p>
</li>
<li><p><code>assert 条件 : 表达式;</code></p>
</li>
</ol>
<p>使用第一种格式，当布尔类型表达式为false时，抛出AssertionError异常；如果是第二种格式，则输出错误消息。</p>
<hr>
<h2 id="7-5-日志"><a href="#7-5-日志" class="headerlink" title="7.5 日志"></a>7.5 日志</h2><hr>
<h1 id="第9章-集合"><a href="#第9章-集合" class="headerlink" title="第9章 集合"></a>第9章 集合</h1><h2 id="9-1-Collection集合"><a href="#9-1-Collection集合" class="headerlink" title="9.1 Collection集合"></a>9.1 Collection集合</h2><h3 id="9-1-1-概述"><a href="#9-1-1-概述" class="headerlink" title="9.1.1 概述"></a>9.1.1 概述</h3><ul>
<li>集合：集合是java中提供的一种容器，可以用来存储多个数据。</li>
</ul>
<p>集合和数组既然都是容器，它们有什么区别</p>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ul>
<blockquote>
<p>Java集合类库将<em><strong>接口</strong></em>与<em><strong>实现</strong></em>进行分离</p>
<p>Collection集合取出元素的方式可以采用：迭代器、增强for</p>
</blockquote>
<h3 id="9-1-2-集合框架"><a href="#9-1-2-集合框架" class="headerlink" title="9.1.2 集合框架"></a>9.1.2 集合框架</h3><p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>。</p>
<p>Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。</p>
<p>其中，<code>List</code>的特点是元素<strong>有序</strong>、元素<strong>可重复</strong>。</p>
<p><code>Set</code>的特点是元素<strong>无序</strong>，而且<strong>不可重复</strong>。</p>
<p>List 接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/9.1.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<h3 id="9-1-3-Collection常用API"><a href="#9-1-3-Collection常用API" class="headerlink" title="9.1.3 Collection常用API"></a>9.1.3 Collection常用API</h3><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>： 把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code>:清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<hr>
<h2 id="9-2-Iterator迭代器"><a href="#9-2-Iterator迭代器" class="headerlink" title="9.2 Iterator迭代器"></a>9.2 Iterator迭代器</h2><h3 id="9-2-1-概述"><a href="#9-2-1-概述" class="headerlink" title="9.2.1 概述"></a>9.2.1 概述</h3><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code> 。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同， Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection 中的元素，因此Iterator 对象也被称为<strong>迭代器</strong>。</p>
<h3 id="9-2-2-获取方法"><a href="#9-2-2-获取方法" class="headerlink" title="9.2.2 获取方法"></a>9.2.2 获取方法</h3><p><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</p>
<h3 id="9-2-3-迭代器常用API"><a href="#9-2-3-迭代器常用API" class="headerlink" title="9.2.3 迭代器常用API"></a>9.2.3 迭代器常用API</h3><ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
<li><code>public void remove()</code>:移除iterator.next()方法最后访问的元素。</li>
<li><code>default void forEachRemaining(Consumer&lt;? super E&gt; action)</code>:对集合中剩余的元素进行操作。</li>
</ul>
<h3 id="9-2-4-迭代器的实现原理"><a href="#9-2-4-迭代器的实现原理" class="headerlink" title="9.2.4 迭代器的实现原理"></a>9.2.4 迭代器的实现原理</h3><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素。</p>
<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<hr>
<h2 id="9-3-List集合"><a href="#9-3-List集合" class="headerlink" title="9.3 List集合"></a>9.3 List集合</h2><h3 id="9-3-1-概述"><a href="#9-3-1-概述" class="headerlink" title="9.3.1 概述"></a>9.3.1 概述</h3><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中<strong>允许出现重复的元素</strong>，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是<strong>元素有序</strong>，即元素的存入顺序和取出顺序一致。</p>
<h3 id="9-3-2-特点"><a href="#9-3-2-特点" class="headerlink" title="9.3.2 特点"></a>9.3.2 特点</h3><ul>
<li><p>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</p>
</li>
<li><p>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</p>
</li>
<li><p>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</p>
</li>
</ul>
<h3 id="9-3-3-List接口中常用方法"><a href="#9-3-3-List接口中常用方法" class="headerlink" title="9.3.3 List接口中常用方法"></a>9.3.3 List接口中常用方法</h3><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p>
<ul>
<li><p><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</p>
</li>
<li><p><code>public E get(int index)</code>:返回集合中指定位置的元素。</p>
</li>
<li><p><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</p>
</li>
<li><p><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</p>
</li>
</ul>
<blockquote>
<p>List集合特有的方法都是跟<strong>索引</strong>相关</p>
<p>List接口的实现类包括：ArrayList，LinkedList</p>
</blockquote>
<h3 id="9-3-4-ArrayList集合"><a href="#9-3-4-ArrayList集合" class="headerlink" title="9.3.4 ArrayList集合"></a>9.3.4 ArrayList集合</h3><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。</p>
<h3 id="9-3-4-LinkedList集合"><a href="#9-3-4-LinkedList集合" class="headerlink" title="9.3.4 LinkedList集合"></a>9.3.4 LinkedList集合</h3><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<blockquote>
<p>LinkedList是一个双向链表。（在Java中，所有链表都是双向链接的）</p>
</blockquote>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/9.2.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<h4 id="LinkedList集合中常用方法"><a href="#LinkedList集合中常用方法" class="headerlink" title="LinkedList集合中常用方法"></a>LinkedList集合中常用方法</h4><ul>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<blockquote>
<p>在开发时，LinkedList集合可以作为堆栈，队列的结构使用。</p>
</blockquote>
<hr>
<h2 id="9-4-Set集合"><a href="#9-4-Set集合" class="headerlink" title="9.4 Set集合"></a>9.4 Set集合</h2><h3 id="9-4-1-概述"><a href="#9-4-1-概述" class="headerlink" title="9.4.1 概述"></a>9.4.1 概述</h3><p><code>java.util.Set</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，它与<code>Collection</code>接口中的方法基本一致，并没有对Collection 接口进行功能上的扩充，只是比Collection 接口更加严格了。<code>Set</code>接口中元素<strong>无序</strong>，并且都会以某种规则保证存入的<strong>元素不出现重复</strong>。</p>
<h3 id="9-4-2-特点"><a href="#9-4-2-特点" class="headerlink" title="9.4.2 特点"></a>9.4.2 特点</h3><ul>
<li>元素无序</li>
<li>元素不能重复</li>
</ul>
<blockquote>
<p>Set接口的实现类包括：HashSet，LinkedHashSet</p>
</blockquote>
<h3 id="9-4-3-HashSet集合"><a href="#9-4-3-HashSet集合" class="headerlink" title="9.4.3 HashSet集合"></a>9.4.3 HashSet集合</h3><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持。</p>
<p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<h4 id="HashSet集合存储数据的结构（哈希表）"><a href="#HashSet集合存储数据的结构（哈希表）" class="headerlink" title="HashSet集合存储数据的结构（哈希表）"></a>HashSet集合存储数据的结构（哈希表）</h4><p>在JDK1.8之前，哈希表底层采用<strong>数组+链表</strong>实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用<strong>数组+链表+红黑树</strong>实现，当链表长度超过阈值（<strong>8</strong>）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/9.3.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<p>存储流程：</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/9.4.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<blockquote>
<p>如果往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p>
</blockquote>
<h3 id="9-4-4-LinkedHashSet集合"><a href="#9-4-4-LinkedHashSet集合" class="headerlink" title="9.4.4 LinkedHashSet集合"></a>9.4.4 LinkedHashSet集合</h3><p><code>java.util.LinkedHashSet</code>是HashSet子类，它是链表和哈希表组合的一个数据存储结构。保证元素唯一时，记录存储顺序。</p>
<hr>
<h2 id="9-5-Collections类"><a href="#9-5-Collections类" class="headerlink" title="9.5 Collections类"></a>9.5 Collections类</h2><h3 id="9-5-1-概述"><a href="#9-5-1-概述" class="headerlink" title="9.5.1 概述"></a>9.5.1 概述</h3><p>此类完全由在collection上进行操作或返回collection的静态方法组成。</p>
<p><code>java.utils.Collections</code>是集合工具类</p>
<h3 id="9-5-2-常用API"><a href="#9-5-2-常用API" class="headerlink" title="9.5.2 常用API"></a>9.5.2 常用API</h3><ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</li>
<li><code>public static void shuffle(List&lt;?&gt; list)</code>:打乱集合顺序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li>
</ul>
<h3 id="9-5-3-Comparator比较器"><a href="#9-5-3-Comparator比较器" class="headerlink" title="9.5.3 Comparator比较器"></a>9.5.3 Comparator比较器</h3><p>两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p>
<ul>
<li><code>public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</li>
</ul>
<blockquote>
<p>两个对象比较的结果有三种：大于，等于，小于。<br>如果要按照升序排序， 则o1小于o2，返回（负数），相等返回0，o1大于o2返回（正数）。 如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，o1大于o2返回（负数）</p>
</blockquote>
<p>Comparable和Comparator的区别。</p>
<p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p>
<p><strong>Comparator</strong>：强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>
<hr>
<h2 id="9-6-Map集合"><a href="#9-6-Map集合" class="headerlink" title="9.6 Map集合"></a>9.6 Map集合</h2><h3 id="9-6-1-概述"><a href="#9-6-1-概述" class="headerlink" title="9.6.1 概述"></a>9.6.1 概述</h3><p>Java提供了<code>java.util.Map</code>接口用来存放具有映射关系的对象。</p>
<ul>
<li><p><code>Collection</code>中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。</p>
</li>
<li><p><code>Map</code>中的集合，元素是成对存在的。每个元素由键与值两部分组成，通过键可以找对所对应的值。</p>
</li>
<li><p><code>Collection</code>中的集合称为单列集合， <code>Map</code>中的集合称为双列集合。</p>
</li>
<li><p><strong>Map 中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</strong></p>
</li>
</ul>
<h3 id="9-6-2-Map常用子类"><a href="#9-6-2-Map常用子类" class="headerlink" title="9.6.2 Map常用子类"></a>9.6.2 Map常用子类</h3><p>Map有多个子类，常用的有HashMap集合、LinkedHashMap集合。</p>
<ul>
<li><p><strong>HashMap</strong>：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</p>
</li>
<li><p><strong>LinkedHashMap</strong>：<code>HashMap</code>下有个子类<code>LinkedHashMap</code>，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</p>
</li>
</ul>
<h3 id="9-6-3-Map常用API"><a href="#9-6-3-Map常用API" class="headerlink" title="9.6.3 Map常用API"></a>9.6.3 Map常用API</h3><p>Map接口中定义了很多方法，常用的如下：</p>
<ul>
<li><code>public V put(K key, V value)</code>: 把指定的键与指定的值添加到Map集合中。</li>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li>
<li><code>public V get(Object key)</code>:根据指定的键，在Map集合中获取对应的值。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():</code> 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<blockquote>
<p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中；<br>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</p>
</blockquote>
<h3 id="9-6-4-Entry键值对对象"><a href="#9-6-4-Entry键值对对象" class="headerlink" title="9.6.4 Entry键值对对象"></a>9.6.4 Entry键值对对象</h3><p><code>Map</code>中存放的是两种对象，一种称为<code>key</code>(键)，一种称为<code>value</code>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry</code>(项) 。<code>Entry</code>将键值对的对应关系封装成了对象。即<strong>键值对对象</strong>，在遍历Map 集合时，可以从每一个键值对（ <code>Entry</code> ）对象中获取对应的键与对应的值。</p>
<p>在Map集合中获取所有Entry对象的方法：</p>
<ul>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<p>Entry对象的方法：</p>
<ul>
<li><code>public K getKey()</code>：获取Entry对象中的键。</li>
<li><code>public V getValue()</code>：获取Entry对象中的值</li>
</ul>
<hr>
<h2 id="9-7-HashMap集合"><a href="#9-7-HashMap集合" class="headerlink" title="9.7 HashMap集合"></a>9.7 HashMap集合</h2><p>见集合源码</p>
<hr>
<h2 id="9-8-LinkedHashMap集合"><a href="#9-8-LinkedHashMap集合" class="headerlink" title="9.8 LinkedHashMap集合"></a>9.8 LinkedHashMap集合</h2><p>在<code>HashMap</code>下面有一个子类<code>LinkedHashMap</code>，它是链表和哈希表组合的一个数据存储结构。保证成对元素唯一，并且有序。</p>
<hr>
<h1 id="第14章-并发"><a href="#第14章-并发" class="headerlink" title="第14章 并发"></a>第14章 并发</h1><h2 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h2><h3 id="14-1-1-并发与并行"><a href="#14-1-1-并发与并行" class="headerlink" title="14.1.1 并发与并行"></a>14.1.1 并发与并行</h3><ul>
<li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li>
<li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li>
</ul>
<h3 id="14-1-2-线程与进程"><a href="#14-1-2-线程与进程" class="headerlink" title="14.1.2 线程与进程"></a>14.1.2 线程与进程</h3><ul>
<li><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个<strong>独立的内存空间</strong>，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是<strong>系统运行程序的基本单位</strong>；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li>
<li><strong>线程</strong>：线程是<strong>进程中的一个执行单元</strong>，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</li>
</ul>
<h2 id="14-2-线程"><a href="#14-2-线程" class="headerlink" title="14.2 线程"></a>14.2 线程</h2><h3 id="14-2-1-多线程原理"><a href="#14-2-1-多线程原理" class="headerlink" title="14.2.1 多线程原理"></a>14.2.1 多线程原理</h3><p>代码如下：</p>
<p>自定义线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>	<span class="hljs-comment">// 继承Thread类,将线程名称传递，进行设置</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span></span>&#123;<br>		<span class="hljs-keyword">super</span>(name);<br>	&#125;<br>	<span class="hljs-comment">//重写run方法，定义线程要执行的代码</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>			<span class="hljs-comment">//getName()方法 来自父亲</span><br>			System.out.println(getName()+i);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;这里是main线程&quot;</span>);<br>		MyThread mt = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;小强&quot;</span>);<br>		mt.start();<span class="hljs-comment">//开启了一个新的线程</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>			System.out.println(<span class="hljs-string">&quot;旺财:&quot;</span>+i);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>流程图：</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/14.1.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。</p>
<p><strong>多线程在内存中运行原理：</strong></p>
<p>多线程执行时，在栈内存中，其实<strong>每一个执行线程都有一片自己所属的栈内存空间</strong>。进行方法的压栈和弹栈。</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/14.2.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<p>当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p>
<h3 id="14-2-2-创建线程的方式1——继承Thread类"><a href="#14-2-2-创建线程的方式1——继承Thread类" class="headerlink" title="14.2.2 创建线程的方式1——继承Thread类"></a>14.2.2 创建线程的方式1——继承Thread类</h3><p><code>java.lang.Thread</code>类的API中定义了有关线程的一些方法，具体如下：</p>
<p><strong>构造方法：</strong></p>
<ul>
<li><code>public Thread()</code>:分配一个新的线程对象。</li>
<li><code>public Thread(String name)</code>:分配一个指定名字的新的线程对象。</li>
<li><code>public Thread(Runnable target)</code>:分配一个带有指定目标新的线程对象。</li>
<li><code>public Thread(Runnable target,String name)</code>:分配一个带有指定目标新的线程对象并指定名字。</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>public String getName()</code>:获取当前线程名称。</li>
<li><code>public void start()</code>:导致此线程开始执行; Java虚拟机调用此线程的run方法。</li>
<li><code>public void run()</code>:此线程要执行的任务在此处定义代码。</li>
<li><code>public static void sleep(long millis)</code>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li>
<li><code>public static Thread currentThread()</code>:返回对当前正在执行的线程对象的引用。</li>
</ul>
<h3 id="14-2-3-创建线程的方式2——实现Runnable接口"><a href="#14-2-3-创建线程的方式2——实现Runnable接口" class="headerlink" title="14.2.3 创建线程的方式2——实现Runnable接口"></a>14.2.3 创建线程的方式2——实现Runnable接口</h3><p>实现<code>java.lang.Runnable</code>接口，重写run方法</p>
<p><strong>步骤</strong></p>
<ol>
<li>定义Runnable接口的实现类，并重写该接口的<code>run()</code>方法，该<code>run()</code>方法的方法体同样是该线程的线程执行体。</li>
<li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>调用线程对象的start()方法来启动线程。</li>
</ol>
<p>通过实现Runnable接口，使得该类有了多线程类的特征。<code>run()</code>方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。<strong>Thread类实际上也是实现了Runnable接口的类。</strong></p>
<p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的<code>start()</code>方法来运行多线程代码。<br>实际上所有的多线程代码都是通过运行Thread的<code>start()</code>方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的。</p>
<blockquote>
<p>注：Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的<code>run()</code>方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的<code>run()</code>方法。</p>
</blockquote>
<h3 id="14-2-4-Thread和Runnable的区别"><a href="#14-2-4-Thread和Runnable的区别" class="headerlink" title="14.2.4 Thread和Runnable的区别"></a>14.2.4 Thread和Runnable的区别</h3><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p>
<p>实现Runnable接口比继承Thread类所具有的优势：</p>
<ol>
<li>适合多个相同的程序代码的线程去<strong>共享同一个资源</strong>。</li>
<li>可以避免java中的单继承的局限性。</li>
<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li>
<li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li>
</ol>
<blockquote>
<p>注：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</p>
</blockquote>
<h3 id="14-2-5-匿名内部类方式实现线程的创建"><a href="#14-2-5-匿名内部类方式实现线程的创建" class="headerlink" title="14.2.5 匿名内部类方式实现线程的创建"></a>14.2.5 匿名内部类方式实现线程的创建</h3><p>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。</p>
<h3 id="14-2-6-线程中断"><a href="#14-2-6-线程中断" class="headerlink" title="14.2.6 线程中断"></a>14.2.6 线程中断</h3><p>没有可以强制线程终止的方法。interrupt方法可以用来请求终止线程。</p>
<p>当对一个线程调用interrupt方法时，线程的<em><strong>中断状态</strong></em>将被置位。这是每一个线程都具有的boolean标志。每个线程都应该不时检查这个标志，以判断线程是否被中断。但是如果线程被阻塞，就无法检测中断状态。这是产生InterruptedException异常的地方</p>
<h3 id="14-2-7-线程状态"><a href="#14-2-7-线程状态" class="headerlink" title="14.2.7 线程状态"></a>14.2.7 线程状态</h3><p>线程可以有如下6种状态：</p>
<ol>
<li>New（新创建）</li>
<li>Runnable（可运行）</li>
<li>Blocked（被阻塞）</li>
<li>Waiting（等待）</li>
<li>Timed waiting（计时等待）</li>
<li>Terminated（被终止）</li>
</ol>
<h4 id="新创建线程（New）"><a href="#新创建线程（New）" class="headerlink" title="新创建线程（New）"></a>新创建线程（New）</h4><p>当我们使用new操作符来创建了一个线程时，如使用<code>new Thread（r）</code>时，线程还未开始运行，线程中的代码也没有开始执行，此时就成为<strong>New状态</strong></p>
<h4 id="可运行线程（Runnable）"><a href="#可运行线程（Runnable）" class="headerlink" title="可运行线程（Runnable）"></a>可运行线程（Runnable）</h4><p>当我们对一个线程执行<strong>start()方法</strong>后，就会启动该线程。但是注意，<strong>一个处于可运行状态的线程可能正在运行也可能没有运行，这时取决于操作系统的时间片调度</strong>。抢占式调度系统会给每一个线程分配一个时间片来运行，在时间片使用完后，操作系统就会剥夺它运行的权力，并更根据优先级选择下一个要运行的线程。</p>
<h4 id="被阻塞、等待状态（Blocked、waiting、Timed-waiting）"><a href="#被阻塞、等待状态（Blocked、waiting、Timed-waiting）" class="headerlink" title="被阻塞、等待状态（Blocked、waiting、Timed waiting）"></a>被阻塞、等待状态（Blocked、waiting、Timed waiting）</h4><p>当一个线程处于阻塞和等待状态时，它不做任何工作，也不执行任何代码。直到操作系统重新激活它。</p>
<ul>
<li>当一个线程试图获取一个内部对象锁，而这个锁又被其它线程持有时，<strong>该线程就进入阻塞状态</strong>，当其它线程释放这个锁后，并且线程调度器允许该线程持有它时，该线程将会变成非阻塞状态。</li>
<li>当线程等待另一个线程通知调度器一个条件时，它自己就<strong>进入等待状态</strong>，再调用Object.wait方法或者Thread.join方法时，就会出现这种情况。<strong>被阻塞状态和等待状态是有大有不同的</strong>。</li>
<li>有几个方法有一个超时参数。调用它们导致线程进入<strong>计时等待状态</strong>这一状态将一直保存到超时期满或者接收到适当的通知。带有超时参数的方法有：Thread.sleep 和 Object.wait、Thread.join、 Lock,tryLock 以及 Condition.await 的计时版</li>
</ul>
<h4 id="被终止的线程（Terminated）"><a href="#被终止的线程（Terminated）" class="headerlink" title="被终止的线程（Terminated）"></a>被终止的线程（Terminated）</h4><p>线程终止有两种原因：</p>
<ul>
<li>因为<code>run()</code>方法执行完毕正常退出</li>
<li>因为一个没有捕获的异常而终止了<code>run</code>方法导致意外死亡</li>
</ul>
<h4 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h4><p><img src="/2019/10/17/Java/JavaSE/JavaSE/14.3.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<blockquote>
<p>可以通过调用<code>t.setDaemon(true);</code>将线程转换为守护线程。守护线程用来服务于用户线程，不需要上层逻辑介入。</p>
<p>当线程只剩下守护线程的时候，JVM就会退出。</p>
</blockquote>
<p>总结：</p>
<table>
<thead>
<tr>
<th align="center">线程状态</th>
<th align="left">线程状态导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NEW(新建)</td>
<td align="left">线程刚被创建，但是并未启动。还没调用start方法。</td>
</tr>
<tr>
<td align="center">Runnable(可运行)</td>
<td align="left">线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</td>
</tr>
<tr>
<td align="center">Blocked(锁阻塞)</td>
<td align="left">当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td>
</tr>
<tr>
<td align="center">Waiting(无限等待)</td>
<td align="left">一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</td>
</tr>
<tr>
<td align="center">TimedWaiting(计时等待)</td>
<td align="left">同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td>
</tr>
<tr>
<td align="center">Teminated(被终止)</td>
<td align="left">因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td>
</tr>
</tbody></table>
<blockquote>
<p>sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证线程睡眠到期后就开始立刻执行。</p>
</blockquote>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/14.5.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<hr>
<h2 id="14-3-线程安全"><a href="#14-3-线程安全" class="headerlink" title="14.3 线程安全"></a>14.3 线程安全</h2><h3 id="14-3-1-概述"><a href="#14-3-1-概述" class="headerlink" title="14.3.1 概述"></a>14.3.1 概述</h3><p>如果有多个线程在同时运行，而这些线程可能会同时运行一段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>举例：模拟电影院的售票窗口，实现多个窗口同时卖一场电影票(多个窗口一起卖这100张票)。需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟。</p>
<p>模拟票：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br>	<span class="hljs-comment">//执行卖票操作</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//每个窗口卖票的操作</span><br>		<span class="hljs-comment">//窗口 永远开启</span><br>		<span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>			<span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有票 可以卖</span><br>				<span class="hljs-comment">//出票操作</span><br>				<span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>				<span class="hljs-keyword">try</span> &#123;<br>					Thread.sleep(<span class="hljs-number">100</span>);<br>				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>					<span class="hljs-comment">// TODO Auto‐generated catch block</span><br>					e.printStackTrace();<br>				&#125;<br>				<span class="hljs-comment">//获取当前线程对象的名字</span><br>				String name = Thread.currentThread().getName();<br>				System.out.println(name + <span class="hljs-string">&quot;正在卖:&quot;</span> + ticket‐‐);<br>            &#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">//创建线程任务对象</span><br>		Ticket ticket = <span class="hljs-keyword">new</span> Ticket();<br>		<span class="hljs-comment">//创建三个窗口对象</span><br>		Thread t1 = <span class="hljs-keyword">new</span> Thread(ticket, <span class="hljs-string">&quot;窗口1&quot;</span>);<br>		Thread t2 = <span class="hljs-keyword">new</span> Thread(ticket, <span class="hljs-string">&quot;窗口2&quot;</span>);<br>		Thread t3 = <span class="hljs-keyword">new</span> Thread(ticket, <span class="hljs-string">&quot;窗口3&quot;</span>);<br>		<span class="hljs-comment">//同时卖票</span><br>		t1.start();<br>		t2.start();<br>		t3.start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/14.4.png" srcset="/img/loading.gif" lazyload alt="pic"></p>
<p>发现程序出现了两个问题：</p>
<ol>
<li>相同的票数,比如3这张票被卖了两回。</li>
<li>不存在的票，比如0票与-1票，是不存在的。</li>
</ol>
<p>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</p>
<blockquote>
<p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
</blockquote>
<h3 id="14-3-2-线程同步"><a href="#14-3-2-线程同步" class="headerlink" title="14.3.2 线程同步"></a>14.3.2 线程同步</h3><p>当使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。要解决多线程并发访问一个资源的安全性问题：也就是解决重复票与不存在票问题，Java中提供了同步机制(<code>synchronized</code>)来解决。</p>
<p>为了保证每个线程都能正常执行原子操作，Java引入了线程同步机制。有三种方式完成同步操作：</p>
<ol>
<li><strong>同步代码块</strong>。</li>
<li><strong>同步方法</strong>。</li>
<li><strong>锁机制</strong>。</li>
</ol>
<h3 id="14-3-3-同步代码块"><a href="#14-3-3-同步代码块" class="headerlink" title="14.3.3 同步代码块"></a>14.3.3 同步代码块</h3><ul>
<li><strong>同步代码块</strong>： <code>synchronized </code>关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li>
</ul>
<p>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁)&#123;<br>	需要同步操作的代码<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>同步锁</strong>：</p>
<p>对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。</p>
<ol>
<li>锁对象，可以是任意类型。</li>
<li>多个线程对象，要使用同一把锁。</li>
</ol>
<blockquote>
<p>在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。</p>
</blockquote>
<p>使用同步代码块解决代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">//同步锁</span><br>    Object lock = <span class="hljs-keyword">new</span> Object();<br>	<span class="hljs-comment">//执行卖票操作</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//每个窗口卖票的操作</span><br>		<span class="hljs-comment">//窗口 永远开启</span><br>		<span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>				<span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有票 可以卖</span><br>					<span class="hljs-comment">//出票操作</span><br>					<span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>					<span class="hljs-keyword">try</span> &#123;<br>						Thread.sleep(<span class="hljs-number">100</span>);<br>					&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>						<span class="hljs-comment">// TODO Auto‐generated catch block</span><br>						e.printStackTrace();<br>					&#125;<br>					<span class="hljs-comment">//获取当前线程对象的名字</span><br>					String name = Thread.currentThread().getName();<br>					System.out.println(name + <span class="hljs-string">&quot;正在卖:&quot;</span> + ticket‐‐);<br>        	    &#125;<br>            &#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="14-3-4-同步方法"><a href="#14-3-4-同步方法" class="headerlink" title="14.3.4 同步方法"></a>14.3.4 同步方法</h3><ul>
<li><strong>同步方法</strong>：使用<code>synchronized</code>修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</li>
</ul>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>	可能会产生线程安全问题的代码<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>同步锁是谁?<br>对于非static方法，同步锁就是this。<br>对于static方法，我们使用当前方法所在类的字节码对象(类名.class)。</p>
</blockquote>
<p>使用同步方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br>	<span class="hljs-comment">//执行卖票操作</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//每个窗口卖票的操作</span><br>		<span class="hljs-comment">//窗口 永远开启</span><br>		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>			sellTicket();<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">//锁对象 是 谁调用这个方法 就是谁, 隐含 锁对象 就是 this</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sellTicket</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br>			<span class="hljs-comment">//出票操作</span><br>			<span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>			<span class="hljs-keyword">try</span> &#123;<br>				Thread.sleep(<span class="hljs-number">100</span>);<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				<span class="hljs-comment">// TODO Auto‐generated</span><br>           		e.printStackTrace();<br>    		&#125;<br>			<span class="hljs-comment">//获取当前线程对象的名字</span><br>			String name = Thread.currentThread().getName();<br>            System.out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="14-3-5-Lock锁"><a href="#14-3-5-Lock锁" class="headerlink" title="14.3.5 Lock锁"></a>14.3.5 Lock锁</h3><p><code>java.util.concurrent.locks.Lock</code>机制提供了比<code>synchronized</code>代码块和<code>synchronized</code>方法更广泛的锁定操作，同步代码块/同步方法具有的功能<code>Lock</code>都有,除此之外更强大,更体现面向对象。</p>
<p>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p>
<ul>
<li><code>public void lock()</code>：加同步锁。</li>
<li><code>public void unlock()</code>：释放同步锁。</li>
</ul>
<p>使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br>	Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>	<span class="hljs-comment">//执行卖票操作</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//每个窗口卖票的操作</span><br>		<span class="hljs-comment">//窗口 永远开启</span><br>		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>			lock.lock();<br>			<span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br>				<span class="hljs-comment">//出票操作</span><br>				<span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>				<span class="hljs-keyword">try</span> &#123;<br>					Thread.sleep(<span class="hljs-number">50</span>);<br>				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>					<span class="hljs-comment">// TODO Auto‐generated catch block</span><br>					e.printStackTrace();<br>				&#125;<br>				<span class="hljs-comment">//获取当前线程对象的名字</span><br>				String name = Thread.currentThread().getName();<br>				System.out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>			&#125;<br>		lock.unlock();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="14-4-等待唤醒机制"><a href="#14-4-等待唤醒机制" class="headerlink" title="14.4 等待唤醒机制"></a>14.4 等待唤醒机制</h2><h3 id="14-4-1-线程间通信"><a href="#14-4-1-线程间通信" class="headerlink" title="14.4.1 线程间通信"></a>14.4.1 线程间通信</h3><p><strong>概念</strong>：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p>
<p><strong>为什么要处理线程间通信：</strong></p>
<p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<p><strong>如何保证线程间通信有效利用资源：</strong></p>
<p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即——<strong>等待唤醒机制</strong>。</p>
<h3 id="14-4-2-等待唤醒机制"><a href="#14-4-2-等待唤醒机制" class="headerlink" title="14.4.2 等待唤醒机制"></a>14.4.2 等待唤醒机制</h3><p><strong>什么是等待唤醒机制：</strong></p>
<p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是全部，线程间也会有协作机制。</p>
<p>就是在一个线程进行了规定操作后，就进入等待状态（<code>wait()</code>）， 等待其他线程执行完他们的指定代码过后再将其唤醒（<code>notify()</code>）;在有多个线程进行等待时， 如果需要，可以使用<code>notifyAll()</code>来唤醒所有的等待线程。<br><strong>wait/notify</strong>就是线程间的一种协作机制。</p>
<p><strong>等待唤醒中的方法：</strong></p>
<p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li><strong>wait</strong>：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是WAITING。它还要等着别的线程执行一个特别的动作，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中。</li>
<li><strong>notify</strong>：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li>
<li><strong>notifyAll</strong>：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注：</p>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态。</li>
<li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态。</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong></p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。</li>
</ol>
<p>  因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</p>
<ol start="2">
<li>wait方法与notify方法是属于Object类的方法的。</li>
</ol>
<p>  因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</p>
<ol start="3">
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。</li>
</ol>
<p>  因为：必须要通过锁对象调用这2个方法。</p>
<p>代码演示：</p>
<p>包子资源类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZi</span> </span>&#123;<br>	String pier ;<br>	String xianer ;<br>	<span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span> ;<span class="hljs-comment">//包子资源 是否存在 包子资源状态</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>吃货线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChiHuo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>	<span class="hljs-keyword">private</span> BaoZi bz;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChiHuo</span><span class="hljs-params">(String name,BaoZi bz)</span></span>&#123;<br>		<span class="hljs-keyword">super</span>(name);<br>		<span class="hljs-keyword">this</span>.bz = bz;<br>	&#125;	<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>			<span class="hljs-keyword">synchronized</span> (bz)&#123;<br>				<span class="hljs-keyword">if</span>(bz.flag == <span class="hljs-keyword">false</span>)&#123;<span class="hljs-comment">//没包子</span><br>					<span class="hljs-keyword">try</span> &#123;<br>						bz.wait();<br>					&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>						e.printStackTrace();<br>					&#125;<br>				&#125;<br>				System.out.println(<span class="hljs-string">&quot;吃货正在吃&quot;</span>+bz.pier+bz.xianer+<span class="hljs-string">&quot;包子&quot;</span>);<br>				bz.flag = <span class="hljs-keyword">false</span>;<br>				bz.notify();<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>包子铺线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZiPu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> BaoZi bz;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaoZiPu</span><span class="hljs-params">(String name,BaoZi bz)</span></span>&#123;<br>		<span class="hljs-keyword">super</span>(name);<br>		<span class="hljs-keyword">this</span>.bz = bz;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>		<span class="hljs-comment">//造包子</span><br>		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>			<span class="hljs-comment">//同步</span><br>			<span class="hljs-keyword">synchronized</span> (bz)&#123;<br>				<span class="hljs-keyword">if</span>(bz.flag == <span class="hljs-keyword">true</span>)&#123;<span class="hljs-comment">//包子资源 存在</span><br>					<span class="hljs-keyword">try</span> &#123;<br>						bz.wait();<br>					&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>						e.printStackTrace();<br>					&#125;<br>				&#125;<br>				<span class="hljs-comment">// 没有包子 造包子</span><br>				System.out.println(<span class="hljs-string">&quot;包子铺开始做包子&quot;</span>);<br>				<span class="hljs-keyword">if</span>(count%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>					<span class="hljs-comment">// 冰皮 五仁</span><br>					bz.pier = <span class="hljs-string">&quot;冰皮&quot;</span>;<br>					bz.xianer = <span class="hljs-string">&quot;五仁&quot;</span>;<br>				&#125;<span class="hljs-keyword">else</span>&#123;<br>					<span class="hljs-comment">// 薄皮 牛肉大葱</span><br>					bz.pier = <span class="hljs-string">&quot;薄皮&quot;</span>;<br>					bz.xianer = <span class="hljs-string">&quot;牛肉大葱&quot;</span>;<br>				&#125;<br>				count++;<br>				bz.flag=<span class="hljs-keyword">true</span>;<br>				System.out.println(<span class="hljs-string">&quot;包子造好了：&quot;</span>+bz.pier+bz.xianer);<br>				System.out.println(<span class="hljs-string">&quot;吃货来吃吧&quot;</span>);<br>				<span class="hljs-comment">//唤醒等待线程 （吃货）</span><br>				bz.notify();<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">//等待唤醒案例</span><br>		BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br>		ChiHuo ch = <span class="hljs-keyword">new</span> ChiHuo(<span class="hljs-string">&quot;吃货&quot;</span>,bz);<br>		BaoZiPu bzp = <span class="hljs-keyword">new</span> BaoZiPu(<span class="hljs-string">&quot;包子铺&quot;</span>,bz);<br>		ch.start();<br>		bzp.start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>IO（Input Output）用于实现对数据的输入与输出操作，Java把不同的输入/输出源（键盘、文件、网络等）抽象表述为流（Stream）。流是从起源到接收的有序数据，有了它程序就可以采用同一方式访问不同的输入/输出源。</p>
<ul>
<li>按照数据流向，可以将流分为<strong>输入流</strong>和<strong>输出流</strong>，其中输入流只能读取数据、不能写入数据，而输出流只能写入数据、不能读取数据。</li>
<li>按照数据类型，可以将流分为<strong>字节流</strong>和<strong>字符流</strong>，其中字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符。</li>
<li>按照处理功能，可以将流分为<strong>节点流</strong>和<strong>处理流</strong>，其中节点流可以直接从/向一个特定的IO设备（磁盘、网络等）读/写数据，也称为低级流，而处理流是对节点流的连接或封装，用于简化数据读/写功能或提高效率，也称为高级流。</li>
</ul>
<p>Java提供了大量的类来支持IO操作，下表整理了其中比较常用的一些类。其中，黑色字体的是抽象基类，其他所有的类都继承自它们。红色字体的是节点流，蓝色字体的是处理流。</p>
<p><img src="/2019/10/17/Java/JavaSE/JavaSE/image-20210823103502984.png" srcset="/img/loading.gif" lazyload alt="image-20210823103502984"></p>
<p>根据命名很容易理解各个流的作用：</p>
<ul>
<li>以File开头的文件流用于访问文件；</li>
<li>以ByteArray/CharArray开头的流用于访问内存中的数组；</li>
<li>以Piped开头的管道流用于访问管道，实现进程之间的通信；</li>
<li>以String开头的流用于访问内存中的字符串；</li>
<li>以Buffered开头的缓冲流，用于在读写数据时对数据进行缓存，以减少IO次数；</li>
<li>InputStreamReader、InputStreamWriter是转换流，用于将字节流转换为字符流；</li>
<li>以Object开头的流是对象流，用于实现对象的序列化；</li>
<li>以Print开头的流是打印流，用于简化打印操作；</li>
<li>以Pushback开头的流是推回输入流，用于将已读入的数据推回到缓冲区，从而实现再次读取；</li>
<li>以Data开头的流是特殊流，用于读写Java基本类型的数据。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Java/JavaSE/">JavaSE</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JavaSE/">JavaSE</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/03/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/Git%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Git</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?cd190160b5401a029cee361d013e32a1";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
