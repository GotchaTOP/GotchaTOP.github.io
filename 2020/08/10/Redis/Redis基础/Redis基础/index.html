

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="懂一点点">
  <meta name="author" content="Gotcha">
  <meta name="keywords" content="">
  
  <title>Redis基础 - Gotcha的笔记总结</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"cd190160b5401a029cee361d013e32a1","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"U8yaiFQ2fUef4ujWTig83mSL-gzGzoHsz","app_key":"akCMytdeJqrMuKP84F4oblqz","server_url":"https://u8yaifq2.lc-cn-n1-shared.com"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Gotcha的笔记总结</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/background/01.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Redis基础">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-08-10 00:00" pubdate>
        2020年8月10日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      387
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis基础</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2020年8月10日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能<strong>键值对</strong>（key-value）数据库。</p>
<h2 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><ul>
<li><p>数据间没有必然的关联关系</p>
</li>
<li><p>内部采用单线程机制进行工作</p>
</li>
<li><p>高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。</p>
</li>
<li><p>多数据类型支持</p>
<ul>
<li><p>字符串类型 string</p>
</li>
<li><p>列表类型 list</p>
</li>
<li><p>散列类型 hash</p>
</li>
<li><p>集合类型 set</p>
</li>
<li><p>有序集合类型 sorted_set</p>
</li>
</ul>
</li>
<li><p>持久化支持。可以进行数据灾难恢复</p>
</li>
</ul>
<h2 id="1-3-应用"><a href="#1-3-应用" class="headerlink" title="1.3 应用"></a>1.3 应用</h2><ul>
<li>为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等</li>
<li>任务队列，如秒杀、抢购、购票排队等</li>
<li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等</li>
<li>时效性信息控制，如验证码控制、投票控制等</li>
<li>分布式数据共享，如分布式集群架构中的 session 分离</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
<h2 id="1-4-综合应用"><a href="#1-4-综合应用" class="headerlink" title="1.4 综合应用"></a>1.4 综合应用</h2><p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/1.1.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="1-5-数据存储格式"><a href="#1-5-数据存储格式" class="headerlink" title="1.5 数据存储格式"></a>1.5 数据存储格式</h2><ul>
<li>redis 自身是一个 Map，其中所有的数据都是采用<strong>key : value</strong>的形式存储</li>
<li>数据类型指的是存储的数据的类型，也就是 value 部分的类型，<strong>key 部分永远都是字符串</strong></li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/1.2.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><p><strong>所有的key都为String类型，讨论数据类型是说的value的类型</strong></p>
<h2 id="2-1-String"><a href="#2-1-String" class="headerlink" title="2.1 String"></a>2.1 String</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li>
<li>存储数据的格式：一个存储空间保存一个数据</li>
<li>存储内容：通常使用字符串，如果字符串以整数的形式展示，<strong>可以作为数字操作使用</strong></li>
</ul>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">//添加/修改String<br>set key value<br>mset key1 value1 key2 value2...<br>//设置生命周期<br>setex key seconds value <br><br>//得到String<br>get key <br>mget key1 key2...<br><br>//得到字符串长度<br>strlen key<br><br>//删除String<br>del key<br><br>//向字符串的后面追加字符，如果有就补在后面，如果没有就新建<br>append key value<br></code></pre></td></tr></table></figure>

<h3 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h3><h4 id="String作为数值的操作"><a href="#String作为数值的操作" class="headerlink" title="String作为数值的操作"></a>String作为数值的操作</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//增长指令，只有当value为数字时才能增长</span><br>incr <span class="hljs-built_in">key</span>  <br>incrby <span class="hljs-built_in">key</span> increment  <br>incrbyfloat <span class="hljs-built_in">key</span> increment <br><br><span class="hljs-comment">//减少指令，有当value为数字时才能减少</span><br>decr <span class="hljs-built_in">key</span>  <br>decrby <span class="hljs-built_in">key</span> increment<br></code></pre></td></tr></table></figure>

<ul>
<li>string在redis内部存储默认就是一个<strong>字符串</strong>，当遇到增减类操作incr，decr时会<strong>转成数值型</strong>进行计算。</li>
<li>redis所有的操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li>
<li>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li>
</ul>
<blockquote>
<p>redis可以用于控制数据库表主键id，为数据库表主键<strong>提供生成策略</strong>，保障数据库表的主键<strong>唯一性</strong></p>
<p>此方案适用于所有数据库，且支持数据库集群</p>
</blockquote>
<h4 id="指定生命周期"><a href="#指定生命周期" class="headerlink" title="指定生命周期"></a>指定生命周期</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>设置数据的生命周期，单位 秒<br>setex key seconds value<br><span class="hljs-regexp">//</span>设置数据的生命周期，单位 毫秒<br>psetex key milliseconds valu<br></code></pre></td></tr></table></figure>

<blockquote>
<p>redis可以控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作    </p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>数据操作不成功的反馈与数据正常操作之间的差异</p>
<ul>
<li><p>表示运行结果是否成功</p>
<ul>
<li><p>(integer) 0 → false 失败</p>
</li>
<li><p>(integer) 1 → true 成功</p>
</li>
</ul>
</li>
<li><p>表示运行结果值</p>
<ul>
<li>(integer) 3 → 3， 3个</li>
<li>(integer) 1 → 1， 1个</li>
</ul>
</li>
</ul>
</li>
<li><p>数据未获取到返回nil，含义等同于null</p>
</li>
<li><p>数据最大存储量 512MB</p>
</li>
<li><p>数值计算最大范围（java中的long的最大值） 9223372036854775807</p>
</li>
</ul>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li><p>习惯以数据库热点数据key命名</p>
<p>​    表名：主键名：主键值：字段名</p>
</li>
</ul>
<p>eg1：order：id        : 29437  ：name</p>
<p>eg2：equip：id        : 39047： type</p>
<p>eg3：news：id        :  20041 ：title</p>
<h2 id="2-2-Hash"><a href="#2-2-Hash" class="headerlink" title="2.2 Hash"></a>2.2 Hash</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>存储的数据：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</li>
<li>存储数据的格式：一个存储空间保存多个键值对数据</li>
<li>hash类型：底层使用<strong>哈希表</strong>结构实现数据存储</li>
<li>hash存储结构优化<ul>
<li>如果field数量较少，存储结构优化为类数组结构</li>
<li>如果field数量较多，存储结构使用HashMap结构</li>
</ul>
</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/2.1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">//插入/修改（如果已存在同名的field，会被覆盖）</span><br>hset <span class="hljs-built_in">key</span> field <span class="hljs-built_in">value</span><br>hmset <span class="hljs-built_in">key</span> field1 value1 field2 value2...<br><span class="hljs-comment">//插入（如果已存在同名的field，不会被覆盖）</span><br>hsetnx <span class="hljs-built_in">key</span> field <span class="hljs-built_in">value</span><br><br><span class="hljs-comment">//取出</span><br>hget <span class="hljs-built_in">key</span> field<br>hmget <span class="hljs-built_in">key</span> field1 field2...<br>hgetall <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//删除</span><br><span class="hljs-built_in">hdel</span> <span class="hljs-built_in">key</span> field1 field2...<br><br><span class="hljs-comment">//获取field数量</span><br>hlen <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//查看是否存在指定的字段</span><br>hexists <span class="hljs-built_in">key</span> field<br><br><span class="hljs-comment">//获取哈希表中所有的字段名或字段值 </span><br>hkeys <span class="hljs-built_in">key</span><br>hvals <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//设置指定字段的数值数据增加/减少指定范围的值 </span><br>hincrby <span class="hljs-built_in">key</span> field increment<br>hincrbyfloat <span class="hljs-built_in">key</span> field increment<br><br>hdecrby <span class="hljs-built_in">key</span> field increment<br>hdecrbyfloat <span class="hljs-built_in">key</span> field increment<br></code></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>hash类型下的value<strong>只能存储字符串</strong>，不允许存储其他数据类型，<strong>不存在嵌套现象</strong>。如果数据未获取到， 对应的值为（nil）</li>
<li>每个 hash 可以存储 2^32 - 1 个键值</li>
<li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，<strong>不可滥用</strong>，更<strong>不可以将hash作为对象列表使用</strong></li>
<li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体<strong>数据效率就很会低</strong>，有可能成为数据访问瓶颈</li>
</ul>
<h2 id="2-3-List"><a href="#2-3-List" class="headerlink" title="2.3 List"></a>2.3 List</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>存储的数据：存储多个数据，并对数据进入存储空间的顺序进行区分</p>
</li>
<li><p>存储数据的格式：一个存储空间保存多个数据，且通过数据可以体现进入顺序</p>
</li>
<li><p>list类型：保存多个数据，底层使用<strong>双向链表</strong>存储结构实现</p>
</li>
<li><p><strong>元素有序，且可重</strong></p>
</li>
</ul>
<h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tcl">//添加修改数据,lpush为从左边添加，rpush为从右边添加<br>lpush key value1 value2 value3...<br>rpush key value1 value2 value3...<br><br>//查看数据, 从左边开始向右查看. 如果不知道<span class="hljs-keyword">list</span>有多少个元素，end的值可以为<span class="hljs-number">-1</span>,代表倒数第一个元素<br>//lpush先进的元素放在最后,rpush先进的元素放在最前面<br><span class="hljs-keyword">lrange</span> key start end<br>//得到长度<br>llen key<br>//取出对应索引的元素<br><span class="hljs-keyword">lindex</span> key index<br><br>//获取并移除元素（从<span class="hljs-keyword">list</span>左边或者右边移除）<br>lpop key<br>rpop key<br></code></pre></td></tr></table></figure>

<h3 id="拓展操作"><a href="#拓展操作" class="headerlink" title="拓展操作"></a>拓展操作</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//规定时间内获取并移除数据,b=block,给定一个时间，如果在指定时间内放入了元素，就移除</span><br><span class="hljs-function"><span class="hljs-title">blpop</span></span> key1 key2... timeout<br><span class="hljs-function"><span class="hljs-title">brpop</span></span> key1 key2... timeout<br><br><span class="hljs-comment">//从列表中取出最后一个元素，并插入到另外一个列表的头部</span><br>brpoplpush source destination timeout<br><br><span class="hljs-comment">//移除指定元素 count:移除的个数 value:移除的值。 移除多个相同元素时，从左边开始移除</span><br>lrem key count value<br></code></pre></td></tr></table></figure>

<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。</li>
<li>list具有索引的概念，但是操作数据时通常以<strong>队列</strong>的形式进行入队出队(rpush, rpop)操作，或以<strong>栈</strong>的形式进行入栈出栈(lpush, lpop)操作</li>
<li>获取全部数据操作结束索引设置为-1 (倒数第一个元素)</li>
<li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</li>
</ul>
<h2 id="2-4-Set"><a href="#2-4-Set" class="headerlink" title="2.4 Set"></a>2.4 Set</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>存储的数据：存储大量的数据，在查询方面提供更高的效率</p>
</li>
<li><p>存储数据的格式：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的</p>
</li>
<li><p>set类型：能够保存大量的数据，高效的内部存储机制，便于查询</p>
</li>
<li><p><strong>不重复且无需</strong></p>
</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/2.2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>添加数据<br>sadd key member1 member2...<br><br><span class="hljs-regexp">//</span>查看全部数据<br>smembers key<br><br><span class="hljs-regexp">//</span>移除数据<br>srem key member1 member2<br><br><span class="hljs-regexp">//</span>查看数据个数<br>scard key<br><br><span class="hljs-regexp">//</span>查看某个元素是否存在<br>sismember key member<br></code></pre></td></tr></table></figure>

<h3 id="扩展操作-1"><a href="#扩展操作-1" class="headerlink" title="扩展操作"></a>扩展操作</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>从set中任意选出count个元素<br>srandmember key [count]<br><br><span class="hljs-regexp">//</span>从set中任意选出count个元素并移除<br>spop key [count]<br><br><span class="hljs-regexp">//</span>求两个集合的交集、并集、差集<br>sinter key1 key2<br>sunion key1 key2<br>sdiff key1 key2<br><br><span class="hljs-regexp">//</span>求两个set的交集、并集、差集，并放入另一个set中<br>sinterstore destination key1 key2<br>sunionstore destination key1 key2<br>sdiffstore destination key1 key2<br><br><span class="hljs-regexp">//</span>求指定数据从原集合移动到目标集合中<br>smove source destination key<br></code></pre></td></tr></table></figure>

<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份</li>
<li>set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间</li>
</ul>
<h2 id="2-5-sorted-set"><a href="#2-5-sorted-set" class="headerlink" title="2.5 sorted_set"></a>2.5 sorted_set</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>存储的数据：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行<strong>排序</strong>的方式</p>
</li>
<li><p>存储数据的格式：新的存储模型，可以保存<strong>可排序</strong>的数据</p>
</li>
<li><p>sorted_set类型：在set的存储结构基础上添加可排序字段</p>
</li>
<li><p><strong>不重但有序（score）</strong></p>
</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/2.3.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">//插入元素, 需要指定score(用于排序)</span><br>zadd <span class="hljs-built_in">key</span> score1 member1 score2 member2<br><br><span class="hljs-comment">//查看元素(score升序), 当末尾添加withscore时，会将元素的score一起打印出来</span><br>zrange <span class="hljs-built_in">key</span> start end [withscore]<br><span class="hljs-comment">//查看元素(score降序), 当末尾添加withscore时，会将元素的score一起打印出来</span><br>zrevrange <span class="hljs-built_in">key</span> start end [withscore]<br><br><span class="hljs-comment">//移除元素</span><br>zrem <span class="hljs-built_in">key</span> member1 member2...<br><br><span class="hljs-comment">//按条件获取数据, 其中offset为索引开始位置，count为获取的数目</span><br>zrangebyscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">min</span> <span class="hljs-built_in">max</span> [withscore] [limit offset <span class="hljs-built_in">count</span>]<br>zrevrangebyscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">max</span> <span class="hljs-built_in">min</span> [withscore] [limit offset <span class="hljs-built_in">count</span>]<br><br><span class="hljs-comment">//按条件移除元素</span><br>zremrangebyrank <span class="hljs-built_in">key</span> start end<br>zremrangebysocre <span class="hljs-built_in">key</span> <span class="hljs-built_in">min</span> <span class="hljs-built_in">max</span><br><br><span class="hljs-comment">//按照从大到小的顺序移除count个值</span><br>zpopmax <span class="hljs-built_in">key</span> [<span class="hljs-built_in">count</span>]<br><span class="hljs-comment">//按照从小到大的顺序移除count个值</span><br>zpopmin <span class="hljs-built_in">key</span> [<span class="hljs-built_in">count</span>]<br><br><span class="hljs-comment">//获得元素个数</span><br>zcard <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//获得元素在范围内的个数</span><br>zcount <span class="hljs-built_in">min</span> <span class="hljs-built_in">max</span><br><br><span class="hljs-comment">//求交集、并集并放入destination中, 其中numkey为要去交集或并集集合的数目</span><br>zinterstore destination numkeys key1 key2...<br>zunionstore destination numkeys key1 key2...<br></code></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>min与max用于限定搜索查询的<strong>条件</strong></li>
<li>start与stop用于限定<strong>查询范围</strong>，作用于索引，表示开始和结束索引</li>
<li>offset与count用于限定查询范围，作用于查询结果，表示<strong>开始位置</strong>和<strong>数据总量</strong></li>
</ul>
<h3 id="拓展操作-1"><a href="#拓展操作-1" class="headerlink" title="拓展操作"></a>拓展操作</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//查看某个元素的索引(排名)</span><br>zrank <span class="hljs-built_in">key</span> member<br>zrevrank <span class="hljs-built_in">key</span> member<br><br><span class="hljs-comment">//查看某个元素索引的值</span><br>zscore <span class="hljs-built_in">key</span> member<br><span class="hljs-comment">//增加某个元素索引的值</span><br>zincrby <span class="hljs-built_in">key</span> increment membe<br></code></pre></td></tr></table></figure>

<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>score保存的数据存储空间是64位，如果是整数，范围是-9007199254740992~9007199254740992</li>
<li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，<strong>可能会丢失精度</strong>，使用时候要<strong>慎重</strong></li>
<li>sorted_set 底层存储还是<strong>基于set</strong>结构的，因此数据<strong>不能重复</strong>，如果重复添加相同的数据，score值将被反复覆盖，<strong>保留最后一次</strong>修改的结果</li>
</ul>
<h1 id="三、通用指令"><a href="#三、通用指令" class="headerlink" title="三、通用指令"></a>三、通用指令</h1><h2 id="3-1-Key的特征"><a href="#3-1-Key的特征" class="headerlink" title="3.1 Key的特征"></a>3.1 Key的特征</h2><ul>
<li>key是一个<strong>字符串</strong>，通过key获取redis中保存的数据</li>
</ul>
<h2 id="3-2-Key的操作"><a href="#3-2-Key的操作" class="headerlink" title="3.2 Key的操作"></a>3.2 Key的操作</h2><h3 id="基本操作-5"><a href="#基本操作-5" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//查看key是否存在</span><br>exists <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//删除key</span><br>del <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//查看key的类型</span><br><span class="hljs-built_in">type</span> <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure>

<h3 id="拓展操作-2"><a href="#拓展操作-2" class="headerlink" title="拓展操作"></a>拓展操作</h3><h4 id="时效性操作"><a href="#时效性操作" class="headerlink" title="时效性操作"></a>时效性操作</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//设置生命周期</span><br>expire <span class="hljs-built_in">key</span> seconds<br>pexpire <span class="hljs-built_in">key</span> milliseconds<br><br>expireat <span class="hljs-built_in">key</span> timestamp<br>pexpireat <span class="hljs-built_in">key</span> milliseconds-timestamp<br><br><span class="hljs-comment">//查看有效时间, 如果有有效时间则返回剩余有效时间, 如果为永久有效，则返回-1, 如果Key不存在则返回-2</span><br>ttl <span class="hljs-built_in">key</span><br>pttl <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//将有时限的数据设置为永久有效</span><br>persist <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure>

<h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>根据key查询符合条件的数据<br>keys pattern<br></code></pre></td></tr></table></figure>

<p><strong>查询规则</strong></p>
<p><code>*</code>匹配任意数量的任意符号</p>
<p> <code>?</code> 配合一个任意符号</p>
<p><code> []</code> 匹配一个指定符号</p>
<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xquery">//重命<span class="hljs-built_in">名key</span>，为了避免覆盖已有数据，尽量少去修改已<span class="hljs-built_in">有key</span>的名字，如果要使用最好使用renamenx<br><span class="hljs-keyword">rename</span><span class="hljs-built_in"> key</span> newKey<br>renamenx<span class="hljs-built_in"> key</span> newKey<br><br>//对所<span class="hljs-built_in">有key</span>排序<span class="hljs-built_in"></span><br><span class="hljs-built_in">sort</span><br><br>//查看所有关<span class="hljs-built_in">于key</span>的操作, 可以使用Tab快速切换<br>help @generic<br></code></pre></td></tr></table></figure>

<h2 id="3-3-数据库通用操作"><a href="#3-3-数据库通用操作" class="headerlink" title="3.3 数据库通用操作"></a>3.3 数据库通用操作</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>Redis为每个服务提供有16个数据库，编号从0到15</li>
<li>每个数据库之间的数据相互独立</li>
</ul>
<h3 id="基本操作-6"><a href="#基本操作-6" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>切换数据库 <span class="hljs-number">0</span>~<span class="hljs-number">15</span><br>select index<br><br><span class="hljs-regexp">//</span>其他操作<br>quit<br>ping<br>echo massage<br></code></pre></td></tr></table></figure>

<h3 id="拓展操作-3"><a href="#拓展操作-3" class="headerlink" title="拓展操作"></a>拓展操作</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>移动数据, 必须保证目的数据库中没有该数据<br>mov key db<br><br><span class="hljs-regexp">//</span>查看该库中数据总量<br>dbsize<br><br><span class="hljs-regexp">//</span>数据清除<br>flushdb<br>flushall<br></code></pre></td></tr></table></figure>

<h1 id="四、Jedis"><a href="#四、Jedis" class="headerlink" title="四、Jedis"></a>四、Jedis</h1><p><strong>JAVA</strong>操作Redis需要导入jar或引入Maven依赖</p>
<h2 id="4-1-Java操作redis的步骤"><a href="#4-1-Java操作redis的步骤" class="headerlink" title="4.1 Java操作redis的步骤"></a>4.1 Java操作redis的步骤</h2><ul>
<li>连接Redis</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//参数为Redis所在的ip地址和端口号</span><br>Jedis jedis = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Jedis(String <span class="hljs-params">host</span>, <span class="hljs-params">int</span> <span class="hljs-params">port</span>)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>操作Redis</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//操作redis的指令和redis本身的指令几乎一致</span><br>jedis.<span class="hljs-built_in">set</span>(<span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span>, <span class="hljs-keyword">String</span> value);<br>jedis.<span class="hljs-built_in">get</span>(<span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>断开连接</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">jedis.close()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h2 id="4-2-配置工具"><a href="#4-2-配置工具" class="headerlink" title="4.2 配置工具"></a>4.2 配置工具</h2><ul>
<li>配置文件</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">redis.host</span>=localhost<br><span class="hljs-attr">redis.port</span>=<span class="hljs-number">6379</span><br><span class="hljs-attr">redis.maxTotal</span>=<span class="hljs-number">30</span><br><span class="hljs-attr">redis.maxIdle</span>=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<ul>
<li>工具类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<br><span class="hljs-keyword">import</span> java.util.ResourceBundle;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtil</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Jedis jedis = <span class="hljs-keyword">null</span>;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String host = <span class="hljs-keyword">null</span>;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> port;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxTotal;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxIdle;<br><br>	<span class="hljs-comment">//使用静态代码块，只加载一次</span><br>	<span class="hljs-keyword">static</span> &#123;<br>		<span class="hljs-comment">//读取配置文件</span><br>		ResourceBundle resourceBundle = ResourceBundle.getBundle(<span class="hljs-string">&quot;redis&quot;</span>);<br>		<span class="hljs-comment">//获取配置文件中的数据</span><br>		host = resourceBundle.getString(<span class="hljs-string">&quot;redis.host&quot;</span>);<br>		port = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">&quot;redis.port&quot;</span>));<br>		<span class="hljs-comment">//读取最大连接数</span><br>		maxTotal = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">&quot;redis.maxTotal&quot;</span>));<br>		<span class="hljs-comment">//读取最大活跃数</span><br>		maxIdle = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">&quot;redis.maxIdle&quot;</span>));<br>		JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>		jedisPoolConfig.setMaxTotal(maxTotal);<br>		jedisPoolConfig.setMaxIdle(maxIdle);<br>		<span class="hljs-comment">//获取连接池</span><br>		JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(jedisPoolConfig, host, port);<br>		jedis = jedisPool.getResource();<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> jedis;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="五、Linux下环境配置"><a href="#五、Linux下环境配置" class="headerlink" title="五、Linux下环境配置"></a>五、Linux下环境配置</h1><h2 id="5-1-基础环境设置"><a href="#5-1-基础环境设置" class="headerlink" title="5.1 基础环境设置"></a>5.1 基础环境设置</h2><ul>
<li>创建软链接<ul>
<li> ln -s 原始目录名 快速访问目录名</li>
</ul>
</li>
<li>创建配置文件管理目录 <ul>
<li> mkdir conf mkdir config</li>
</ul>
</li>
<li>创建数据文件管理目录 <ul>
<li> mkdir data</li>
</ul>
</li>
</ul>
<h2 id="5-2-服务启动"><a href="#5-2-服务启动" class="headerlink" title="5.2 服务启动"></a>5.2 服务启动</h2><ul>
<li>默认配置启动<ul>
<li>redis-server</li>
<li>redis-server –-port 6379</li>
</ul>
</li>
<li>指定配置文件启动<ul>
<li>redis-server redis.conf</li>
<li> redis-server redis-6379.conf</li>
<li>redis-server conf/redis-6379.conf</li>
</ul>
</li>
</ul>
<h2 id="5-3-客户端连接"><a href="#5-3-客户端连接" class="headerlink" title="5.3 客户端连接"></a>5.3 客户端连接</h2><ul>
<li>默认连接<ul>
<li> redis-cli</li>
</ul>
</li>
<li>连接指定服务器<ul>
<li> redis-cli -h 127.0.0.1</li>
<li> redis-cli –port 6379</li>
<li> redis-cli -h 127.0.0.1 –port 6379</li>
</ul>
</li>
</ul>
<h2 id="5-4-服务端配置"><a href="#5-4-服务端配置" class="headerlink" title="5.4 服务端配置"></a>5.4 服务端配置</h2><ul>
<li><strong>daemonize yes</strong> 以守护进程方式启动，使用本启动方式，redis将以服务的形式存在，日志将不再打印到命令窗口中</li>
<li><strong>bind XXX.XXX.XXX.XXX</strong> 绑定主机地址</li>
<li>**port XXXX ** 设定当前服务启动端口号</li>
<li><strong>databases XX</strong> 设置数据库数量</li>
<li><strong>dir “/自定义目录/redis/data“</strong> 设定当前服务文件保存位置，包含日志文件、持久化文件等</li>
<li><strong>logfile “XXXX.log“</strong> 设定日志文件名，便于查阅</li>
<li><strong>loglevel debug|verbose|notice|warning</strong>  设置服务器以指定日志记录级别</li>
<li><strong>include /path/XXXX.conf</strong> 导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件</li>
</ul>
<h1 id="六、持久化"><a href="#六、持久化" class="headerlink" title="六、持久化"></a>六、持久化</h1><h2 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1 简介"></a>6.1 简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>利用<strong>永久性</strong>存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p><strong>防止</strong>数据的意外<strong>丢失</strong>，确保数据<strong>安全性</strong></p>
<h3 id="持久化过程保存什么"><a href="#持久化过程保存什么" class="headerlink" title="持久化过程保存什么"></a>持久化过程保存什么</h3><ul>
<li>将当前<strong>数据状态</strong>进行保存，<strong>快照</strong>形式，存储数据结果，存储格式简单，关注点在<strong>数据</strong></li>
<li>将数据的<strong>操作过程</strong>进行保存，<strong>日志</strong>形式，存储操作过程，存储格式复杂，关注点在数据的操作<strong>过程</strong></li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.1.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="6-2-RDB"><a href="#6-2-RDB" class="headerlink" title="6.2 RDB"></a>6.2 RDB</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>RDB全称<strong>redis database</strong>，在指定的时间间隔内将内存中的数据集快照写入磁盘，（即Snapshot快照），它恢复时直接将快照文件直接读到内存里</p>
<h3 id="RDB启动方式——手动save"><a href="#RDB启动方式——手动save" class="headerlink" title="RDB启动方式——手动save"></a>RDB启动方式——手动save</h3><ul>
<li><p>命令</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">save</span><br></code></pre></td></tr></table></figure></li>
<li><p>作用</p>
<p>手动执行一次保存操作</p>
</li>
</ul>
<blockquote>
<p>save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用。</p>
</blockquote>
<h4 id="RDB配置相关命令"><a href="#RDB配置相关命令" class="headerlink" title="RDB配置相关命令"></a>RDB配置相关命令</h4><ul>
<li>dbfilename dump.rdb<ul>
<li>说明：设置本地数据库文件名，默认值为 dump.rdb</li>
<li>经验：通常设置为<strong>dump-端口号.rdb</strong></li>
</ul>
</li>
<li>dir<ul>
<li>说明：设置存储.rdb文件的路径</li>
<li>经验：通常设置成存储空间较大的目录中，目录名称data</li>
</ul>
</li>
<li>rdbcompression yes<ul>
<li>说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩</li>
<li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</li>
</ul>
</li>
<li>rdbchecksum yes<ul>
<li>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行</li>
<li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</li>
</ul>
</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="RDB启动方式——bgsave"><a href="#RDB启动方式——bgsave" class="headerlink" title="RDB启动方式——bgsave"></a>RDB启动方式——bgsave</h3><ul>
<li><p>命令</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bgsave</span><br></code></pre></td></tr></table></figure></li>
<li><p>作用</p>
<p>手动启动后台保存操作，但<strong>不是立即执行</strong></p>
</li>
</ul>
<h4 id="RDB配置相关命令-1"><a href="#RDB配置相关命令-1" class="headerlink" title="RDB配置相关命令"></a>RDB配置相关命令</h4><ul>
<li>stop-writes-on-bgsave-error yes<ul>
<li>说明：后台存储过程中如果出现错误现象，是否停止保存操作</li>
<li>经验：通常默认为<strong>开启</strong>状态</li>
</ul>
</li>
</ul>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.3.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="RDB启动方式——自动save"><a href="#RDB启动方式——自动save" class="headerlink" title="RDB启动方式——自动save"></a>RDB启动方式——自动save</h3><h4 id="RDB配置相关命令-2"><a href="#RDB配置相关命令-2" class="headerlink" title="RDB配置相关命令"></a>RDB配置相关命令</h4><ul>
<li><p>配置</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">save</span> <span class="hljs-built_in">second</span> changes<br></code></pre></td></tr></table></figure></li>
<li><p>作用</p>
<p>满足<strong>限定时间</strong>范围内key的变化数量达到<strong>指定数量</strong>即进行持久化</p>
</li>
<li><p>参数</p>
<ul>
<li>second：监控时间范围</li>
<li>changes：监控key的变化量</li>
</ul>
</li>
<li><p>配置位置</p>
<p>在<strong>conf文件</strong>中进行配置</p>
</li>
</ul>
<h4 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.4.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="RDB启动方式对比"><a href="#RDB启动方式对比" class="headerlink" title="RDB启动方式对比"></a>RDB启动方式对比</h3><table>
<thead>
<tr>
<th>方式</th>
<th>手动save</th>
<th>bgsave</th>
<th>自动save</th>
</tr>
</thead>
<tbody><tr>
<td>读写</td>
<td>同步</td>
<td>异步</td>
<td>本质上是bgsave</td>
</tr>
<tr>
<td>阻塞客户端指令</td>
<td>是</td>
<td>否</td>
<td>本质上是bgsave</td>
</tr>
<tr>
<td>额外内存消耗</td>
<td>否</td>
<td>是</td>
<td>本质上是bgsave</td>
</tr>
<tr>
<td>启动新进程</td>
<td>否</td>
<td>是</td>
<td>本质上是bgsave</td>
</tr>
</tbody></table>
<h3 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h3><ul>
<li>优点<ul>
<li>RDB是一个紧凑压缩的二进制文件，<strong>存储效率较高</strong></li>
<li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于<strong>数据备份，全量复制</strong>等场景</li>
<li>RDB恢复数据的<strong>速度</strong>要比AOF<strong>快</strong>很多</li>
<li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，<strong>用于灾难恢复</strong></li>
</ul>
</li>
<li>缺点<ul>
<li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li>
<li>bgsave指令每次运行要执行fork操作<strong>创建子进程</strong>，要<strong>牺牲</strong>掉一些<strong>性能</strong></li>
<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式<strong>无法兼容</strong>现象</li>
</ul>
</li>
</ul>
<h2 id="6-3-AOF"><a href="#6-3-AOF" class="headerlink" title="6.3 AOF"></a>6.3 AOF</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>AOF全称<strong>Append Only File</strong>，以redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构造数据。即，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<ul>
<li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的<strong>主流</strong>方式</li>
</ul>
<h3 id="AOF写数据过程"><a href="#AOF写数据过程" class="headerlink" title="AOF写数据过程"></a>AOF写数据过程</h3><p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.5.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="AOF写数据三种策略-appendfsync"><a href="#AOF写数据三种策略-appendfsync" class="headerlink" title="AOF写数据三种策略(appendfsync)"></a>AOF写数据三种策略(appendfsync)</h3><ul>
<li>always<ul>
<li>每次写入操作均同步到AOF文件中，数据零误差，<strong>性能较低</strong>,<strong>不建议使用</strong></li>
</ul>
</li>
<li>everysec<ul>
<li>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，<strong>性能较高</strong> ，<strong>建议使用</strong>，也是默认配置</li>
<li>在系统突然宕机的情况下丢失1秒内的数据</li>
</ul>
</li>
<li>no<ul>
<li>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong></li>
</ul>
</li>
</ul>
<h3 id="AOF功能开启"><a href="#AOF功能开启" class="headerlink" title="AOF功能开启"></a>AOF功能开启</h3><ul>
<li><p>配置</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure>

<ul>
<li> 作用</li>
<li>是否开启AOF持久化功能，<strong>默认为不开启状态</strong></li>
</ul>
</li>
<li><p>配置</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">appendfsync always|<span class="hljs-type">everysec</span>|<span class="hljs-type">no</span><br></code></pre></td></tr></table></figure>

<ul>
<li>作用<ul>
<li>AOF写数据策略</li>
</ul>
</li>
</ul>
</li>
<li><p>配置</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">appendfilename filename</span><br></code></pre></td></tr></table></figure>

<ul>
<li>作用<ul>
<li>AOF持久化文件名，默认文件名未appendonly.aof，建议配置为appendonly-端口号.aof</li>
</ul>
</li>
</ul>
</li>
<li><p>配置</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">dir</span><br></code></pre></td></tr></table></figure>

<ul>
<li>作用<ul>
<li>AOF持久化文件保存路径，与RDB持久化文件保持一致即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>降低磁盘占用量，提高磁盘利用率</li>
<li>提高持久化效率，降低持久化写时间，提高IO性能</li>
<li>降低数据恢复用时，提高数据恢复效率</li>
</ul>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul>
<li>进程内已超时的数据不再写入文件</li>
<li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<ul>
<li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</li>
</ul>
</li>
<li>对同一数据的多条写命令合并为一条命令<ul>
<li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c</li>
<li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li>
</ul>
</li>
</ul>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul>
<li><p>手动重写</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bgrewriteaof</span><br></code></pre></td></tr></table></figure></li>
<li><p>自动重写</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span>-aof-rewrite-min-size size <br><span class="hljs-keyword">auto</span>-aof-rewrite-percentage percentage<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="手动重写"><a href="#手动重写" class="headerlink" title="手动重写"></a>手动重写</h4><p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.6.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="自动重写"><a href="#自动重写" class="headerlink" title="自动重写"></a>自动重写</h4><p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/6.7.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="缓冲策略"><a href="#缓冲策略" class="headerlink" title="缓冲策略"></a>缓冲策略</h4><p>AOF缓冲区同步文件策略，由参数<strong>appendfsync</strong>控制</p>
<ul>
<li>write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用 来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依 赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。</li>
<li>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞直到写入硬盘完成后返回，保证了数据持久化。</li>
</ul>
<h2 id="6-4-RDB与AOF对比"><a href="#6-4-RDB与AOF对比" class="headerlink" title="6.4 RDB与AOF对比"></a>6.4 RDB与AOF对比</h2><table>
<thead>
<tr>
<th>持久化方式</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>占用存储空间</td>
<td>小（数据级：压缩）</td>
<td>大（指令级：重写）</td>
</tr>
<tr>
<td>存储速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>会丢失数据</td>
<td>依据策略决定</td>
</tr>
<tr>
<td>资源消耗</td>
<td>高/重量级</td>
<td>低/轻量级</td>
</tr>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<ul>
<li>对数据非常敏感，建议使用默认的AOF持久化方案<ul>
<li>AOF持久化策略使用<strong>everysecond</strong>，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li>
<li>注意：由于AOF文件<strong>存储体积较大</strong>，且<strong>恢复速度较慢</strong></li>
</ul>
</li>
<li>数据呈现阶段有效性，建议使用RDB持久化方案<ul>
<li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且<strong>恢复速度较快</strong>，阶段 点数据恢复通常采用RDB方案</li>
<li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低</li>
</ul>
</li>
<li>综合比对<ul>
<li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li>
<li>如不能承受数分钟以内的数据丢失，对业务数据非常<strong>敏感</strong>，选用<strong>AOF</strong></li>
<li>如能承受数分钟以内的数据丢失，且追求大数据集的<strong>恢复速度</strong>，选用<strong>RDB</strong></li>
<li><strong>灾难恢复选用RDB</strong></li>
<li>双保险策略，同时开启 RDB 和 AOF，<strong>重启后，Redis优先使用 AOF 来恢复数据</strong>，降低丢失数据</li>
</ul>
</li>
</ul>
<h1 id="七、事务"><a href="#七、事务" class="headerlink" title="七、事务"></a>七、事务</h1><h2 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h2><p>redis事务就是一个命令执行的队列，将一系列预定义命令<strong>包装成一个整体</strong>（一个队列）。当执行时，<strong>一次性按照添加顺序依次执行</strong>，中间不会被打断或者干扰</p>
<h2 id="7-2-事务的基本操作"><a href="#7-2-事务的基本操作" class="headerlink" title="7.2 事务的基本操作"></a>7.2 事务的基本操作</h2><ul>
<li><p>开启事务</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">multi</span><br></code></pre></td></tr></table></figure>

<ul>
<li>作用<ul>
<li>作设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li>
</ul>
</li>
</ul>
</li>
<li><p>取消事务</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">discard</span><br></code></pre></td></tr></table></figure>

<ul>
<li>作用<ul>
<li>终止当前事务的定义，发生在multi之后，exec之前</li>
</ul>
</li>
</ul>
</li>
<li><p>执行事务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span><br></code></pre></td></tr></table></figure>

<ul>
<li>作用<ul>
<li>设定事务的结束位置，同时执行事务。<strong>与multi成对出现</strong>，成对使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</p>
</blockquote>
<h2 id="7-3-工作流程"><a href="#7-3-工作流程" class="headerlink" title="7.3 工作流程"></a>7.3 工作流程</h2><p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/7.1.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="7-4-注意事项"><a href="#7-4-注意事项" class="headerlink" title="7.4 注意事项"></a>7.4 注意事项</h2><p><strong>定义事务的过程中，出现错误</strong></p>
<ul>
<li><p>语法错误，指命令书写格式有误 例如执行了一条不存在的指令</p>
<ul>
<li>处理结果：如果定义的事务中所包含的命令存在语法错误，整体事务中<strong>所有命令均不会执行</strong>。包括那些语法正确的命令</li>
</ul>
</li>
<li><p>运行错误，指命令<strong>格式正确</strong>，但是<strong>无法正确的执行</strong>。例如对list进行incr操作</p>
<ul>
<li>处理结果：<strong>能够正确运行的命令会执行</strong>，运行错误的命令不会被执行</li>
</ul>
</li>
</ul>
<blockquote>
<p>已经执行完毕的命令对应的数据<strong>不会自动回滚</strong>，需要程序员自己在代码中实现回滚。</p>
</blockquote>
<h2 id="7-5、基于特定条件的事务执行"><a href="#7-5、基于特定条件的事务执行" class="headerlink" title="7.5、基于特定条件的事务执行"></a>7.5、基于特定条件的事务执行</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">watch</span> key<span class="hljs-number">1</span>, key<span class="hljs-number">2</span>....<br></code></pre></td></tr></table></figure></li>
<li><p>取消对<strong>所有</strong>key的监视</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">unwatch</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul>
<li><p>使用 setnx 设置一个公共锁</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>上锁<br>setnx lock-key value<br><span class="hljs-regexp">//</span>释放锁<br>del lock-key<br></code></pre></td></tr></table></figure>

<ul>
<li>利用setnx命令的返回值特征，有值（被上锁了）则返回设置失败，无值（没被上锁）则返回设置成功</li>
<li>操作完毕通过del操作释放锁</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>：上述解决方案是一种<strong>设计概念</strong>，依赖规范保障，具有风险性</p>
<h4 id="分布式锁加强"><a href="#分布式锁加强" class="headerlink" title="分布式锁加强"></a>分布式锁加强</h4><ul>
<li><p>使用 expire 为锁key添加<strong>时间限定</strong>，到时不释放，放弃锁</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">expire <span class="hljs-keyword">lock</span>-key seconds<br>pexpire <span class="hljs-keyword">lock</span>-key milliseconds<br></code></pre></td></tr></table></figure></li>
<li><p>由于操作通常都是微秒或毫秒级，因此该锁定时间<strong>不宜设置过大</strong>。具体时间需要业务测试后确认。</p>
<ul>
<li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。</li>
<li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</li>
<li>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%</li>
<li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li>
</ul>
</li>
</ul>
<h1 id="八、删除策略"><a href="#八、删除策略" class="headerlink" title="八、删除策略"></a>八、删除策略</h1><h2 id="8-1-数据删除策略"><a href="#8-1-数据删除策略" class="headerlink" title="8.1 数据删除策略"></a>8.1 数据删除策略</h2><ul>
<li>定时删除</li>
<li>惰性删除</li>
<li>定期删除</li>
</ul>
<h3 id="时效性数据的存储结构"><a href="#时效性数据的存储结构" class="headerlink" title="时效性数据的存储结构"></a>时效性数据的存储结构</h3><ul>
<li>Redis中的数据，在expire中以哈希的方式保存在其中。其value是数据在内存中的地址，filed是对应的生命周期</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/8.1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="数据删除策略的目标"><a href="#数据删除策略的目标" class="headerlink" title="数据删除策略的目标"></a>数据删除策略的目标</h3><p>在内存占用与CPU占用之间寻找一种<strong>平衡</strong>，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露</p>
<h2 id="8-2-三种删除策略"><a href="#8-2-三种删除策略" class="headerlink" title="8.2 三种删除策略"></a>8.2 三种删除策略</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><ul>
<li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务<strong>立即执行</strong>对键的删除操作</li>
<li>优点：<strong>节约内存</strong>，到时就删除，快速释放掉不必要的内存占用</li>
<li>缺点：<strong>CPU压力很大</strong>，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li>
<li>总结：用处理器性能换取存储空间 （<strong>拿时间换空间</strong>）</li>
</ul>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><ul>
<li>数据到达过期时间，不做处理。等下次访问该数据时<ul>
<li>如果未过期，返回数据</li>
<li>发现已过期，删除，返回不存在</li>
</ul>
</li>
<li>优点：<strong>节约CPU性能</strong>，发现必须删除的时候才删除</li>
<li>缺点：<strong>内存压力很大</strong>，出现长期占用内存的数据</li>
<li>总结：用存储空间换取处理器性能 （拿空间换时间）</li>
</ul>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/8.2.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>周期性轮询redis库中的时效性数据，采用<strong>随机抽取的策略</strong>，利用过期数据占比的方式控制删除频度</li>
<li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li>
<li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li>
<li>总结：周期性抽查存储空间 （随机抽查，重点抽查）</li>
</ul>
<h2 id="8-3-删除策略对比"><a href="#8-3-删除策略对比" class="headerlink" title="8.3 删除策略对比"></a>8.3 删除策略对比</h2><table>
<thead>
<tr>
<th>删除方式</th>
<th>内存占用</th>
<th>CPU占用</th>
<th>本质</th>
</tr>
</thead>
<tbody><tr>
<td>定时删除</td>
<td>节约内存，无占用</td>
<td>不分时段占用CPU资源，频度高</td>
<td>拿时间换空间</td>
</tr>
<tr>
<td>惰性删除</td>
<td>内存占用严重</td>
<td>延时执行，CPU利用率高</td>
<td>拿空间换时间</td>
</tr>
<tr>
<td>定期删除</td>
<td>内存定期随机清理</td>
<td>每秒花费固定的CPU资源维护内存</td>
<td>随机抽查，重点抽查</td>
</tr>
</tbody></table>
<h2 id="8-4-逐出算法"><a href="#8-4-逐出算法" class="headerlink" title="8.4 逐出算法"></a>8.4 逐出算法</h2><ul>
<li>Redis使用内存存储数据，在执行每一个命令前，会调用<strong>freeMemoryIfNeeded()<strong>检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为</strong>逐出算法</strong></li>
<li><strong>注意</strong>：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息（OOM）。</li>
</ul>
<h3 id="影响数据逐出的相关配置"><a href="#影响数据逐出的相关配置" class="headerlink" title="影响数据逐出的相关配置"></a>影响数据逐出的相关配置</h3><ul>
<li><p>最大可使用内存</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory</span><br></code></pre></td></tr></table></figure>

<p>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</p>
</li>
<li><p>每次选取待删除数据的个数</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory-samples</span><br></code></pre></td></tr></table></figure>

<p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p>
</li>
<li><p>删除策略</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">maxmemory-<span class="hljs-keyword">policy</span><br></code></pre></td></tr></table></figure>

<p>达到最大内存后的，对被挑选出来的数据进行删除的策略</p>
</li>
<li><p>检测易失数据（可能会过期的数据集server.db[i].expires ）<br>① volatile-lru：挑选最近最少使用的数据淘汰<br>② volatile-lfu：挑选最近使用次数最少的数据淘汰<br>③ volatile-ttl：挑选将要过期的数据淘汰<br>④ volatile-random：任意选择数据淘汰</p>
</li>
<li><p>检测全库数据（所有数据集server.db[i].dict ）<br>⑤ allkeys-lru：挑选最近最少使用的数据淘汰<br>⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰<br>⑦ allkeys-random：任意选择数据淘汰</p>
</li>
<li><p>放弃数据驱逐<br>⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</p>
</li>
</ul>
<blockquote>
<p><strong>LRU</strong>：最长时间没被使用的数据</p>
<p><strong>LFU</strong>：一段时间内使用次数最少的数据</p>
</blockquote>
<h3 id="数据逐出策略配置依据"><a href="#数据逐出策略配置依据" class="headerlink" title="数据逐出策略配置依据"></a>数据逐出策略配置依据</h3><ul>
<li>使用<strong>INFO命令</strong>输出监控信息，查询缓存 <strong>hit 和 miss</strong> 的次数，根据业务需求调优Redis配置</li>
</ul>
<h1 id="九、高级数据类型"><a href="#九、高级数据类型" class="headerlink" title="九、高级数据类型"></a>九、高级数据类型</h1><h2 id="9-1-Bitmaps"><a href="#9-1-Bitmaps" class="headerlink" title="9.1 Bitmaps"></a>9.1 Bitmaps</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ul>
<li><p>获取指定key对应偏移量上的bit值</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">getbit key <span class="hljs-built_in">offset</span><br></code></pre></td></tr></table></figure></li>
<li><p>设置指定key对应偏移量上的bit值，value只能是1或0</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">setbit key <span class="hljs-built_in">offset</span> value<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="扩展操作-2"><a href="#扩展操作-2" class="headerlink" title="扩展操作"></a>扩展操作</h3><ul>
<li><p>对指定key按位进行交、并、非、异或操作，并将结果<strong>保存到destKey</strong>中</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bitop</span> op destKey key<span class="hljs-number">1</span><span class="hljs-meta"> [key2...]</span><br></code></pre></td></tr></table></figure>

<ul>
<li>and：交</li>
<li>or：并</li>
<li>not：非</li>
<li>xor：异或</li>
</ul>
</li>
<li><p>统计指定key中1的数量</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">bitcount<span class="hljs-built_in"> key</span> [<span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>]<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-2-HyperLogLog"><a href="#9-2-HyperLogLog" class="headerlink" title="9.2 HyperLogLog"></a>9.2 HyperLogLog</h2><h3 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h3><ul>
<li>基数是数据集<strong>去重后元素个数</strong></li>
<li>HyperLogLog 是用来做基数统计的，运用了LogLog的算法</li>
</ul>
<blockquote>
<p>{1,3,5,7,5,1,5,9}    基数集：{1,3,5,7,9}    基数：5</p>
<p>{1,1,1,2,2,1,1,1}    基数集：{1,2}    基数：2</p>
</blockquote>
<h3 id="基本操作-7"><a href="#基本操作-7" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li><p>添加数据</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pfadd</span> key element<span class="hljs-number">1</span>, element<span class="hljs-number">2</span>...Copy<br></code></pre></td></tr></table></figure></li>
<li><p>统计数据</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pfcount</span> key<span class="hljs-number">1</span> key<span class="hljs-number">2</span>....Copy<br></code></pre></td></tr></table></figure></li>
<li><p>合并数据</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pfmerge</span> destkey sourcekey<span class="hljs-meta"> [sourcekey...]</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>HyperLogLog用于进行基数统计，<strong>不是集合，不保存数据</strong>，只记录数量而不是具体数据</li>
<li>核心是基数估算算法，最终数值<strong>存在一定误差</strong></li>
<li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li>
<li><strong>耗空间极小</strong>，每个hyperloglog key占用了12K的内存用于标记基数</li>
<li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存<strong>逐渐增大</strong></li>
<li>Pfmerge命令<strong>合并后占用</strong>的存储空间为<strong>12K</strong>，无论合并之前数据量多少</li>
</ul>
<h2 id="9-3-GEO"><a href="#9-3-GEO" class="headerlink" title="9.3 GEO"></a>9.3 GEO</h2><h4 id="基本操作-8"><a href="#基本操作-8" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><p>添加坐标点</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">geoadd key longitude latitude member <span class="hljs-comment">[longitude latitude member ...]</span> <br>georadius key longitude latitude radius m|km|ft|mi <span class="hljs-comment">[withcoord]</span> <span class="hljs-comment">[withdist]</span> <span class="hljs-comment">[withhash]</span> <span class="hljs-comment">[count count]</span>Copy<br></code></pre></td></tr></table></figure></li>
<li><p>获取坐标点</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">geopos <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...] <br>georadiusbymember <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> <span class="hljs-built_in">radius</span> m|km|ft|mi [withcoord] [withdist] [withhash] [count count]Copy<br></code></pre></td></tr></table></figure></li>
<li><p>计算坐标点距离</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">geodist <span class="hljs-built_in">key</span> member1 member2 [unit] <br>geohash <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...]<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="十、主从复制"><a href="#十、主从复制" class="headerlink" title="十、主从复制"></a>十、主从复制</h1><h2 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h2><h3 id="多台服务器连接方案"><a href="#多台服务器连接方案" class="headerlink" title="多台服务器连接方案"></a>多台服务器连接方案</h3><ul>
<li>提供数据方：master<ul>
<li>主服务器，主节点，主库</li>
<li>主客户端</li>
</ul>
</li>
<li>接收数据的方：slave<ul>
<li>从服务器，从节点，从库</li>
<li>从客户端</li>
</ul>
</li>
<li>需要解决的问题<ul>
<li><strong>数据同步</strong></li>
</ul>
</li>
<li>核心工作<ul>
<li>master的数据<strong>复制</strong>到slave中</li>
</ul>
</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主从复制即将master中的数据即时、有效的<strong>复制</strong>到slave中</p>
<p>特征：一个master可以拥有多个slave，一个slave只对应一个master</p>
<p>职责：</p>
<ul>
<li>master:<ul>
<li>写数据</li>
<li>执行写操作时，将出现变化的数据自动<strong>同步</strong>到slave</li>
<li>读数据（可忽略）</li>
</ul>
</li>
<li>slave:<ul>
<li>读数据</li>
<li>写数据（<strong>禁止</strong>）</li>
</ul>
</li>
</ul>
<h2 id="10-2-作用"><a href="#10-2-作用" class="headerlink" title="10.2 作用"></a>10.2 作用</h2><ul>
<li>读写分离：master写、slave读，提高服务器的读写负载能力</li>
<li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li>
<li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li>
<li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li>
<li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li>
</ul>
<h2 id="10-3-工作流程"><a href="#10-3-工作流程" class="headerlink" title="10.3 工作流程"></a>10.3 工作流程</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><ul>
<li>主从复制过程大体可以分为3个阶段<ul>
<li>建立连接阶段（即准备阶段）</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ul>
</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="阶段一：建立连接"><a href="#阶段一：建立连接" class="headerlink" title="阶段一：建立连接"></a>阶段一：建立连接</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号</p>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.3.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul>
<li><p>方式一：客户端发送命令</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>方式二：启动服务器参数</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">redis-server -slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>方式三：服务器配置 （常用）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>断开连接（<strong>客户端</strong>发送命令）</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">slaveof</span> <span class="hljs-literal">no</span> one<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注： slave断开连接后，<strong>不会删除已有数据</strong>，只是不再接受master发送的数据</p>
</blockquote>
</li>
</ul>
<p><strong>授权访问</strong></p>
<ul>
<li><p>master客户端发送命令设置密码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">requirepass <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>master配置文件设置密码</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">config <span class="hljs-builtin-name">set</span> requirepass &lt;password&gt; <span class="hljs-built_in"></span><br><span class="hljs-built_in">config </span><span class="hljs-builtin-name">get</span> requirepass<br></code></pre></td></tr></table></figure></li>
<li><p>slave客户端发送命令设置密码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">auth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>slave配置文件设置密码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">masterauth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>slave启动服务器设置密码</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redis-<span class="hljs-keyword">server</span> –a &lt;<span class="hljs-keyword">password</span>&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="阶段二：数据同步阶段"><a href="#阶段二：数据同步阶段" class="headerlink" title="阶段二：数据同步阶段"></a>阶段二：数据同步阶段</h3><ul>
<li>在slave初次连接master后，复制master中的所有数据到slave</li>
<li>将slave的数据库状态更新成master当前的数据库状态</li>
</ul>
<h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.4.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>全量复制<ul>
<li>将master执行bgsave之前，master中所有的数据同步到slave中</li>
</ul>
</li>
<li>部分复制（增量复制）<ul>
<li>将master执行bgsave操作中，新加入的数据（复制缓冲区中的数据）传给slave，slave通过bgrewriteaof指令来恢复数据</li>
</ul>
</li>
</ul>
<h4 id="master注意事项"><a href="#master注意事项" class="headerlink" title="master注意事项"></a>master注意事项</h4><ol>
<li>如果master数据量巨大，数据同步阶段应<strong>避开流量高峰期</strong>，<strong>避免</strong>造成master<strong>阻塞</strong>，影响业务正常执行</li>
<li>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入<strong>死循环</strong>状态。</li>
</ol>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">repl</span>-backlog-size <span class="hljs-number">1</span>mb<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区</li>
</ol>
<h4 id="slave注意事项"><a href="#slave注意事项" class="headerlink" title="slave注意事项"></a>slave注意事项</h4><ol>
<li>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，<strong>建议关闭</strong>此期间的对外服务</li>
</ol>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">slave-serve-stale-data <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure>

<ol>
<li>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</li>
<li>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</li>
<li>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，<strong>数据一致性变差，应谨慎选择</strong></li>
</ol>
<h3 id="阶段三：命令传播阶段"><a href="#阶段三：命令传播阶段" class="headerlink" title="阶段三：命令传播阶段"></a>阶段三：命令传播阶段</h3><ul>
<li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，<strong>同步</strong>的动作称为<strong>命令传播</strong></li>
<li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</li>
</ul>
<h4 id="命令传播阶段的部分复制"><a href="#命令传播阶段的部分复制" class="headerlink" title="命令传播阶段的部分复制"></a>命令传播阶段的部分复制</h4><ul>
<li><p>命令传播阶段出现了断网现象</p>
<ul>
<li>网络闪断闪连，忽略</li>
<li>短时间网络中断，部分复制</li>
<li>长时间网络中断，全量复制</li>
</ul>
</li>
<li><p>部分复制的<strong>三个核心要素</strong></p>
<ul>
<li>服务器的<strong>运行 id</strong>（run id）</li>
<li>主服务器的复制积压<strong>缓冲区</strong></li>
<li>主从服务器的复制<strong>偏移量</strong></li>
</ul>
</li>
</ul>
<h5 id="服务器运行ID（runid）"><a href="#服务器运行ID（runid）" class="headerlink" title="服务器运行ID（runid）"></a>服务器运行ID（runid）</h5><ul>
<li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</li>
<li>组成：运行id由40位字符组成，是一个随机的十六进制字符 例如fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</li>
<li>作用：运行id被用于在服务器间进行传输，识别身份<ul>
<li>如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</li>
</ul>
</li>
<li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过<strong>info Server</strong>命令，可以查看节点的runid</li>
</ul>
<h5 id="复制缓冲区"><a href="#复制缓冲区" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h5><ul>
<li>概念：复制缓冲区，又名复制积压缓冲区，是一个<strong>先进先出（FIFO）的队列</strong>，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</li>
<li>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区</li>
<li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</li>
<li>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</li>
</ul>
<h6 id="缓冲区工作原理"><a href="#缓冲区工作原理" class="headerlink" title="缓冲区工作原理"></a>缓冲区工作原理</h6><ul>
<li>组成<ul>
<li>偏移量</li>
<li>字节值</li>
</ul>
</li>
<li>工作原理<ul>
<li>通过offset区分不同的slave当前数据传播的差异</li>
<li>master记录<strong>已发送</strong>的信息对应的offset</li>
<li>slave记录<strong>已接收</strong>的信息对应的offset</li>
</ul>
</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.5.png" srcset="/img/loading.gif" lazyload></p>
<h6 id="主从服务器复制偏移量（offset）"><a href="#主从服务器复制偏移量（offset）" class="headerlink" title="主从服务器复制偏移量（offset）"></a>主从服务器复制偏移量（offset）</h6><ul>
<li>概念：一个数字，描述复制缓冲区中的指令字节位置</li>
<li>分类：<ul>
<li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li>
<li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li>
</ul>
</li>
<li>数据来源： master端：发送一次记录一次 slave端：接收一次记录一次</li>
<li>作用：<strong>同步信息</strong>，比对master与slave的差异，当slave断线后，恢复数据使用</li>
</ul>
<h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.6.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/10.7.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="10-4-心跳机制"><a href="#10-4-心跳机制" class="headerlink" title="10.4 心跳机制"></a>10.4 心跳机制</h2><ul>
<li>进入<strong>命令传播阶段候</strong>，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</li>
<li>master心跳：<ul>
<li>指令：PING</li>
<li>周期：由repl-ping-slave-period决定，默认10秒</li>
<li>作用：判断slave是否在线</li>
<li>查询：INFO replication ，获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li>
</ul>
</li>
<li>slave心跳任务<ul>
<li>指令：REPLCONF ACK {offset}</li>
<li>周期：1秒</li>
<li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li>
<li>作用2：判断master是否在线</li>
</ul>
</li>
</ul>
<h3 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">2</span> <br><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>

<ul>
<li>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</li>
</ul>
</li>
<li><p>slave数量由slave发送<strong>REPLCONF ACK</strong>命令做确认</p>
</li>
<li><p>slave延迟由slave发送<strong>REPLCONF ACK</strong>命令做确认</p>
</li>
</ul>
<h1 id="十一、哨兵"><a href="#十一、哨兵" class="headerlink" title="十一、哨兵"></a>十一、哨兵</h1><h2 id="11-1-定义"><a href="#11-1-定义" class="headerlink" title="11.1 定义"></a>11.1 定义</h2><p>哨兵(sentinel) 是一个<strong>分布式系统</strong>，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过<strong>投票机制</strong>选择新的master并将所有slave连接到新的master。</p>
<h2 id="11-2-作用"><a href="#11-2-作用" class="headerlink" title="11.2 作用"></a>11.2 作用</h2><ul>
<li>监控<ul>
<li>不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测</li>
</ul>
</li>
<li>通知（提醒）<ul>
<li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</li>
</ul>
</li>
<li>自动故障转移<ul>
<li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li>
</ul>
</li>
</ul>
<blockquote>
<p>哨兵也是一台<strong>redis服务器</strong>，只是不提供数据服务 通常哨兵配置数量为<strong>单数</strong></p>
</blockquote>
<h2 id="11-3-配置哨兵"><a href="#11-3-配置哨兵" class="headerlink" title="11.3 配置哨兵"></a>11.3 配置哨兵</h2><ul>
<li><p>配置文件</p>
<ul>
<li>参看sentinel.conf</li>
</ul>
</li>
<li><p>启动哨兵</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">redis-sentinel sentinel端口号 <span class="hljs-string">.conf</span><br></code></pre></td></tr></table></figure></li>
<li><p>配置详解</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>配置项</th>
<th>范例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sentinel auth-pass&lt;服务器名称&gt; <password></password></td>
<td>sentinel auth-pass mymaster gotcha</td>
<td>连接服务器口令</td>
</tr>
<tr>
<td>sentinel down-after-milliseconds &lt;自定义服务名称&gt;&lt;主机地址&gt;&lt;端口&gt;&lt;主从服务器总量&gt;</td>
<td>sentinel monitor mymaster 192.168.194.131 6381 1</td>
<td>设置哨兵监听的主服务器信息，最后的参数决定了最终参与选举的服务器数量（-1）</td>
</tr>
<tr>
<td>sentinel down-after-milliseconds&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td>
<td>sentinel down-after-milliseconds mymaster 3000</td>
<td>指定哨兵在监控Redis服务时，判定服务器挂掉的时间周期，默认30秒（30000），也是主从切换的启动条件之一</td>
</tr>
<tr>
<td>sentinel parallel-syncs&lt;服务名称&gt;&lt;服务器数（整数）&gt;</td>
<td>sentinel parallel-syncs mymaster 1</td>
<td>指定同时进行主从的slave数量，数值越大，要求网络资源越高，要求约小，同步时间约长</td>
</tr>
<tr>
<td>sentinel failover-timeout&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td>
<td>sentinel failover-timeout mymaster 9000</td>
<td>指定出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认3分钟</td>
</tr>
<tr>
<td>sentinel notification-script&lt;服务名称&gt;&lt;脚本路径&gt;</td>
<td></td>
<td>服务器无法正常联通时，设定的执行脚本，通常调试使用。</td>
</tr>
</tbody></table>
<h2 id="11-4-工作原理"><a href="#11-4-工作原理" class="headerlink" title="11.4 工作原理"></a>11.4 工作原理</h2><h3 id="监控阶段"><a href="#监控阶段" class="headerlink" title="监控阶段"></a>监控阶段</h3><ul>
<li>用于同步各个节点的状态信息<ul>
<li>获取各个sentinel的状态（是否在线）</li>
</ul>
</li>
<li>获取master的状态<ul>
<li>master属性<ul>
<li>runid</li>
<li>role：master</li>
<li>各个slave的详细信息</li>
</ul>
</li>
</ul>
</li>
<li>获取所有slave的状态（根据master中的slave信息）<ul>
<li>slave属性<ul>
<li>runid</li>
<li>role：slave</li>
<li>master_host、master_port</li>
<li>offset</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/11.1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="通知阶段"><a href="#通知阶段" class="headerlink" title="通知阶段"></a>通知阶段</h3><ul>
<li>各个哨兵将得到的信息相互同步（信息对称）</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/11.2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><h4 id="确认master下线"><a href="#确认master下线" class="headerlink" title="确认master下线"></a>确认master下线</h4><ul>
<li>当某个哨兵发现主服务器挂掉了，会将master中的SentinelRedistance中的master改为<strong>SRI_S_DOWN</strong>（主观下线），并通知其他哨兵，告诉他们发现master挂掉了。</li>
<li>其他哨兵在接收到该哨兵发送的信息后，也会尝试去连接master，如果超过半数（配置文件中设置的）确认master挂掉后，会将master中的SentinelRedistance中的master改为<strong>SRI_O_DOWN</strong>（客观下线）</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/11.3.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="推选哨兵进行处理"><a href="#推选哨兵进行处理" class="headerlink" title="推选哨兵进行处理"></a>推选哨兵进行处理</h4><ul>
<li>在确认master挂掉以后，会推选出一个哨兵来进行故障转移工作（由该哨兵来指定哪个slave来做新的master）。</li>
<li>筛选方式是哨兵互相发送消息，并且参与投票，票多者当选。</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/11.4.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="具体处理"><a href="#具体处理" class="headerlink" title="具体处理"></a>具体处理</h4><ul>
<li><p>由推选出来的哨兵对当前的slave进行筛选，筛选条件有：</p>
<ul>
<li><p>在线的</p>
</li>
<li><p>响应快的</p>
</li>
<li><p>与原master断开时间短的</p>
</li>
<li><p>优先原则</p>
<ul>
<li>优先级</li>
<li>offset</li>
<li>runid</li>
</ul>
</li>
</ul>
</li>
<li><p>发送指令（ sentinel ）</p>
<ul>
<li>向新的master发送<strong>slaveof no one</strong>(断开与原master的连接)</li>
<li>向其他slave发送slaveof 新masterIP端口（让其他slave与新的master相连）</li>
</ul>
</li>
<li><p>原master故障恢复后，作为slave连接</p>
</li>
</ul>
<h1 id="十二、集群"><a href="#十二、集群" class="headerlink" title="十二、集群"></a>十二、集群</h1><h2 id="12-1、定义"><a href="#12-1、定义" class="headerlink" title="12.1、定义"></a>12.1、定义</h2><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><ul>
<li>集群（Cluster）就是使用网络将若干台计算机<strong>联通</strong>起来，并提供<strong>统一的管理方式</strong>，使其对外呈现单机的服务效果</li>
</ul>
<h3 id="集群作用"><a href="#集群作用" class="headerlink" title="集群作用"></a>集群作用</h3><ul>
<li>分散单台服务器的访问压力，实现<strong>负载均衡</strong></li>
<li>分散单台服务器的存储压力，实现<strong>可扩展性</strong></li>
<li><strong>降低</strong>单台服务器宕机带来的<strong>业务灾难</strong></li>
</ul>
<h2 id="12-2-Redis集群结构设计"><a href="#12-2-Redis集群结构设计" class="headerlink" title="12.2 Redis集群结构设计"></a>12.2 Redis集群结构设计</h2><h3 id="数据存储设计"><a href="#数据存储设计" class="headerlink" title="数据存储设计"></a>数据存储设计</h3><ul>
<li>通过算法设计，计算出key应该保存的位置</li>
<li>将所有的存储空间计划切割成16384份（计算公式为<code>slot=CRC16(key)&amp;16383</code>），每台主机保存一部分 每份代表的是一个存储空间，不是一个key的保存空间</li>
<li>将key按照计算出的结果放到对应的存储空间</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/12.1.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>增强可扩展性 ——槽<ul>
<li>增加一台新设备时，每个设备让出一部分槽，分给新设备，保持槽总量不变</li>
<li>减少一台设备时，每个设备分配到移除设备的一部分槽，保持槽总量不变</li>
</ul>
</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/12.2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="集群内部通讯设计"><a href="#集群内部通讯设计" class="headerlink" title="集群内部通讯设计"></a>集群内部通讯设计</h3><ul>
<li>各个数据库互相连通，保存各个库中槽的编号数据</li>
<li>一次命中，直接返回</li>
<li>一次未命中，告知具体的位置，key再直接去找对应的库保存数据</li>
</ul>
<p><img src="/2020/08/10/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/12.3.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="12-3-配置"><a href="#12-3-配置" class="headerlink" title="12.3 配置"></a>12.3 配置</h2><h3 id="Cluster配置"><a href="#Cluster配置" class="headerlink" title="Cluster配置"></a>Cluster配置</h3><ul>
<li><p>添加节点</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">cluster-enabled <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure></li>
<li><p>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">cluster</span>-config-<span class="hljs-keyword">file</span> &lt;filename&gt;<br></code></pre></td></tr></table></figure></li>
<li><p>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">cluster-<span class="hljs-keyword">node</span><span class="hljs-title">-timeout</span> <span class="hljs-tag">&lt;milliseconds&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>master连接的slave最小数量</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cluster-migration-<span class="hljs-keyword">barrier </span>&lt;<span class="hljs-built_in">count</span>&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Cluster节点操作命令"><a href="#Cluster节点操作命令" class="headerlink" title="Cluster节点操作命令"></a>Cluster节点操作命令</h3><ul>
<li><p>查看集群节点信息</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cluster nodes</span><br></code></pre></td></tr></table></figure></li>
<li><p>进入一个从节点 redis，切换其主节点</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cluster replicate &lt;master-<span class="hljs-built_in">id</span>&gt;<br></code></pre></td></tr></table></figure></li>
<li><p>发现一个新节点，新增主节点</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">cluster</span> meet <span class="hljs-built_in">ip</span>:port<br></code></pre></td></tr></table></figure></li>
<li><p>忽略一个没有solt的节点</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cluster forget &lt;<span class="hljs-built_in">id</span>&gt;<br></code></pre></td></tr></table></figure></li>
<li><p>手动故障转移</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cluster failover</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="redis-trib命令"><a href="#redis-trib命令" class="headerlink" title="redis-trib命令"></a>redis-trib命令</h3><ul>
<li><p>添加节点</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">redis-trib.rb add-<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure></li>
<li><p>删除节点</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">redis-trib.rb del-<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure></li>
<li><p>重新分片</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">redis-trib<span class="hljs-selector-class">.rb</span> reshard<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="十三、企业级解决方案"><a href="#十三、企业级解决方案" class="headerlink" title="十三、企业级解决方案"></a>十三、企业级解决方案</h1><h2 id="13-1-缓存预热"><a href="#13-1-缓存预热" class="headerlink" title="13.1 缓存预热"></a>13.1 缓存预热</h2><h3 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h3><p>服务器启动后迅速宕机</p>
<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><ul>
<li>请求数量较高</li>
<li>主从之间数据吞吐量较大，数据同步操作频度较高</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>前置准备工作：<ul>
<li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li>
<li>利用LRU数据删除策略，构建数据留存队列 例如：storm与kafka配合</li>
</ul>
</li>
<li>准备工作：<ul>
<li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li>
<li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li>
<li>热点数据主从同时预热</li>
</ul>
</li>
<li>实施：<ul>
<li>使用脚本程序固定触发数据预热过程</li>
<li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。</p>
<h2 id="13-2-缓存雪崩"><a href="#13-2-缓存雪崩" class="headerlink" title="13.2 缓存雪崩"></a>13.2 缓存雪崩</h2><h3 id="问题现象-1"><a href="#问题现象-1" class="headerlink" title="问题现象"></a>问题现象</h3><h4 id="数据库服务器崩溃（1）"><a href="#数据库服务器崩溃（1）" class="headerlink" title="数据库服务器崩溃（1）"></a>数据库服务器崩溃（1）</h4><ol>
<li>系统平稳运行过程中，忽然数据库连接量激增</li>
<li>应用服务器无法及时处理请求</li>
<li>大量408，500错误页面出现</li>
<li>客户反复刷新页面获取数据</li>
<li>数据库崩溃</li>
<li>应用服务器崩溃</li>
<li>重启应用服务器无效</li>
<li>Redis服务器崩溃</li>
<li>Redis集群崩溃</li>
<li>重启数据库后再次被瞬间流量放倒</li>
</ol>
<h3 id="问题排查-1"><a href="#问题排查-1" class="headerlink" title="问题排查"></a>问题排查</h3><ol>
<li>在一个<strong>较短</strong>的时间内，缓存中较多的key<strong>集中过期</strong></li>
<li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li>
<li>数据库同时接收到大量的请求无法及时处理</li>
<li>Redis大量请求被积压，开始出现超时现象</li>
<li>数据库流量激增，数据库崩溃</li>
<li>重启后仍然面对缓存中无数据可用</li>
<li>Redis服务器资源被严重占用，Redis服务器崩溃</li>
<li>Redis集群呈现崩塌，集群瓦解</li>
<li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li>
<li>应用服务器，redis，数据库全部重启，效果不理想</li>
</ol>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>短时间范围内</li>
<li>大量key集中过期</li>
</ul>
<h3 id="解决方案（设计层面）"><a href="#解决方案（设计层面）" class="headerlink" title="解决方案（设计层面）"></a>解决方案（设计层面）</h3><ol>
<li>更多的页面静态化处理</li>
<li>构建<strong>多级缓存架构</strong> Nginx缓存+redis缓存+ehcache缓存</li>
<li>检测Mysql严重耗时业务进行优化 对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li>
<li>灾难预警机制 监控redis服务器性能指标<ul>
<li>CPU占用、CPU使用率</li>
<li>内存容量</li>
<li>查询平均响应时间</li>
<li>线程数</li>
</ul>
</li>
<li>限流、降级 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li>
</ol>
<h3 id="解决方案（操作层面）"><a href="#解决方案（操作层面）" class="headerlink" title="解决方案（操作层面）"></a>解决方案（操作层面）</h3><ol>
<li>LRU与LFU切换</li>
<li>数据有效期策略调整<ul>
<li>根据业务数据有效期进行<strong>分类错峰</strong>，A类90分钟，B类80分钟，C类70分钟</li>
<li>过期时间使用固定时间+随机值的形式，<strong>稀释</strong>集中到期的key的数量</li>
</ul>
</li>
<li><strong>超热</strong>数据使用永久key</li>
<li>定期维护（自动+人工） 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li>
<li>加锁 <strong>慎用</strong></li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>缓存雪崩就是<strong>瞬间过期数据量太大</strong>，导致对数据库服务器造成压力。如能够<strong>有效避免过期时间集中</strong>，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p>
<h2 id="13-3-缓存击穿"><a href="#13-3-缓存击穿" class="headerlink" title="13.3 缓存击穿"></a>13.3 缓存击穿</h2><h3 id="问题现象-2"><a href="#问题现象-2" class="headerlink" title="问题现象"></a>问题现象</h3><h4 id="数据库服务器崩溃（2）"><a href="#数据库服务器崩溃（2）" class="headerlink" title="数据库服务器崩溃（2）"></a>数据库服务器崩溃（2）</h4><ol>
<li>系统平稳运行过程中</li>
<li>数据库连接量<strong>瞬间激增</strong></li>
<li>Redis服务器<strong>无大量key过期</strong></li>
<li>Redis内存平稳，无波动</li>
<li>Redis服务器CPU正常</li>
<li><strong>数据库崩溃</strong></li>
</ol>
<h3 id="问题排查-2"><a href="#问题排查-2" class="headerlink" title="问题排查"></a>问题排查</h3><ol>
<li>Redis中<strong>某个key过期，该key访问量巨大</strong></li>
<li>多个数据请求从服务器直接压到Redis后，均未命中</li>
<li>Redis在短时间内发起了大量对数据库中同一数据的访问</li>
</ol>
<h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>单个key高热数据</li>
<li>key过期</li>
</ul>
<h3 id="解决方案（操作层面）-1"><a href="#解决方案（操作层面）-1" class="headerlink" title="解决方案（操作层面）"></a>解决方案（操作层面）</h3><ol>
<li><p>预先设定</p>
<p>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，<strong>加大</strong>此类信息key的<strong>过期时长</strong></p>
<p>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p>
</li>
<li><p>现场调整</p>
<ul>
<li>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li>
</ul>
</li>
<li><p>后台刷新数据</p>
<ul>
<li>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li>
</ul>
</li>
<li><p>二级缓存</p>
<ul>
<li>设置不同的失效时间，保障不会被同时淘汰就行</li>
</ul>
</li>
<li><p>加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，<strong>慎重！</strong></p>
</li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>缓存击穿就是<strong>单个高热数据过期的瞬间</strong>，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可</p>
<h2 id="13-4-缓存穿透"><a href="#13-4-缓存穿透" class="headerlink" title="13.4 缓存穿透"></a>13.4 缓存穿透</h2><h3 id="问题现象-3"><a href="#问题现象-3" class="headerlink" title="问题现象"></a>问题现象</h3><h4 id="数据库服务器崩溃（3）"><a href="#数据库服务器崩溃（3）" class="headerlink" title="数据库服务器崩溃（3）"></a>数据库服务器崩溃（3）</h4><ol>
<li>系统平稳运行过程中</li>
<li>应用服务器流量随时间增量较大</li>
<li>Redis服务器命中率随时间逐步降低</li>
<li>Redis内存平稳，内存无压力</li>
<li>Redis服务器CPU占用激增</li>
<li>数据库服务器压力激增</li>
<li>数据库崩溃</li>
</ol>
<h3 id="问题排查-3"><a href="#问题排查-3" class="headerlink" title="问题排查"></a>问题排查</h3><ul>
<li>Redis中大面积出现<strong>未命中</strong></li>
<li>出现<strong>非正常URL</strong>访问</li>
</ul>
<h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li>
<li>Redis获取到null数据未进行持久化，直接返回</li>
<li>下次此类数据到达重复上述过程</li>
<li>可能出现黑客攻击服务器</li>
</ul>
<h3 id="解决方案（操作层面）-2"><a href="#解决方案（操作层面）-2" class="headerlink" title="解决方案（操作层面）"></a>解决方案（操作层面）</h3><ol>
<li><p>缓存null 对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</p>
</li>
<li><p>白名单策略</p>
<ul>
<li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）</li>
<li>使用<strong>布隆过滤器</strong></li>
</ul>
</li>
<li><p>实施监控</p>
<p>  实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比</p>
<ul>
<li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</li>
<li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象 根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li>
</ul>
</li>
<li><p>key加密</p>
<p>  问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验 例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</p>
</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>缓存击穿<strong>访问了不存在的数据</strong>，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，应当及时报警。<br>无论是黑名单还是白名单，都是对整体系统的压力，问题解决后尽快移除。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Redis/">Redis</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Redis/">Redis</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/20/JVM/JVM%E5%AD%A6%E4%B9%A0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM学习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/06/10/Mysql/Mysql%E5%9F%BA%E7%A1%80/mysql%E5%9F%BA%E7%A1%80/">
                        <span class="hidden-mobile">MySQL基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?cd190160b5401a029cee361d013e32a1";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
