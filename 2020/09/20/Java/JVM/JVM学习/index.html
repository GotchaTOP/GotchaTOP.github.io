

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="懂一点点">
  <meta name="author" content="Gotcha">
  <meta name="keywords" content="">
  
  <title>JVM学习 - Gotcha的笔记总结</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"cd190160b5401a029cee361d013e32a1","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"U8yaiFQ2fUef4ujWTig83mSL-gzGzoHsz","app_key":"akCMytdeJqrMuKP84F4oblqz","server_url":"https://u8yaifq2.lc-cn-n1-shared.com"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Gotcha的笔记总结</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/background/01.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JVM学习">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-20 00:00" pubdate>
        2020年9月20日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      51.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      1519
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JVM学习</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年7月22日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ul>
<li>一次编写，到处运行</li>
<li>自动内存管理，垃圾回收机制</li>
<li>数组下标越界检查</li>
</ul>
<h3 id="1-3-比较"><a href="#1-3-比较" class="headerlink" title="1.3 比较"></a>1.3 比较</h3><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.0.1.png" srcset="/img/loading.gif" lazyload alt="2.0.1"></p>
<hr>
<h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.1.png" srcset="/img/loading.gif" lazyload alt="2.1"></p>
<ul>
<li>线程共享：方法区、堆</li>
<li>线程隔离：虚拟机栈、程序计数器、本地方法栈</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721113517327.png" srcset="/img/loading.gif" lazyload alt="image-20210721113517327"></p>
<h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><h4 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h4><p>Program Counter Register 程序计数器（寄存器）</p>
<ul>
<li>作用是，记住下一条jvm指令的执行地址</li>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>每条线程都有一个独立的程序计数器，此内存区域是唯一一个在《Java虚拟机规范》中<strong>没有规定任何OutOfMemoryError情况的区域</strong>（<strong>不存在内存溢出</strong>）<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>
<li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li>
</ul>
</li>
</ul>
<h3 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h3><h4 id="2-2-1-定义"><a href="#2-2-1-定义" class="headerlink" title="2.2.1 定义"></a>2.2.1 定义</h4><p>Java Virtual Machine Stacks （Java虚拟机栈），虚拟机栈描述的是Java方法执行的线程内存模型，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>、<strong>方法出口</strong>等信息。</p>
<ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721194930197.png" srcset="/img/loading.gif" lazyload alt="image-20210721194930197"></p>
<h4 id="2-2-2-特点"><a href="#2-2-2-特点" class="headerlink" title="2.2.2 特点"></a>2.2.2 特点</h4><ul>
<li>生命周期与线程相同</li>
<li>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</li>
<li>每个线程只能有一个<strong>活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li>
<li><strong>垃圾回收不涉及栈内存</strong>，因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
<li>方法内的局部变量是否线程安全？<ul>
<li>如果方法内局部变量没有逃离方法（return）的作用访问，它是线程安全的</li>
<li>如果是局部变量引用了对象，并逃离方法的作用范围，线程可能不安全</li>
</ul>
</li>
<li>栈内存的分配越大越好吗？<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
</ul>
</li>
</ul>
<h4 id="2-2-3-演示"><a href="#2-2-3-演示" class="headerlink" title="2.2.3 演示"></a>2.2.3 演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		method1();<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>		method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> c = a + b;<br>		<span class="hljs-keyword">return</span> c;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.1.2.png" srcset="/img/loading.gif" lazyload alt="2.1.2"></p>
<h4 id="2-2-4-栈内存溢出"><a href="#2-2-4-栈内存溢出" class="headerlink" title="2.2.4 栈内存溢出"></a>2.2.4 栈内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p>
<p>原因：</p>
<ul>
<li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li>
<li>每个栈帧<strong>所占用过大</strong></li>
</ul>
<h4 id="2-2-5-线程运行诊断"><a href="#2-2-5-线程运行诊断" class="headerlink" title="2.2.5 线程运行诊断"></a>2.2.5 线程运行诊断</h4><p>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程</p>
<ul>
<li>用<strong>top</strong>定位哪个进程对cpu的占用过高</li>
<li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong>，（用ps命令进一步定位是哪个线程引起的cpu占用过高）</li>
<li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li>
</ul>
<h4 id="2-2-6-栈帧的内部结构"><a href="#2-2-6-栈帧的内部结构" class="headerlink" title="2.2.6 栈帧的内部结构"></a>2.2.6 栈帧的内部结构</h4><p>每个栈帧中存储着：</p>
<ul>
<li><p>局部变量表（Local Variables）</p>
</li>
<li><p>操作数栈（operand Stack）（或表达式栈）</p>
</li>
<li><p>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</p>
</li>
<li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p>
</li>
<li><p>一些附加信息</p>
</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721195636046.png" srcset="/img/loading.gif" lazyload alt="image-20210721195636046"></p>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>局部变量表也被称之为局部变量数组或本地变量表</p>
<p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p>
<ul>
<li><p> 定义为一个数字<strong>数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。 </p>
</li>
<li><p> 由于局部变量表是建立在线程的栈上，是<strong>线程的私有数据</strong>，因此不存在数据安全问题 </p>
</li>
<li><p> 局部变量表所需的<strong>容量大小是在编译期确定</strong>下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。 </p>
</li>
<li><p> <strong>方法嵌套调用的次数由栈的大小决定。</strong>一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。 </p>
</li>
<li><p> <strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 </p>
</li>
</ul>
<p><strong>静态变量与局部变量的对比</strong></p>
<p><strong>类变量表有两次初始化的机会</strong>，第一次是在“<strong>准备阶段</strong>”，执行系统初始化，对类变量设置零值，另一次则是在“<strong>初始化</strong>”阶段，赋予程序员在代码中定义的初始值。</p>
<p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着<strong>一旦定义了局部变量则必须人为的初始化</strong>，否则无法使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> a;<span class="hljs-comment">//这样是对的</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    	<span class="hljs-keyword">int</span> i; <span class="hljs-comment">//这样是错的</span><br>    	System. out. println(i);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的<strong>操作数栈</strong>，也可以称之为表达式栈（Expression Stack）</p>
<p><strong>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></p>
<p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p>
<ul>
<li><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</p>
</li>
<li><p>比如：执行复制、交换、求和等操作</p>
</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721215213032.png" srcset="/img/loading.gif" lazyload alt="image-20210721215213032"></p>
<blockquote>
<p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p>
</blockquote>
<ul>
<li>栈顶缓存技术（Top Of Stack Cashing）技术</li>
</ul>
<blockquote>
<p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中</strong>，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p>
</blockquote>
<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>每一个栈帧内部都包含一个指向<strong>运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</p>
<p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong>。</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721220507542.png" srcset="/img/loading.gif" lazyload alt="image-20210721220507542"></p>
<h5 id="方法出口（返回地址）"><a href="#方法出口（返回地址）" class="headerlink" title="方法出口（返回地址）"></a>方法出口（返回地址）</h5><p> 存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p>
<ul>
<li><p>正常执行完成</p>
</li>
<li><p>出现未处理的异常，非正常退出</p>
</li>
</ul>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。<strong>方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<hr>
<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><h4 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h4><p>本地方法栈是为虚拟机使用到的本地（native）方法服务</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常</p>
<ul>
<li>本地方法栈，也是线程私有的。</li>
</ul>
<hr>
<h3 id="2-4-Java堆"><a href="#2-4-Java堆" class="headerlink" title="2.4 Java堆"></a>2.4 Java堆</h3><ul>
<li>堆针对一个JVM进程来说是唯一的，也就是<strong>一个进程只有一个JVM</strong>，但是进程包含多个线程，他们是共享同一堆空间的。</li>
</ul>
<h4 id="2-4-1-定义"><a href="#2-4-1-定义" class="headerlink" title="2.4.1 定义"></a>2.4.1 定义</h4><p>Heap 堆：通过<code>new</code>关键字，创建对象都会使用堆内存</p>
<h4 id="2-4-2-特点"><a href="#2-4-2-特点" class="headerlink" title="2.4.2 特点"></a>2.4.2 特点</h4><ul>
<li>它是线程共享的，堆中对象都需要<strong>考虑线程安全</strong>的问题</li>
<li>有垃圾回收机制</li>
<li><strong>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置</strong>。</li>
</ul>
<blockquote>
<p>根据《Java虚拟机规范》规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上他应该被视为连续的</p>
</blockquote>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721222718429.png" srcset="/img/loading.gif" lazyload alt="image-20210721222718429"></p>
<h4 id="2-4-3-堆内存溢出"><a href="#2-4-3-堆内存溢出" class="headerlink" title="2.4.3 堆内存溢出"></a>2.4.3 堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p>
<h4 id="2-4-4-堆内存诊断"><a href="#2-4-4-堆内存诊断" class="headerlink" title="2.4.4 堆内存诊断"></a>2.4.4 堆内存诊断</h4><ol>
<li><p>jps工具<br> 查看当前系统中有哪些 java 进程</p>
</li>
<li><p>jmap工具<br> 查看堆内存占用情况<code>jmap - heap</code>进程id</p>
</li>
<li><p>jconsole工具<br> 图形界面的，多功能的监测工具，可以连续监测</p>
</li>
<li><p>jvirsalvm工具</p>
</li>
</ol>
<p>  可视化，动态监测程序的线程状况，可以查看当前堆快照，并分析各类的实例所占内存比</p>
<h4 id="2-4-5-为对象分配内存：TLAB"><a href="#2-4-5-为对象分配内存：TLAB" class="headerlink" title="2.4.5 为对象分配内存：TLAB"></a>2.4.5 为对象分配内存：TLAB</h4><ul>
<li>TLAB：Thread Local Allocation Buffer，目的是为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li>
</ul>
<p><strong>什么是TLAB？</strong></p>
<ul>
<li> 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。 </li>
<li> 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。 </li>
<li> 对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210722105315793.png" srcset="/img/loading.gif" lazyload alt="image-20210722105315793"></p>
<hr>
<h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><h4 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1 定义"></a>2.5.1 定义</h4><p>方法区存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化以及接口初始化中使用的特殊方法。</p>
<p>类加载后会将类的class文件读入jvm的方法区</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210722114949976.png" srcset="/img/loading.gif" lazyload alt="image-20210722114949976"></p>
<h4 id="2-5-2-内部结构"><a href="#2-5-2-内部结构" class="headerlink" title="2.5.2 内部结构"></a>2.5.2 内部结构</h4><h5 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h5><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p>
<ol>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ol>
<h5 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h5><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
<p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p>
<h5 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h5><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ol>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li>
<li>异常表（abstract和native方法除外） </li>
</ol>
<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
<h5 id="非final的类变量"><a href="#非final的类变量" class="headerlink" title="非final的类变量"></a>非final的类变量</h5><ul>
<li><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p>
</li>
<li><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p>
</li>
</ul>
<blockquote>
<p>static final 全局常量</p>
<p>被声明为final的类变量的处理方法则不同，每个final全局常量在编译成字节码文件的时候就会被分配了。</p>
</blockquote>
<h4 id="2-5-3-特点"><a href="#2-5-3-特点" class="headerlink" title="2.5.3 特点"></a>2.5.3 特点</h4><ul>
<li>线程共享</li>
<li>方法区在逻辑上是堆的一部分，但实现不同（hotspot虚拟机，JDK1.8之前在永久代中实现，JDK1.8之后在元空间中实现）</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.2.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-5-4-方法区内存溢出"><a href="#2-5-4-方法区内存溢出" class="headerlink" title="2.5.4 方法区内存溢出"></a>2.5.4 方法区内存溢出</h4><ul>
<li>1.8 以前会导致永久代内存溢出</li>
<li>1.8 之后会导致元空间内存溢出</li>
</ul>
<blockquote>
<p>方法区和永久代的关系</p>
<blockquote>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
</blockquote>
</blockquote>
<h4 id="2-5-5-运行时常量池"><a href="#2-5-5-运行时常量池" class="headerlink" title="2.5.5 运行时常量池"></a>2.5.5 运行时常量池</h4><p>运行时常量池是方法区的一部分。</p>
<ul>
<li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量与符号引用等信息</li>
<li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li>
</ul>
<p><strong>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></p>
<p><strong>通过反编译来查看类的信息</strong></p>
<ul>
<li>输入 <strong>javac 对应类的绝对路径</strong></li>
<li> <strong>javap -v 类的绝对路径</strong></li>
</ul>
<p><strong>反编译以后类的信息</strong></p>
<p>类的基本信息</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.2.2.png" srcset="/img/loading.gif" lazyload></p>
<p>常量池</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.2.3.png" srcset="/img/loading.gif" lazyload></p>
<p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.2.4.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.2.5.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="2-5-5-1-字符串池-StringTable"><a href="#2-5-5-1-字符串池-StringTable" class="headerlink" title="2.5.5.1 字符串池-StringTable"></a>2.5.5.1 字符串池-StringTable</h5><p>JDK1.6之前，位于常量池中，JDK1.8之后位于堆中</p>
<p>底层是<strong>HashTable</strong>（用来放字符串对象且里面的<strong>元素不重复</strong>），可能发生哈希碰撞，可以设置哈希桶的个数进行调优</p>
<p><strong>特点</strong></p>
<ul>
<li>常量池中的字符串仅是符号，<strong>第一次用到时才变为对象</strong></li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串<strong>变量</strong>拼接的原理是 <code>StringBuilder</code>的<code>append</code>方法（JDK1.8）</li>
<li>字符串<strong>常量</strong>拼接的原理是<strong>编译期优化</strong></li>
<li>可以使用<code>intern</code>方法，主动将串池中还没有的字符串对象放入串池<ul>
<li>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入,返回常量池对象，如果没有则<strong>放入串池</strong>， 会把串池中的对象返回</li>
<li>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入,返回常量池对象，如果没有会把此对象<strong>复制</strong>一份，放入串池， 会把串池中的对象返回</li>
</ul>
</li>
<li><strong>无论是串池还是堆里面的字符串，都是对象</strong></li>
</ul>
<h6 id="1-使用字符串直接赋值创建字符串的过程"><a href="#1-使用字符串直接赋值创建字符串的过程" class="headerlink" title="1. 使用字符串直接赋值创建字符串的过程"></a>1. 使用<strong>字符串直接赋值</strong>创建字符串的过程</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		String a = <span class="hljs-string">&quot;a&quot;</span>; <br>		String b = <span class="hljs-string">&quot;b&quot;</span>;<br>		String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p>
<p>反编译后的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br><span class="hljs-number">2</span>: astore_1<br><span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br><span class="hljs-number">5</span>: astore_2<br><span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br><span class="hljs-number">8</span>: astore_3<br><span class="hljs-number">9</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p>
<p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p>
<p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p>
<p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p>
<p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p>
<h6 id="2-使用拼接字符串变量对象创建字符串的过程"><a href="#2-使用拼接字符串变量对象创建字符串的过程" class="headerlink" title="2. 使用拼接字符串变量对象创建字符串的过程"></a>2. 使用拼接<strong>字符串变量对象</strong>创建字符串的过程</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		String a = <span class="hljs-string">&quot;a&quot;</span>;<br>		String b = <span class="hljs-string">&quot;b&quot;</span>;<br>		String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br>		<span class="hljs-comment">//拼接字符串对象来创建新的字符串</span><br>		String ab2 = a+b; <br>        <span class="hljs-comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span><br>		System.out.println(ab == ab2);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反编译后的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>       <span class="hljs-number">2</span>: astore_1<br>       <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>       <span class="hljs-number">5</span>: astore_2<br>       <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>       <span class="hljs-number">8</span>: astore_3<br>       <span class="hljs-number">9</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>      <span class="hljs-number">12</span>: dup<br>      <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>      <span class="hljs-number">16</span>: aload_1<br>      <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>								 	  <span class="hljs-comment">//;)Ljava/lang/StringBuilder;</span><br>      <span class="hljs-number">20</span>: aload_2<br>      <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>								 	  <span class="hljs-comment">//;)Ljava/lang/StringBuilder;</span><br>      <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br>      <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span><br>      <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<p>通过拼接的方式来创建字符串的<strong>过程</strong>是：<code>StringBuilder().append(“a”).append(“b”).toString()</code></p>
<p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p>
<h6 id="3-使用拼接字符串常量对象的方法创建字符串"><a href="#3-使用拼接字符串常量对象的方法创建字符串" class="headerlink" title="3. 使用拼接字符串常量对象的方法创建字符串"></a>3. 使用<strong>拼接字符串常量对象</strong>的方法创建字符串</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		String a = <span class="hljs-string">&quot;a&quot;</span>;<br>		String b = <span class="hljs-string">&quot;b&quot;</span>;<br>		String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br>		String ab2 = a+b;<br>		<span class="hljs-comment">//使用拼接字符串的方法创建字符串</span><br>		String ab3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反编译后的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>  stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span><br>     <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>     <span class="hljs-number">2</span>: astore_1<br>     <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>     <span class="hljs-number">5</span>: astore_2<br>     <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>     <span class="hljs-number">8</span>: astore_3<br>     <span class="hljs-number">9</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>    <span class="hljs-number">12</span>: dup<br>    <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>    <span class="hljs-number">16</span>: aload_1<br>    <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>							  <span class="hljs-comment">//;)Ljava/lang/StringBuilder;</span><br>    <span class="hljs-number">20</span>: aload_2<br>    <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>							  <span class="hljs-comment">//;)Ljava/lang/StringBuilder;</span><br>    <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br>    <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span><br>    <span class="hljs-comment">//ab3初始化时直接从串池中获取字符串</span><br>    <span class="hljs-number">29</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>    <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span><br>    <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<ul>
<li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li>
<li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li>
</ul>
<h6 id="4-使用new-String-构造方法创建字符串"><a href="#4-使用new-String-构造方法创建字符串" class="headerlink" title="4. 使用new String()构造方法创建字符串"></a>4. 使用new String()构造方法创建字符串</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>        String s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>        String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br><br>        System.out.println(s == s1);  <span class="hljs-comment">//false</span><br>        System.out.println(s == s2);  <span class="hljs-comment">//false</span><br>        System.out.println(s1 == s2); <span class="hljs-comment">//false</span><br>    &#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><p>String s = new String(“abc”)：首先会在String Pool查询是否有字符串“abc”，如果没有，则创建一个“abc”对象，放到String Pool中。如果存在，就不再创建</p>
<p>然后遇到new，则会在堆中创建一个“abc”对象，然后用<strong>s指向堆中的“abc”</strong>。因此这一步创建了两个对象</p>
<blockquote>
<p>注意：s是引用，不是对象，真正的对象时存在堆中的“abc”。s记录了“abc”的地址</p>
</blockquote>
</li>
<li><p>String s1 = “abc”：首先会在String Pool查询是否有字符串“abc”，如果存在，s1指向位于String Pool中“abc”的地址</p>
</li>
<li><p>String s2 = new String(“abc”)：首先会在String Pool查询是否有字符串“abc”，如果没有，则创建一个“abc”对象，放到String Pool中。如果存在，就不再创建</p>
<p>然后遇到new，则会在堆中创建一个“abc”对象，然后用<strong>s2指向堆中的“abc”</strong>。因此这一步创建了一个对象</p>
</li>
</ul>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ul>
<li>不管是<code>String s = new String(&quot;xx&quot;)</code>还是<code>String s = &quot;xxx&quot;</code>都会先在<code>String Pool</code>中查找想要创建的字符串是否已经存在。<ul>
<li>如果存在，则都不会再在<code>String Pool</code>中创建对象。<ul>
<li>但是<code>new</code>还会在堆中创建一个对象，</li>
<li><code>String = &quot;XXX&quot;</code>方式会直接把字符串常量池中的地址返回给变量<code>s</code></li>
</ul>
</li>
<li>如果不存在<ul>
<li><code>new</code>会在常量池和堆中<strong>分别创建一个对象</strong>，然后指向堆中的对象</li>
<li><code>String = &quot; &quot;</code>仅仅在常量池中创建对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="intern-方法的作用"><a href="#intern-方法的作用" class="headerlink" title="intern()方法的作用"></a>intern()方法的作用</h6><ul>
<li><p>任何一个字符串只要调用了<code>.intern()</code>方法都会去<code>String Pool</code>中查找该字符串是否存在，如果存在，则返回该字符串在<code>String Pool</code>的地址</p>
</li>
<li><p>如果不存在，则会在<code>String Pool</code>中创建该字符串，然后返回地址。<strong>那么这里的创建方式呢，根据JDK版本的不同，又会有两种方式。假设该字符串已经在堆中存在</strong></p>
<ul>
<li><p>JDK1.6：常量池和堆完全分开，会创建新对象</p>
</li>
<li><p>JDK1.7以上：常量池是堆的一部分，不会创建新对象，而是指向堆中对象的一个引用。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>        String s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>        String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>		<span class="hljs-comment">// s指向堆中 s1指向常量池  所以 false</span><br>        System.out.println(s == s1);<br>        <span class="hljs-comment">// s指向堆中 s2指向堆中另外一块内存区域  所以false</span><br>        System.out.println(s == s2);<br>        <span class="hljs-comment">// s1指向常量池 s2指向堆 所以false</span><br>        System.out.println(s1 == s2);<br>		<span class="hljs-comment">// s指向堆  s.intern()是常量池中的地址 所以 false</span><br>        System.out.println(s == s.intern());<br>        <span class="hljs-comment">// s1指向常量池  s1.intern()也指向常量池 所以true</span><br>        System.out.println(s1 == s1.intern());<br>        <span class="hljs-comment">// s.intern()和s2.intern()都指向常量池 所以true</span><br>        System.out.println(s.intern() == s2.intern());<br>    &#125;<br><br></code></pre></td></tr></table></figure>



<p>习题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>String s3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;	<span class="hljs-comment">//编译器优化，变为ab，储存在字符串常量池</span><br>String s4 = s1 + s2;	<span class="hljs-comment">//StringBuilder.append.toString,储存在堆中，并试图放到字符串常量池中一份（发现已存在）</span><br>String s5 = <span class="hljs-string">&quot;ab&quot;</span>;	<span class="hljs-comment">//发现字符串常量池中已有ab，直接引用ab</span><br>String s6 = s4.intern();	<span class="hljs-comment">//发现池中存在，入池失败，返回常量池对象</span><br><span class="hljs-comment">// 问</span><br>System.out.println(s3 == s4);	<span class="hljs-comment">//false</span><br>System.out.println(s3 == s5);	<span class="hljs-comment">//true</span><br>System.out.println(s3 == s6);	<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK1.8</span><br>String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>);	<span class="hljs-comment">//堆中（不会试图添加到常量池中）</span><br>String x1 = <span class="hljs-string">&quot;cd&quot;</span>;	<span class="hljs-comment">//常量池中</span><br>x2.intern();	<span class="hljs-comment">//入池失败</span><br>System.out.println(x1 == x2);	<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK1.8</span><br>String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>);	<span class="hljs-comment">//堆中（不会试图添加到常量池中）</span><br>x2.intern();	<span class="hljs-comment">//入池成功</span><br>String x1 = <span class="hljs-string">&quot;cd&quot;</span>;	<span class="hljs-comment">//从池中获取,与x2堆中是同一个对象</span><br>System.out.println(x1 == x2);	<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK1.6</span><br>String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>);	<span class="hljs-comment">//堆中（不会试图添加到常量池中）</span><br>x2.intern();	<span class="hljs-comment">//入池成功</span><br>String x1 = <span class="hljs-string">&quot;cd&quot;</span>;	<span class="hljs-comment">//从池中获取,与x2堆中不是同一个对象</span><br>System.out.println(x1 == x2);	<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK1.8</span><br>String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);<br>System.out.println(s == s.intern()); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<p>分析：</p>
<p><code>String s = new String(&quot;1&quot;) + new String(&quot;1&quot;)</code>：会在堆中创建对象<code>s = &quot;11&quot;</code>。但是不会在常量池中创建。如果接下来调用s.intern()。那么，会尝试在常量池中创建对象，此时根据JDK版本不同，会有两种情况：</p>
<ul>
<li>JDK1.6：常量池和堆完全分开，会创建新对象</li>
<li>JDK1.7以上：常量池是堆的一部分，不会创建新对象，而是<strong>指向堆中对象的一个引用</strong>。因此在上面的例子中，二者指向的是同一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    String s0 = <span class="hljs-string">&quot;beijing&quot;</span>;<br>    String s1 = <span class="hljs-string">&quot;bei&quot;</span>;<br>    String s2 = <span class="hljs-string">&quot;jing&quot;</span>;<br>    String s3 = s1 + s2;<br>    System.out.println(s0 == s3); <span class="hljs-comment">// false s3指向对象实例，s0指向字符串常量池中的&quot;beijing&quot;</span><br>    String s7 = <span class="hljs-string">&quot;shanxi&quot;</span>;<br>    <span class="hljs-keyword">final</span> String s4 = <span class="hljs-string">&quot;shan&quot;</span>;<br>    <span class="hljs-keyword">final</span> String s5 = <span class="hljs-string">&quot;xi&quot;</span>;<br>    String s6 = s4 + s5;<br>    System.out.println(s6 == s7); <span class="hljs-comment">// true s4和s5是final修饰的，编译期就能确定s6的值了</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>不使用final修饰，即为变量。如s3行的s1和s2，会通过new StringBuilder进行拼接</p>
</li>
<li><p>使用final修饰，即为常量。会在编译器进行代码优化。在实际开发中，能够使用final的，尽量使用</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ① String s = new String(&quot;1&quot;)</span><br><span class="hljs-comment"> * 创建了两个对象</span><br><span class="hljs-comment"> * 		堆空间中一个new对象</span><br><span class="hljs-comment"> * 		字符串常量池中一个字符串常量&quot;1&quot;（注意：此时字符串常量池中已有&quot;1&quot;）</span><br><span class="hljs-comment"> * ② s.intern()由于字符串常量池中已存在&quot;1&quot;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * s  指向的是堆空间中的对象地址</span><br><span class="hljs-comment"> * s2 指向的是堆空间中常量池中&quot;1&quot;的地址</span><br><span class="hljs-comment"> * 所以不相等</span><br><span class="hljs-comment"> */</span><br>String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);<br>s.intern();<br>String s2 = <span class="hljs-string">&quot;1&quot;</span>;<br>System.out.println(s==s2); <span class="hljs-comment">// jdk1.6 false jdk7/8 false</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ① String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;)</span><br><span class="hljs-comment"> * 等价于new String（&quot;11&quot;），但是，常量池中并不生成字符串&quot;11&quot;；</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ② s3.intern()</span><br><span class="hljs-comment"> * 由于此时常量池中并无&quot;11&quot;，所以把s3中记录的对象的地址存入常量池</span><br><span class="hljs-comment"> * 所以s3 和 s4 指向的都是一个地址</span><br><span class="hljs-comment">*/</span><br>String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);<br>s3.intern();<br>String s4 = <span class="hljs-string">&quot;11&quot;</span>;<br>System.out.println(s3==s4); <span class="hljs-comment">//jdk1.6 false jdk7/8 true</span><br></code></pre></td></tr></table></figure>

<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723151600561.png" srcset="/img/loading.gif" lazyload alt="image-20210723151600561"></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723151833638.png" srcset="/img/loading.gif" lazyload alt="image-20210723151833638"></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723151925809.png" srcset="/img/loading.gif" lazyload alt="image-20210723151925809"></p>
<hr>
<h3 id="2-6-直接内存"><a href="#2-6-直接内存" class="headerlink" title="2.6 直接内存"></a>2.6 直接内存</h3><h4 id="2-6-1-定义"><a href="#2-6-1-定义" class="headerlink" title="2.6.1 定义"></a>2.6.1 定义</h4><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。常见于 NIO 操作时，用于<strong>数据缓冲区</strong></p>
<h4 id="2-6-2-特点"><a href="#2-6-2-特点" class="headerlink" title="2.6.2 特点"></a>2.6.2 特点</h4><ul>
<li>分配回收成本较高，但读写性能高</li>
<li>不受 JVM 内存回收管理</li>
<li>也会发生内存溢出异常</li>
</ul>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<h5 id="不使用直接内存时"><a href="#不使用直接内存时" class="headerlink" title="不使用直接内存时"></a>不使用直接内存时</h5><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.3.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="使用直接内存时"><a href="#使用直接内存时" class="headerlink" title="使用直接内存时"></a>使用直接内存时</h5><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/2.4.png" srcset="/img/loading.gif" lazyload></p>
<p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p>
<h4 id="2-6-3-分配和回收原理"><a href="#2-6-3-分配和回收原理" class="headerlink" title="2.6.3 分配和回收原理"></a>2.6.3 分配和回收原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p>
<ul>
<li>使用了<code>Unsafe</code>对象完成直接内存的分配回收，并且回收需要主动调用<code>freeMemory</code>方法</li>
<li><code>ByteBuffer</code>的实现类内部，使用了<code>Cleaner</code>（虚引用）来监测<code>ByteBuffer</code>对象，一旦<code>ByteBuffer</code>对象被垃圾回收，那么就会由<code>ReferenceHandler</code>线程通过<code>Cleaner</code>的<code>clean</code>方法调用<code>freeMemory</code>来释放直接内存</li>
</ul>
<h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="3-1-如何判断对象可回收"><a href="#3-1-如何判断对象可回收" class="headerlink" title="3.1 如何判断对象可回收"></a>3.1 如何判断对象可回收</h3><h4 id="3-1-1-引用计数法"><a href="#3-1-1-引用计数法" class="headerlink" title="3.1.1 引用计数法"></a>3.1.1 引用计数法</h4><p>每一个对象有一个引用计数器，当对象被引用一次则计数器加一，当引用对象失效一次则计数器减一，对于计数器为0的对象意味着是垃圾对象，可以被GC回收</p>
<p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.1.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-1-2-可达性分析算法"><a href="#3-1-2-可达性分析算法" class="headerlink" title="3.1.2 可达性分析算法"></a>3.1.2 可达性分析算法</h4><ul>
<li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li>
<li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li>
<li>可以作为GC Root的对象<ul>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</p>
<ul>
<li>如，各个线程被调用的方法中使用到的参数、局部变量等</li>
</ul>
</li>
<li><p>方法区中类静态属性引用的对象</p>
<ul>
<li>Java类的引用类型静态变量</li>
</ul>
</li>
<li><p>方法区中常量引用的对象</p>
<ul>
<li>字符串常量池（String Table）里的引用</li>
</ul>
</li>
<li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象</p>
</li>
<li><p>所有被同步锁synchronized持有的对象</p>
</li>
<li><p>Java虚拟机内部的引用。 </p>
<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li>
</ul>
</li>
<li><p>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-1-3-五种引用"><a href="#3-1-3-五种引用" class="headerlink" title="3.1.3 五种引用"></a>3.1.3 五种引用</h4><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.2.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210714222004243.png" srcset="/img/loading.gif" lazyload alt="image-20210714222004243"></p>
<h5 id="1-强引用-不回收"><a href="#1-强引用-不回收" class="headerlink" title="1. 强引用 - 不回收"></a>1. 强引用 - 不回收</h5><p><code>new</code>一个对象时候，就是强引用，只有GC Root<strong>都不引用</strong>该对象时（显式地将强引用赋值为null），才会回收<strong>强引用</strong>对象</p>
<ul>
<li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuffer str = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello gotcha&quot;</span>);<br>StringBuffer str1 = str;<br></code></pre></td></tr></table></figure>

<p>局部变量str,str1指向StringBuffer实例所在堆空间，通过str,str1可以操作该实例，那么str,str1就是StringBuffer实例的强引用</p>
<p><strong>对应内存结构</strong></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210714222459049.png" srcset="/img/loading.gif" lazyload alt="image-20210714222459049"></p>
<blockquote>
<p>强引用特点</p>
<ul>
<li><p>强引用可以直接访问目标对象。</p>
</li>
<li><p>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</p>
</li>
<li><p>强引用可能导致内存泄漏。</p>
</li>
</ul>
</blockquote>
<h5 id="2-软引用（SoftReference）-GC后仍内存不足时，回收"><a href="#2-软引用（SoftReference）-GC后仍内存不足时，回收" class="headerlink" title="2. 软引用（SoftReference）- GC后仍内存不足时，回收"></a>2. 软引用（SoftReference）- GC后仍内存不足时，回收</h5><p>当GC Root指向软引用对象时（仅有软引用引用该对象时），在<strong>垃圾回收后，内存仍不足</strong>时会再次触发垃圾回收，<strong>回收软引用所引用的对象</strong></p>
<p>软引用通常用来实现<strong>内存敏感的缓存</strong>。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>可以配合引用队列来释放软引用自身</p>
<ul>
<li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li>
</ul>
<p><strong>软引用的使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>		<span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>		List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>		SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p>
<p>如果想要<strong>清理软引用</strong>，需要使用<strong>引用队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>		<span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span><br>		ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br>		<span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>		List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>		SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);<br><br>		<span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span><br>		Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<br>		<span class="hljs-keyword">while</span>(poll != <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span><br>			list.remove(poll);<br>			<span class="hljs-comment">//移动到引用队列中的下一个元素</span><br>			poll = queue.poll();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="3-弱引用（WeakReference）-GC时回收"><a href="#3-弱引用（WeakReference）-GC时回收" class="headerlink" title="3. 弱引用（WeakReference）- GC时回收"></a>3. 弱引用（WeakReference）- GC时回收</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p>
<p>可以配合引用队列来释放弱引用自身</p>
<ul>
<li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li>
</ul>
<p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p>
<blockquote>
<p>由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
</blockquote>
<blockquote>
<p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
</blockquote>
<h5 id="4-虚引用（PhantomReference）-对象回收追踪"><a href="#4-虚引用（PhantomReference）-对象回收追踪" class="headerlink" title="4. 虚引用（PhantomReference）- 对象回收追踪"></a>4. <strong>虚引用</strong>（PhantomReference）- 对象回收追踪</h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p>
<p>为一个对象设置虚引用关联的唯一目的在于<strong>跟踪垃圾回收过程</strong>。比如：能在这个对象被收集器回收时收到一个系统通知。</p>
<ul>
<li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
<li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li>
</ul>
<blockquote>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
</blockquote>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>被回收时间</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>从来不会</td>
<td>对象的一般状态</td>
<td>JVM停止运行时</td>
</tr>
<tr>
<td>软引用</td>
<td>GC后，内存依旧不足时</td>
<td>对象缓存</td>
<td>内存不足时</td>
</tr>
<tr>
<td>弱引用</td>
<td>jvm垃圾回收时</td>
<td>对象缓存</td>
<td>gc运行后</td>
</tr>
<tr>
<td>虚引用</td>
<td>未知</td>
<td>对象回收追踪</td>
<td>未知</td>
</tr>
</tbody></table>
<h5 id="5-终结器引用（FinalReference）"><a href="#5-终结器引用（FinalReference）" class="headerlink" title="5. 终结器引用（FinalReference）"></a>5. 终结器引用（FinalReference）</h5><p>所有的类都继承自Object类，Object类有一个<code>finalize</code>方法，其内部配合引用队列使用。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的<code>finalize</code>方法。调用以后，该对象就可以被垃圾回收了</p>
<ul>
<li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
</ul>
<h6 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h6><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p>
<p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，<strong>总会先调用这个对象的finalize()方法</strong>。</p>
<p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
<p><strong>永远不要主动调用某个对象的finalize()方法</strong>，应该交给垃圾回收机制调用。理由包括下面三点：</p>
<ul>
<li><p>在finalize()时可能会导致对象复活。</p>
</li>
<li><p>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</p>
</li>
<li><p>一个糟糕的finalize()会严重影响Gc的性能。</p>
</li>
</ul>
<p>从功能上来说，finalize()方法与C中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C中的析构函数。</p>
<p>由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>
<h5 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h5><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>
<ul>
<li><p><strong>可触及的</strong>：从根节点开始，可以到达这个对象。</p>
</li>
<li><p><strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</p>
</li>
<li><p><strong>不可触及的</strong>：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。</p>
</li>
</ul>
<p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
<h6 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h6><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p>
<ol>
<li><p>如果对象objA到GC Roots没有引用链，则进行第一次标记。</p>
</li>
<li><p>进行筛选，判断此对象是否有必要执行finalize()方法</p>
</li>
<li><p>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</p>
</li>
<li><p>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</p>
</li>
<li><p>finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</p>
</li>
</ol>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CanReliveObj</span> </span>&#123;<br>    <span class="hljs-comment">// 类变量，属于GC Roots的一部分</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CanReliveObj canReliveObj;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-keyword">super</span>.finalize();<br>        System.out.println(<span class="hljs-string">&quot;调用当前类重写的finalize()方法&quot;</span>);<br>        canReliveObj = <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        canReliveObj = <span class="hljs-keyword">new</span> CanReliveObj();<br>        canReliveObj = <span class="hljs-keyword">null</span>;<br>        System.gc();<br>        System.out.println(<span class="hljs-string">&quot;-----------------第一次gc操作------------&quot;</span>);<br>        <span class="hljs-comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span><br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">if</span> (canReliveObj == <span class="hljs-keyword">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----------------第二次gc操作------------&quot;</span>);<br>        canReliveObj = <span class="hljs-keyword">null</span>;<br>        System.gc();<br>        <span class="hljs-comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span><br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">if</span> (canReliveObj == <span class="hljs-keyword">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">-----------------第一次gc操作------------<br>调用当前类重写的finalize()方法<br>obj is still alive<br>-----------------第二次gc操作------------<br>obj is dead<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在第一次GC时，执行了finalize方法，但finalize()方法只会被调用一次，所以第二次该对象被GC标记并清除了。</p>
</blockquote>
<h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul>
<li>软引用和弱引用<strong>可以配合</strong>引用队列<ul>
<li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li>
</ul>
</li>
<li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul>
<li>虚引用和终结器引用在使用时会关联一个引用队列，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li>
</ul>
</li>
</ul>
<p><strong>大概思路为：</strong>查看引用队列中有无软/弱引用，如果有，则将该软/弱引用从存放它的集合中移除（这里为一个list集合）</p>
<h3 id="3-2-垃圾回收算法"><a href="#3-2-垃圾回收算法" class="headerlink" title="3.2 垃圾回收算法"></a>3.2 垃圾回收算法</h3><h4 id="3-2-1-标记-清除"><a href="#3-2-1-标记-清除" class="headerlink" title="3.2.1 标记-清除"></a>3.2.1 标记-清除</h4><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p>
<ul>
<li>这里的腾出内存空间并不是将内存空间的字节清零，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><p><strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
</li>
<li><p>在进行GC的时候，需要停止整个应用程序，用户体验较差</p>
</li>
<li><p>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个<strong>空闲列表</strong></p>
</li>
</ul>
<h4 id="3-2-2-标记-复制"><a href="#3-2-2-标记-复制" class="headerlink" title="3.2.2 标记-复制"></a>3.2.2 标记-复制</h4><p><strong>定义</strong>：将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题。</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.4.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>缺点</strong>：会占用双倍的内存空间。</p>
<p><strong>应用场景</strong>：在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<p><strong>改进</strong>：由于新生代都是朝生夕死的，所以不需要1：1划分内存空间，可以将内存划分为一块较大的Eden和两块较小的Suvivor空间。每次使用Eden和其中一块Survivor。当回收的时候，将Eden和Survivor中还活着的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才使用过的Suevivor空间。其中Eden和Suevivor的大小比例是8：1。缺点是需要老年代进行分配担保，如果第二块的Survovor空间不够的时候，需要对老年代进行垃圾回收，然后存储新生代的对象，这些新生代当然会直接进入来老年代。</p>
<h4 id="3-2-3-标记-整理"><a href="#3-2-3-标记-整理" class="headerlink" title="3.2.3 标记-整理"></a>3.2.3 标记-整理</h4><p><strong>定义</strong>：将不被GC Root引用的对象回收，清除其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.5.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>标记-清除算法是一种<strong>非移动式</strong>的回收算法，标记-压缩是<strong>移动式</strong>的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，<strong>JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销</strong>。</p>
<h5 id="指针碰撞（Bump-the-Pointer）"><a href="#指针碰撞（Bump-the-Pointer）" class="headerlink" title="指针碰撞（Bump the Pointer）"></a>指针碰撞（Bump the Pointer）</h5><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump tHe Pointer）。</p>
<p><strong>优点</strong></p>
<ul>
<li><p>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</p>
</li>
<li><p>消除了复制算法当中，内存减半的高额代价。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>从效率上来说，标记-整理算法要低于复制算法。</p>
</li>
<li><p>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</p>
</li>
<li><p>移动过程中，需要全程暂停用户应用程序。即：STW</p>
</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep（标记-清除）</th>
<th>Mark-Compact（标记-整理）</th>
<th>Copying<strong>（标记-复制）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>速率</strong></td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍空间（不堆积碎片）</td>
</tr>
<tr>
<td><strong>移动对象</strong></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-3-分代回收"><a href="#3-3-分代回收" class="headerlink" title="3.3 分代回收"></a>3.3 分代回收</h3><p>分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<ul>
<li>年轻代（Young Gen）</li>
</ul>
<p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况使用<strong>标记-复制</strong>，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<p>新生代收集：Minor GC / Young GC</p>
<ul>
<li>老年代（Tenured Gen）</li>
</ul>
<p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由<strong>标记-清除</strong>或者是标记-清除与标记-整理的混合实现。</p>
<ol>
<li>Mark阶段的开销与存活对象的数量成正比。</li>
<li>Sweep阶段的开销与所管理区域的大小成正相关。</li>
<li>Compact阶段的开销与存活对象的数据成正比。</li>
</ol>
<p>老年代收集：Major GC / Old GC</p>
<h4 id="3-3-1-回收流程"><a href="#3-3-1-回收流程" class="headerlink" title="3.3.1 回收流程"></a>3.3.1 回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.6.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p>
<p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.7.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.8.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.9.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>如果新生代老年代中的内存都满了，就会先触发Minor Gc，再触发<strong>Full GC</strong>（会触发 <strong>stop the world</strong>且时间更长），扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p>
<hr>
<h4 id="3-3-2-GC-分析"><a href="#3-3-2-GC-分析" class="headerlink" title="3.3.2 GC 分析"></a>3.3.2 GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><ul>
<li><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p>
</li>
<li><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
</li>
</ul>
<h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p>
<p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<blockquote>
<p>线程开启了一个新线程，新的线程OOM，不影响主线程运行</p>
</blockquote>
<hr>
<h3 id="3-4-垃圾回收器种类"><a href="#3-4-垃圾回收器种类" class="headerlink" title="3.4 垃圾回收器种类"></a>3.4 垃圾回收器种类</h3><h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a>按线程数分</h4><h5 id="串行回收器"><a href="#串行回收器" class="headerlink" title="串行回收器"></a>串行回收器</h5><p>串行回收指的是在<strong>同一时间段内只允许有一个CPU用于执行垃圾回收操作</strong>，此时工作线程被暂停，直至垃圾收集工作结束。</p>
<p>如，Serial、Serial Old</p>
<ul>
<li>单线程</li>
<li>内存较小，个人电脑（CPU核数较少）</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.10.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p>
<p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p>
<h5 id="并行回收器"><a href="#并行回收器" class="headerlink" title="并行回收器"></a>并行回收器</h5><p>并行回收指<strong>运用多个CPU，多条垃圾收集线程并行工作</strong>，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。此时<strong>用户线程仍处于等待状态</strong>。</p>
<p>如，ParNew、Parallel Scavenge、Parallel old</p>
<h4 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h4><h5 id="独占式回收器"><a href="#独占式回收器" class="headerlink" title="独占式回收器"></a>独占式回收器</h5><p>独占式垃圾回收器（Stop the world）一旦运行，就<strong>停止应用程序中的所有用户线程</strong>，直到垃圾回收过程完全结束。</p>
<h5 id="并发式回收器"><a href="#并发式回收器" class="headerlink" title="并发式回收器"></a>并发式回收器</h5><p>并发式垃圾回收器与应用程序线程<strong>交替工作</strong>，以尽可能减少应用程序的停顿时间。</p>
<p>如，CMS、G1</p>
<h4 id="按碎片处理方式区分"><a href="#按碎片处理方式区分" class="headerlink" title="按碎片处理方式区分"></a>按碎片处理方式区分</h4><h5 id="压缩式垃圾回收器"><a href="#压缩式垃圾回收器" class="headerlink" title="压缩式垃圾回收器"></a>压缩式垃圾回收器</h5><p>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</p>
<h5 id="非压缩式垃圾回收器"><a href="#非压缩式垃圾回收器" class="headerlink" title="非压缩式垃圾回收器"></a>非压缩式垃圾回收器</h5><p>非压缩式的垃圾回收器不进行这步操作。</p>
<h4 id="按工作区间区分"><a href="#按工作区间区分" class="headerlink" title="按工作区间区分"></a>按工作区间区分</h4><h5 id="年轻代垃圾回收器"><a href="#年轻代垃圾回收器" class="headerlink" title="年轻代垃圾回收器"></a>年轻代垃圾回收器</h5><p>如，Serial、ParNew、Parallel Scavenge</p>
<h5 id="老年代垃圾回收器"><a href="#老年代垃圾回收器" class="headerlink" title="老年代垃圾回收器"></a>老年代垃圾回收器</h5><p>如，SerialOld、Parallel Old、CMS</p>
<hr>
<h4 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h4><ul>
<li><p><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</p>
</li>
<li><p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</p>
</li>
<li><p><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</p>
</li>
<li><p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p>
</li>
<li><p>内存占用：Java堆区所占的内存大小。</p>
</li>
<li><p>快速：一个对象从诞生到被回收所经历的时间。</p>
</li>
</ul>
<h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>
<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715105056153.png" srcset="/img/loading.gif" lazyload alt="image-20210715105056153"></p>
<p><strong>特点</strong></p>
<ul>
<li>单位时间内，STW（stop the world，停掉其他所有工作线程）总时间最短</li>
</ul>
<h5 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h5><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。</p>
<p>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p>
<p>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715105213520.png" srcset="/img/loading.gif" lazyload alt="image-20210715105213520"></p>
<p><strong>特点</strong></p>
<ul>
<li>尽可能让<strong>单次</strong>STW时间变短（尽量不影响其他线程运行）</li>
</ul>
<hr>
<h4 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h4><h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p>
<p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p>
<p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<h6 id="抢先式中断：（目前没有虚拟机采用了）"><a href="#抢先式中断：（目前没有虚拟机采用了）" class="headerlink" title="抢先式中断：（目前没有虚拟机采用了）"></a>抢先式中断：（目前没有虚拟机采用了）</h6><ul>
<li>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>
</ul>
<h6 id="主动式中断："><a href="#主动式中断：" class="headerlink" title="主动式中断："></a>主动式中断：</h6><p>设置一个中断标志，各个线程运行到Safe Point的时候主动<strong>轮询</strong>这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</p>
<h5 id="安全区域（Safe-Resion）"><a href="#安全区域（Safe-Resion）" class="headerlink" title="安全区域（Safe Resion）"></a>安全区域（Safe Resion）</h5><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>
<h5 id="实际执行时："><a href="#实际执行时：" class="headerlink" title="实际执行时："></a>实际执行时：</h5><ol>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Relgion，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li>
</ol>
<hr>
<h3 id="3-5-几种垃圾回收器"><a href="#3-5-几种垃圾回收器" class="headerlink" title="3.5 几种垃圾回收器"></a>3.5 几种垃圾回收器</h3><h4 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h4><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p>
<p>Serial收集器是HotSpot中client模式下的默认新生代垃圾收集器。</p>
<p>Serial收集器采用<strong>标记-复制算法</strong>、<strong>串行回收</strong>和”stop-the-World”机制的方式执行内存回收。</p>
<p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是<strong>标记-整理</strong>算法。</p>
<ul>
<li><p>Serial old是运行在Client模式下默认的老年代的垃圾回收器</p>
</li>
<li><p>Serial 0ld在Server模式下主要有两个用途：① 与新生代的Parallel scavenge配合使用 ② 作为老年代CMS收集器的后备垃圾收集方案</p>
</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715150100026.png" srcset="/img/loading.gif" lazyload alt="image-20210715150100026"></p>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p>
<p>优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。</p>
<blockquote>
<p>在HotSpot虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC，且老年代用Serial Old GC</p>
</blockquote>
<p><strong>总结</strong></p>
<p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p>
<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p>
<hr>
<h4 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h4><p>ParNew收集器其实就是Serial收集器的多线程版本。Par是Parallel的缩写，New：只能处理的是新生代</p>
<p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用<strong>标记-复制</strong>算法、”Stop-the-World”机制。</p>
<p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715150735810.png" srcset="/img/loading.gif" lazyload alt="image-20210715150735810"></p>
<ul>
<li><p>对于新生代，回收次数频繁，使用并行方式高效。</p>
</li>
<li><p>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</p>
</li>
</ul>
<blockquote>
<p>在程序中，开发人员可以通过选项”<code>-XX:+UseParNewGC</code>“手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。<code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和CPU数据相同的线程数。</p>
</blockquote>
<blockquote>
<p>除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p>
</blockquote>
<hr>
<h4 id="Parallel-Scavenge回收器：吞吐量优先"><a href="#Parallel-Scavenge回收器：吞吐量优先" class="headerlink" title="Parallel Scavenge回收器：吞吐量优先"></a>Parallel Scavenge回收器：吞吐量优先</h4><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了<strong>标记-复制</strong>算法、并行回收和”Stop the World”机制。</p>
<p>那么Parallel 收集器的出现是否多此一举？</p>
<ul>
<li><p>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为<strong>吞吐量优先</strong>的垃圾收集器。</p>
</li>
<li><p><strong>自适应调节策略</strong>也是Parallel Scavenge与ParNew一个重要区别。</p>
</li>
<li><p><strong>JDK1.8默认使用</strong>的垃圾回收器</p>
</li>
</ul>
<blockquote>
<p><strong>GC自适应调节策略</strong>：</p>
<p>Parallel Scavenge收集器可设置</p>
<p>-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>
</blockquote>
<p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
<hr>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>Parallel Old 是Parallel Scavenge收集器的老年代版本，在JDK1.6时提供。用于代替老年代的Serial Old收集器。</p>
<p>Parallel Old收集器采用了<strong>标记-整理</strong>算法（老年代没有幸存区），但同样也是基于并行回收和”Stop-the-World”机制。</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715151403328.png" srcset="/img/loading.gif" lazyload alt="image-20210715151403328"></p>
<hr>
<h4 id="CMS回收器：响应时间优先"><a href="#CMS回收器：响应时间优先" class="headerlink" title="CMS回收器：响应时间优先"></a>CMS回收器：响应时间优先</h4><p>在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次<strong>实现了让垃圾收集线程与用户线程同时工作</strong>。</p>
<p>CMS收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p>
<p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。但是会<strong>产生内存碎片</strong></p>
<ul>
<li>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li>
</ul>
<p>CMS的垃圾收集算法采用<strong>标记-清除</strong>算法，并且也会”Stop-the-World”</p>
<p>不幸的是，CMS作为<strong>老年代</strong>的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择<strong>ParNew</strong>或者Serial收集器中的一个。</p>
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>
<p><strong>初始标记</strong>：暂停所有的其他线程，并标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p>
<p><strong>并发标记</strong>：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p>
<p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。<strong>仍然存在Stop The World问题</strong></p>
<p><strong>并发清除</strong>： 开启用户线程，同时 GC 线程对标记的对象进行清除回收</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715154114166.png" srcset="/img/loading.gif" lazyload alt="image-20210715154114166"></p>
<blockquote>
<p>由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了</p>
</blockquote>
<ul>
<li>为什么CMS不能用标记-整理方法</li>
</ul>
<p>因为当并发清除的时候，整理内存会导致，原来的用户线程使用的内存无法使用</p>
<blockquote>
<p>CMS收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择<strong>空闲列表</strong>（Free List）执行内存分配。</p>
</blockquote>
<ul>
<li><p>CMS的优点</p>
<ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</li>
<li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li>CMS收集器无法处理浮动垃圾。可能出现“<code>Concurrent Mode Failure</code>“失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li>
</ul>
</li>
</ul>
<blockquote>
<p>设置的参数</p>
<ul>
<li><p><code>-XX:+UseConcMarkSweepGC</code>手动指定使用CMS收集器执行内存回收任务。<br>开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开。即：ParNew（Young区用）+CMS（Old区用）+ Serial Old的组合。 </p>
</li>
<li><p> <code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。 </p>
</li>
<li><p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</p>
</li>
<li><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</p>
</li>
<li><p> <code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。 </p>
</li>
<li><p> <code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次Full GC后对内存空间进行压缩整理。 </p>
</li>
<li><p> <code>-XX:ParallelcMSThreads</code> 设置CMS的线程数量。 </p>
</li>
<li><p>CMS默认启动的线程数是（ParallelGCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>JDK9中：CMS被标记为Deprecate（JEP291）</p>
<p>JDK14中：移除了CMS垃圾回收器（JEP363）</p>
</blockquote>
<hr>
<h4 id="G1收集器：区域化分代式"><a href="#G1收集器：区域化分代式" class="headerlink" title="G1收集器：区域化分代式"></a>G1收集器：区域化分代式</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</p>
<p>Garbage First(G1)是一个<strong>并行</strong>回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p>
<p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong>。</p>
<p>这种方式的侧重点在于<strong>回收垃圾最大量的区间</strong>（Region），所以G1叫做：垃圾优先（Garbage First）。</p>
<p>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为“全功能的垃圾收集器”。</p>
<p>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.13.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<hr>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p>
<h6 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h6><ul>
<li><p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</p>
</li>
<li><p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p>
</li>
</ul>
<h6 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h6><ul>
<li><p>从分代上看，G1<strong>依然属于分代型垃圾回收器</strong>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p>
</li>
<li><p>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</p>
</li>
<li><p>和之前的各类回收器不同，它同时<strong>兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代</p>
</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210716104300313.png" srcset="/img/loading.gif" lazyload alt="image-20210716104300313"></p>
<h6 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h6><ul>
<li><p>CMS：<strong>标记-清除</strong>算法，会产生内存碎片，若干次GC后需要进行碎片整理</p>
</li>
<li><p>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是<strong>标记-复制</strong>算法，但整体上实际可看作是<strong>标记-整理</strong>算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。<strong>尤其是当Java堆非常大的时候，G1的优势更加明显</strong>。</p>
</li>
</ul>
<h6 id="可预测的停顿时间模型（即：软实时soft-real-time）"><a href="#可预测的停顿时间模型（即：软实时soft-real-time）" class="headerlink" title="可预测的停顿时间模型（即：软实时soft real-time）"></a>可预测的停顿时间模型（即：软实时soft real-time）</h6><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<ul>
<li><p>由于分区的原因，G1可以<strong>只选取部分区域进行内存回收</strong>，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</p>
</li>
<li><p>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个<strong>优先列表</strong>，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
</li>
<li><p>相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是<strong>最差情况要好很多</strong>。</p>
</li>
</ul>
<hr>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</p>
<p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p>
<hr>
<h5 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区Region：化整为零</h5><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<strong>所有的Region大小相同，且在JVM生命周期内不会被改变</strong>。</p>
<p>虽然还保留有新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离的</strong>了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210716105026391.png" srcset="/img/loading.gif" lazyload alt="image-20210716105026391"></p>
<p>一个region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，S表示属于survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p>
<p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p>
<p>设置H的原因：对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。<strong>如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
<p>每个Region都是通过<strong>指针碰撞</strong>来分配空间</p>
<hr>
<h5 id="G1垃圾回收流程"><a href="#G1垃圾回收流程" class="headerlink" title="G1垃圾回收流程"></a>G1垃圾回收流程</h5><p>G1GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li><p> 年轻代GC（Young GC） </p>
</li>
<li><p> 老年代并发标记过程（Concurrent Marking） </p>
</li>
<li><p>混合回收（Mixed GC）<br>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。） </p>
</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210716105424690.png" srcset="/img/loading.gif" lazyload alt="image-20210716105424690"></p>
<p><strong>Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC</strong>顺序，进行垃圾回收。</p>
<p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；**G1的年轻代收集阶段是一个并行的独占式收集器(会stw)**。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>
<p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了</strong>。同时，这个老年代Region是和年轻代一起被回收的。</p>
<p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
<hr>
<h5 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h5><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.20.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在G1收集器可能存在如下问题：</p>
<ul>
<li><p> 一个对象被不同区域引用的问题 （跨区/代引用），如上图</p>
</li>
<li><p> 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？ </p>
</li>
<li><p> 在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？ </p>
</li>
<li><p> 这样的话会降低MinorGC的效率； </p>
</li>
</ul>
<p><strong>解决方法：</strong></p>
<p>无论G1还是其他分代收集器，JVM都是使用Remembered Set（记忆集）来避免全局扫描：</p>
<p><strong>每个Region都有一个对应的Remembered Set；</strong></p>
<p>每次Reference类型数据写操作时，都会产生一个Write Barrier（写屏障）暂时中断操作；</p>
<p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p>
<p>如果不同，通过CardTable（卡表）把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</p>
<p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
<blockquote>
<p> 例如，下图中，Region1 和 Region 3 分别引用了 Region2 中的对象。则在Region2 对应的RememberSet中进行记录。对Region2进行GC时，发现有两个对象时有被其他区域引用的，则不清理</p>
</blockquote>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210716111525903.png" srcset="/img/loading.gif" lazyload alt="image-20210716111525903"></p>
<hr>
<h5 id="G1回收过程一：年轻代GC"><a href="#G1回收过程一：年轻代GC" class="headerlink" title="G1回收过程一：年轻代GC"></a>G1回收过程一：年轻代GC</h5><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p><strong>年轻代垃圾回收只会回收Eden区和Survivor区。</strong></p>
<p>首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p>
<ul>
<li>会发生STW</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210716111223590.png" srcset="/img/loading.gif" lazyload alt="image-20210716111223590"></p>
<p>然后开始如下回收过程：</p>
<ol>
<li><strong>第一阶段，扫描根</strong>。根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li>
<li><strong>第二阶段，更新RSet</strong>。处理dirty card queue（脏卡表）中的card，更新RSet。此阶段完成后，<strong>RSet可以准确的反映老年代对所在的内存分段中对象的引用</strong>。</li>
<li><strong>第三阶段，处理RSet</strong>。识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li>
<li><strong>第四阶段，复制对象</strong>。此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li>
<li><strong>第五阶段，处理引用</strong>。处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li>
</ol>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210719212540339.png" srcset="/img/loading.gif" lazyload alt="image-20210719212540339"></p>
<hr>
<h5 id="G1回收过程二：并发标记-YongGC"><a href="#G1回收过程二：并发标记-YongGC" class="headerlink" title="G1回收过程二：并发标记+ YongGC"></a>G1回收过程二：并发标记+ YongGC</h5><ol>
<li><strong>初始标记</strong>：标记从根节点直接可达的对象。这个阶段是<strong>STW</strong>的，并且会触发一次年轻代GC。</li>
<li><strong>根区域扫描</strong>（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在YoungGC之前完成。（因为YongGC 会操作 Survivor区 ）</li>
<li><strong>并发标记</strong>（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收（也叫做<strong>实时回收</strong>）。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
<li><strong>重新标记</strong>（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li>
<li><strong>独占清理</strong>（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是<strong>STW</strong>的。这个阶段并不会实际上去做垃圾的收集</li>
<li><strong>并发清理</strong>：识别并清理完全空闲的区域。</li>
</ol>
<p>重新标记阶段，方法</p>
<p>在垃圾回收时，收集器处理对象的过程中</p>
<p>黑色：已被处理，需要保留的</p>
<p>灰色：正在处理中的 </p>
<p>白色：还未处理的</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.21.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p>
<p>过程如下</p>
<ul>
<li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为<strong>处理中</strong>状态</li>
<li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.22.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<hr>
<h5 id="G1回收过程三：混合回收"><a href="#G1回收过程三：混合回收" class="headerlink" title="G1回收过程三：混合回收"></a>G1回收过程三：混合回收</h5><p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了<strong>回收整个Young Region，还会回收一部分的Old Region</strong>。这里需要注意：是<strong>一部分老年代</strong>，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210719213658936.png" srcset="/img/loading.gif" lazyload alt="image-20210719213658936"></p>
<p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p>
<p>并发标记结束以后，老年代中百分百为垃圾的内存分段（即，这部分内存全部为垃圾）被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收</p>
<p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p>
<p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p>
<p>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p>
<hr>
<h5 id="G1回收可选的过程四：Full-GC"><a href="#G1回收可选的过程四：Full-GC" class="headerlink" title="G1回收可选的过程四：Full GC"></a>G1回收可选的过程四：Full GC</h5><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>什么时候会发生Full GC呢？</p>
<ul>
<li><p>堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</p>
</li>
<li><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p>
</li>
<li><p>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</p>
</li>
</ul>
<hr>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><h6 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h6><p>过程</p>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li>
<li>注意，其与String.intern的区别<ul>
<li>intern关注的是字符串对象</li>
<li>字符串去重关注的是char[]</li>
<li>在JVM内部，使用了不同的字符串标</li>
</ul>
</li>
</ul>
<p>优点与缺点</p>
<ul>
<li>节省了大量内存</li>
<li>新生代回收时间略微增加，导致略微多占用CPU</li>
</ul>
<h6 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h6><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p>
<h6 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h6><ul>
<li>一个对象大于region的一半时，就称为巨型对象</li>
<li>G1不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.23.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<hr>
<h3 id="3-6-垃圾收集器总结"><a href="#3-6-垃圾收集器总结" class="headerlink" title="3.6 垃圾收集器总结"></a>3.6 垃圾收集器总结</h3><h4 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h4><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210715121053340.png" srcset="/img/loading.gif" lazyload alt="image-20210715121053340"></p>
<ol>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li>
<li>其中Serial Old作为CMS出现”<code>Concurrent Mode Failure</code>“失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK14中：弃用Parallel Scavenge和Serialold GC组合（JEP366）</li>
<li>（蓝色虚框）JDK14中：删除CMS垃圾回收器（JEP363）</li>
</ol>
<hr>
<h4 id="7种经典垃圾回收器"><a href="#7种经典垃圾回收器" class="headerlink" title="7种经典垃圾回收器"></a>7种经典垃圾回收器</h4><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>分类</th>
<th>作用位置</th>
<th>使用算法</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>适用于单CPU环境下的client模式</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境Server模式下与CMS配合使用</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>并行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行运行</td>
<td>作用于老年代</td>
<td>标记-压缩算法</td>
<td>响应速度优先</td>
<td>适用于单CPU环境下的Client模式</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行运行</td>
<td>作用于老年代</td>
<td>标记-压缩算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>CMS</td>
<td>并发运行</td>
<td>作用于老年代</td>
<td>标记-清除算法</td>
<td>响应速度优先</td>
<td>适用于互联网或B／S业务</td>
</tr>
<tr>
<td>G1</td>
<td>并发、并行运行</td>
<td>作用于新生代、老年代</td>
<td>标记-压缩算法、复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用</td>
</tr>
</tbody></table>
<p>GC发展阶段：Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p>
<hr>
<h3 id="3-7-GC-调优"><a href="#3-7-GC-调优" class="headerlink" title="3.7 GC 调优"></a>3.7 GC 调优</h3><p>查看虚拟机参数命令</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">-XX:+PrintFlagsFinal -version <span class="hljs-string">| findstr &quot;</span>GC<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure>

<p>可以根据参数去查询具体的信息</p>
<h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU占用</li>
<li>IO</li>
<li>GC</li>
</ul>
<h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p>
<ul>
<li>CMS G1 ZGC</li>
<li>ParallelGC</li>
<li>Zing</li>
</ul>
<h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<ul>
<li>查看Full GC前后的内存占用，考虑以下几个问题<ul>
<li>数据是不是太多？</li>
<li>数据表示是否太臃肿<ul>
<li>对象图</li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏</li>
</ul>
</li>
</ul>
<h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul>
<li>新生代的特点<ul>
<li>所有的new操作分配内存都是非常廉价的<ul>
<li>TLAB（Thread Local Allocation Buffer）：线程本地分配缓存区，这是一个线程专用的内存分配区域</li>
</ul>
</li>
<li>死亡对象回收零代价</li>
<li>大部分对象用过即死（朝生夕死）</li>
<li>MInor GC 所用时间远小于Full GC</li>
</ul>
</li>
<li>新生代内存越大越好么？<ul>
<li>不是<ul>
<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li>
</ul>
</li>
<li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li>
</ul>
</li>
</ul>
<h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul>
<li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li>
</ul>
<h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><p>以CMS为例</p>
<ul>
<li>CMS的老年代内存越大越好</li>
<li>如果没有发生过Full GC，优先调优新生代</li>
<li>观察发生Full GC时老年代的占用，将老年代预设内存调大1/4~1/3<ul>
<li>-XX:CMSInitiatingOccupancyFraction=percent</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-8-GC日志分析"><a href="#3-8-GC日志分析" class="headerlink" title="3.8 GC日志分析"></a>3.8 GC日志分析</h3><p>通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p>
<ul>
<li><p><code>-XX:+PrintGC</code> 输出GC日志。类似：<code>-verbose:gc</code></p>
</li>
<li><p><code>-XX:+PrintGCDetails</code> 输出GC的详细日志</p>
</li>
<li><p><code>-XX:+PrintGCTimestamps</code> 输出GC的时间戳（以基准时间的形式）</p>
</li>
<li><p><code>-XX:+PrintGCDatestamps</code> 输出GcC的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）</p>
</li>
<li><p><code>-XX:+PrintHeapAtGC</code> 在进行GC的前后打印出堆的信息</p>
</li>
<li><p><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</p>
</li>
</ul>
<ol>
<li>打开GC日志</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-verbose:gc<br></code></pre></td></tr></table></figure>



<p>这个只会显示总的GC堆的变化，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) 80832K-&gt;19298K(227840K),<span class="hljs-number">0.0084018</span> secs]<br>[GC (Metadata GC Threshold) 109499K-&gt;21465K(228352K),<span class="hljs-number">0.0184066</span> secs]<br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Metadata GC Threshold)</span> 21465K-&gt;16716<span class="hljs-title">K</span><span class="hljs-params">(201728K)</span>,0.0619261 secs]</span><br></code></pre></td></tr></table></figure>

<p>参数解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代，老年代。<br>Allocation Failure：GC发生的原因。<br>80832K-&gt;19298K：堆在GC前的大小和GC后的大小。<br>228840k：现在的堆大小。<br><span class="hljs-number">0.0084018</span> secs：GC持续的时间。<br></code></pre></td></tr></table></figure>



<ol start="2">
<li>打开GC日志</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-verbose:gc -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure>

<p>输入信息如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen:70640K-&gt;10116K(141312K)] 80541K-&gt;20017K(227328K),<span class="hljs-number">0.0172573</span> secs] [Times:user=<span class="hljs-number">0.03</span> sys=<span class="hljs-number">0.00</span>,real=<span class="hljs-number">0.02</span> secs]<br>[GC (Metadata GC Threshold) [PSYoungGen:98859K-&gt;8154K(142336K)] 108760K-&gt;21261K(228352K),<span class="hljs-number">0.0151573</span> secs] [Times:user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.01</span>,real=<span class="hljs-number">0.02</span> secs]<br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Metadata GC Threshold)</span>[PSYoungGen:8154K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(142336K)</span>]</span><br><span class="hljs-function">[ParOldGen:13107K-&gt;16809<span class="hljs-title">K</span><span class="hljs-params">(62464K)</span>] 21261K-&gt;16809<span class="hljs-title">K</span><span class="hljs-params">(204800K)</span>,[Metaspace:20599K-&gt;20599<span class="hljs-title">K</span><span class="hljs-params">(1067008K)</span>],0.0639732 secs]</span><br><span class="hljs-function">[Times:user</span>=<span class="hljs-number">0.14</span> sys=<span class="hljs-number">0.00</span>,real=<span class="hljs-number">0.06</span> secs]<br></code></pre></td></tr></table></figure>

<p>参数解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">GC，Full FC：同样是GC的类型<br>Allocation Failure：GC原因<br>PSYoungGen：使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化<br>ParOldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化<br>Metaspace： 元数据区GC前后大小的变化，JDK1<span class="hljs-number">.8</span>中引入了元数据区以替代永久代<br>xxx secs：指GC花费的时间<br>Times：user：指的是垃圾收集器花费的所有CPU时间，sys：花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。<br></code></pre></td></tr></table></figure>



<ol start="3">
<li>打开GC日志</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCDatestamps<br></code></pre></td></tr></table></figure>

<p>输入信息如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2019</span>-09-24T22:<span class="hljs-number">15</span>:<span class="hljs-number">24.518</span>+0800: <span class="hljs-number">3.287</span>: [GC (Allocation Failure) [PSYoungGen:136162K-&gt;5113K(136192K)] 141425K-&gt;17632K(222208K),<span class="hljs-number">0.0248249</span> secs] [Times:user=<span class="hljs-number">0.05</span> sys=<span class="hljs-number">0.00</span>,real=<span class="hljs-number">0.03</span> secs]<br><br><span class="hljs-number">2019</span>-09-24T22:<span class="hljs-number">15</span>:<span class="hljs-number">25.559</span>+0800: <span class="hljs-number">4.329</span>: [GC (Metadata GC Threshold) [PSYoungGen:97578K-&gt;10068K(274944K)] 110096K-&gt;22658K(360960K),<span class="hljs-number">0.0094071</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>,real=<span class="hljs-number">0.01</span> secs]<br><br><span class="hljs-number">2019</span>-09-24T22:<span class="hljs-number">15</span>:<span class="hljs-number">25.569</span>+0800: <span class="hljs-number">4.338</span>: [<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Metadata GC Threshold)</span> [PSYoungGen:10068K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(274944K)</span>][ParoldGen:12590K-&gt;13564<span class="hljs-title">K</span><span class="hljs-params">(56320K)</span>] 22658K-&gt;13564<span class="hljs-title">K</span><span class="hljs-params">(331264K)</span>,[Metaspace:20590K-&gt;20590<span class="hljs-title">K</span><span class="hljs-params">(1067008K)</span>],0.0494875 secs] [Times: user</span>=<span class="hljs-number">0.17</span> sys=<span class="hljs-number">0.02</span>,real=<span class="hljs-number">0.05</span> secs]<br></code></pre></td></tr></table></figure>



<blockquote>
<p>说明：带上了日期和实践</p>
</blockquote>
<p>如果想把GC日志存到文件的话，是下面的参数：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">-Xloggc:/<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/gc.<span class="hljs-keyword">log</span><br></code></pre></td></tr></table></figure>



<p><strong>日志补充说明</strong></p>
<ul>
<li><p> “<code>GC</code>“和”<code>Full GC</code>“说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World” </p>
</li>
<li><p> 使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”<code>DefNew</code>“ </p>
</li>
<li><p> 使用ParNew收集器在新生代的名字会变成”<code>ParNew</code>“，意思是”Parallel New Generation” </p>
</li>
<li><p> 使用Parallel scavenge收集器在新生代的名字是”<code>PSYoungGen</code>“ </p>
</li>
<li><p> 老年代的收集和新生代道理一样，名字也是收集器决定的 </p>
</li>
<li><p> 使用G1收集器的话，会显示为”garbage-first heap” </p>
</li>
<li><p><strong>Allocation Failure</strong><br>表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。 </p>
</li>
<li><p><strong>[PSYoungGen：5986K-&gt;696K(8704K) ] 5986K-&gt;704K(9216K)</strong><br>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）<br>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小） </p>
</li>
<li><p> user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核的原因，时间总和可能会超过real时间 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Heap（堆）<br>PSYoungGen（Parallel Scavenge收集器新生代）total 9216K，used 6234K [<span class="hljs-number">0x00000000ff600000</span>,<span class="hljs-number">0x0000000100000000</span>,<span class="hljs-number">0x0000000100000000</span>)<br>eden space（堆中的Eden区默认占比是<span class="hljs-number">8</span>）8192K，<span class="hljs-number">768</span> used [<span class="hljs-number">0x00000000ff600000</span>,<span class="hljs-number">0x00000000ffc16b08</span>,<span class="hljs-number">0x00000000ffe00000</span>)<br>from space（堆中的Survivor，这里是From Survivor区默认占比是<span class="hljs-number">1</span>）1024K， <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x0000000100000000</span>)<br>to space（堆中的Survivor，这里是to Survivor区默认占比是<span class="hljs-number">1</span>，需要先了解一下堆的分配策略）1024K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ffe00000</span>,<span class="hljs-number">0x00000000ffe00000</span>,<span class="hljs-number">0x00000000fff00000</span>)<br>                                                                         <br>ParOldGen（老年代总大小和使用大小）total 10240K， used 7001K ［<span class="hljs-number">0x00000000fec00000</span>,<span class="hljs-number">0x00000000ff600000</span>,<span class="hljs-number">0x00000000ff600000</span>)<br>object space（显示个使用百分比）10240K，<span class="hljs-number">688</span> used [<span class="hljs-number">0x00000000fec00000</span>,<span class="hljs-number">0x00000000ff2d6630</span>,<span class="hljs-number">0x00000000ff600000</span>)<br><br>PSPermGen（永久代总大小和使用大小）total 21504K， used 4949K [<span class="hljs-number">0x00000000f9a00000</span>,<span class="hljs-number">0x00000000faf00000</span>,<span class="hljs-number">0x00000000fec00000</span>)<br>object space（显示个使用百分比，自己能算出来）21504K， <span class="hljs-number">238</span> used [<span class="hljs-number">0x00000000f9a00000</span>,<span class="hljs-number">0x00000000f9ed55e0</span>,<span class="hljs-number">0x00000000faf00000</span>)<br>                                     <br></code></pre></td></tr></table></figure>

<hr>
<h4 id="Minor-GC日志"><a href="#Minor-GC日志" class="headerlink" title="Minor GC日志"></a>Minor GC日志</h4><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210720100250419.png" srcset="/img/loading.gif" lazyload alt="image-20210720100250419"></p>
<h4 id="Full-GC日志"><a href="#Full-GC日志" class="headerlink" title="Full GC日志"></a>Full GC日志</h4><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210720100328546.png" srcset="/img/loading.gif" lazyload alt="image-20210720100328546"></p>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAllocation</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">byte</span> [] allocation1, allocation2, allocation3, allocation4;<br>    allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];<br>    allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];<br>    allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];<br>    allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span> *_1MB];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    testAllocation();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>设置JVM参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-Xms10m -Xmx10m -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure>

<p><strong>图示</strong></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210720101832143.png" srcset="/img/loading.gif" lazyload alt="image-20210720101832143"></p>
<hr>
<h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><h3 id="4-1-类文件结构"><a href="#4-1-类文件结构" class="headerlink" title="4.1 类文件结构"></a>4.1 类文件结构</h3><p>HelloWorld.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HelloWorld 示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行<code>javac -parameters -d . HellowWorld.java</code><br>编译为<code>HelloWorld.class</code>后是这个样子的：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@localhost ~]<span class="hljs-comment"># od -t xC HelloWorld.class</span><br>0000000 ca fe ba be<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>34<span class="hljs-number"> 00 </span>23 0a<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 00 </span>15 09<br>0000020<span class="hljs-number"> 00 </span>16<span class="hljs-number"> 00 </span>17<span class="hljs-number"> 08 </span>00<span class="hljs-number"> 18 </span>0a<span class="hljs-number"> 00 </span>19<span class="hljs-number"> 00 </span>1a<span class="hljs-number"> 07 </span>00 1b 07<br>0000040<span class="hljs-number"> 00 </span>1c<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 06 </span>3c<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 69 </span>74 3e<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 03 </span>28 29<br>0000060<span class="hljs-number"> 56 </span>01<span class="hljs-number"> 00 </span>04<span class="hljs-number"> 43 </span>6f<span class="hljs-number"> 64 </span>65<span class="hljs-number"> 01 </span>00 0f 4c<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 65 </span>4e<br>0000100<span class="hljs-number"> 75 </span>6d<span class="hljs-number"> 62 </span>65<span class="hljs-number"> 72 </span>54<span class="hljs-number"> 61 </span>62 6c<span class="hljs-number"> 65 </span>01<span class="hljs-number"> 00 </span>12 4c 6f 63<br>0000120<span class="hljs-number"> 61 </span>6c<span class="hljs-number"> 56 </span>61<span class="hljs-number"> 72 </span>69<span class="hljs-number"> 61 </span>62 6c<span class="hljs-number"> 65 </span>54<span class="hljs-number"> 61 </span>62 6c<span class="hljs-number"> 65 </span>01<br>0000140<span class="hljs-number"> 00 </span>04<span class="hljs-number"> 74 </span>68<span class="hljs-number"> 69 </span>73<span class="hljs-number"> 01 </span>00 1d 4c<span class="hljs-number"> 63 </span>6e 2f<span class="hljs-number"> 69 </span>74 63<br>0000160<span class="hljs-number"> 61 </span>73<span class="hljs-number"> 74 </span>2f 6a<span class="hljs-number"> 76 </span>6d 2f<span class="hljs-number"> 74 </span>35 2f<span class="hljs-number"> 48 </span>65 6c 6c 6f<br>0000200<span class="hljs-number"> 57 </span>6f<span class="hljs-number"> 72 </span>6c<span class="hljs-number"> 64 </span>3b<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 04 </span>6d<span class="hljs-number"> 61 </span>69 6e<span class="hljs-number"> 01 </span>00 16<br>0000220<span class="hljs-number"> 28 </span>5b 4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74 72<br>0000240<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 67 </span>3b<span class="hljs-number"> 29 </span>56<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 04 </span>61<span class="hljs-number"> 72 </span>67<span class="hljs-number"> 73 </span>01<span class="hljs-number"> 00 </span>13<br>0000260 5b 4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74<span class="hljs-number"> 72 </span>69<br>0000300 6e<span class="hljs-number"> 67 </span>3b<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 10 </span>4d<span class="hljs-number"> 65 </span>74<span class="hljs-number"> 68 </span>6f<span class="hljs-number"> 64 </span>50<span class="hljs-number"> 61 </span>72 61<br>0000320 6d<span class="hljs-number"> 65 </span>74<span class="hljs-number"> 65 </span>72<span class="hljs-number"> 73 </span>01<span class="hljs-number"> 00 </span>0a<span class="hljs-number"> 53 </span>6f<span class="hljs-number"> 75 </span>72<span class="hljs-number"> 63 </span>65 46<br>0000340<span class="hljs-number"> 69 </span>6c<span class="hljs-number"> 65 </span>01<span class="hljs-number"> 00 </span>0f<span class="hljs-number"> 48 </span>65 6c 6c 6f<span class="hljs-number"> 57 </span>6f<span class="hljs-number"> 72 </span>6c 64<br>0000360 2e 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>0c<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 00 </span>08<span class="hljs-number"> 07 </span>00 1d 0c<span class="hljs-number"> 00 </span>1e<br>0000400<span class="hljs-number"> 00 </span>1f<span class="hljs-number"> 01 </span>00 0b<span class="hljs-number"> 68 </span>65 6c 6c 6f<span class="hljs-number"> 20 </span>77 6f<span class="hljs-number"> 72 </span>6c 64<br>0000420<span class="hljs-number"> 07 </span>00<span class="hljs-number"> 20 </span>0c<span class="hljs-number"> 00 </span>21<span class="hljs-number"> 00 </span>22<span class="hljs-number"> 01 </span>00 1b<span class="hljs-number"> 63 </span>6e 2f<span class="hljs-number"> 69 </span>74<br>0000440<span class="hljs-number"> 63 </span>61<span class="hljs-number"> 73 </span>74 2f 6a<span class="hljs-number"> 76 </span>6d 2f<span class="hljs-number"> 74 </span>35 2f<span class="hljs-number"> 48 </span>65 6c 6c<br>0000460 6f<span class="hljs-number"> 57 </span>6f<span class="hljs-number"> 72 </span>6c<span class="hljs-number"> 64 </span>01<span class="hljs-number"> 00 </span>10 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c 61<br>0000500 6e<span class="hljs-number"> 67 </span>2f 4f<span class="hljs-number"> 62 </span>6a<span class="hljs-number"> 65 </span>63<span class="hljs-number"> 74 </span>01<span class="hljs-number"> 00 </span>10 6a<span class="hljs-number"> 61 </span>76 61<br>0000520 2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>79<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 65 </span>6d<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 03 </span>6f<br>0000540<span class="hljs-number"> 75 </span>74<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 15 </span>4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f<span class="hljs-number"> 69 </span>6f 2f<span class="hljs-number"> 50 </span>72<br>0000560<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 74 </span>53<span class="hljs-number"> 74 </span>72<span class="hljs-number"> 65 </span>61 6d 3b<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 13 </span>6a<span class="hljs-number"> 61 </span>76<br>0000600<span class="hljs-number"> 61 </span>2f<span class="hljs-number"> 69 </span>6f 2f<span class="hljs-number"> 50 </span>72<span class="hljs-number"> 69 </span>6e<span class="hljs-number"> 74 </span>53<span class="hljs-number"> 74 </span>72<span class="hljs-number"> 65 </span>61 6d<br>0000620<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 07 </span>70<span class="hljs-number"> 72 </span>69 6e<span class="hljs-number"> 74 </span>6c 6e<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 15 </span>28 4c 6a<br>0000640<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74<span class="hljs-number"> 72 </span>69 6e<span class="hljs-number"> 67 </span>3b<br>0000660<span class="hljs-number"> 29 </span>56<span class="hljs-number"> 00 </span>21<span class="hljs-number"> 00 </span>05<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>01<br>0000700<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 00 </span>08<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>2f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>01<br>0000720<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>05 2a b7<span class="hljs-number"> 00 </span>01 b1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>0a 00<br>0000740<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 06 </span>00<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 04 </span>00 0b<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>0c 00<br>0000760<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 05 </span>00 0c<span class="hljs-number"> 00 </span>0d<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>0e 00<br>0001000 0f<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>37<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00 00<br>0001020<span class="hljs-number"> 09 </span>b2<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 12 </span>03 b6<span class="hljs-number"> 00 </span>04 b1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>0a<br>0001040<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>0a<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 00 </span>08<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 00 </span>0b<br>0001060<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>0c<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>09<span class="hljs-number"> 00 </span>10<span class="hljs-number"> 00 </span>11<span class="hljs-number"> 00 </span>00<br>0001100<span class="hljs-number"> 00 </span>12<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>05<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 10 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 13 </span>00<br>0001120<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 02 </span>00 14<br></code></pre></td></tr></table></figure>

<p>根据 JVM 规范，<strong>类文件结构</strong>如下</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs abnf">u4 			   magic<span class="hljs-comment">;</span><br>u2             minor_version<span class="hljs-comment">;    </span><br>u2             major_version<span class="hljs-comment">;    </span><br>u2             constant_pool_count<span class="hljs-comment">;    </span><br>cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>]<span class="hljs-comment">;    </span><br>u2             access_flags<span class="hljs-comment">;    </span><br>u2             this_class<span class="hljs-comment">;    </span><br>u2             super_class<span class="hljs-comment">;   </span><br>u2             interfaces_count<span class="hljs-comment">;    </span><br>u2             interfaces[interfaces_count]<span class="hljs-comment">;   </span><br>u2             fields_count<span class="hljs-comment">;    </span><br>field_info     fields[fields_count]<span class="hljs-comment">;   </span><br>u2             methods_count<span class="hljs-comment">;    </span><br>method_info    methods[methods_count]<span class="hljs-comment">;    </span><br>u2             attributes_count<span class="hljs-comment">;    </span><br>attribute_info attributes[attributes_count]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>u数字：代表字节数</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th>长度</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>魔数</td>
<td>u4</td>
<td>magic</td>
<td>魔数,识别Class文件格式</td>
<td>4个字节</td>
<td>1</td>
</tr>
<tr>
<td>版本号</td>
<td>u2</td>
<td>minor_version</td>
<td>副版本号(小版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>u2</td>
<td>major_version</td>
<td>主版本号(大版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>常量池集合</td>
<td>u2</td>
<td>constant_pool_count</td>
<td>常量池计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>cp_info</td>
<td>constant_pool</td>
<td>常量池表</td>
<td>n个字节</td>
<td>constant_pool_count- 1</td>
</tr>
<tr>
<td>访问标识</td>
<td>u2</td>
<td>access_flags</td>
<td>访问标识</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>索引集合</td>
<td>u2</td>
<td>this_class</td>
<td>类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>u2</td>
<td>super_class</td>
<td>父类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>u2</td>
<td>interfaces_count</td>
<td>接口计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>u2</td>
<td>interfaces</td>
<td>接口索引集合</td>
<td>2个字节</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>字段表集合</td>
<td>u2</td>
<td>fields_count</td>
<td>字段计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>field_info</td>
<td>fields</td>
<td>字段表</td>
<td>n个字节</td>
<td>fields_count</td>
</tr>
<tr>
<td>方法表集合</td>
<td>u2</td>
<td>methods_count</td>
<td>方法计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>method_info</td>
<td>methods</td>
<td>方法表</td>
<td>n个字节</td>
<td>methods_count</td>
</tr>
<tr>
<td>属性表集合</td>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>attribute_info</td>
<td>attributes</td>
<td>属性表</td>
<td>n个字节</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<hr>
<h4 id="Class文件数据类型"><a href="#Class文件数据类型" class="headerlink" title="Class文件数据类型"></a>Class文件数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>定义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>无符号数</td>
<td>无符号数可以用来描述数字、索引引用、数量值或按照utf-8编码构成的字符串值。</td>
<td>其中无符号数属于基本的数据类型。 以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节</td>
</tr>
<tr>
<td>表</td>
<td>表是由多个无符号数或其他表构成的复合数据结构。</td>
<td>所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td>
</tr>
</tbody></table>
<hr>
<h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>u4 magic;</p>
<p>对应字节码文件的0~3个字节（一个16进制数可以用4位表示，相当于半个字节）</p>
<p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<ul>
<li><p>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符。</p>
</li>
<li><p>魔数值固定为0xCAFEBABE。不会改变。</p>
</li>
</ul>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>u2 minor_version;</p>
<p>u2 major_version;</p>
<p>对应字节码文件的4~7个字节</p>
<p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p>
<p>H 34 = 52，代表JDK8</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>Class文件使用了一个前置的容量计数器（<strong>constant_pool_count</strong>）加若干个连续的数据项（<strong>constant_pool</strong>）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2（无符号数）</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info（表）</td>
<td>constant_pool</td>
<td>constant_pool_count - 1</td>
</tr>
</tbody></table>
<h5 id="常量池计数器"><a href="#常量池计数器" class="headerlink" title="常量池计数器"></a>常量池计数器</h5><ul>
<li><p>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</p>
</li>
<li><p>常量池容量计数值（u2类型）：从1开始，表示常量池中有多少项常量。即constant_pool_count=1表示常量池中有0个常量项。</p>
</li>
</ul>
<p>u2  constant_pool_count;   </p>
<p>对应字节码文件的8~9个字节</p>
<p>0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09</p>
<p>H 23 = 35，代表常量池中有35个项目，#1~#34项，注意 #0 项不计入，也没有值（从#1开始）</p>
<blockquote>
<p>为什么要空出0</p>
<p>这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值0来表示。</p>
</blockquote>
<h5 id="常量池表"><a href="#常量池表" class="headerlink" title="常量池表"></a>常量池表</h5><p>constant_pool是一种表结构，以1 ~ constant_pool_count - 1为索引。表明了后面有多少个常量项。</p>
<p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）</p>
<p>它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte（标记字节、标签字节）。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志/标识（十进制）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_Utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li><p>这14种常量项结构的共同点是：表开始的第一位是一个u1类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</p>
</li>
<li><p>在常量池列表中，CONSTANT_Utf8_info常量项是一种使用改进过的UTF-8编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</p>
</li>
<li><p>这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_Utf8_info占用字节不固定，其大小由length决定。为什么呢？因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过utf-8编码，就可以知道其长度。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用Class文件空间最大的数据项目之一。</p>
</li>
<li><p>常量池中为什么要包含这些内容？Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
</li>
</ul>
</blockquote>
<h5 id="字面量和符号引用"><a href="#字面量和符号引用" class="headerlink" title="字面量和符号引用"></a>字面量和符号引用</h5><p>在对这些常量解读前，我们需要搞清楚几个概念。</p>
<p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。如下表：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>具体的常量</th>
</tr>
</thead>
<tbody><tr>
<td>字面量</td>
<td>文本字符串</td>
</tr>
<tr>
<td></td>
<td>声明为final的常量值</td>
</tr>
<tr>
<td>符号引用</td>
<td>类和接口的全限定名</td>
</tr>
<tr>
<td></td>
<td>字段的名称和描述符</td>
</tr>
<tr>
<td></td>
<td>方法的名称和描述符</td>
</tr>
</tbody></table>
<p><strong>全限定名</strong></p>
<p>top/igotcha/test/Demo这个就是类的全限定名，仅仅是把包名的“.“替换成”/”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。</p>
<p><strong>简单名称</strong></p>
<p>简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的add()方法和num字段的简单名称分别是add和num。</p>
<p><strong>描述符</strong></p>
<p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见下表：</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表void类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：<code>double[] is [D</code></td>
</tr>
</tbody></table>
<p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法java.lang.String tostring()的描述符为()Ljava/lang/String; ，方法int abc(int[]x, int y)的描述符为([II)I。</p>
<blockquote>
<p>虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息。因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再<strong>在类加载过程中的解析阶段将其替换为直接引用</strong>，并翻译到具体的内存地址中。</p>
</blockquote>
<ul>
<li><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。</p>
</li>
<li><p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</p>
</li>
</ul>
<hr>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>0000000 ca fe ba be 00 00 00 34 00 23 <strong>0a</strong> 00 06 00 15 09</p>
<p><strong>第#1项</strong>，H 0a = 10，查表得知，10 表示 Method 信息（方法信息长度固定四个字节）</p>
<p>0000000 ca fe ba be 00 00 00 34 00 23 0a <strong>00 06 00 15</strong> 09</p>
<p>H 00 06 = 6 ，H 00 15= 21， 表示它引用了常量池中 #6 和 #21 项来获得这个方法的【所属类】和【方法名】</p>
<p>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 <strong>09</strong></p>
<p><strong>第#2项</strong> ，H 09 = 9 ，查表得知，9表示 Field 信息（成员变量信息长度固定四个字节）</p>
<p>0000020 <strong>00 16 00 17</strong> 08 00 18 0a 00 19 00 1a 07 00 1b 07</p>
<p>H 00 16 = 22 ，H 00 17 = 23 ，表示它引用了常量池中 #22 和 # 23 项来获得这个成员变量的【所属类】和【成员变量名】</p>
<p>0000020 00 16 00 17 **08 **00 18 0a 00 19 00 1a 07 00 1b 07</p>
<p><strong>第#3项</strong>，H 08 = 8 ，查表得知，8表示字符串常量名称（字符串常量信息长度固定两个字节）</p>
<p>0000020 00 16 00 17 08 <strong>00 18</strong> 0a 00 19 00 1a 07 00 1b 07</p>
<p>H 00 18 = 24，表示它引用了常量池中 #24 项</p>
<p>0000020 00 16 00 17 08 00 18 <strong>0a</strong> 00 19 00 1a 07 00 1b 07</p>
<p><strong>第#4项</strong>，H 0a = 10，查表得知，10 表示 Method 信息（方法信息长度固定四个字节）</p>
<p>0000020 00 16 00 17 08 00 18 0a <strong>00 19 00 1a</strong> 07 00 1b 07</p>
<p>H 00 19 = 25 ，H 00 1a = 26， 表示它引用了常量池中 #6 和 #21 项来获得这个方法的【所属类】和【方法名】</p>
<p>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a <strong>07</strong> 00 1b 07</p>
<p><strong>第#5项</strong>，H 07 = 7，查表得知，7 表示 Class信息（类信息长度固定两个字节）</p>
<p>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 <strong>00 1b</strong> 07</p>
<p>H 00 1b = 27， 表示它引用了常量池中 #27 项</p>
<p>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b <strong>07</strong></p>
<p><strong>第#6项</strong>，H 07 = 7，查表得知，7 表示 Class信息（类信息长度固定两个字节）<br>0000040 <strong>00 1c</strong> 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p>
<p>H 00 1c = 28， 表示它引用了常量池中 #28 项</p>
<p>0000040 00 1c <strong>01</strong> 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p>
<p><strong>第#7项</strong>，H 01 = 1，查表得知，1 表示 utf8 串</p>
<p>0000040 00 1c 01 <strong>00 06</strong> 3c 69 6e 69 74 3e 01 00 03 28 29</p>
<p>H 00 06  = 6 表示长度是6个字节</p>
<p>0000040 00 1c 01 00 06 <strong>3c 69 6e 69 74 3e</strong> 01 00 03 28 29</p>
<p>H 3c 69 6e 69 74 3e 是<init> </init></p>
<p>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e <strong>01</strong> 00 03 28 29</p>
<p><strong>第#8项</strong>，H 01 = 1，查表得知，1 表示 utf8 串</p>
<p>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01<strong>00 03</strong> 28 29</p>
<p>H 00 03  = 3 表示长度是3个字节</p>
<p>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 <strong>28 29</strong><br>0000060 <strong>56</strong> 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p>
<p>H 28 29 56 是 ()V，表示无参、无返回值</p>
<p>………………略</p>
<p>参考文献：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
<hr>
<h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p><strong>访问标识（access_flag、访问标志、访问标记）</strong></p>
<p>在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。各种访问标记如下所示：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>标志为public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>标志被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody></table>
<p>类的访问权限通常为ACC_开头的常量。</p>
<p>每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类，则该标记为ACC_PUBLIC | ACC_FINAL。</p>
<p>使用ACC_SUPER可以让类更准确地定位到父类的方法super.method()，现代编译器都会设置并且使用这个标记。</p>
<blockquote>
<p><strong>补充说明：</strong></p>
<ol>
<li> 带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。 </li>
</ol>
<ul>
<li><p>如果一个class文件被设置了ACC_INTERFACE标志，那么同时也得设置ACC_ABSTRACT标志。同时它不能再设置ACC_FINAL、ACC_SUPER 或ACC_ENUM标志。</p>
</li>
<li><p>如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表中除ACC_ANNOTATION外的其他所有标志。当然，ACC_FINAL和ACC_ABSTRACT这类互斥的标志除外。这两个标志不得同时设置。</p>
</li>
</ul>
<ol start="2">
<li>ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。针对Java虚拟机指令集的编译器都应当设置这个标志。对于Java SE 8及后续版本来说，无论class文件中这个标志的实际值是什么，也不管class文件的版本号是多少，Java虚拟机都认为每个class文件均设置了ACC_SUPER标志。 </li>
</ol>
<ul>
<li>ACC_SUPER标志是为了向后兼容由旧Java编译器所编译的代码而设计的。目前的ACC_SUPER标志在由JDK1.0.2之前的编译器所生成的access_flags中是没有确定含义的，如果设置了该标志，那么0racle的Java虚拟机实现会将其忽略</li>
</ul>
<ol start="3">
<li> ACC_SYNTHETIC标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。 </li>
<li>注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，那么也必须设置ACC_INTERFACE标志。 </li>
<li>ACC_ENUM标志表明该类或其父类为枚举类型。 </li>
</ol>
</blockquote>
<hr>
<h4 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h4><p>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>this_class</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count]</td>
</tr>
</tbody></table>
<p>这三项数据来确定这个类的继承关系：</p>
<ul>
<li><p>类索引用于确定这个类的全限定名</p>
</li>
<li><p>父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为空。</p>
</li>
<li><p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</p>
</li>
</ul>
<h5 id="this-class（类索引）"><a href="#this-class（类索引）" class="headerlink" title="this_class（类索引）"></a>this_class（类索引）</h5><p>2字节无符号整数，指向常量池的索引。它提供了类的全限定名，如top/igotcha/java/Demo。this_class的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为CONSTANT_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口。</p>
<h5 id="super-class（父类索引）"><a href="#super-class（父类索引）" class="headerlink" title="super_class（父类索引）"></a>super_class（父类索引）</h5><p>2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是java/lang/object类。同时，由于Java不支持多继承，所以其父类只有一个。</p>
<p>super_class指向的父类不能是final。</p>
<h5 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h5><p>指向常量池索引集合，它提供了一个符号引用到所有已实现的接口</p>
<p>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的CONSTANT_Class（当然这里就必须是接口，而不是类）。</p>
<h6 id="Ⅰ-interfaces-count（接口计数器）"><a href="#Ⅰ-interfaces-count（接口计数器）" class="headerlink" title="Ⅰ. interfaces_count（接口计数器）"></a>Ⅰ. interfaces_count（接口计数器）</h6><p>interfaces_count项的值表示当前类或接口继承/实现的接口数量。</p>
<h6 id="Ⅱ-interfaces-（接口索引集合）"><a href="#Ⅱ-interfaces-（接口索引集合）" class="headerlink" title="Ⅱ. interfaces[]（接口索引集合）"></a>Ⅱ. interfaces[]（接口索引集合）</h6><p>interfaces[]中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为interfaces_count。每个成员interfaces[i]必须为CONSTANT_Class_info结构，其中0 &lt;= i &lt; interfaces_count。在interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口。</p>
<hr>
<h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p><strong>fields</strong></p>
<p>用于描述接口或类中声明的变量。字段（field）包括<strong>类级变量</strong>以及<strong>实例级变量</strong>，但是不包括方法内部、代码块内部声明的局部变量。</p>
<p>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>
<p>它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符（public、private或protected）、是类变量还是实例变量（static修饰符）、是否是常量（final修饰符）等。</p>
<blockquote>
<p> <strong>注意：</strong></p>
<ul>
<li><p>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p>
</li>
<li><p>在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</p>
</li>
</ul>
</blockquote>
<h5 id="字段计数器"><a href="#字段计数器" class="headerlink" title="字段计数器"></a>字段计数器</h5><p><strong>fields_count（字段计数器）</strong></p>
<p>fields_count的值表示当前class文件fields表的成员个数。使用两个字节来表示。</p>
<p>fields表中每个成员都是一个field_info结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>字段名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<h5 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h5><h6 id="Ⅰ-字段表访问标识"><a href="#Ⅰ-字段表访问标识" class="headerlink" title="Ⅰ. 字段表访问标识"></a>Ⅰ. 字段表访问标识</h6><p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static修饰符、final修饰符、volatile修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>字段是否为public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>字段是否为private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>字段是否为protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>字段是否为final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>字段是否为volatile</td>
</tr>
<tr>
<td>ACC_TRANSTENT</td>
<td>0x0080</td>
<td>字段是否为transient</td>
</tr>
<tr>
<td>ACC_SYNCHETIC</td>
<td>0x1000</td>
<td>字段是否为由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>字段是否为enum</td>
</tr>
</tbody></table>
<h6 id="Ⅱ-描述符索引"><a href="#Ⅱ-描述符索引" class="headerlink" title="Ⅱ. 描述符索引"></a>Ⅱ. 描述符索引</h6><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte，char，double，float，int，long，short，boolean）及代表无返回值的void类型都用一个大写字符来表示，而对象则用字符L加对象的全限定名来表示，如下所示：</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表void类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody></table>
<h6 id="Ⅲ-属性表集合"><a href="#Ⅲ-属性表集合" class="headerlink" title="Ⅲ. 属性表集合"></a>Ⅲ. 属性表集合</h6><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在attribute_count中，属性具体内容存放在attributes数组中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 以常量属性为例，结构为：</span><br>ConstantValue_attribute&#123;<br>	u2 attribute_name_index;<br>	u4 attribute_length;<br>    u2 constantvalue_index;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>对于常量属性而言，attribute_length值恒为2。</p>
</blockquote>
<hr>
<h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><p>methods：指向常量池索引集合，它完整描述了每个方法的签名。</p>
<ul>
<li><p>在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private或protected），方法的返回值类型以及方法的参数信息等。</p>
</li>
<li><p>如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来。</p>
</li>
<li><p>一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法<code>&lt;clinit&gt;()</code>和实例初始化方法<code>&lt;init&gt;()</code>）。</p>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，<strong>特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合</strong>，也就是因为返回值不会包含在特征签名之中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中。</p>
<p>也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p>
</blockquote>
<h5 id="方法计数器"><a href="#方法计数器" class="headerlink" title="方法计数器"></a>方法计数器</h5><p><strong>methods_count（方法计数器）</strong></p>
<p>methods_count的值表示当前class文件methods表的成员个数。使用两个字节来表示。</p>
<p>methods表中每个成员都是一个method_info结构。</p>
<h5 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h5><p><strong>methods[]（方法表）</strong></p>
<p>methods表中的每个成员都必须是一个method_info结构，用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access_flags项既没有设置ACC_NATIVE标志也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。</p>
<p>method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</p>
<p>方法表的结构实际跟字段表是一样的，方法表结构如下：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>方法名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p><strong>方法表访问标志</strong></p>
<p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，方法可以从包外访问</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，方法只能本类访问</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态方法</td>
</tr>
</tbody></table>
<h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>方法表集合之后的属性表集合，指的是class文件所携带的辅助信息，比如该class文件的源文件的名称。以及任何带有RetentionPolicy.CLASS 或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解。</p>
<p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p>
<p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性。</p>
<h5 id="属性计数器"><a href="#属性计数器" class="headerlink" title="属性计数器"></a>属性计数器</h5><p><strong>attributes_count（属性计数器）</strong></p>
<p>attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是一个attribute_info结构。</p>
<h5 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h5><p><strong>attributes[]（属性表）</strong></p>
<p>属性表的每个项的值必须是attribute_info结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p>
<p><strong>属性的通用格式</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
<td>属性表</td>
</tr>
</tbody></table>
<p><strong>属性类型</strong></p>
<p>属性表实际上可以有很多类型，上面看到的Code属性只是其中一种，Java8里面定义了23种属性。下面这些是虚拟机中预定义的属性：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>方法表</td>
<td>Java代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final关键字定义的常量池</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类，方法，字段表</td>
<td>被声明为deprecated的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EnclosingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td>InnerClass</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code属性</td>
<td>Java源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code属性</td>
<td>方法的局部变量描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code属性</td>
<td>JDK1.6中新增的属性，供新的类型检查检验器和处理目标方法的局部变量和操作数有所需要的类是否匹配</td>
</tr>
<tr>
<td>Signature</td>
<td>类，方法表，字段表</td>
<td>用于支持泛型情况下的方法签名</td>
</tr>
<tr>
<td>SourceFile</td>
<td>类文件</td>
<td>记录源文件名称</td>
</tr>
<tr>
<td>SourceDebugExtension</td>
<td>类文件</td>
<td>用于存储额外的调试信息</td>
</tr>
<tr>
<td>Synthetic</td>
<td>类，方法表，字段表</td>
<td>标志方法或字段为编译器自动生成的</td>
</tr>
<tr>
<td>LocalVariableTypeTable</td>
<td>类</td>
<td>是哟很难过特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations</td>
<td>类，方法表，字段表</td>
<td>为动态注解提供支持</td>
</tr>
<tr>
<td>RuntimeInvisibleAnnotations</td>
<td>类，方法表，字段表</td>
<td>用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td>RuntimeVisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与RuntimeVisibleAnnotations属性类似，只不过作用对象或方法</td>
</tr>
<tr>
<td>RuntimeInvisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与RuntimeInvisibleAnnotations属性类似，只不过作用对象或方法</td>
</tr>
<tr>
<td>AnnotationDefault</td>
<td>方法表</td>
<td>用于记录注解类元素的默认值</td>
</tr>
<tr>
<td>BootstrapMethods</td>
<td>类文件</td>
<td>用于保存invokeddynamic指令引用的引导方法限定符</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-2-字节码指令"><a href="#4-2-字节码指令" class="headerlink" title="4.2 字节码指令"></a>4.2 字节码指令</h3><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><p><code>public cn.itcast.jvm.t5.HelloWorld();</code> 构造方法的字节码指令</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2a</span> b<span class="hljs-number">7</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> b<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<ul>
<li>2a =&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数</li>
<li>b7 =&gt; invokespecial 预备调用构造方法</li>
<li>00 01 引用常量池中 #1 项，即【Method java/lang/Object.”<init>“:()V 】</init></li>
<li>b1 表示返回</li>
</ul>
<h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><p><code>public static void main(java.lang.String[]); </code>主方法的字节码指令</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">b2</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">12</span> <span class="hljs-number">03</span> b<span class="hljs-number">6</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> b<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<ul>
<li>b2 =&gt; getstatic 用来加载静态变量</li>
<li>00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】</li>
<li>12 =&gt; ldc 加载参数</li>
<li>03 引用常量池中 #3 项，即 【String hello world】</li>
<li>b6 =&gt; invokevirtual 预备调用成员方法</li>
<li>00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】</li>
<li>b1 表示返回</li>
</ul>
<p>参考文献：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p>
<h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 javap 工具来反编译 class 文件</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs clean">[root@localhost ~]# javap -v HelloWorld.<span class="hljs-keyword">class</span><br>Classfile /root/HelloWorld.<span class="hljs-keyword">class</span><br>	Last modified Jul <span class="hljs-number">7</span>, <span class="hljs-number">2019</span>; size <span class="hljs-number">597</span> bytes<br>	MD5 checksum <span class="hljs-number">361</span>dca1c3f4ae38644a9cd5060ac6dbc<br>	Compiled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;HelloWorld.java&quot;</span><br>public <span class="hljs-keyword">class</span> cn.itcast.jvm.t5.HelloWorld<br>	minor version: <span class="hljs-number">0</span><br>	major version: <span class="hljs-number">52</span><br>	flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>	#<span class="hljs-number">1</span> = Methodref #<span class="hljs-number">6.</span>#<span class="hljs-number">21</span> <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>	#<span class="hljs-number">2</span> = Fieldref #<span class="hljs-number">22.</span>#<span class="hljs-number">23</span> <span class="hljs-comment">//java/lang/System.out:Ljava/io/PrintStream;</span><br>	#<span class="hljs-number">3</span> = String #<span class="hljs-number">24</span> <span class="hljs-comment">// hello world</span><br>	#<span class="hljs-number">4</span> = Methodref #<span class="hljs-number">25.</span>#<span class="hljs-number">26</span> <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>	#<span class="hljs-number">5</span> = Class #<span class="hljs-number">27</span> <span class="hljs-comment">// cn/itcast/jvm/t5/HelloWorld</span><br>	#<span class="hljs-number">6</span> = Class #<span class="hljs-number">28</span> <span class="hljs-comment">// java/lang/Object</span><br>	#<span class="hljs-number">7</span> = Utf8 &lt;init&gt;<br>	#<span class="hljs-number">8</span> = Utf8 ()V<br>	#<span class="hljs-number">9</span> = Utf8 Code<br>	#<span class="hljs-number">10</span> = Utf8 LineNumberTable<br>	#<span class="hljs-number">11</span> = Utf8 LocalVariableTable<br>	#<span class="hljs-number">12</span> = Utf8 this<br>	#<span class="hljs-number">13</span> = Utf8 Lcn/itcast/jvm/t5/HelloWorld;<br>    #<span class="hljs-number">14</span> = Utf8 main<br> 	#<span class="hljs-number">15</span> = Utf8 (Ljava/lang/String;)V<br>	#<span class="hljs-number">16</span> = Utf8 args<br>	#<span class="hljs-number">17</span> = Utf8 [Ljava/lang/String;<br>	#<span class="hljs-number">18</span> = Utf8 MethodParameters<br>	#<span class="hljs-number">19</span> = Utf8 SourceFile<br>	#<span class="hljs-number">20</span> = Utf8 HelloWorld.java<br>	#<span class="hljs-number">21</span> = NameAndType #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span> <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>	#<span class="hljs-number">22</span> = Class #<span class="hljs-number">29</span> <span class="hljs-comment">// java/lang/System</span><br>	#<span class="hljs-number">23</span> = NameAndType #<span class="hljs-number">30</span>:#<span class="hljs-number">31</span> <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>	#<span class="hljs-number">24</span> = Utf8 hello world<br>	#<span class="hljs-number">25</span> = Class #<span class="hljs-number">32</span> <span class="hljs-comment">// java/io/PrintStream</span><br>	#<span class="hljs-number">26</span> = NameAndType #<span class="hljs-number">33</span>:#<span class="hljs-number">34</span> <span class="hljs-comment">// println:(Ljava/lang/String;)V</span><br>	#<span class="hljs-number">27</span> = Utf8 cn/itcast/jvm/t5/HelloWorld<br>	#<span class="hljs-number">28</span> = Utf8 java/lang/Object<br>	#<span class="hljs-number">29</span> = Utf8 java/lang/System<br>	#<span class="hljs-number">30</span> = Utf8 out<br>	#<span class="hljs-number">31</span> = Utf8 Ljava/io/PrintStream;<br>	#<span class="hljs-number">32</span> = Utf8 java/io/PrintStream<br>	#<span class="hljs-number">33</span> = Utf8 println<br>	#<span class="hljs-number">34</span> = Utf8 (Ljava/lang/String;)V<br>&#123;<br>	public cn.itcast.jvm.t5.HelloWorld();<br>		descriptor: ()V<br>		flags: ACC_PUBLIC<br>		Code:<br>			stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>				<span class="hljs-number">0</span>: aload_0<br>				<span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span> <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>				<span class="hljs-number">4</span>: return<br>			LineNumberTable:<br>				line <span class="hljs-number">4</span>: <span class="hljs-number">0</span><br>			LocalVariableTable:<br>				Start Length Slot Name 		Signature<br>				  <span class="hljs-number">0</span>	    <span class="hljs-number">5</span> 	   <span class="hljs-number">0</span>  this	 Lcn/itcast/jvm/t5/HelloWorld;<br>	public static void main(java.lang.String[]);<br>		descriptor: ([Ljava/lang/String;)V<br>		flags: ACC_PUBLIC, ACC_STATIC<br>		Code:<br>			stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>				<span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>				<span class="hljs-number">3</span>: ldc #<span class="hljs-number">3</span> <span class="hljs-comment">// String hello world</span><br>				<span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">4</span> <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>				<span class="hljs-number">8</span>: return<br>			LineNumberTable:<br>				line <span class="hljs-number">6</span>: <span class="hljs-number">0</span><br>				line <span class="hljs-number">7</span>: <span class="hljs-number">8</span><br>			LocalVariableTable:<br>				Start Length Slot Name 		Signature<br>				  <span class="hljs-number">0</span> 	<span class="hljs-number">9</span> 	  <span class="hljs-number">0</span>   args	 [Ljava/lang/String;<br>			MethodParameters:<br>				Name	 Flags<br>				args<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> &#123;</span>    <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        <br>		<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <br>		<span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;        <br>		<span class="hljs-keyword">int</span> c = a + b;        <br>		System.out.<span class="hljs-built_in">println</span>(c);   <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="常量池载入运行时常量池"><a href="#常量池载入运行时常量池" class="headerlink" title="常量池载入运行时常量池"></a>常量池载入运行时常量池</h5><p>常量池也属于方法区，只不过这里单独提出来了</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.24.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="方法字节码载入方法区"><a href="#方法字节码载入方法区" class="headerlink" title="方法字节码载入方法区"></a>方法字节码载入方法区</h5><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.25.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="main线程开始运行，分配栈帧内存"><a href="#main线程开始运行，分配栈帧内存" class="headerlink" title="main线程开始运行，分配栈帧内存"></a>main线程开始运行，分配栈帧内存</h5><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.26.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="执行引擎开始执行字节码"><a href="#执行引擎开始执行字节码" class="headerlink" title="执行引擎开始执行字节码"></a>执行引擎开始执行字节码</h5><h6 id="bipush-10"><a href="#bipush-10" class="headerlink" title="bipush 10"></a>bipush 10</h6><ul>
<li>将一个 byte 压入操作数栈（其长度会补齐 4 个字节，因为操作数栈长度是4个字节），类似的指令还有<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li>
</ul>
</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.27.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="istore-1"><a href="#istore-1" class="headerlink" title="istore 1"></a>istore 1</h6><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p>
<p>对应代码中的</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.28.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="ldc-3"><a href="#ldc-3" class="headerlink" title="ldc #3"></a>ldc #3</h6><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p>
<p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.29.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="istore-2"><a href="#istore-2" class="headerlink" title="istore 2"></a>istore 2</h6><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.30.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="iload1-iload2"><a href="#iload1-iload2" class="headerlink" title="iload1 iload2"></a>iload1 iload2</h6><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p>
<ul>
<li>因为只能在操作数栈中执行运算操作</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.31.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="iadd"><a href="#iadd" class="headerlink" title="iadd"></a>iadd</h6><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.32.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="istore-3"><a href="#istore-3" class="headerlink" title="istore 3"></a>istore 3</h6><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.33.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="getstatic-4"><a href="#getstatic-4" class="headerlink" title="getstatic #4"></a>getstatic #4</h6><p>在运行时常量池中找到#4，发现是一个对象</p>
<p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.34.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="iload-3"><a href="#iload-3" class="headerlink" title="iload 3"></a>iload 3</h6><p>将局部变量表中3号位置的元素压入操作数栈中</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.35.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="invokevirtual-5"><a href="#invokevirtual-5" class="headerlink" title="invokevirtual 5"></a>invokevirtual 5</h6><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p>
<p>生成新的栈帧（分配 locals、stack等）</p>
<p>传递参数，执行新栈帧中的字节码</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.36.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>执行完毕，弹出栈帧</p>
<p>清除 main 操作数栈内容</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.37.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="return"><a href="#return" class="headerlink" title="return"></a>return</h6><p>完成 main 方法调用，弹出 main 栈帧，程序结束</p>
<h4 id="从字节码角度分析i-与-i"><a href="#从字节码角度分析i-与-i" class="headerlink" title="从字节码角度分析i++与++i"></a>从字节码角度分析i++与++i</h4><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_2</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>		<span class="hljs-keyword">int</span> b = a++ + ++a + a--;<br>		System.out.println(a);<br>		System.out.println(b);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>字节码</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> static void main(java.lang.String[]);<br>	<span class="hljs-attribute">descriptor</span>: ([Ljava/lang/String;)V<br>	<span class="hljs-attribute">flags</span>: (<span class="hljs-number">0</span>x<span class="hljs-number">0009</span>) ACC_PUBLIC, ACC_STATIC<br>	<span class="hljs-attribute">Code</span>:<br>		<span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>			<span class="hljs-attribute">0</span>: bipush <span class="hljs-number">10</span><br>			<span class="hljs-attribute">2</span>: istore_<span class="hljs-number">1</span><br>			<span class="hljs-attribute">3</span>: iload_<span class="hljs-number">1</span><br>			<span class="hljs-attribute">4</span>: iinc <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>			<span class="hljs-attribute">7</span>: iinc <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>			<span class="hljs-attribute">10</span>: iload_<span class="hljs-number">1</span><br>			<span class="hljs-attribute">11</span>: iadd<br>			<span class="hljs-attribute">12</span>: iload_<span class="hljs-number">1</span><br>			<span class="hljs-attribute">13</span>: iinc <span class="hljs-number">1</span>, -<span class="hljs-number">1</span><br>			<span class="hljs-attribute">16</span>: iadd<br>			<span class="hljs-attribute">17</span>: istore_<span class="hljs-number">2</span><br>			<span class="hljs-attribute">18</span>: getstatic #<span class="hljs-number">2</span> // Field java/lang/System.out:Ljava/io/PrintStream;<br>			<span class="hljs-attribute">21</span>: iload_<span class="hljs-number">1</span><br>			<span class="hljs-attribute">22</span>: invokevirtual #<span class="hljs-number">3</span> // Method java/io/PrintStream.println:(I)V<br>			<span class="hljs-attribute">25</span>: getstatic #<span class="hljs-number">2</span> // Field java/lang/System.out:Ljava/io/PrintStream;<br>			<span class="hljs-attribute">28</span>: iload_<span class="hljs-number">2</span><br>			<span class="hljs-attribute">29</span>: invokevirtual #<span class="hljs-number">3</span> // Method java/io/PrintStream.println:(I)V<br>			<span class="hljs-attribute">32</span>: return<br>		<span class="hljs-attribute">LineNumberTable</span>:<br>			<span class="hljs-attribute">line</span> <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>			<span class="hljs-attribute">line</span> <span class="hljs-number">9</span>: <span class="hljs-number">3</span><br>			<span class="hljs-attribute">line</span> <span class="hljs-number">10</span>: <span class="hljs-number">18</span><br>			<span class="hljs-attribute">line</span> <span class="hljs-number">11</span>: <span class="hljs-number">25</span><br>			<span class="hljs-attribute">line</span> <span class="hljs-number">12</span>: <span class="hljs-number">32</span><br>		<span class="hljs-attribute">LocalVariableTable</span>:<br>			<span class="hljs-attribute">Start</span> Length Slot Name 		Signature<br>			<span class="hljs-attribute">0</span>		<span class="hljs-number">33</span>	  <span class="hljs-number">0</span>	  args <span class="hljs-meta">	[Ljava/lang/String;</span><br><span class="hljs-meta">			3		30 	  1	   a 			I</span><br><span class="hljs-meta">			18 		15	  2	   b		    I</span><br></code></pre></td></tr></table></figure>

<p>注意</p>
<blockquote>
<p>iinc 指令是直接在局部变量 slot 上进行运算，iinc有两个参数，第一个参数是操作哪个solt，第二个参数是自增几<br>a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc</p>
</blockquote>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.38.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.39.png" srcset="/img/loading.gif" lazyload alt="image-20201022125325530"></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.40.png" srcset="/img/loading.gif" lazyload alt="image-20201022125325530"></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.41.png" srcset="/img/loading.gif" lazyload alt="image-20201022125325530"></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.42.png" srcset="/img/loading.gif" lazyload alt="image-20201022125325530"></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.43.png" srcset="/img/loading.gif" lazyload alt="image-20201022125325530"></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.44.png" srcset="/img/loading.gif" lazyload alt="image-20201022125325530"></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.45.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.46.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.47.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.48.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="条件判断指令"><a href="#条件判断指令" class="headerlink" title="条件判断指令"></a>条件判断指令</h4><table>
<thead>
<tr>
<th>指令</th>
<th>助记符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x99</td>
<td>ifeq</td>
<td>判断是否 == 0</td>
</tr>
<tr>
<td>0x9a</td>
<td>ifne</td>
<td>判断是否 != 0</td>
</tr>
<tr>
<td>0x9b</td>
<td>iflt</td>
<td>判断是否 &lt; 0</td>
</tr>
<tr>
<td>0x9c</td>
<td>ifge</td>
<td>判断是否 &gt;= 0</td>
</tr>
<tr>
<td>0x9d</td>
<td>ifgt</td>
<td>判断是否 &gt; 0</td>
</tr>
<tr>
<td>0x9e</td>
<td>ifle</td>
<td>判断是否 &lt;= 0</td>
</tr>
<tr>
<td>0x9f</td>
<td>if_icmpeq</td>
<td>两个int是否 ==</td>
</tr>
<tr>
<td>0xa0</td>
<td>if_icmpne</td>
<td>两个int是否 !=</td>
</tr>
<tr>
<td>0xa1</td>
<td>if_icmplt</td>
<td>两个int是否 &lt;</td>
</tr>
<tr>
<td>0xa2</td>
<td>if_icmpge</td>
<td>两个int是否 &gt;=</td>
</tr>
<tr>
<td>0xa3</td>
<td>if_icmpgt</td>
<td>两个int是否 &gt;</td>
</tr>
<tr>
<td>0xa4</td>
<td>if_icmple</td>
<td>两个int是否 &lt;=</td>
</tr>
<tr>
<td>0xa5</td>
<td>if_acmpeq</td>
<td>两个引用是否 ==</td>
</tr>
<tr>
<td>0xa6</td>
<td>if_acmpne</td>
<td>两个引用是否 !=</td>
</tr>
<tr>
<td>0xc6</td>
<td>ifnull</td>
<td>判断是否 == null</td>
</tr>
<tr>
<td>0xc7</td>
<td>ifnonnull</td>
<td>判断是否 != null</td>
</tr>
</tbody></table>
<ul>
<li>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节</li>
<li>goto 用来进行跳转到指定行号的字节码</li>
</ul>
<blockquote>
<p> long，float，double 的比较<br>参考 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp</a></p>
</blockquote>
<h4 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h4><ul>
<li><code>while</code>和<code>for</code>的字节码，是一样的</li>
</ul>
<h4 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h4><p>理解如下x结果为什么是0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>) &#123;<br>			x = x++;<br>			i++;<br>		&#125;<br>		System.out.println(x); <span class="hljs-comment">//结果为0</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">Code:<br>     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>	<span class="hljs-regexp">//</span>操作数栈分配<span class="hljs-number">2</span>个空间，局部变量表分配<span class="hljs-number">3</span>个空间<br>        <span class="hljs-number">0</span>: iconst_0	<span class="hljs-regexp">//</span>准备一个常数<span class="hljs-number">0</span><br>        <span class="hljs-number">1</span>: istore_1	<span class="hljs-regexp">//</span>将常数<span class="hljs-number">0</span>放入局部变量表的<span class="hljs-number">1</span>号槽位 i=<span class="hljs-number">0</span><br>        <span class="hljs-number">2</span>: iconst_0	<span class="hljs-regexp">//</span>准备一个常数<span class="hljs-number">0</span><br>        <span class="hljs-number">3</span>: istore_2	<span class="hljs-regexp">//</span>将常数<span class="hljs-number">0</span>放入局部变量的<span class="hljs-number">2</span>号槽位 x=<span class="hljs-number">0</span>	<br>        <span class="hljs-number">4</span>: iload_1		<span class="hljs-regexp">//</span>将局部变量表<span class="hljs-number">1</span>号槽位的数放入操作数栈中<br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span>	<span class="hljs-regexp">//</span>将数字<span class="hljs-number">10</span>放入操作数栈中，此时操作数栈中有<span class="hljs-number">2</span>个数<br>        <span class="hljs-number">7</span>: if_icmpge     <span class="hljs-number">21</span>	<span class="hljs-regexp">//</span>比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到<span class="hljs-number">21</span>。<br>        		这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空<br>       <span class="hljs-number">10</span>: iload_2		<span class="hljs-regexp">//</span>将局部变量<span class="hljs-number">2</span>号槽位的数放入操作数栈中，放入的值是<span class="hljs-number">0</span><br>       <span class="hljs-number">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span>	<span class="hljs-regexp">//</span>将局部变量<span class="hljs-number">2</span>号槽位的数加<span class="hljs-number">1</span>，自增后，槽位中的值为<span class="hljs-number">1</span><br>       <span class="hljs-number">14</span>: istore_2	<span class="hljs-regexp">//</span>将操作数栈中的数放入到局部变量表的<span class="hljs-number">2</span>号槽位，<span class="hljs-number">2</span>号槽位的值又变为了<span class="hljs-number">0</span><br>       <span class="hljs-number">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-regexp">//</span><span class="hljs-number">1</span>号槽位的值自增<span class="hljs-number">1</span><br>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">4</span> <span class="hljs-regexp">//</span>跳转到第<span class="hljs-number">4</span>条指令<br>       <span class="hljs-number">21</span>: getstatic     <span class="hljs-comment">#2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">24</span>: iload_2<br>       <span class="hljs-number">25</span>: invokevirtual <span class="hljs-comment">#3                  // Method java/io/PrintStream.println:(I)V</span><br>       <span class="hljs-number">28</span>: return<br></code></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>	<span class="hljs-keyword">static</span> &#123;<br>		i = <span class="hljs-number">20</span>;<br>	&#125;<br>	<span class="hljs-keyword">static</span> &#123;<br>		i = <span class="hljs-number">30</span>;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		System.out.println(i); <span class="hljs-comment">//结果为30</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">stack=1,</span> <span class="hljs-string">locals=0,</span> <span class="hljs-string">args_size=0</span><br>         <span class="hljs-attr">0:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">10</span><br>         <span class="hljs-attr">2:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>         <span class="hljs-attr">5:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">20</span><br>         <span class="hljs-attr">7:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>        <span class="hljs-attr">10:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">30</span><br>        <span class="hljs-attr">12:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>        <span class="hljs-attr">15:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure>

<h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> String a = <span class="hljs-string">&quot;s1&quot;</span>;<br>    <br>	&#123;<br>		b = <span class="hljs-number">20</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br><br>	&#123;<br>		a = <span class="hljs-string">&quot;s2&quot;</span>;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo4</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.a = a;<br>		<span class="hljs-keyword">this</span>.b = b;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Demo4 d = <span class="hljs-keyword">new</span> Demo4(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">30</span>);<br>		System.out.println(d.a);	<span class="hljs-comment">//输出：s3</span><br>		System.out.println(d.b);	<span class="hljs-comment">//输出：30</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Code:</span><br>     <span class="hljs-string">stack=2,</span> <span class="hljs-string">locals=3,</span> <span class="hljs-string">args_size=3</span><br>        <span class="hljs-attr">0:</span> <span class="hljs-string">aload_0</span><br>        <span class="hljs-attr">1:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-attr">4:</span> <span class="hljs-string">aload_0</span><br>        <span class="hljs-attr">5:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#2                  // String s1</span><br>        <span class="hljs-attr">7:</span> <span class="hljs-string">putfield</span>      <span class="hljs-comment">#3                  // Field a:Ljava/lang/String;</span><br>       <span class="hljs-attr">10:</span> <span class="hljs-string">aload_0</span><br>       <span class="hljs-attr">11:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">20</span><br>       <span class="hljs-attr">13:</span> <span class="hljs-string">putfield</span>      <span class="hljs-comment">#4                  // Field b:I</span><br>       <span class="hljs-attr">16:</span> <span class="hljs-string">aload_0</span><br>       <span class="hljs-attr">17:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">10</span><br>       <span class="hljs-attr">19:</span> <span class="hljs-string">putfield</span>      <span class="hljs-comment">#4                  // Field b:I</span><br>       <span class="hljs-attr">22:</span> <span class="hljs-string">aload_0</span><br>       <span class="hljs-attr">23:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#5                  // String s2</span><br>       <span class="hljs-attr">25:</span> <span class="hljs-string">putfield</span>      <span class="hljs-comment">#3                  // Field a:Ljava/lang/String;</span><br>       <span class="hljs-string">//原始构造方法在最后执行</span><br>       <span class="hljs-attr">28:</span> <span class="hljs-string">aload_0</span><br>       <span class="hljs-attr">29:</span> <span class="hljs-string">aload_1</span><br>       <span class="hljs-attr">30:</span> <span class="hljs-string">putfield</span>      <span class="hljs-comment">#3                  // Field a:Ljava/lang/String;</span><br>       <span class="hljs-attr">33:</span> <span class="hljs-string">aload_0</span><br>       <span class="hljs-attr">34:</span> <span class="hljs-string">iload_2</span><br>       <span class="hljs-attr">35:</span> <span class="hljs-string">putfield</span>      <span class="hljs-comment">#4                  // Field b:I</span><br>       <span class="hljs-attr">38:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure>

<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo5</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Demo5 demo5 = <span class="hljs-keyword">new</span> Demo5();<br>		demo5.test1();<br>		demo5.test2();<br>		demo5.test3();<br>		Demo5.test4();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不同方法在调用时，对应的虚拟机指令有所区别</p>
<ul>
<li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li>
<li>普通成员方法在调用时，使用<strong>invokevirtual</strong>指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li>
<li>静态方法在调用时使用<strong>invokestatic</strong>指令</li>
</ul>
<ul>
<li><strong>invokespecial</strong>，<strong>invokestatic</strong>都属于<strong>静态绑定</strong>（编译期间就可以确定）</li>
<li><strong>invokevirtual</strong>，属于<strong>动态绑定</strong>（运行期间才可以确定）</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Code</span>:<br>      <span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-attribute">0</span>: new           #<span class="hljs-number">2</span>                  // class com/nyima/JVM/day<span class="hljs-number">5</span>/Demo<span class="hljs-number">5</span> <br>         <span class="hljs-attribute">3</span>: dup<br>         <span class="hljs-attribute">4</span>: invokespecial #<span class="hljs-number">3</span>                  // Method <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>:()V<br>         <span class="hljs-attribute">7</span>: astore_<span class="hljs-number">1</span><br>         <span class="hljs-attribute">8</span>: aload_<span class="hljs-number">1</span><br>         <span class="hljs-attribute">9</span>: invokespecial #<span class="hljs-number">4</span>                  // Method test<span class="hljs-number">1</span>:()V<br>        <span class="hljs-attribute">12</span>: aload_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">13</span>: invokespecial #<span class="hljs-number">5</span>                  // Method test<span class="hljs-number">2</span>:()V<br>        <span class="hljs-attribute">16</span>: aload_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">17</span>: invokevirtual #<span class="hljs-number">6</span>                  // Method test<span class="hljs-number">3</span>:()V<br>        <span class="hljs-attribute">20</span>: invokestatic  #<span class="hljs-number">7</span>                  // Method test<span class="hljs-number">4</span>:()V<br>        <span class="hljs-attribute">23</span>: return<br></code></pre></td></tr></table></figure>

<ul>
<li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li>
<li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li>
<li>成员方法与静态方法调用的另一个区别是，执行方法前是否需要<strong>【对象引用】</strong></li>
<li>还有一个执行 invokespecial 的情况是通过 super 调用父类方法</li>
</ul>
<h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p>
<p>在执行invokevirtual指令时，经历了以下几个步骤</p>
<ul>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的Class</li>
<li>Class结构中有<strong>vtable</strong>（虚方法表）</li>
<li>查询vtable找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			i = <span class="hljs-number">10</span>;<br>		&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			i = <span class="hljs-number">20</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码指令</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Code</span>:<span class="hljs-string"></span><br>     <span class="hljs-attr">stack</span>=<span class="hljs-string">1, locals=3, args_size=1</span><br>        <span class="hljs-attr">0</span>: <span class="hljs-string">iconst_0</span><br>        <span class="hljs-attr">1</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-attr">2</span>: <span class="hljs-string">bipush        10</span><br>        <span class="hljs-attr">4</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-attr">5</span>: <span class="hljs-string">goto          12</span><br>        <span class="hljs-attr">8</span>: <span class="hljs-string">astore_2</span><br>        <span class="hljs-attr">9</span>: <span class="hljs-string">bipush        20</span><br>       <span class="hljs-attr">11</span>: <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">12</span>: <span class="hljs-string">return</span><br>     <span class="hljs-attr">//多出来一个异常表</span><br>     <span class="hljs-attr">Exception</span> <span class="hljs-string">table:</span><br>        <span class="hljs-attr">from</span>    <span class="hljs-string">to  target 			type</span><br>     	  <span class="hljs-attr">2</span>     <span class="hljs-string">5     8   Class java/lang/Exception</span><br></code></pre></td></tr></table></figure>

<ul>
<li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li>
<li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li>
</ul>
<h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			i = <span class="hljs-number">10</span>;<br>		&#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>			i = <span class="hljs-number">20</span>;<br>		&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			i = <span class="hljs-number">30</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应的字节码</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Code</span>:<br>     <span class="hljs-attribute">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-attribute">0</span>: iconst_<span class="hljs-number">0</span><br>        <span class="hljs-attribute">1</span>: istore_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">2</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-attribute">4</span>: istore_<span class="hljs-number">1</span><br>        <span class="hljs-attribute">5</span>: goto          <span class="hljs-number">19</span><br>        <span class="hljs-attribute">8</span>: astore_<span class="hljs-number">2</span><br>        <span class="hljs-attribute">9</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-attribute">11</span>: istore_<span class="hljs-number">1</span><br>       <span class="hljs-attribute">12</span>: goto          <span class="hljs-number">19</span><br>       <span class="hljs-attribute">15</span>: astore_<span class="hljs-number">2</span><br>       <span class="hljs-attribute">16</span>: bipush        <span class="hljs-number">30</span><br>       <span class="hljs-attribute">18</span>: istore_<span class="hljs-number">1</span><br>       <span class="hljs-attribute">19</span>: return<br>     <span class="hljs-attribute">Exception</span> table:<br>        <span class="hljs-attribute">from</span>    to  target 			type<br>          <span class="hljs-attribute">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   	Class java/lang/ArithmeticException<br>          <span class="hljs-attribute">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">15</span>   	Class java/lang/Exception<br></code></pre></td></tr></table></figure>

<ul>
<li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li>
</ul>
<h5 id="multi-catch"><a href="#multi-catch" class="headerlink" title="multi-catch"></a>multi-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_3</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Method test = Demo3_11_3.class.getMethod(<span class="hljs-string">&quot;test&quot;</span>);<br>			test.invoke(<span class="hljs-keyword">null</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException |InvocationTargetException e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Code:</span><br>	<span class="hljs-string">stack=3,</span> <span class="hljs-string">locals=2,</span> <span class="hljs-string">args_size=1</span><br>		<span class="hljs-attr">0:</span> <span class="hljs-string">ldc</span> <span class="hljs-comment">#2</span><br>		<span class="hljs-attr">2:</span> <span class="hljs-string">ldc</span> <span class="hljs-comment">#3</span><br>		<span class="hljs-attr">4:</span> <span class="hljs-string">iconst_0</span><br>		<span class="hljs-attr">5:</span> <span class="hljs-string">anewarray</span> <span class="hljs-comment">#4</span><br>		<span class="hljs-attr">8:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#5</span><br>		<span class="hljs-attr">11:</span> <span class="hljs-string">astore_1</span><br>		<span class="hljs-attr">12:</span> <span class="hljs-string">aload_1</span><br>		<span class="hljs-attr">15:</span> <span class="hljs-string">anewarray</span> <span class="hljs-comment">#6</span><br>		<span class="hljs-attr">18:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#7</span><br>		<span class="hljs-attr">21:</span> <span class="hljs-string">pop</span><br>		<span class="hljs-attr">22:</span> <span class="hljs-string">goto</span> <span class="hljs-number">30</span><br>		<span class="hljs-attr">25:</span> <span class="hljs-string">astore_1</span><br>		<span class="hljs-attr">26:</span> <span class="hljs-string">aload_1</span><br>		<span class="hljs-attr">27:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#11 // e.printStackTrace:()V</span><br>		<span class="hljs-attr">30:</span> <span class="hljs-string">return</span><br>	<span class="hljs-attr">Exception table:</span><br>		<span class="hljs-string">from</span> <span class="hljs-string">to</span> <span class="hljs-string">target</span> 					<span class="hljs-string">type</span><br>		<span class="hljs-number">0</span>    <span class="hljs-number">22</span>   <span class="hljs-number">25</span>	 <span class="hljs-string">Class</span> <span class="hljs-string">java/lang/NoSuchMethodException</span><br>		<span class="hljs-number">0</span>    <span class="hljs-number">22</span>   <span class="hljs-number">25</span>     <span class="hljs-string">Class</span> <span class="hljs-string">java/lang/IllegalAccessException</span><br>  	    <span class="hljs-number">0</span>    <span class="hljs-number">22</span>   <span class="hljs-number">25</span>     <span class="hljs-string">Class</span> <span class="hljs-string">java/lang/reflect/InvocationTargetException</span><br></code></pre></td></tr></table></figure>

<ul>
<li>异常出现时，<strong>都进入</strong> 25，执行astore_1</li>
</ul>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			i = <span class="hljs-number">10</span>;<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			i = <span class="hljs-number">20</span>;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			i = <span class="hljs-number">30</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Code</span>:<span class="hljs-string"></span><br>     <span class="hljs-attr">stack</span>=<span class="hljs-string">1, locals=4, args_size=1</span><br>        <span class="hljs-attr">0</span>: <span class="hljs-string">iconst_0</span><br>        <span class="hljs-attr">1</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-attr">//try块</span><br>        <span class="hljs-attr">2</span>: <span class="hljs-string">bipush        10</span><br>        <span class="hljs-attr">4</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-meta">//try块执行完后，会执行finally</span>    <span class="hljs-string"></span><br>        <span class="hljs-attr">5</span>: <span class="hljs-string">bipush        30</span><br>        <span class="hljs-attr">7</span>: <span class="hljs-string">istore_1</span><br>        <span class="hljs-attr">8</span>: <span class="hljs-string">goto          27</span><br>       <span class="hljs-meta">//catch块</span>     <span class="hljs-string"></span><br>       <span class="hljs-attr">11</span>: <span class="hljs-string">astore_2 //异常信息放入局部变量表的2号槽位</span><br>       <span class="hljs-attr">12</span>: <span class="hljs-string">bipush        20</span><br>       <span class="hljs-attr">14</span>: <span class="hljs-string">istore_1</span><br>       <span class="hljs-meta">//catch块执行完后，会执行finally</span>        <span class="hljs-string"></span><br>       <span class="hljs-attr">15</span>: <span class="hljs-string">bipush        30</span><br>       <span class="hljs-attr">17</span>: <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">18</span>: <span class="hljs-string">goto          27</span><br>       <span class="hljs-meta">//出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码</span>   <span class="hljs-string"></span><br>       <span class="hljs-attr">21</span>: <span class="hljs-string">astore_3</span><br>       <span class="hljs-attr">22</span>: <span class="hljs-string">bipush        30</span><br>       <span class="hljs-attr">24</span>: <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">25</span>: <span class="hljs-string">aload_3</span><br>       <span class="hljs-attr">26</span>: <span class="hljs-string">athrow  //抛出异常</span><br>       <span class="hljs-attr">27</span>: <span class="hljs-string">return</span><br>     <span class="hljs-attr">Exception</span> <span class="hljs-string">table:</span><br>      	  <span class="hljs-attr">from</span>    <span class="hljs-string">to  target 		type</span><br>            <span class="hljs-attr">2</span>     <span class="hljs-string">5    11   Class java/lang/Exception</span><br>            <span class="hljs-attr">2</span>     <span class="hljs-string">5    21   		any	//剩余的异常类型，比如 Error</span><br>           <span class="hljs-attr">11</span>    <span class="hljs-string">15    21  			any	//剩余的异常类型，比如 Error</span><br></code></pre></td></tr></table></figure>

<p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p>
<p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p>
<h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i = Demo3.test();<br>        <span class="hljs-comment">//结果为20</span><br>		System.out.println(i);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i;<br>		<span class="hljs-keyword">try</span> &#123;<br>			i = <span class="hljs-number">10</span>;<br>			<span class="hljs-keyword">return</span> i;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			i = <span class="hljs-number">20</span>;<br>			<span class="hljs-keyword">return</span> i;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Code</span>:<span class="hljs-string"></span><br>     <span class="hljs-attr">stack</span>=<span class="hljs-string">1, locals=3, args_size=0</span><br>        <span class="hljs-attr">0</span>: <span class="hljs-string">bipush        10</span><br>        <span class="hljs-attr">2</span>: <span class="hljs-string">istore_0</span><br>        <span class="hljs-attr">3</span>: <span class="hljs-string">iload_0</span><br>        <span class="hljs-attr">4</span>: <span class="hljs-string">istore_1  //暂存返回值</span><br>        <span class="hljs-attr">5</span>: <span class="hljs-string">bipush        20</span><br>        <span class="hljs-attr">7</span>: <span class="hljs-string">istore_0</span><br>        <span class="hljs-attr">8</span>: <span class="hljs-string">iload_0</span><br>        <span class="hljs-attr">9</span>: <span class="hljs-string">ireturn	//ireturn会返回操作数栈顶的整型值20</span><br>       <span class="hljs-attr">//如果出现异常，还是会执行finally块中的内容，没有抛出异常</span><br>       <span class="hljs-attr">10</span>: <span class="hljs-string">astore_2</span><br>       <span class="hljs-attr">11</span>: <span class="hljs-string">bipush        20</span><br>       <span class="hljs-attr">13</span>: <span class="hljs-string">istore_0</span><br>       <span class="hljs-attr">14</span>: <span class="hljs-string">iload_0</span><br>       <span class="hljs-attr">15</span>: <span class="hljs-string">ireturn	//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span><br>     <span class="hljs-attr">Exception</span> <span class="hljs-string">table:</span><br>      	  <span class="hljs-attr">from</span>    <span class="hljs-string">to  target  type</span><br>            <span class="hljs-attr">0</span>     <span class="hljs-string">5    10  	  any</span><br></code></pre></td></tr></table></figure>

<ul>
<li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li>
<li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li>
<li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li>
<li>所以<strong>不要在finally中进行返回操作</strong></li>
</ul>
<h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i = Demo3.test();<br>      <span class="hljs-comment">//最终结果为20</span><br>      System.out.println(i);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i;<br>      <span class="hljs-keyword">try</span> &#123;<br>         i = <span class="hljs-number">10</span>;<br>         <span class="hljs-comment">//这里应该会抛出异常</span><br>         i = i/<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         i = <span class="hljs-number">20</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>会发现打印结果为20，并未抛出异常</p>
<h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i = Demo4.test();<br>        <span class="hljs-comment">//最终结果为10</span><br>		System.out.println(i);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-keyword">return</span> i;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			i = <span class="hljs-number">20</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Code</span>:<br>     <span class="hljs-attribute">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>        <span class="hljs-attribute">0</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-attribute">2</span>: istore_<span class="hljs-number">0</span> //赋值给i <span class="hljs-number">10</span><br>        <span class="hljs-attribute">3</span>: iload_<span class="hljs-number">0</span>	//加载到操作数栈顶<br>        <span class="hljs-attribute">4</span>: istore_<span class="hljs-number">1</span> //加载到局部变量表的<span class="hljs-number">1</span>号位置<br>        <span class="hljs-attribute">5</span>: bipush        <span class="hljs-number">20</span><br>        <span class="hljs-attribute">7</span>: istore_<span class="hljs-number">0</span> //赋值给i <span class="hljs-number">20</span><br>        <span class="hljs-attribute">8</span>: iload_<span class="hljs-number">1</span> //加载局部变量表<span class="hljs-number">1</span>号位置的数<span class="hljs-number">10</span>到操作数栈<br>        <span class="hljs-attribute">9</span>: ireturn //返回操作数栈顶元素 <span class="hljs-number">10</span><br>       <span class="hljs-attribute">10</span>: astore_<span class="hljs-number">2</span><br>       <span class="hljs-attribute">11</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-attribute">13</span>: istore_<span class="hljs-number">0</span><br>       <span class="hljs-attribute">14</span>: aload_<span class="hljs-number">2</span> //加载异常<br>       <span class="hljs-attribute">15</span>: athrow //抛出异常<br>     <span class="hljs-attribute">Exception</span> table:<br>        <span class="hljs-attribute">from</span>    to  target type<br>         <span class="hljs-attribute">3</span>      <span class="hljs-number">5</span>    <span class="hljs-number">10</span>    any<br></code></pre></td></tr></table></figure>

<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>		Lock lock = <span class="hljs-keyword">new</span> Lock();<br>		<span class="hljs-keyword">synchronized</span> (lock) &#123;<br>			System.out.println(i);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">2</span>: istore_1<br>        <span class="hljs-number">3</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class com/nyima/JVM/day06/Lock</span><br>        <span class="hljs-number">6</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈顶，用于构造函数消耗</span><br>        <span class="hljs-number">7</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">//剩下的一份放到局部变量表的2号位置</span><br>       <span class="hljs-number">11</span>: aload_2 <span class="hljs-comment">//加载到操作数栈</span><br>       <span class="hljs-number">12</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈，用于加锁时消耗</span><br>       <span class="hljs-number">13</span>: astore_3 <span class="hljs-comment">//将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span><br>       <span class="hljs-number">14</span>: monitorenter <span class="hljs-comment">//加锁</span><br>       <span class="hljs-comment">//锁住后代码块中的操作    </span><br>       <span class="hljs-number">15</span>: getstatic     #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">18</span>: iload_1<br>       <span class="hljs-number">19</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span><br>       <span class="hljs-comment">//加载局部变量表中三号槽位对象的引用，用于解锁    </span><br>       <span class="hljs-number">22</span>: aload_3    <br>       <span class="hljs-number">23</span>: monitorexit <span class="hljs-comment">//解锁</span><br>       <span class="hljs-number">24</span>: goto          <span class="hljs-number">34</span><br>       <span class="hljs-comment">//异常操作    </span><br>       <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span><br>       <span class="hljs-number">29</span>: aload_3<br>       <span class="hljs-number">30</span>: monitorexit <span class="hljs-comment">//解锁</span><br>       <span class="hljs-number">31</span>: aload         <span class="hljs-number">4</span><br>       <span class="hljs-number">33</span>: athrow<br>       <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span><br>     <span class="hljs-comment">//可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span><br>     Exception table:<br>        from   to  target type<br>         <span class="hljs-number">15</span>    <span class="hljs-number">24</span>    <span class="hljs-number">27</span>   any<br>         <span class="hljs-number">27</span>    <span class="hljs-number">31</span>    <span class="hljs-number">27</span>   any<br></code></pre></td></tr></table></figure>

<ul>
<li>无论会不会出现异常都会进行解锁操作</li>
</ul>
<blockquote>
<p>方法级别的 synchronized 不会在字节码指令中有所体现</p>
</blockquote>
<h3 id="4-3-编译期处理"><a href="#4-3-编译期处理" class="headerlink" title="4.3 编译期处理"></a>4.3 编译期处理</h3><p>所谓的<strong>语法糖</strong>，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p>
<p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是class字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码。</p>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过编译期优化后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;<br>   <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span><br>      <span class="hljs-keyword">super</span>();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p>
<p>在JDK 5以后，它们的转换可以在编译期自动完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Integer x = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">int</span> y = x;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转换过程如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span><br>      Integer x = Integer.valueOf(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span><br>      <span class="hljs-keyword">int</span> y = x.intValue();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      list.add(<span class="hljs-number">10</span>);<span class="hljs-comment">// 实际调用的是 List.add(Object e)</span><br>      Integer x = list.get(<span class="hljs-number">0</span>);<span class="hljs-comment">// 实际调用的是 Object obj = List.get(int index);</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Code:</span><br>    <span class="hljs-string">stack=2,</span> <span class="hljs-string">locals=3,</span> <span class="hljs-string">args_size=1</span><br>       <span class="hljs-attr">0:</span> <span class="hljs-string">new</span>           <span class="hljs-comment">#2                  // class java/util/ArrayList</span><br>       <span class="hljs-attr">3:</span> <span class="hljs-string">dup</span><br>       <span class="hljs-attr">4:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-attr">7:</span> <span class="hljs-string">astore_1</span><br>       <span class="hljs-attr">8:</span> <span class="hljs-string">aload_1</span><br>       <span class="hljs-attr">9:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">10</span><br>      <span class="hljs-attr">11:</span> <span class="hljs-string">invokestatic</span>  <span class="hljs-comment">#4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br>      <span class="hljs-string">//这里进行了泛型擦除，实际调用的是add(Objcet</span> <span class="hljs-string">o)</span><br>      <span class="hljs-attr">14:</span> <span class="hljs-string">invokeinterface</span> <span class="hljs-comment">#5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><br>      <span class="hljs-attr">19:</span> <span class="hljs-string">pop</span><br>      <span class="hljs-attr">20:</span> <span class="hljs-string">aload_1</span><br>      <span class="hljs-attr">21:</span> <span class="hljs-string">iconst_0</span><br>      <span class="hljs-string">//这里也进行了泛型擦除，实际调用的是get(Object</span> <span class="hljs-string">o)</span>   <br>      <span class="hljs-attr">22:</span> <span class="hljs-string">invokeinterface</span> <span class="hljs-comment">#6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="hljs-string">//这里进行了类型转换，将Object转换成了Integer</span><br>      <span class="hljs-attr">27:</span> <span class="hljs-string">checkcast</span>     <span class="hljs-comment">#7                  // class java/lang/Integer</span><br>      <span class="hljs-attr">30:</span> <span class="hljs-string">astore_2</span><br>      <span class="hljs-attr">31:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure>

<p>所以调用get函数取值时，有一个类型转换的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = (Integer) list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x = (Integer) list.get(<span class="hljs-number">0</span>).intValue();<br></code></pre></td></tr></table></figure>

<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>      <span class="hljs-comment">//将args赋值给arr，可以看出String...实际就是String[] </span><br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> Demo4 &#123;&#125;<br><br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      foo(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p> 注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p>
</blockquote>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//数组赋初值的简化写法也是一种语法糖。</span><br>		<span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : arr) &#123;<br>			System.out.println(x);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译器会帮我们转换为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; ++i) &#123;<br>			<span class="hljs-keyword">int</span> x = arr[i];<br>			System.out.println(x);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>如果是集合使用foreach</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-keyword">for</span> (Integer x : list) &#123;<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-comment">//获得该集合的迭代器</span><br>      Iterator&lt;Integer&gt; iterator = list.iterator();<br>      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>         Integer x = iterator.next();<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">switch</span> (str) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;world&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在编译器中执行的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo6</span><span class="hljs-params">()</span> </span>&#123;<br>      <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;<br>      <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span><br>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;<br>         <span class="hljs-comment">//hello的hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :<br>            <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span><br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;<br>               x = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-comment">//world的hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :<br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;world&quot;</span>)) &#123;<br>               x = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      <span class="hljs-comment">//用第二个switch在进行输出判断</span><br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>过程说明：</p>
<ul>
<li>在编译期间，单个的switch被分为了两个<ul>
<li>第一个用来匹配字符串，并给x赋值<ul>
<li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li>
<li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li>
</ul>
</li>
<li>第二个用来根据x的值来决定输出语句</li>
</ul>
</li>
</ul>
<h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-keyword">switch</span> (sex) &#123;<br>         <span class="hljs-keyword">case</span> MALE:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> FEMALE:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译器中执行的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>   <span class="hljs-comment">/**     </span><br><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><br><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><br><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><br><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><br><span class="hljs-comment">    */</span> <br>   <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>&#123;<br>      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span><br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">static</span> &#123;<br>         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span><br>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;<br>         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span><br>      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];<br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转换后的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>&#123;   <br>   <span class="hljs-comment">//对应枚举类中的元素</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;    <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;    <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;<br>   <br>    <span class="hljs-keyword">static</span> &#123;       <br>    	<span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span><br>    	MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);    <br>        FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);   <br>        $VALUES = <span class="hljs-keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; <br>   &#125;<br> 	<br>   <span class="hljs-comment">//调用父类中的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>&#123;     <br>        <span class="hljs-keyword">super</span>(name, ordinal);    <br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;  <br>        <span class="hljs-keyword">return</span> $VALUES.clone();  <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);  <br>    &#125; <br>   <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(资源变量 = 创建资源对象)&#123;<br>	&#125; <span class="hljs-keyword">catch</span>( ) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中资源对象需要实现 <code>AutoCloseable</code>接口，例如<code>InputStream</code>、<code>OutputStream</code>、<code>Connection</code>、<code>Statement</code>、<code>ResultSet</code>等接口都实现 <code>AutoCloseable</code>，使用<code>try-withresources</code>可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span>(InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>)) &#123;<br>			System.out.println(is);<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转换后的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy9</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>);<br>            Throwable t = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span>&#123;<br>            	System.out.println(is);<br>				&#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123;<br>					<span class="hljs-comment">// t 是我们代码出现的异常</span><br>					t = e1;<br>					<span class="hljs-keyword">throw</span> e1;<br>				&#125; <span class="hljs-keyword">finally</span> &#123;<br>					<span class="hljs-comment">// 判断了资源不为空</span><br>					<span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;<br>						<span class="hljs-comment">// 如果我们代码有异常</span><br>						<span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>							<span class="hljs-keyword">try</span> &#123;<br>								is.close();<br>							&#125; <span class="hljs-keyword">catch</span> (Throwable e2) &#123;<br>								<span class="hljs-comment">// 如果 close 出现异常，作为被压制异常添加</span><br>								t.addSuppressed(e2);<br>							&#125;<br>						&#125; <span class="hljs-keyword">else</span> &#123;<br>							<span class="hljs-comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e</span><br>							is.close();<br>						&#125;<br>					&#125;<br>				&#125;<br>			&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>				e.printStackTrace();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>addSuppressed(Throwable e)作用是：添加被压制异常。是为了防止异常信息的丢失（如try-with-resources 生成的 fianlly 中如果抛出了异常）</p>
</blockquote>
<h4 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a>方法重写时的桥接方法</h4><p>方法重写时对返回值分两种情况：</p>
<ul>
<li>父子类的返回值完全一致</li>
<li>子类返回值可以是父类返回值的子类（见下面的例子）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转换后的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>	&#125;<br>	<span class="hljs-comment">// 此方法才是真正重写了父类 public Number m() 方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 调用 public Integer m()</span><br>		<span class="hljs-keyword">return</span> m();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的<code>public Integer m()</code>没有命名冲突</p>
</blockquote>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转换后的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//用额外创建的类来创建匿名内部类对象</span><br>      Runnable runnable = <span class="hljs-keyword">new</span> Demo8$<span class="hljs-number">1</span>();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//创建了一个额外的类，实现了Runnable接口</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() &#123;&#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果匿名内部类中引用了<strong>局部变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(x);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转化后代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(x);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-comment">//多创建了一个变量</span><br>   <span class="hljs-keyword">int</span> val$x;<br>   <span class="hljs-comment">//变为了有参构造器</span><br>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) &#123;<br>      <span class="hljs-keyword">this</span>.val$x = x;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(val$x);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>解释了为什么匿名内部类引用局部变量时，局部变量必须是final的。因为在创建Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的val$x属性， 所以x不应该再发生变化了，如果变化，val$x属性没有机会再跟着一起变化。</p>
</blockquote>
<blockquote>
<p>特别说明：在jdk1.8之后，匿名内部类使用局部变量的时候，局部变量已经不需要使用final修饰了，可以编译通过，并不是编译器的实现机制改变了，只是编译器在编译的时候不允许对这个变量进行变更，也就是说，如果你内外只是使用这个变量，而不进行重新赋值，那么就编译通过，如果内外有重新赋值，那么还是会报编译错误。</p>
</blockquote>
<h3 id="4-4-类加载阶段"><a href="#4-4-类加载阶段" class="headerlink" title="4.4 类加载阶段"></a>4.4 类加载阶段</h3><h4 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h4><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210720164326498.png" srcset="/img/loading.gif" lazyload alt="image-20210720164326498"></p>
<ul>
<li><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p>
</li>
<li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine（执行引擎）决定。</p>
</li>
<li><p>加载的类信息存放于一块称为<strong>方法区</strong>的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p>
</li>
</ul>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>类加载过程的第一步，主要完成下面3件事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为<strong>方法区</strong>的运行时数据结构</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口</li>
</ol>
<blockquote>
<p>创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。</p>
</blockquote>
<ul>
<li><p>将类的字节码载入<strong>方法区</strong>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p>
<ul>
<li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li>
<li>_super 即父类</li>
<li>_ﬁelds 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表</li>
<li>_itable 接口方法</li>
</ul>
</li>
<li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p>
</li>
<li><p>加载和链接可能是<strong>交替运行</strong>的</p>
</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.49.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li>
<li>_java_mirror则是保存在<strong>堆内存</strong>中</li>
<li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li>
<li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li>
</ul>
<blockquote>
<p>数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p>
</blockquote>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p>
<p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p>
<ul>
<li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.491.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。</p>
<p>为 static 变量分配空间，设置默认值</p>
<ul>
<li>static变量在JDK 7以前是存储与instanceKlass（方法区中）末尾。但在JDK 7以后就存储在_java_mirror末尾（堆中）了</li>
<li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li>
<li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li>
<li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong><ul>
<li>于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行 </li>
</ul>
</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li>
</ul>
<blockquote>
<p>比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INT_CONSTANT = <span class="hljs-number">10</span>; <span class="hljs-comment">// 在链接阶段的准备环节赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUM1 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">10</span>); <span class="hljs-comment">// 在初始化阶段clinit&gt;()中赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="hljs-number">100</span>); <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="hljs-number">100</span>); <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中概值</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String s0 = <span class="hljs-string">&quot;helloworld0&quot;</span>;  <span class="hljs-comment">// 在链接阶段的准备环节赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;helloworld1&quot;</span>); <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String s2 = <span class="hljs-string">&quot;hellowrold2&quot;</span>;   <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><br></code></pre></td></tr></table></figure>



<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>解析的含义</strong></p>
<p>将常量池中的<strong>符号引用解析为直接引用</strong></p>
<ul>
<li><p>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</p>
</li>
<li><p>解析以后，会将常量池中的符号引用解析为直接引用</p>
</li>
</ul>
<h6 id="未解析演示"><a href="#未解析演示" class="headerlink" title="未解析演示"></a>未解析演示</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>      ClassLoader loader = Demo1.class.getClassLoader();<br>      <span class="hljs-comment">//只加载不解析</span><br>      Class&lt;?&gt; c = loader.loadClass(<span class="hljs-string">&quot;com.nyima.JVM.day8.C&quot;</span>);<br>      <span class="hljs-comment">//用于阻塞主线程</span><br>      System.in.read();<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>   D d = <span class="hljs-keyword">new</span> D();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时只加载了类C</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.50.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.51.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="解析演示"><a href="#解析演示" class="headerlink" title="解析演示"></a>解析演示</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>      <span class="hljs-comment">//解析</span><br>      <span class="hljs-keyword">new</span> C();<br>      <span class="hljs-comment">//用于阻塞主线程</span><br>      System.in.read();<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>   D d = <span class="hljs-keyword">new</span> D();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时已加载并解析了类C和类D，并且常量池类D已经指向内存空间中D的位置</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.52.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化即调用 <strong>cinit()V</strong> ，虚拟机会保证这个类的『构造方法』的线程安全</p>
<h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p>
<ul>
<li><p>main 方法所在的类，总会被首先初始化</p>
</li>
<li><p>首次访问这个类的静态变量或静态方法时</p>
</li>
<li><p>子类初始化，如果父类还没初始化，会引发</p>
</li>
<li><p>子类访问父类的静态变量，只会触发父类的初始化。不会导致子类初始化，只有真正声明这个字段的类才会被初始化。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassiveUse</span> </span>&#123;<br> 	<span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Child.num);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child类的初始化&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Parent类的初始化&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Class.forName</p>
</li>
<li><p>new 会导致初始化</p>
</li>
</ul>
<p>以下情况不会初始化</p>
<ul>
<li><p>访问类的 static ﬁnal 静态常量（基本类型和字符串）</p>
</li>
<li><p>类对象.class 不会触发初始化</p>
</li>
<li><p><strong>创建该类对象的数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Parent[] parents= <span class="hljs-keyword">new</span> Parent[<span class="hljs-number">10</span>];<span class="hljs-comment">//不会初始化</span><br>System.out.println(parents.getClass()); <br><span class="hljs-comment">// new的话才会初始化</span><br>parents[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Parent();<br></code></pre></td></tr></table></figure></li>
<li><p><strong>类加载器的.loadClass方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz = ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;com.test.java.Person&quot;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>Class.forNamed的参数2为false时</p>
</li>
</ul>
<p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p>
<h5 id="指针碰撞和空闲列表"><a href="#指针碰撞和空闲列表" class="headerlink" title="指针碰撞和空闲列表"></a>指针碰撞和空闲列表</h5><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<strong>指针碰撞</strong>”（Bump thePointer）。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<strong>空闲列表</strong>”（FreeList）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p>
<p>下面两张图可以解释指针碰撞和空闲列表：</p>
<ul>
<li><strong>指针碰撞</strong></li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.521.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li> <strong>空闲列表</strong></li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.522.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="4-5-类加载器"><a href="#4-5-类加载器" class="headerlink" title="4.5 类加载器"></a>4.5 类加载器</h3><p>以JDK 8为例</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>加载的类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Bootstrap ClassLoader（启动类加载器）</td>
<td>JAVA_HOME/jre/lib</td>
<td>无法直接访问</td>
</tr>
<tr>
<td>Extension ClassLoader(扩展类加载器)</td>
<td>JAVA_HOME/jre/lib/ext</td>
<td>上级为Bootstrap，<strong>显示为null</strong></td>
</tr>
<tr>
<td>Application ClassLoader(应用程序类加载器)</td>
<td>classpath</td>
<td>上级为Extension</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为Application</td>
</tr>
</tbody></table>
<h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p>
<ul>
<li><p>这个类加载器使用C/C++语言实现的，嵌套在JVM内部。</p>
</li>
<li><p>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</p>
</li>
<li><p>并不继承自ava.lang.ClassLoader，没有父加载器。</p>
</li>
<li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
</li>
<li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
</li>
</ul>
<h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>扩展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p>
<ul>
<li><p>Java语言实现，由sun.misc.Launcher$ExtClassLoader实现。</p>
</li>
<li><p>派生于ClassLoader类，父类加载器为启动类加载器</p>
</li>
<li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p>
</li>
</ul>
<h4 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h4><ul>
<li><p>java语言编写，由sun.misc.Launcher$AppClassLoader实现</p>
</li>
<li><p>派生于ClassLoader类，父类加载器为扩展类加载器</p>
</li>
<li><p>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</p>
</li>
<li><p>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</p>
</li>
<li><p>通过ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</p>
</li>
</ul>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
</ul>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>继承ClassLoader父类</li>
<li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul>
<li>不是重写loadClass方法，否则不会走双亲委派机制</li>
</ul>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的 deﬁneClass 方法来加载类</li>
<li>使用者调用该类加载器的 loadClass 方法</li>
</ul>
<h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p>
<p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是<strong>双亲委派</strong>模式，即把请求交由父类处理，它是一种任务委派模式。</p>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ul>
<li><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</p>
</li>
<li><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</p>
</li>
<li><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>
</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210721112334183.png" srcset="/img/loading.gif" lazyload alt="image-20210721112334183"></p>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul>
<li><p>避免类的重复加载，沙箱安全机制</p>
</li>
<li><p>保护程序安全，防止核心API被随意篡改 </p>
</li>
<li><p>自定义类：java.lang.String</p>
</li>
<li><p>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</p>
</li>
</ul>
<blockquote>
<p>沙箱安全机制</p>
<p>如自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class）。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>
</blockquote>
<h5 id="loadClass源码"><a href="#loadClass源码" class="headerlink" title="loadClass源码"></a>loadClass源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// 首先查找该类是否已经被该类加载器加载过了</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-comment">//如果没有被加载过</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//看是否被启动类加载器加载过</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>                <span class="hljs-comment">//捕获异常，但不做任何处理</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span><br>                <span class="hljs-comment">//然后让应用类加载器去找classpath下找该类</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// 记录时间</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="什么地方违反了双亲委派模型"><a href="#什么地方违反了双亲委派模型" class="headerlink" title="什么地方违反了双亲委派模型"></a>什么地方违反了双亲委派模型</h4><p><strong>第一次破坏双亲委派机制</strong></p>
<p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代。</p>
<p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协。<strong>为了兼容这些已有的代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</strong>只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。</p>
<p><strong>第二次破坏双亲委派机制：线程上下文类加载器</strong></p>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<strong>越基础的类由越上层的加载器进行加载</strong>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，但是<strong>这样无法实现基础类型调用用户代码</strong></p>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，<strong>启动类加载器绝不可能认识、加载这些代码的</strong>（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（ThreadContextClassLoader）</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<strong>这是一种父类加载器去请求子类加载器完成类加载的行为</strong>，违背了双亲委派模型，但也是无可奈何的事情。 ，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<blockquote>
<p>SPI机制简介 SPI的全名为Service Provider Interface，主要是应用于厂商自定义组件或插件中。在java.util.ServiceLoader的文档里有比较详细的介绍。简单的总结下java SPI机制的思想：我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块、xml解析模块、jdbc模块等方案。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。</p>
<p>使用线程上下文类加载器打破双亲委派模型</p>
</blockquote>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210724161029353.png" srcset="/img/loading.gif" lazyload alt="image-20210724161029353"></p>
<p><strong>第三次破坏双亲委派机制</strong></p>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p>
<p><strong>Tomcat 加载器为何违背双亲委派模型</strong></p>
<p>Tomcat 如果使用默认的类加载机制行不行？<br>我们思考一下：Tomcat是个web容器， 那么它要解决什么问题：</p>
<ol>
<li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖<strong>同一个第三方类库的不同版本</strong>，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互<strong>隔离</strong>。</li>
<li>部署在同一个web容器中相同的类库相同的版本可以<strong>共享</strong>。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。</li>
<li>web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让<strong>容器的类库和程序的类库隔离</strong>开来。</li>
<li>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，<strong>web容器需要支持 jsp 修改后不用重启</strong>。</li>
</ol>
<p>再看看我们的问题：Tomcat 如果使用默认的类加载机制行不行？<br>答案是不行的。为什么？我们看，第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的累加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。第三个问题和第一个问题一样。我们再看第四个问题，我们想我们要怎么实现jsp文件的热修改，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以<strong>直接卸载掉这jsp文件的类加载器</strong>，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p>
<ul>
<li>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li>
<li>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li>
<li>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li>
<li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；</li>
</ul>
<ul>
<li>比较两个类是否“相等”，<code>只有在这两个类是由同一个类加载器加载的前提下才有意义</code>，否则，即使这两个类来自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这个两个类就必定不相等。</li>
</ul>
<h3 id="4-6-运行期优化"><a href="#4-6-运行期优化" class="headerlink" title="4.6 运行期优化"></a>4.6 运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>0层：解释执行，用解释器将字节码翻译为机器码</li>
<li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li>
<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用 C2 即时编译器编译执行</li>
</ul>
<blockquote>
<p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p>
</blockquote>
<h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul>
<li>解释器<ul>
<li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
</li>
<li>即时编译器<ul>
<li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li>
<li>根据平台类型，生成平台特定的机器码</li>
</ul>
</li>
</ul>
<p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由来），并优化这些热点代码</p>
<h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p>
<p>逃逸分析的 JVM 参数如下：</p>
<ul>
<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li>
<li>显示分析结果：-XX:+PrintEscapeAnalysis</li>
</ul>
<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p>
<p><strong>对象逃逸状态</strong></p>
<p><strong>全局逃逸（GlobalEscape）</strong></p>
<ul>
<li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul>
<li>对象是一个静态变量</li>
<li>对象是一个已经发生逃逸的对象</li>
<li>对象作为当前方法的返回值</li>
</ul>
</li>
</ul>
<p><strong>参数逃逸（ArgEscape）</strong></p>
<ul>
<li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li>
</ul>
<p><strong>没有逃逸</strong></p>
<ul>
<li>即方法中的对象没有发生逃逸</li>
</ul>
<p><strong>逃逸分析优化</strong></p>
<p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p>
<p><strong>锁消除</strong></p>
<p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p>
<p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p>
<p>锁消除的 JVM 参数如下：</p>
<ul>
<li>开启锁消除：-XX:+EliminateLocks</li>
<li>关闭锁消除：-XX:-EliminateLocks</li>
</ul>
<p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p>
<p><strong>标量替换</strong></p>
<p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p>
<ul>
<li><p><strong>标量</strong>（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
</li>
<li><p>相对的，那些还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量</p>
</li>
</ul>
<p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p>
<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p>
<p>标量替换的 JVM 参数如下：</p>
<ul>
<li>开启标量替换：-XX:+EliminateAllocations</li>
<li>关闭标量替换：-XX:-EliminateAllocations</li>
<li>显示标量替换详情：-XX:+PrintEliminateAllocations</li>
</ul>
<p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p>
<p><strong>栈上分配</strong></p>
<p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p>
<h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// to do something  </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p>
<p>JVM内有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p>
<p>第二个原因则更重要：<strong>方法内联</strong></p>
<p>如果JVM检测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123; <br>    <span class="hljs-comment">//这里调用了add2方法</span><br>    <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);  <br>&#125;  <br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2)</span> </span>&#123;  <br>    <span class="hljs-keyword">return</span> x1 + x2;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法调用被替换后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;  <br>    <span class="hljs-comment">//被替换为了方法本身</span><br>    <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reflect1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;foo...&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>      Method foo = Demo3.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>);<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">16</span>; i++) &#123;<br>         foo.invoke(<span class="hljs-keyword">null</span>);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p>
<p>invoke方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,InvocationTargetException</span>&#123;<br>    <span class="hljs-keyword">if</span> (!override) &#123;<br>        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;<br>            Class&lt;?&gt; caller = Reflection.getCallerClass();<br>            checkAccess(caller, clazz, obj, modifiers);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类，默认使用DelegatingMethodAccessorImpl类</span><br>    MethodAccessor ma = methodAccessor;             <span class="hljs-comment">// read volatile</span><br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) &#123;<br>        ma = acquireMethodAccessor();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.53.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p>
<p>NativeMethodAccessorImpl源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MethodAccessorImpl</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;<br>    <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numInvocations;<br><br>    NativeMethodAccessorImpl(Method var1) &#123;<br>        <span class="hljs-keyword">this</span>.method = var1;<br>    &#125;<br>	<br>	<span class="hljs-comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><br>	<span class="hljs-comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object var1, Object[] var2)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;<br>        <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; 			!ReflectUtil.isVMAnonymousClass(<span class="hljs-keyword">this</span>.method.getDeclaringClass())) &#123;<br>            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="hljs-keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="hljs-keyword">this</span>.method.getDeclaringClass(), <span class="hljs-keyword">this</span>.method.getName(), <span class="hljs-keyword">this</span>.method.getParameterTypes(), <span class="hljs-keyword">this</span>.method.getReturnType(), <span class="hljs-keyword">this</span>.method.getExceptionTypes(), <span class="hljs-keyword">this</span>.method.getModifiers());<br>            <span class="hljs-keyword">this</span>.parent.setDelegate(var3);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> invoke0(<span class="hljs-keyword">this</span>.method, var1, var2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.parent = var1;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">invoke0</span><span class="hljs-params">(Method var0, Object var1, Object[] var2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReflectionFactory.inflationThreshold()方法的返回值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inflationThreshold = <span class="hljs-number">15</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>一开始if条件不满足，就会调用本地方法invoke0</li>
<li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul>
<li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li>
</ul>
</li>
</ul>
<p>动态生成的访问器反编译后如下：</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/3.54.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>通过查看 ReflectionFactory 源码可知<br>sun.reflect.noInflation 可以用来禁用膨胀（直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算）<br>sun.reflect.inflationThreshold 可以修改膨胀阈值</p>
</blockquote>
<hr>
<h2 id="五、对象实例化"><a href="#五、对象实例化" class="headerlink" title="五、对象实例化"></a>五、对象实例化</h2><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723134508418.png" srcset="/img/loading.gif" lazyload alt="image-20210723134508418"></p>
<h3 id="5-1-创建对象的方式"><a href="#5-1-创建对象的方式" class="headerlink" title="5.1 创建对象的方式"></a>5.1 创建对象的方式</h3><ul>
<li><p>new：最常见的方式、Xxx的静态方法，XxxBuilder/XxxFactory的静态方法</p>
</li>
<li><p>Class的newInstance方法：反射的方式，只能调用空参的构造器，权限必须是public</p>
<ul>
<li><code>Demo demo01 = Demo.class.newInstance();</code></li>
</ul>
</li>
<li><p>Constructor的newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求</p>
<ul>
<li><code>Demo demo02= Demo.class.getDeclaredConstructor(Integer.class, String.class).newInstance(12,&quot;张三&quot;);</code></li>
</ul>
</li>
<li><p>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone()</p>
</li>
<li><p>使用序列化：从文件中、从网络中获取一个对象的二进制流</p>
</li>
<li><p>第三方库 Objenesis</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo</span><span class="hljs-params">(Integer id, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Demo&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-2-创建对象的步骤"><a href="#5-2-创建对象的步骤" class="headerlink" title="5.2 创建对象的步骤"></a>5.2 创建对象的步骤</h3><h4 id="1-判断对象对应的类是否加载、链接、初始化"><a href="#1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1. 判断对象对应的类是否加载、链接、初始化"></a>1. 判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。</p>
<p>如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件；</p>
<ul>
<li><p>如果没有找到文件，则抛出ClassNotFoundException异常</p>
</li>
<li><p>如果找到，则进行类加载，并生成对应的Class对象</p>
</li>
</ul>
<h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2. 为对象分配内存"></a>2. 为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p>
<p><strong>如果内存规整</strong>：虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p>
<ul>
<li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li>
</ul>
<p><strong>如果内存不规整</strong>：虚拟机需要维护一个空闲列表（Free List）来为对象分配内存。</p>
<ul>
<li>已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</li>
</ul>
<p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h4 id="3-处理并发问题"><a href="#3-处理并发问题" class="headerlink" title="3. 处理并发问题"></a>3. 处理并发问题</h4><ul>
<li><p>采用CAS失败重试、区域加锁保证更新的原子性</p>
</li>
<li><p>每个线程预先分配一块TLAB：通过设置 <code>-XX:+UseTLAB</code>参数来设定</p>
</li>
</ul>
<h4 id="4-初始化分配到的内存"><a href="#4-初始化分配到的内存" class="headerlink" title="4. 初始化分配到的内存"></a>4. 初始化分配到的内存</h4><p>所有类属性设置默认值，保证对象实例字段在不赋值时可以直接使用</p>
<h4 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5. 设置对象的对象头"></a>5. 设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
<h4 id="6-执行init方法进行初始化"><a href="#6-执行init方法进行初始化" class="headerlink" title="6. 执行init方法进行初始化"></a>6. 执行init方法进行初始化</h4><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p>
<p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p>
<p><strong>给对象属性赋值的操作</strong></p>
<ul>
<li><p>属性的默认初始化</p>
</li>
<li><p>显式初始化</p>
</li>
<li><p>代码块中初始化</p>
</li>
<li><p>构造器中初始化</p>
</li>
</ul>
<p><strong>对象实例化的过程</strong></p>
<ol>
<li>加载类元信息</li>
<li>为对象分配内存</li>
<li>处理并发问题</li>
<li>属性的默认初始化（零值初始化）</li>
<li>设置对象头信息</li>
<li>属性的显示初始化、代码块中初始化、构造器中初始化</li>
</ol>
<h4 id="对象的实例化过程"><a href="#对象的实例化过程" class="headerlink" title="对象的实例化过程"></a>对象的实例化过程</h4><p>对象实例化过程，就是执行类构造函数对应在字节码文件中的<code>&lt;init&gt;()</code>方法(实例构造器)，<code>&lt;init&gt;()</code>方法由非静态变量、非静态代码块以及对应的构造器组成。</p>
<ul>
<li><code>&lt;init&gt;()</code>方法可以重载多个，类有几个构造器就有几个<code>&lt;init&gt;()</code>方法；</li>
<li><code>&lt;init&gt;()</code>方法中的代码执行顺序为：父类变量初始化、父类代码块、父类构造器、子类变量初始化、子类代码块、子类构造器。</li>
</ul>
<p>静态变量、静态代码块、普通变量、普通代码块、构造器的执行顺序如下图：</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210824170126835.png" srcset="/img/loading.gif" lazyload alt="image-20210824170126835"></p>
<p>具有父类的子类的实例化顺序如下：</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210824170152708.png" srcset="/img/loading.gif" lazyload alt="image-20210824170152708"></p>
<hr>
<h2 id="六、对象内存模型"><a href="#六、对象内存模型" class="headerlink" title="六、对象内存模型"></a>六、对象内存模型</h2><h3 id="6-1-内存布局"><a href="#6-1-内存布局" class="headerlink" title="6.1 内存布局"></a>6.1 内存布局</h3><p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723135415086.png" srcset="/img/loading.gif" lazyload alt="image-20210723135415086"></p>
<h4 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h4><p>对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针。如果是数组，还需要记录数组的长度</p>
<h5 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h5><ul>
<li><p>哈希值（HashCode）</p>
</li>
<li><p>GC分代年龄</p>
</li>
<li><p>锁状态标志</p>
</li>
<li><p>线程持有的锁</p>
</li>
<li><p>偏向线程ID</p>
</li>
<li><p>翩向时间戳</p>
</li>
</ul>
<h5 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h5><p>指向类元数据InstanceKlass，确定该对象所属的类型。</p>
<h4 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h4><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）</p>
<ul>
<li><p>相同宽度的字段总是被分配在一起</p>
</li>
<li><p>父类中定义的变量会出现在子类之前</p>
</li>
<li><p>如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙</p>
</li>
</ul>
<h4 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h4><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723135955189.png" srcset="/img/loading.gif" lazyload alt="image-20210723135955189"></p>
<h3 id="6-2-对象的访问方式"><a href="#6-2-对象的访问方式" class="headerlink" title="6.2 对象的访问方式"></a>6.2 对象的访问方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><ul>
<li>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723141137169.png" srcset="/img/loading.gif" lazyload alt="image-20210723141137169"></p>
<h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><ul>
<li>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</li>
</ul>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210723141341840.png" srcset="/img/loading.gif" lazyload alt="image-20210723141341840"></p>
<hr>
<h3 id="6-3-内存泄露"><a href="#6-3-内存泄露" class="headerlink" title="6.3 内存泄露"></a>6.3 内存泄露</h3><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。</p>
<p><strong>内存泄漏的情况</strong></p>
<h4 id="1-静态集合类"><a href="#1-静态集合类" class="headerlink" title="1.静态集合类"></a>1.静态集合类</h4><p>静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，<strong>长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryLeak</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> List list = <span class="hljs-keyword">new</span> ArrayList();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">oomTests</span><span class="hljs-params">()</span></span>&#123;<br>        Object obj＝<span class="hljs-keyword">new</span> Object();<span class="hljs-comment">//局部变量</span><br>        list.add(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h4><p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p>
<h4 id="3-内部类持有外部类"><a href="#3-内部类持有外部类" class="headerlink" title="3.内部类持有外部类"></a>3.内部类持有外部类</h4><p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p>
<h4 id="4-各种连接，如数据库连接、网络连接和IO连接等"><a href="#4-各种连接，如数据库连接、网络连接和IO连接等" class="headerlink" title="4.各种连接，如数据库连接、网络连接和IO连接等"></a>4.各种连接，如数据库连接、网络连接和IO连接等</h4><p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
<h4 id="5-变量不合理的作用域"><a href="#5-变量不合理的作用域" class="headerlink" title="5.变量不合理的作用域"></a>5.变量不合理的作用域</h4><p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsingRandom</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String msg;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMsg</span><span class="hljs-params">()</span></span>&#123;<br>        readFromNet();<span class="hljs-comment">//从网络中接受数据保存到msg中</span><br>        saveDB();<span class="hljs-comment">//把msg保存到数据库中</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上面这个伪代码，通过readFromNet方法把接受的消息保存在变量msg中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了内存泄漏。实际上这个msg变量可以放在receiveMsg方法内部，当方法使用完，那么msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。</p>
<h4 id="6-改变哈希值"><a href="#6-改变哈希值" class="headerlink" title="6.改变哈希值"></a>6.改变哈希值</h4><p>改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p>
<p>否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p>
<p>这也是 String 为什么被设置成了不可变类型，我们可以放心地把 String 存入 HashSet，或者把String 当做 HashMap 的 key 值；</p>
<p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的 hashCode 不可变。</p>
<h4 id="7-缓存泄露"><a href="#7-缓存泄露" class="headerlink" title="7.缓存泄露"></a>7.缓存泄露</h4><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p>
<p>对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p>
<h4 id="8-监听器和其他回调"><a href="#8-监听器和其他回调" class="headerlink" title="8.监听器和其他回调"></a>8.监听器和其他回调</h4><p>内存泄漏常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。</p>
<p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。</p>
<h4 id="9-ThreadLocal"><a href="#9-ThreadLocal" class="headerlink" title="9.ThreadLocal"></a>9.ThreadLocal</h4><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用<strong>弱引用</strong>的ThreadLocal实例，value为线程变量的副本。这些对象之间的引用关系如下</p>
<p><img src="/2020/09/20/Java/JVM/JVM%E5%AD%A6%E4%B9%A0/image-20210724165354000.png" srcset="/img/loading.gif" lazyload alt="image-20210724165354000"></p>
<p>从上图中可以看出，threadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部<strong>强引用</strong>时，Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强引用，只有thead线程退出以后，value的强引用链条才会断掉。</p>
<p>但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p>
<blockquote>
<p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p>
</blockquote>
<p>永远无法回收，造成内存泄漏。</p>
<ul>
<li><p>为什么ThreadLocalMap的key要使用弱引用</p>
<ul>
<li><p>key 使用强引用</p>
<p>当ThreadLocalMap的key为强引用，回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，<strong>导致Entry内存泄漏</strong>。</p>
</li>
<li><p>key 使用弱引用</p>
<p>当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set()，get()，remove()方法的时候会被清除value值。(没有调用时，<strong>会导致Value内存泄漏</strong>)</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>ThreadLocal正确的使用方法</p>
<ul>
<li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li>
<li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li>
</ul>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Java/JVM/">JVM</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JVM/">JVM</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/10/01/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java 并发</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%9F%BA%E7%A1%80/Redis%E5%9F%BA%E7%A1%80/">
                        <span class="hidden-mobile">Redis基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?cd190160b5401a029cee361d013e32a1";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
