

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="懂一点点">
  <meta name="author" content="Gotcha">
  <meta name="keywords" content="">
  
  <title>Java 并发 - Gotcha的笔记总结</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"cd190160b5401a029cee361d013e32a1","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"U8yaiFQ2fUef4ujWTig83mSL-gzGzoHsz","app_key":"akCMytdeJqrMuKP84F4oblqz","server_url":"https://u8yaifq2.lc-cn-n1-shared.com"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Gotcha的笔记总结</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/background/01.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java 并发">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-01 00:00" pubdate>
        2020年10月1日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      39.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      1341
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java 并发</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年3月20日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1、进程与线程"><a href="#1-1、进程与线程" class="headerlink" title="1.1、进程与线程"></a>1.1、进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云、安全卫士等）</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>一个进程之内可以分为一到多个线程。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li>
<li>Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li>
</ul>
<h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul>
<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 </li>
<li>进程拥有共享的资源，如内存空间等，供其内部的线程共享<ul>
<li>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 </li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<h2 id="1-2、并发与并行"><a href="#1-2、并发与并行" class="headerlink" title="1.2、并发与并行"></a>1.2、并发与并行</h2><p><strong>单核</strong>cpu下，线程实际还是<strong>串行执行</strong>的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。总结为一句话就是：<strong>微观串行，宏观并行</strong></p>
<p>并发是<strong>一个CPU</strong>在不同的时间去不同线程中执行指令。</p>
<p>并行是<strong>多个CPU</strong>同时处理不同的线程。</p>
<p>引用 Rob Pike 的一段描述：</p>
<ul>
<li>并发（concurrent）是同一时间<strong>应对</strong>（dealing with）多件事情的能力</li>
<li>并行（parallel）是同一时间<strong>动手做</strong>（doing）多件事情的能力</li>
</ul>
<h2 id="1-3、应用"><a href="#1-3、应用" class="headerlink" title="1.3、应用"></a>1.3、应用</h2><h3 id="应用之异步调用"><a href="#应用之异步调用" class="headerlink" title="应用之异步调用"></a>应用之异步调用</h3><p>以调用方角度来讲，如果</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<blockquote>
<p>同步在多线程中还有另一层意思：让多个线程步调一致</p>
</blockquote>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul>
<li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li>
<li>tomcat的异步servlet也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li>
<li>tomcat的工作线程ui程序中，开线程进行其他操作，避免阻塞ui线程</li>
</ul>
<h3 id="应用之提高效率"><a href="#应用之提高效率" class="headerlink" title="应用之提高效率"></a>应用之提高效率</h3><h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><ul>
<li><p>单核cpu下，多线程<strong>不能实际提高程序运行效率</strong>，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p>
</li>
<li><p>多核cpu可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p>
<ul>
<li>有些任务，经过精心设计，将任务拆分，并行执行，可以提高程序的运行效率。但不是所有计算任务都能拆分（参考【阿姆达尔定律】）</li>
<li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率就没有意义</li>
</ul>
</li>
<li><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</p>
</li>
</ul>
<h2 id="1-4、查看进程线程的方法"><a href="#1-4、查看进程线程的方法" class="headerlink" title="1.4、查看进程线程的方法"></a>1.4、查看进程线程的方法</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p>
<ul>
<li><strong>tasklist</strong>查看进程</li>
<li><strong>taskkill</strong>杀死进程</li>
</ul>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p><strong>ps -fe</strong>查看所有进程<br>**ps -fT -p <PID> **查看某个进程（PID）的所有线程<br><strong>kill</strong>杀死进程<br><strong>top</strong>按大写 H 切换是否显示线程<br>**top -H -p <PID> **查看某个进程（PID）的所有线程</PID></PID></p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p><strong>jps</strong> 命令查看所有 Java 进程<br><strong>jstack <PID></PID></strong> 查看某个 Java 进程（PID）的所有线程状态<br><strong>jconsole</strong>* 来查看某个 Java 进程中线程的运行情况（图形界面）</p>
<hr>
<h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="2-1、创建一个线程（非主线程）"><a href="#2-1、创建一个线程（非主线程）" class="headerlink" title="2.1、创建一个线程（非主线程）"></a>2.1、创建一个线程（非主线程）</h2><h3 id="方法一：通过继承Thread创建线程"><a href="#方法一：通过继承Thread创建线程" class="headerlink" title="方法一：通过继承Thread创建线程"></a>方法一：通过继承Thread创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread myThread = <span class="hljs-keyword">new</span> MyThread();<br>        <span class="hljs-comment">// 启动线程</span><br>        myThread.start();<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;my thread running...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用继承方式的好处是，在run（）方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread（）方法；不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p>
<h3 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread02</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建线程任务</span><br>        Runnable r = <span class="hljs-keyword">new</span> Runnable()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;Runnable running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//将Runnable对象传给Thread</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(r);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread02</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;my runnable running...&quot;</span>);<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      MyRunnable myRunnable = <span class="hljs-keyword">new</span> MyRunnable();<br>      Thread thread = <span class="hljs-keyword">new</span> Thread(myRunnable);<br>      thread.start();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</p>
<h4 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h4><p><strong>当一个接口带有@FunctionalInterface注解时，是可以使用lambda来简化操作的</strong></p>
<p>所以方法二中的代码可以被简化为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread02</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//改成lambda表达式方式如下</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt;System.out.println(<span class="hljs-string">&quot;Runnable running&quot;</span>)).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以在Runnable上使用<strong>Alt+Ente</strong>r,IDE会自动用lambda表达式替换匿名内部类</p>
<h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br><strong>小结</strong></p>
<ul>
<li>方法1 是把线程和任务合并在了一起</li>
<li>方法2 是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
<h3 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h3><p><strong>使用FutureTask(接收Callable类型参数)，可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread03</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//需要传入一个Callable对象</span><br>		FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>				System.out.println(<span class="hljs-string">&quot;线程执行!&quot;</span>);<br>				Thread.sleep(<span class="hljs-number">1000</span>);<br>				<span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>			&#125;<br>		&#125;);<br><br>		Thread r1 = <span class="hljs-keyword">new</span> Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);<br>		r1.start();<br>		<span class="hljs-comment">//获取线程中方法执行后的返回结果</span><br>		System.out.println(task.get());<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseFutureTask</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>      FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyCall());<br>      Thread thread = <span class="hljs-keyword">new</span> Thread(futureTask);<br>      thread.start();<br>      <span class="hljs-comment">// 获得线程运行后的返回值</span><br>      System.out.println(futureTask.get());<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<strong>继承方式的好处是方便传参</strong>，可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量（JDK1.8之后可以用不发生改变的非final变量）。<strong>不好的地方是Java不支持多继承</strong>，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</strong></p>
<h2 id="2-2、原理之线程运行"><a href="#2-2、原理之线程运行" class="headerlink" title="2.2、原理之线程运行"></a>2.2、原理之线程运行</h2><h3 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈） JVM 中由堆、栈、方法区所组成，其中栈内存是给线程使用的</p>
<ul>
<li>每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li>
<li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong></li>
<li>每个线程只能有一个<strong>活动栈帧</strong>，对应着当前正在执行的那个方法</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/2.1.png" srcset="/img/loading.gif" lazyload alt="2.0.1"></p>
<h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的 cpu 时间片用完</li>
<li>垃圾回收 有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ul>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条jvm指令的执行地址，是线程私有的</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch频繁发生会影响性能</li>
</ul>
<h2 id="2-3、常用方法"><a href="#2-3、常用方法" class="headerlink" title="2.3、常用方法"></a>2.3、常用方法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能说明</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>start()</td>
<td></td>
<td>启动一个新线程，在新的线程运行 run 方法中的代码</td>
<td>start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现IllegalThreadStateException</td>
</tr>
<tr>
<td>run()</td>
<td></td>
<td>新线程启动后会调用的方法</td>
<td>如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为</td>
</tr>
<tr>
<td>join()</td>
<td></td>
<td>等待线程运行结束</td>
<td></td>
</tr>
<tr>
<td>join(long n)</td>
<td></td>
<td>等待线程运行结束,最多等待 n毫秒</td>
<td></td>
</tr>
<tr>
<td>getId()</td>
<td></td>
<td>获取线程长整型的 id</td>
<td>id 唯一</td>
</tr>
<tr>
<td>getName()</td>
<td></td>
<td>获取线程名</td>
<td></td>
</tr>
<tr>
<td>setName(String)</td>
<td></td>
<td>修改线程名</td>
<td></td>
</tr>
<tr>
<td>getPriority()</td>
<td></td>
<td>获取线程优先级</td>
<td></td>
</tr>
<tr>
<td>setPriority(int)</td>
<td></td>
<td>修改线程优先级</td>
<td>java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率</td>
</tr>
<tr>
<td>getState()</td>
<td></td>
<td>获取线程状态</td>
<td>Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING,TIMED_WAITING, TERMINATED</td>
</tr>
<tr>
<td>isInterrupted()</td>
<td></td>
<td>判断是否被打断</td>
<td>不会清除打断标记</td>
</tr>
<tr>
<td>isAlive()</td>
<td></td>
<td>线程是否存活（还没有运行完毕）</td>
<td></td>
</tr>
<tr>
<td>interrupt()</td>
<td></td>
<td>打断线程</td>
<td>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除打断标记；如果打断的正在运行的线程，则会设置打断标记；park的线程被打断，也会设置打断标记。interrupt()<code>会使得</code>中断状态<code>为true，并调用</code>unpark</td>
</tr>
<tr>
<td>interrupted()</td>
<td>static</td>
<td>判断当前线程是否被打断</td>
<td>会清除打断标记</td>
</tr>
<tr>
<td>currentThread()</td>
<td>static</td>
<td>获取当前正在执行的线程</td>
<td></td>
</tr>
<tr>
<td>sleep(long n)</td>
<td>static</td>
<td>让当前执行的线程休眠n毫秒，休眠时让出 cpu的时间片给其它线程</td>
<td></td>
</tr>
<tr>
<td>yield()</td>
<td>static</td>
<td>提示线程调度器让出当前线程对CPU的使用</td>
<td>主要是为了测试和调试</td>
</tr>
</tbody></table>
<h3 id="start-与-run"><a href="#start-与-run" class="headerlink" title="start() 与 run()"></a>start() 与 run()</h3><h4 id="调用-run"><a href="#调用-run" class="headerlink" title="调用 run"></a>调用 run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>			log.debug(Thread.currentThread().getName());<br>			FileReader.read(Constants.MP4_FULL_PATH);<br>		&#125;<br>	&#125;;<br>	t1.run();<br>	log.debug(<span class="hljs-string">&quot;do other things ...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">19</span>:<span class="hljs-number">39</span>:<span class="hljs-number">14</span> [main] c.TestStart - main<br><span class="hljs-number">19</span>:<span class="hljs-number">39</span>:<span class="hljs-number">14</span> [main] c.FileReader - read [<span class="hljs-number">1.</span>mp4] start ...<br><span class="hljs-number">19</span>:<span class="hljs-number">39</span>:<span class="hljs-number">18</span> [main] c.FileReader - read [<span class="hljs-number">1.</span>mp4] end ... cost: <span class="hljs-number">4227</span> ms<br><span class="hljs-number">19</span>:<span class="hljs-number">39</span>:<span class="hljs-number">18</span> [main] c.TestStart - <span class="hljs-keyword">do</span> other things ...<br></code></pre></td></tr></table></figure>

<p>结果</p>
<ul>
<li>程序仍在 main 线程运行，没有开启新的线程。<code>FileReader.read()</code>方法调用还是同步的</li>
</ul>
<h4 id="调用-start"><a href="#调用-start" class="headerlink" title="调用 start"></a>调用 start</h4><p>将上述代码的 <code>t1.run();</code>改为<code>t1.start();</code></p>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">19</span>:<span class="hljs-number">41</span>:<span class="hljs-number">30</span> [main] c.TestStart - <span class="hljs-keyword">do</span> other things ...<br><span class="hljs-number">19</span>:<span class="hljs-number">41</span>:<span class="hljs-number">30</span> [t1] c.TestStart - t1<br><span class="hljs-number">19</span>:<span class="hljs-number">41</span>:<span class="hljs-number">30</span> [t1] c.FileReader - read [<span class="hljs-number">1.</span>mp4] start ...<br><span class="hljs-number">19</span>:<span class="hljs-number">41</span>:<span class="hljs-number">35</span> [t1] c.FileReader - read [<span class="hljs-number">1.</span>mp4] end ... cost: <span class="hljs-number">4542</span> ms<br></code></pre></td></tr></table></figure>

<p>结果</p>
<ul>
<li>开启了新的线程t1，程序在t1线程运行，<code>FileReader.read()</code>方法调用是异步的</li>
</ul>
<h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h4><ul>
<li>直接调用run是在<strong>主线程中执行</strong>了run，没有启动新的线程</li>
<li>使用start是<strong>启动新的线程</strong>，通过新的线程间接执行 run 中的代码</li>
</ul>
<h3 id="sleep-与yield"><a href="#sleep-与yield" class="headerlink" title="sleep()与yield()"></a>sleep()与yield()</h3><h4 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep(使线程阻塞)"></a>sleep(使线程阻塞)</h4><ol>
<li>调用 sleep 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</li>
<li>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出<code>InterruptedException</code>异常</li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span><br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//休眠一分钟</span><br>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<h4 id="yield（让出当前线程）"><a href="#yield（让出当前线程）" class="headerlink" title="yield（让出当前线程）"></a>yield（让出当前线程）</h4><ol>
<li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ol>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul>
<li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li>
<li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li>
<li>设置方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-comment">//设置为优先级最高</span><br></code></pre></td></tr></table></figure>

<h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h3><ul>
<li>用于等待某个线程结束。线程内调用哪个线程join()方法，就等待哪个线程结束，然后再去执行其他线程。</li>
</ul>
<blockquote>
<p>如：在主线程中调用ti.join()，则是主线程等待t1线程结束</p>
</blockquote>
<ul>
<li>有时效的 join，join(long n)，等待线程运行结束,最多等待 n毫秒。如果n毫秒内线程执行完毕，则会直接执行之后的语句</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread();<br><span class="hljs-comment">//等待thread线程执行结束</span><br>thread.join();<br><span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span><br>thread.join(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<h3 id="interrupt-方法"><a href="#interrupt-方法" class="headerlink" title="interrupt()方法"></a>interrupt()方法</h3><p>用于打断<strong>阻塞</strong>(sleep、wait、join…)的线程。（处于阻塞状态的线程，CPU不会给其分配时间片）。</p>
<ul>
<li>如果一个线程在在运行中被打断，打断标记会被置为true（即打断正常运行的线程, 不会清空打断状态）</li>
<li>如果是打断因sleep、wait、join方法而被阻塞的线程，会将打断标记置为false</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于查看打断标记，返回值被boolean类型</span><br>t1.isInterrupted();<br></code></pre></td></tr></table></figure>

<p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a>interrupt方法的应用——两阶段终止模式</h4><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/2.2.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTerminationPattern</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>        monitor.start();<br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        monitor.stop();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;<br><br>    Thread monitor;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>        monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//开始不停的监控</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-comment">//判断当前线程是否被打断了</span><br>                    <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-comment">//终止线程执行</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//线程休眠</span><br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                        <span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span><br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 	用于停止监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//打断线程</span><br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Thread.interrupted()：用来清除打断状态</p>
</blockquote>
<h3 id="不推荐使用的方法"><a href="#不推荐使用的方法" class="headerlink" title="不推荐使用的方法"></a>不推荐使用的方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>stop()</td>
<td></td>
<td>停止线程运行</td>
</tr>
<tr>
<td>suspend()</td>
<td></td>
<td>挂起（暂停）线程运行</td>
</tr>
<tr>
<td>resume()</td>
<td></td>
<td>恢复线程运行</td>
</tr>
</tbody></table>
<blockquote>
<p>上述三个方法，已过时，容易破坏同步代码块，造成线程死锁</p>
</blockquote>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>当Java进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，Java进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将线程设置为守护线程, 默认为false</span><br>monitor.setDaemon(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure>

<h4 id="守护线程的应用"><a href="#守护线程的应用" class="headerlink" title="守护线程的应用"></a>守护线程的应用</h4><ul>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat 中的Acceptor和Poller线程都是守护线程，所以 Tomcat 接收到shutdown命令后，不会等待它们处理完当前请求</li>
</ul>
<h2 id="2-4、线程的状态"><a href="#2-4、线程的状态" class="headerlink" title="2.4、线程的状态"></a>2.4、线程的状态</h2><h3 id="2-4-1-五种状态"><a href="#2-4-1-五种状态" class="headerlink" title="2.4.1 五种状态"></a>2.4.1 五种状态</h3><p>这是从<strong>操作系统</strong>层面来描述的</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/2.3.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如new了Thread对象但还没有调用start方法）</li>
<li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li>
<li>【运行状态】指获取了 CPU 时间片运行中的状态<ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li>【阻塞状态】<ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li>
</ul>
</li>
<li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ul>
<h3 id="2-5-2-六种状态"><a href="#2-5-2-六种状态" class="headerlink" title="2.5.2 六种状态"></a>2.5.2 六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/2.4.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li>
<li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是<strong>可运行</strong>）</li>
<li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。</li>
<li><strong>TERMINATED</strong> 当线程代码运行结束</li>
</ul>
<hr>
<h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="3-1、共享带来的问题"><a href="#3-1、共享带来的问题" class="headerlink" title="3.1、共享带来的问题"></a>3.1、共享带来的问题</h2><h3 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 Critical Section"></a>临界区 Critical Section</h3><ul>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在多个线程访问共享资源<ul>
<li>多个线程读共享资源其实也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
</ul>
</li>
<li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong><br>例如，下面代码中的临界区</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br><span class="hljs-function"></span>&#123;   <br>    counter++; <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br><span class="hljs-function"></span>&#123; <br>    counter--; <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="竞态条件-Race-Condition"><a href="#竞态条件-Race-Condition" class="headerlink" title="竞态条件 Race Condition"></a>竞态条件 Race Condition</h3><p>多个线程在<strong>临界区</strong>内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p>
<h2 id="3-2、synchronized-解决方案"><a href="#3-2、synchronized-解决方案" class="headerlink" title="3.2、synchronized 解决方案"></a>3.2、synchronized 解决方案</h2><h3 id="解决手段"><a href="#解决手段" class="headerlink" title="解决手段"></a>解决手段</h3><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p>
<ul>
<li>阻塞式的解决方案：synchronized，Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p>
<h3 id="synchronized语法"><a href="#synchronized语法" class="headerlink" title="synchronized语法"></a>synchronized语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;<br>	<span class="hljs-comment">//临界区</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Synchronized01</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//创建一个公共对象，作为对象锁的对象</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    counter++;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    counter--;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="面向对象改进"><a href="#面向对象改进" class="headerlink" title="面向对象改进"></a>面向对象改进</h3><p>把需要保护的共享变量放入一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Synchronized02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Room room = <span class="hljs-keyword">new</span> Room();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    room.increment();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    room.decrement();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,room.get());<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            value++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            value--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="synchronized加在方法上"><a href="#synchronized加在方法上" class="headerlink" title="synchronized加在方法上"></a>synchronized加在方法上</h3><h4 id="加在成员方法上"><a href="#加在成员方法上" class="headerlink" title="加在成员方法上"></a>加在成员方法上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>	<span class="hljs-comment">//在方法上加上synchronized关键字</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>	<br>	&#125;<br>	<span class="hljs-comment">//等价于</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>		<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="加在静态方法上"><a href="#加在静态方法上" class="headerlink" title="加在静态方法上"></a>加在静态方法上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>	<span class="hljs-comment">//在静态方法上加上synchronized关键字</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>	<br>	&#125;<br>	<span class="hljs-comment">//等价于</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">synchronized</span>(Demo.class) &#123;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-3、变量的线程安全分析"><a href="#3-3、变量的线程安全分析" class="headerlink" title="3.3、变量的线程安全分析"></a>3.3、变量的线程安全分析</h2><h3 id="成员变量和静态变量线程安全性"><a href="#成员变量和静态变量线程安全性" class="headerlink" title="成员变量和静态变量线程安全性"></a>成员变量和静态变量线程安全性</h3><p>成员变量和静态变量是否线程安全？</p>
<ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h3 id="局部变量线程安全性"><a href="#局部变量线程安全性" class="headerlink" title="局部变量线程安全性"></a>局部变量线程安全性</h3><p>局部变量是否线程安全？</p>
<ul>
<li>局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>	i++;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.1.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>但局部变量引用的对象则未必 （要看该对象是否被共享且被执行了读写操作）<ul>
<li>如果该对象没有逃离方法的作用范围，它是线程安全的</li>
<li>如果该对象逃离（return）方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafe</span> </span>&#123;<br>	ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>		<span class="hljs-comment">// &#123; 临界区, 会产生竞态条件</span><br>			method2();<br>			method3();<br>        <span class="hljs-comment">// &#125; 临界区</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>		list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>		list.remove(<span class="hljs-number">0</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THREAD_NUMBER = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LOOP_NUMBER = <span class="hljs-number">200</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	ThreadUnsafe test = <span class="hljs-keyword">new</span> ThreadUnsafe();<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br>		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>			test.method1(LOOP_NUMBER);<br>		&#125;, <span class="hljs-string">&quot;Thread&quot;</span> + i).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中一种情况是，如果线程2还未add，线程1remove就会报错：</p>
<p><code>Exception in thread &quot;Thread1&quot; java.lang.IndexOutOfBoundsException: Index: 0, Size: 0</code></p>
<blockquote>
<p>因为会出现指令重排，在同一个线程中有可能method3先于method2执行</p>
</blockquote>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.2.png" srcset="/img/loading.gif" lazyload></p>
<p>将 list 修改为局部变量，就不会有上述问题了</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>		ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>			method2(list);<br>			method3(list);<br>		&#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>		list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>		list.remove(<span class="hljs-number">0</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>分析：<br>list 是局部变量，每个线程调用时会创建其不同实例，没有共享<br>而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象<br>method3 的参数分析与 method2 相同</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.3.png" srcset="/img/loading.gif" lazyload></p>
<p>如果把 method2 和 method3 的方法修改为 public 会不会线程安全问题？</p>
<ul>
<li>情况1：有其它线程调用 method2 和 method3<ul>
<li>不会，因为其他线程调用时，传入的list对象，与其他线程不是同一个</li>
</ul>
</li>
<li>情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadSafe</span></span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>			list.remove(<span class="hljs-number">0</span>);<br>		&#125;).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>会，因为有新的线程，和原来的线程，共享了同一个list对象</li>
</ul>
<blockquote>
<p>可以用private，final修饰，加强线程安全性</p>
</blockquote>
<h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuﬀer</li>
<li>Random</li>
<li>Vector （List的线程安全实现类）</li>
<li>Hashtable （Hash的线程安全实现类）</li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p>
<ul>
<li>它们的每个方法是原子的（都被加上了synchronized）</li>
<li>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</li>
</ul>
<p>组合后，线程不安全。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Hashtable table = <span class="hljs-keyword">new</span> Hashtable();<br><span class="hljs-comment">// 线程1，线程2</span><br><span class="hljs-keyword">if</span>( table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-keyword">null</span>) &#123;<br>	table.put(<span class="hljs-string">&quot;key&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure>



<pre><code class=" mermaid">sequenceDiagram
participant t1 as 线程1
participant t2 as 线程2
participant table
t1 -&gt;&gt; table : get(&quot;key&quot;) == null
t2 -&gt;&gt; table : get(&quot;key&quot;) == null
t2 -&gt;&gt; table : put(&quot;key&quot;,v2)
t1 -&gt;&gt; table : put(&quot;key&quot;,v1)
</code></pre>

<h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其<strong>内部的状态不可以改变</strong>，因此它们的方法都是线程安全的</p>
<p>String 有 replace，substring 等方法可以”改变值“，这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>	<span class="hljs-comment">// 是否安全？</span><br>	Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();  <span class="hljs-comment">//不安全</span><br>	<span class="hljs-comment">// 是否安全？</span><br>	String S1 = <span class="hljs-string">&quot;...&quot;</span>;	<span class="hljs-comment">//安全</span><br>	<span class="hljs-comment">// 是否安全？</span><br>	<span class="hljs-keyword">final</span> String S2 = <span class="hljs-string">&quot;...&quot;</span>;	<span class="hljs-comment">//安全</span><br>	<span class="hljs-comment">// 是否安全？</span><br>	Date D1 = <span class="hljs-keyword">new</span> Date();	<span class="hljs-comment">//不安全</span><br>	<span class="hljs-comment">// 是否安全？</span><br>	<span class="hljs-keyword">final</span> Date D2 = <span class="hljs-keyword">new</span> Date();	<span class="hljs-comment">//不安全，D2引用地址不会变，但是地址存的内容(如Date的属性)可能发生改变</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>    	<span class="hljs-comment">// 使用上述变量</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>	<span class="hljs-comment">// 是否安全？ </span><br>	<span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl(); <span class="hljs-comment">//	不安全，Servlet是单例的，UserServiceImpl有成员变量。多个线程会共享MyServlet</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>		userService.update(...);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>	<span class="hljs-comment">// 记录调用次数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// ...</span><br>		count++;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>	<span class="hljs-comment">// 是否安全？</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">0L</span>; <span class="hljs-comment">// spring默认是单例的，这个MyAspect类会被共享，不安全。改成多例也不行，进入前置通知和后置通知时可能是不同的对象</span><br>	<span class="hljs-meta">@Before(&quot;execution(* *(..))&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>		start = System.nanoTime();<br>	&#125;<br>	<span class="hljs-meta">@After(&quot;execution(* *(..))&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">long</span> end = System.nanoTime();<br>		System.out.println(<span class="hljs-string">&quot;cost time:&quot;</span> + (end-start));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>可以换成环绕通知，把成员变量变成局部变量</p>
</blockquote>
<p>例4：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>	<span class="hljs-comment">// 是否安全</span><br>	<span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl(); <span class="hljs-comment">// 线程安全，UserServiceImpl中有成员变量但是私有，外界无法修改</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>		userService.update(...);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>	<span class="hljs-comment">// 是否安全</span><br>	<span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<span class="hljs-comment">// 线程安全，userDaoImpl中没有共享的成员变量</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>		userDao.update();<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>		String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>		<span class="hljs-comment">// 是否安全 </span><br>		<span class="hljs-keyword">try</span> (Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>))&#123;<span class="hljs-comment">// 线程安全，Connection是局部变量，没有用到成员变量</span><br>			<span class="hljs-comment">// ...</span><br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			<span class="hljs-comment">// ...</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例5：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>	<span class="hljs-comment">// 是否安全</span><br>	<span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>		userService.update(...);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>	<span class="hljs-comment">// 是否安全</span><br>	<span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>		userDao.update();<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>	<span class="hljs-comment">// 是否安全</span><br>	<span class="hljs-keyword">private</span> Connection conn = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 线程不安全，Connection是成员变量，</span><br>    								<span class="hljs-comment">//Myservlet是单例被个线程共享，UserDaoImpl以及成员变量Connection也是线程共享</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>		String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>		conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>		<span class="hljs-comment">// ...</span><br>		conn.close();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例6：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>	<span class="hljs-comment">// 是否安全</span><br>	<span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>		userService.update(...);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>		UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl(); <span class="hljs-comment">// 线程安全，虽然Connection是成员变量</span><br>        									 <span class="hljs-comment">//，但是每次调用UserServiceImpl时都会创建新的Connection互不干扰</span><br>		userDao.update();<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>	<span class="hljs-comment">// 是否安全</span><br>	<span class="hljs-keyword">private</span> Connection = <span class="hljs-keyword">null</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>		String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>		conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>		<span class="hljs-comment">// ...</span><br>		conn.close();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例7：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 是否安全</span><br>		SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="hljs-comment">//线程不安全，虽然sdf是局部变量。但是子类可能启动一个新的线程并发</span><br>        																   <span class="hljs-comment">//访问，导致不安全的发生，造成泄漏			</span><br>		foo(sdf);<br>    &#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title">foo</span><span class="hljs-params">(SimpleDateFormat sdf)</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">new</span> Test().bar();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为<strong>外星方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(SimpleDateFormat sdf)</span> </span>&#123;<br>	String dateStr = <span class="hljs-string">&quot;1999-10-11 00:00:00&quot;</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				sdf.parse(dateStr);<br>			&#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>		&#125;).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer i = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>	List&lt;Thread&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>		Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">5000</span>; k++) &#123;<br>				<span class="hljs-keyword">synchronized</span> (i) &#123;<br>					i++;<br>				&#125;<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;&quot;</span> + j);<br>		list.add(thread);<br>	&#125;<br>	list.stream().forEach(t -&gt; t.start());<br>	list.stream().forEach(t -&gt; &#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			t.join();<br>		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;);<br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-4、Monitor"><a href="#3-4、Monitor" class="headerlink" title="3.4、Monitor"></a>3.4、Monitor</h2><h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>以 32 位虚拟机为例</p>
<h4 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-params">|--------------------------------------------------------------|</span><br><span class="hljs-params">| 					Object Header (64 bits)                    |</span><br><span class="hljs-params">|------------------------------------|</span>-------------------------<span class="hljs-params">|</span><br><span class="hljs-params">|</span> Mark Word (<span class="hljs-number">32</span> bits)	 			 <span class="hljs-params">| Klass Word (32 bits)	   |</span><br><span class="hljs-params">|------------------------------------|</span>-------------------------<span class="hljs-params">|</span><br></code></pre></td></tr></table></figure>

<h4 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">|---------------------------------------------------------------------------------|<br>| 							<span class="hljs-function">Object <span class="hljs-title">Header</span> <span class="hljs-params">(<span class="hljs-number">96</span> bits)</span> 							  |</span><br><span class="hljs-function">|--------------------------------|-----------------------|------------------------|</span><br><span class="hljs-function">| Mark <span class="hljs-title">Word</span><span class="hljs-params">(32bits)</span> 			 | Klass <span class="hljs-title">Word</span><span class="hljs-params">(32bits)</span>    | array <span class="hljs-title">length</span><span class="hljs-params">(32bits)</span>   |</span><br><span class="hljs-function">|--------------------------------|-----------------------|------------------------|</span><br></code></pre></td></tr></table></figure>

<p>其中 Mark Word 结构为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">|-------------------------------------------------------|--------------------|<br>| <span class="hljs-function">Mark <span class="hljs-title">Word</span> <span class="hljs-params">(<span class="hljs-number">32</span> bits)</span> 									| 		State		 |</span><br><span class="hljs-function">|-------------------------------------------------------|--------------------|</span><br><span class="hljs-function">| hashcode:25		  | age:4 | biased_lock:0	| 01 	| 		Normal 		 |</span><br><span class="hljs-function">|-------------------------------------------------------|--------------------|</span><br><span class="hljs-function">| thread:23 | epoch:2 | age:4 | biased_lock:1 	| 01 	| 		Biased		 |</span><br><span class="hljs-function">|-------------------------------------------------------|--------------------|</span><br><span class="hljs-function">|			 ptr_to_lock_record:30 				| 00	| Lightweight Locked |</span><br><span class="hljs-function">|-------------------------------------------------------|--------------------|</span><br><span class="hljs-function">| 			ptr_to_heavyweight_monitor:30 		| 10    | Heavyweight Locked |</span><br><span class="hljs-function">|-------------------------------------------------------|--------------------|</span><br><span class="hljs-function">| 												| 11	|	 Marked <span class="hljs-keyword">for</span> GC   |</span><br><span class="hljs-function">|-------------------------------------------------------|--------------------|</span><br></code></pre></td></tr></table></figure>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用synchronized给对象上锁（<strong>重量级</strong>）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针。</p>
<p>原本对象头中的hashcode、age、biased_lock等信息会被复制到对应的Monitor对象中保存。解锁时，再复制回对象头</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.4.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.5.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>刚开始 Monitor 中 Owner 为 null</p>
</li>
<li><p>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。</p>
<p>（obj对象和Monitor对象，是一对一的）</p>
<ul>
<li>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。（Monitor中只能有一个 Owner）</li>
<li>如果已经绑定，则会去查询该Monitor是否已经有了Owner<ul>
<li>如果没有，则Owner与将当前线程绑定</li>
<li>如果有，则放入EntryList（阻塞队列），进入阻塞状态(blocked)</li>
</ul>
</li>
</ul>
</li>
<li><p>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></p>
</li>
<li><p><strong>注意</strong>：</p>
<ul>
<li>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</li>
<li>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</li>
</ul>
</li>
</ul>
<h3 id="字节码角度分析"><a href="#字节码角度分析" class="headerlink" title="字节码角度分析"></a>字节码角度分析</h3><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-keyword">synchronized</span> (lock) &#123;<br>		counter++;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应的字节码为    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>	descriptor: ([Ljava/lang/String;)V<br>	flags: ACC_PUBLIC, ACC_STATIC<br>	Code:<br>		stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>			<span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// &lt;- lock引用 （synchronized开始）</span><br>			<span class="hljs-number">3</span>: dup<br>			<span class="hljs-number">4</span>: astore_1 <span class="hljs-comment">// lock引用 -&gt; slot 1 (解锁时使用)</span><br>			<span class="hljs-number">5</span>: monitorenter <span class="hljs-comment">// 将 lock对象 MarkWord 置为 Monitor 指针</span><br>			<span class="hljs-number">6</span>: getstatic #<span class="hljs-number">3</span> <span class="hljs-comment">// &lt;- i</span><br>			<span class="hljs-number">9</span>: iconst_1 <span class="hljs-comment">// 准备常数 1</span><br>			<span class="hljs-number">10</span>: iadd <span class="hljs-comment">// +1</span><br>			<span class="hljs-number">11</span>: putstatic #<span class="hljs-number">3</span> <span class="hljs-comment">// -&gt; i</span><br>			<span class="hljs-number">14</span>: aload_1 <span class="hljs-comment">// &lt;- lock引用</span><br>			<span class="hljs-number">15</span>: monitorexit <span class="hljs-comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span><br>			<span class="hljs-number">16</span>: goto <span class="hljs-number">24</span><br>			<span class="hljs-number">19</span>: astore_2 <span class="hljs-comment">// e -&gt; slot 2 (发生异常，将异常对象存储)</span><br>			<span class="hljs-number">20</span>: aload_1 <span class="hljs-comment">// &lt;- lock引用</span><br>			<span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span><br>			<span class="hljs-number">22</span>: aload_2 <span class="hljs-comment">// &lt;- slot 2 (e)</span><br>			<span class="hljs-number">23</span>: athrow <span class="hljs-comment">// throw e</span><br>			<span class="hljs-number">24</span>: <span class="hljs-keyword">return</span><br>		Exception table:<br>			from to target type<br>			  <span class="hljs-number">6</span>  <span class="hljs-number">16</span>  <span class="hljs-number">19</span>	    any<br>			  <span class="hljs-number">19</span> <span class="hljs-number">22</span>  <span class="hljs-number">19</span>     any<br>		LineNumberTable:<br>			line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>			line <span class="hljs-number">9</span>: <span class="hljs-number">6</span><br>			line <span class="hljs-number">10</span>: <span class="hljs-number">14</span><br>			line <span class="hljs-number">11</span>: <span class="hljs-number">24</span><br>		LocalVariableTable:<br>			Start Length Slot Name     Signature<br>			  <span class="hljs-number">0</span>     <span class="hljs-number">25</span>    <span class="hljs-number">0</span>   args [Ljava/lang/String;<br>		StackMapTable: number_of_entries = <span class="hljs-number">2</span><br>		frame_type = <span class="hljs-number">255</span> <span class="hljs-comment">/* full_frame */</span><br>		offset_delta = <span class="hljs-number">19</span><br>		locals = [ <span class="hljs-class"><span class="hljs-keyword">class</span> &quot;[<span class="hljs-title">Ljava</span>/<span class="hljs-title">lang</span>/<span class="hljs-title">String</span></span>;<span class="hljs-string">&quot;, class java/lang/Object ]</span><br><span class="hljs-string">		stack = [ class java/lang/Throwable ]</span><br><span class="hljs-string">		frame_type = 250 /* chop */</span><br><span class="hljs-string">		 offset_delta = 4</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>在同步代码块内，发生了异常也会正常解锁</p>
<p>方法级别的 synchronized 不会在字节码指令中有所体现</p>
</blockquote>
<h2 id="3-5、Synchronized原理进阶"><a href="#3-5、Synchronized原理进阶" class="headerlink" title="3.5、Synchronized原理进阶"></a>3.5、Synchronized原理进阶</h2><h3 id="3-5-1-轻量级锁"><a href="#3-5-1-轻量级锁" class="headerlink" title="3.5.1 轻量级锁"></a>3.5.1 轻量级锁</h3><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。即用于优化Monitor这类的重量级锁。</p>
<p>轻量级锁对使用者是透明的，即语法<strong>仍然是synchronized</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>		<span class="hljs-comment">// 同步块 A</span><br>		method2();<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>		<span class="hljs-comment">// 同步块 B</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个<strong>锁记录</strong>对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）<ul>
<li>注意，此时对象mark word，最后是<strong>01，代表没有加锁</strong></li>
</ul>
</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.6.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>让锁记录中的Object reference指向锁对象（Object），并尝试用<strong>cas</strong>去替换Object中的mark word，将此mark word放入lock record中保存</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.7.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁<ul>
<li>注意，此时对象mark word，最后是<strong>00，代表轻量级锁状态</strong></li>
</ul>
</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.8.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>如果 cas 失败，有两种情况</p>
<ul>
<li><p>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入<strong>锁膨胀</strong>过程</p>
</li>
<li><p>如果是自己执行了 synchronized <strong>锁重入</strong>，那么再添加一条 Lock Record 作为重入的计数</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-5-2-锁重入"><a href="#3-5-2-锁重入" class="headerlink" title="3.5.2 锁重入"></a>3.5.2 锁重入</h3><ul>
<li>如果是自己执行了 synchronized <strong>锁重入</strong>，那么再添加一条 Lock Record 作为重入的计数（Object已经被自己线程锁住，可以正常使用）</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.9.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p>
</li>
<li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas <strong>将 Mark Word 的值恢复给对象头</strong></p>
<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，<strong>进入重量级锁解锁流程</strong></li>
</ul>
</li>
</ul>
<h3 id="3-5-3-锁膨胀"><a href="#3-5-3-锁膨胀" class="headerlink" title="3.5.3 锁膨胀"></a>3.5.3 锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行<strong>锁膨胀</strong>，<strong>将轻量级锁变为重量级锁</strong>。</p>
<ul>
<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.10.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul>
<li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址<ul>
<li>注意，此时对象mark word，最后是<strong>10，代表重量级锁状态</strong></li>
</ul>
</li>
<li>然后自己进入 Monitor 的 EntryList BLOCKED</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.11.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>当 Thread-0退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会<strong>进入重量级解锁流程</strong>，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li>
</ul>
<h3 id="3-5-4-自旋优化"><a href="#3-5-4-自旋优化" class="headerlink" title="3.5.4 自旋优化"></a>3.5.4 自旋优化</h3><p><strong>重量级锁</strong>竞争时，还可以使用自旋来优化，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>），这时就可以避免线程进入阻塞状态。</p>
<ul>
<li>自旋成功</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.12.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>自旋失败</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.13.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋反而浪费性能（一定自旋不开），多核 CPU 自旋才能发挥优势。</li>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h3 id="3-5-5-偏向锁"><a href="#3-5-5-偏向锁" class="headerlink" title="3.5.5 偏向锁"></a>3.5.5 偏向锁</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p>
<p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。即，<strong>偏向锁用于优化轻量级锁重入</strong></p>
<blockquote>
<p>JDK15已经默认禁用偏向锁机制</p>
</blockquote>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>			<span class="hljs-comment">// 同步块 A</span><br>			m2();<br>		&#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>			<span class="hljs-comment">// 同步块 B</span><br>			m3();<br>		&#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>            <span class="hljs-comment">// 同步块 C</span><br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>使用偏向锁前：</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.14.png" srcset="/img/loading.gif" lazyload></p>
<p>使用偏向锁前：</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.15.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><ul>
<li><strong>Normal</strong>：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li>
<li><strong>Biased</strong>：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li>
<li><strong>Lightweight</strong>：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li>
<li><strong>Heavyweight</strong>：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.16.png" srcset="/img/loading.gif" lazyload></p>
<p>一个对象创建时：</p>
<ul>
<li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101，这时它的thread、epoch、age 都为 0</li>
<li>但是偏向锁默认是<strong>有延迟</strong>的，不会在程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态<ul>
<li>如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay=0 来禁用延迟</li>
</ul>
</li>
<li>如果没有开启偏向锁，对象的Mark Word后三位应该是001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li>
</ul>
<h4 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h4><p>以下几种情况会使对象的偏向锁失效</p>
<ul>
<li>调用对象的hashCode方法<ul>
<li>调用了对象的 hashCode后，偏向锁的对象MarkWord中存储的线程 id会被hashCode所覆盖，导致偏向锁失效<ul>
<li>轻量级锁会在锁记录中记录 hashCode</li>
<li>重量级锁会在 Monitor 中记录 hashCode</li>
</ul>
</li>
</ul>
</li>
<li>多个线程使用该对象，，会将偏向锁升级为轻量级锁（不存在竞争时），存在竞争会升级到重量锁</li>
<li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li>
</ul>
<h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><ul>
<li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul>
<li>没有超过阈值时，重偏向会重置Thread ID</li>
</ul>
</li>
<li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li>
</ul>
<h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><p>当撤销偏向锁的阈值超过40以后，JVM就会将<strong>整个类的对象都改为不可偏向的</strong></p>
<h3 id="3-5-6-锁消除"><a href="#3-5-6-锁消除" class="headerlink" title="3.5.6 锁消除"></a>3.5.6 锁消除</h3><p>锁消除是发生在编译器级别的一种锁优化方式。如果判断到一段代码中，在<strong>堆上的所有数据都不会逃逸</strong>出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。 运行时就会消除锁，提高运行效率</p>
<p>锁消除是指虚拟机即时编译器（JIT）运行时，对一些代码上要求同步，但是被检测到<strong>不可能存在共享数据竞争</strong>的锁进行消除。</p>
<h3 id="3-5-7-锁粗化"><a href="#3-5-7-锁粗化" class="headerlink" title="3.5.7 锁粗化"></a>3.5.7 锁粗化</h3><p>在遇到一连串地对同一锁不断进行请求和释放的操作时，<strong>把所有的锁操作整合成锁的一次请求</strong>，从而减少对锁的请求同步次数。</p>
<h3 id="3-5-8-概述"><a href="#3-5-8-概述" class="headerlink" title="3.5.8 概述"></a>3.5.8 概述</h3><p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.17.1.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="3-6、Wait-Notify"><a href="#3-6、Wait-Notify" class="headerlink" title="3.6、Wait/Notify"></a>3.6、Wait/Notify</h2><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.17.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li>
</ul>
<h4 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h4><p><code>obj.wait() </code>让进入 object 监视器的线程到 waitSet 等待。无限制等待，直到notify 为止</p>
<p><code>obj.wait(long n) </code>有时限的等待, 到 n 毫秒后结束等待，或是被 notify</p>
<p><code>obj.notify()</code> 在 object 上正在 waitSet 等待的线程中挑一个唤醒</p>
<p><code>obj.notifyAll() </code>让 object 上正在 waitSet 等待的线程全部唤醒</p>
<p><strong>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法</strong></p>
<ul>
<li><strong>锁对象调用wait方法（</strong>obj.wait），就会使当前线程进入WaitSet中，变为WAITING状态。</li>
<li>处于BLOCKED和WAITING状态的线程都为阻塞状态，CPU都不会分给他们时间片。但是有所区别：<ul>
<li>BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li>
<li>WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li>
</ul>
</li>
<li>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于WAITING状态的线程只有被<strong>锁对象调用了notify方法</strong>(obj.notify/obj.notifyAll)，才会被唤醒。</li>
</ul>
<blockquote>
<p>是锁对象调用wait\notify方法，调用前线程必须获得此对象的锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>	<span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//只有在对象被锁住后才能调用wait方法</span><br>		<span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>			LOCK.wait();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Wait与Sleep的区别"><a href="#Wait与Sleep的区别" class="headerlink" title="Wait与Sleep的区别"></a>Wait与Sleep的区别</h4><p><strong>不同点</strong></p>
<ul>
<li>Sleep是<strong>Thread</strong>类的静态方法，Wait是<strong>Object</strong>的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li>
<li><strong>Sleep在阻塞的时候不会释放锁</strong>，而Wait在阻塞的时候会释放锁</li>
<li>Sleep不需要与synchronized一起使用，而<strong>Wait需要与synchronized一起使用</strong>（对象被锁以后才能使用）</li>
</ul>
<p><strong>相同点</strong></p>
<ul>
<li>阻塞状态都为<strong>TIMED_WAITING</strong></li>
</ul>
<h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 等待的A线程</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>	<span class="hljs-keyword">while</span>(条件不成立) &#123;<br>		lock.wait();<br>	&#125;	<br>	<span class="hljs-comment">// 干活</span><br>&#125;<br><br><span class="hljs-comment">// 正在运行的B线程</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>	lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-7、同步模式之保护性暂停"><a href="#3-7、同步模式之保护性暂停" class="headerlink" title="3.7、同步模式之保护性暂停"></a>3.7、同步模式之保护性暂停</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果<br><strong>要点</strong></p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到<strong>同步模式</strong></li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.18.png" srcset="/img/loading.gif" lazyload></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedSuspension01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String hello = <span class="hljs-string">&quot;hello thread!&quot;</span>;<br>        Guarded guarded = <span class="hljs-keyword">new</span> Guarded();<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;想要得到结果&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (guarded) &#123;<br>                System.out.println(<span class="hljs-string">&quot;结果是：&quot;</span>+guarded.getResponse());<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;得到结果&quot;</span>);<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;设置结果&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (guarded) &#123;<br>                guarded.setResponse(hello);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Guarded</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 要返回的结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">//优雅地使用wait/notify</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//如果返回结果为空就一直等待，避免虚假唤醒</span><br>        <span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(Object response)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.response = response;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">//唤醒休眠的线程</span><br>            <span class="hljs-keyword">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Guarded&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;response=&quot;</span> + response +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="带超时判断的暂停"><a href="#带超时判断的暂停" class="headerlink" title="带超时判断的暂停"></a>带超时判断的暂停</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>		<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>			<span class="hljs-comment">//获取开始时间</span><br>			<span class="hljs-keyword">long</span> currentTime = System.currentTimeMillis();<br>			<span class="hljs-comment">//用于保存已经等待了的时间</span><br>			<span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-comment">//看经过的时间-开始时间是否超过了指定时间</span><br>				<span class="hljs-keyword">long</span> waitTime = time -passedTime;<br>				<span class="hljs-keyword">if</span>(waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>				<span class="hljs-keyword">try</span> &#123;<br>                   	<span class="hljs-comment">//等待剩余时间</span><br>					<span class="hljs-keyword">this</span>.wait(waitTime);<br>				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>					e.printStackTrace();<br>				&#125;<br>				<span class="hljs-comment">//获取当前时间</span><br>				passedTime = System.currentTimeMillis()-currentTime;		<br>            &#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> response;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="join源码——使用保护性暂停模式"><a href="#join源码——使用保护性暂停模式" class="headerlink" title="join源码——使用保护性暂停模式"></a>join源码——使用保护性暂停模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>	<span class="hljs-keyword">long</span> base = System.currentTimeMillis();<br>	<span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;<br><br>  	<span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            <span class="hljs-keyword">long</span> delay = millis - now;<br>            <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            wait(delay);<br>            now = System.currentTimeMillis() - base;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-8、异步模式之生产者-消费者"><a href="#3-8、异步模式之生产者-消费者" class="headerlink" title="3.8、异步模式之生产者/消费者"></a>3.8、异步模式之生产者/消费者</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>要点</strong></p>
<ul>
<li>不需要产生结果和消费结果的线程一一对应</li>
<li>消费队列可以用来平衡生产和消费的线程资源</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.19.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MessageQueue queue = <span class="hljs-keyword">new</span> MessageQueue(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> id = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                queue.put(<span class="hljs-keyword">new</span> Message(id , <span class="hljs-string">&quot;值&quot;</span>+id));<br>            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                Message message = queue.take();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;消费者&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 消息队列类 ， java 线程之间通信</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueue</span> </span>&#123;<br>    <span class="hljs-comment">// 消息的队列集合</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// 队列容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capcity;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capcity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capcity = capcity;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 检查队列是否为空</span><br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-keyword">while</span>(list.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列为空, 消费者线程等待&quot;</span>);<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 从队列头部获取消息并返回</span><br>            Message message = list.removeFirst();<br>            log.debug(<span class="hljs-string">&quot;已消费消息 &#123;&#125;&quot;</span>, message);<br>            list.notifyAll();<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 存入消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-comment">// 检查对象是否已满</span><br>            <span class="hljs-keyword">while</span>(list.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列已满, 生产者线程等待&quot;</span>);<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将消息加入队列尾部</span><br>            list.addLast(message);<br>            log.debug(<span class="hljs-string">&quot;已生产消息 &#123;&#125;&quot;</span>, message);<br>            list.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> Object value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, value=&quot;</span> + value +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.19.1.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="3-9、park-unpark"><a href="#3-9、park-unpark" class="headerlink" title="3.9、park/unpark"></a>3.9、park/unpark</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>park/unpark都是LockSupport类中的的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//暂停线程运行</span><br>LockSupport.park;<br><br><span class="hljs-comment">//恢复线程运行</span><br>LockSupport.unpark(thread);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;park&quot;</span>);<br>        <span class="hljs-comment">//暂停线程运行</span><br>        LockSupport.park();<br>        System.out.println(<span class="hljs-string">&quot;resume&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    thread.start();<br>    <br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">&quot;unpark&quot;</span>);<br>    <span class="hljs-comment">//恢复线程运行</span><br>    LockSupport.unpark(thread);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>与wait/notify的区别</strong></p>
<ul>
<li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</li>
<li>park ，unpark 是以<strong>线程为单位</strong>来<strong>阻塞</strong>和<strong>唤醒</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</li>
<li>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</li>
<li><strong>park不会释放锁</strong>，而wait会释放锁</li>
</ul>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象**_counter, _cond,__mutex**组成</p>
<ul>
<li>先调用park再调用unpark时<ul>
<li>先调用park<ul>
<li>线程运行时，会将Park对象中的**_counter的值设为0**；</li>
<li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li>
<li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li>
</ul>
</li>
<li>然后调用unpark<ul>
<li>调用unpark方法后，会将counter的值设置为1</li>
<li>去唤醒阻塞队列cond中的线程</li>
<li>线程继续运行并将counter的值设为0</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.20.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.21.png" srcset="/img/loading.gif" lazyload></p>
<p>先调用unpark，再调用park</p>
<ul>
<li>调用unpark<ul>
<li>会将counter设置为1（运行时0）</li>
</ul>
</li>
<li>调用park方法<ul>
<li>查看counter是否为0</li>
<li>因为unpark已经把counter设置为1，所以此时将counter设置为0，但<strong>不放入</strong>阻塞队列cond中</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.22.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li><code>interrupt()</code>会使得中断状态为<code>true</code>，并调用<code>unpark</code></li>
<li><code>park</code>调用后一定会消耗掉<code>permit</code>，无论<code>unpark</code>操作先做还是后做。</li>
<li>如果<code>中断状态</code>为true，那么<code>park</code>无法阻塞。</li>
<li><code>unpark</code>会使得<code>permit</code>为1，并唤醒处于阻塞的线程。</li>
</ul>
</blockquote>
<h2 id="3-10、线程中的状态转换"><a href="#3-10、线程中的状态转换" class="headerlink" title="3.10、线程中的状态转换"></a>3.10、线程中的状态转换</h2><p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.23.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="情况一：NEW-–-gt-RUNNABLE"><a href="#情况一：NEW-–-gt-RUNNABLE" class="headerlink" title="情况一：NEW –&gt; RUNNABLE"></a>情况一：NEW –&gt; RUNNABLE</h3><ul>
<li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE</li>
</ul>
<h3 id="情况二：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况二：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况二： RUNNABLE &lt;–&gt; WAITING"></a>情况二： RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li>当调用了t 线程用 synchronized(obj) 获取了对象锁后<ul>
<li>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul>
<li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="情况三：RUNNABLE-lt-–-gt-WAITING"><a href="#情况三：RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;–&gt; WAITING"></a>情况三：RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li><p>当前线程</p>
<p>调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING</p>
<ul>
<li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li>
</ul>
</li>
<li><p>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</p>
</li>
</ul>
<h3 id="情况四：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;–&gt; WAITING"></a>情况四： RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li>
</ul>
<h3 id="情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 synchronized(obj) 获取了对象锁后</p>
<ul>
<li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul>
<li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
<h3 id="情况六：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li><p>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING</p>
<ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li><p>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</p>
</li>
</ul>
<h3 id="情况七：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
<h3 id="情况八：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li>
</ul>
<h3 id="情况九：RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;–&gt; BLOCKED"></a>情况九：RUNNABLE &lt;–&gt; BLOCKED</h3><ul>
<li>t 线程用 synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED</li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然 BLOCKED</li>
</ul>
<h3 id="情况十：-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;–&gt; TERMINATED"></a>情况十： RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/image-20210330110237353.png" srcset="/img/loading.gif" lazyload alt="image-20210330110237353"></p>
<h2 id="3-11、多把锁"><a href="#3-11、多把锁" class="headerlink" title="3.11、多把锁"></a>3.11、多把锁</h2><p><strong>将锁的粒度细分</strong></p>
<ul>
<li>好处，可以增强并发度</li>
<li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;<br>    <span class="hljs-comment">//额外创建对象来作为锁</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object studyRoom = <span class="hljs-keyword">new</span> Object();<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object bedRoom = <span class="hljs-keyword">new</span> Object();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-12、活跃性"><a href="#3-12、活跃性" class="headerlink" title="3.12、活跃性"></a>3.12、活跃性</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p>
<p>如：t1线程获得A对象 锁，接下来想获取B对象的锁t2线程获得B对象锁，接下来想获取A对象的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Object A = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">final</span> Object B = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">synchronized</span> (A) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (B) &#123;<br>                <br>            &#125;<br>        &#125;<br>    &#125;).start();<br>    <br>    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">synchronized</span> (B) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (A) &#123;<br><br>            &#125;<br>        &#125;<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h4><ul>
<li>互斥条件<ul>
<li>在一段时间内，一种资源只能被一个进程所使用</li>
</ul>
</li>
<li>请求和保持条件<ul>
<li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li>
</ul>
</li>
<li>不可抢占条件<ul>
<li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li>
</ul>
</li>
<li>循环等待条件<ul>
<li>发生死锁时，必然存在一个进程——资源的循环链。</li>
</ul>
</li>
</ul>
<h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><ul>
<li>jps+jstack ThreadID</li>
<li>在JAVA控制台中的Terminal中输入<strong>jps</strong>指令可以查看运行中的线程ID  <img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.23.1.png" srcset="/img/loading.gif" lazyload><ul>
<li><p>使用<strong>jstack ThreadID</strong>可以查看线程状态。</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.23.2.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
</li>
<li>jconsole检测死锁</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.23.3.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.23.4.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.23.5.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.24.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/3.25.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p>
<h4 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h4><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p>
<h4 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h4><ul>
<li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li>
<li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li>
</ul>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p>
<p>在使用顺序加锁时，可能会出现饥饿现象</p>
<h2 id="3-12、ReentrantLock"><a href="#3-12、ReentrantLock" class="headerlink" title="3.12、ReentrantLock"></a>3.12、ReentrantLock</h2><h3 id="和synchronized相比具有的的特点"><a href="#和synchronized相比具有的的特点" class="headerlink" title="和synchronized相比具有的的特点"></a>和synchronized相比具有的的特点</h3><ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁 (先到先得)</li>
<li>支持多个条件变量( 具有<strong>多个</strong>waitset)</li>
</ul>
<p>与 synchronized 一样，都支持可重入</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取ReentrantLock对象</span><br><span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">//加锁</span><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-comment">//需要执行的代码</span><br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>	<span class="hljs-comment">//释放锁</span><br>	lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul>
<li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li>
<li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li>
</ul>
<h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p>
<p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;加可打断锁&quot;</span>);<br>                <span class="hljs-comment">//加锁，可打断锁</span><br>                lock.lockInterruptibly();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-comment">//被打断，返回，不再向下执行</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>                <span class="hljs-comment">//释放锁</span><br>                lock.unlock();<br>            &#125;<br>        &#125;);<br><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            t1.start();<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-comment">//打断</span><br>            t1.interrupt();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</p>
</blockquote>
<h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p>
<p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位</p>
<p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p>
<p>不设置等待时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-comment">//如果未设置等待时间，一旦获取失败，直接返回false</span><br>            <span class="hljs-keyword">if</span>(!lock.tryLock()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>                <span class="hljs-comment">//获取失败，不再向下执行，返回</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);<br>            lock.unlock();<br>        &#125;);<br><br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            t1.start();<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>设置等待时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//判断获取锁是否成功，最多等待1秒</span><br>                <span class="hljs-keyword">if</span>(!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>                    <span class="hljs-comment">//获取失败，不再向下执行，直接返回</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-comment">//被打断，不再向下执行，直接返回</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;);<br><br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            t1.start();<br>            <span class="hljs-comment">//打断等待</span><br>            t1.interrupt();<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span><br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>公平锁一般没有必要，会降低并发度</p>
</blockquote>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet的阻塞队列，当条件不满足时进入waitSet 等待</p>
<p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比</p>
<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li>
</ul>
<p>使用要点：</p>
<ul>
<li>await 前需要<strong>获得锁</strong></li>
<li>await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock04</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>        <span class="hljs-comment">//获得条件变量</span><br>        Condition condition = lock.newCondition();<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">while</span>(!judge) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;不满足条件，等待...&quot;</span>);<br>                    <span class="hljs-comment">//等待</span><br>                    condition.await();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;执行完毕！&quot;</span>);<br>                lock.unlock();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1</span>);<br>                judge = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">//释放</span><br>                condition.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br><br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-13、同步模式之顺序控制"><a href="#3-13、同步模式之顺序控制" class="headerlink" title="3.13、同步模式之顺序控制"></a>3.13、同步模式之顺序控制</h2><h3 id="固定运行顺序"><a href="#固定运行顺序" class="headerlink" title="固定运行顺序"></a>固定运行顺序</h3><h4 id="Wait-Notify版"><a href="#Wait-Notify版" class="headerlink" title="Wait/Notify版"></a>Wait/Notify版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> startFromT1 = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">while</span> (!startFromT1)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;线程t1开始运行&quot;</span>);<br>                startFromT1 = !startFromT1;<br>                lock.notifyAll();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">while</span> (startFromT1)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;线程t2开始运行&quot;</span>);<br>                startFromT1 = !startFromT1;<br>                lock.notifyAll();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>存在的缺点</strong>：</p>
<ul>
<li>首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该wait</li>
<li>第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决此问题</li>
<li>最后，唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个</li>
</ul>
<h4 id="Park-Unpark版"><a href="#Park-Unpark版" class="headerlink" title="Park/Unpark版"></a>Park/Unpark版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkUnPark</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;线程t2开始运行&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;线程t1开始运行&quot;</span>);<br>            LockSupport.unpark(t2);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc</p>
<h4 id="Wait-Notify版-1"><a href="#Wait-Notify版-1" class="headerlink" title="Wait/Notify版"></a>Wait/Notify版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Symbol symbol = <span class="hljs-keyword">new</span> Symbol(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            symbol.print(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            symbol.print(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            symbol.print(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Symbol</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Symbol</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = flag;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> waitFlag, <span class="hljs-keyword">int</span> nextFlag, String str)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.flag != waitFlag) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                flag = nextFlag;<br>                <span class="hljs-keyword">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="Lock-条件变量版"><a href="#Lock-条件变量版" class="headerlink" title="Lock 条件变量版"></a>Lock 条件变量版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal();<br>    <span class="hljs-keyword">static</span> Condition conditionA = awaitSignal.newCondition();<br>    <span class="hljs-keyword">static</span> Condition conditionB = awaitSignal.newCondition();<br>    <span class="hljs-keyword">static</span> Condition conditionC = awaitSignal.newCondition();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            awaitSignal.run(<span class="hljs-string">&quot;a&quot;</span>, conditionA, conditionB);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            awaitSignal.run(<span class="hljs-string">&quot;b&quot;</span>, conditionB, conditionC);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            awaitSignal.run(<span class="hljs-string">&quot;c&quot;</span>, conditionC, conditionA);<br>        &#125;).start();<br>        awaitSignal.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//唤醒一个等待的线程</span><br>            conditionA.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            awaitSignal.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String str, Condition thisCondition, Condition nextCondition)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;loopNumber; i++) &#123;<br>            lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//全部进入等待状态</span><br>                thisCondition.await();<br>                System.out.print(str);<br>                nextCondition.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber=<span class="hljs-number">5</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLoopNumber</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> loopNumber;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoopNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Park-Unpark-版"><a href="#Park-Unpark-版" class="headerlink" title="Park/Unpark 版"></a>Park/Unpark 版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkUnPark</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SyncPark syncPark = <span class="hljs-keyword">new</span> SyncPark(<span class="hljs-number">5</span>);<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            syncPark.print(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            syncPark.print(<span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            syncPark.print(<span class="hljs-string">&quot;c&quot;</span>);<br>        &#125;);<br>        syncPark.setThreads(t1, t2, t3);<br>        syncPark.start();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncPark</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;<br>    <span class="hljs-keyword">private</span> Thread[] threads;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SyncPark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setThreads</span><span class="hljs-params">(Thread... threads)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.threads = threads;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            LockSupport.park();<br>            System.out.print(str);<br>            LockSupport.unpark(nextThread());<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Thread <span class="hljs-title">nextThread</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(threads[i] == current) &#123;<br>                index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index &lt; threads.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> threads[index+<span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> threads[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            thread.start();<br>        &#125;<br>        LockSupport.unpark(threads[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="4-1、JAVA内存模型（JMM）"><a href="#4-1、JAVA内存模型（JMM）" class="headerlink" title="4.1、JAVA内存模型（JMM）"></a>4.1、JAVA内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享内存）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p>
<p><strong>JMM体现在以下几个方面</strong></p>
<ul>
<li>原子性 - 保证指令不会受到线程上下文切换的影响</li>
<li>可见性 - 保证指令不会受cpu缓存的影响</li>
<li>有序性 - 保证指令不会受cpu指令并行优化的影响</li>
</ul>
<h2 id="4-2、可见性"><a href="#4-2、可见性" class="headerlink" title="4.2、可见性"></a>4.2、可见性</h2><h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><p><strong>退出不出的循环</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span> (run) &#123;<br>            <span class="hljs-comment">//如果run为真，则一直执行</span><br>        &#125;<br>    &#125;).start();<br><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);<br>    run = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>为什么无法退出该循环</strong></p>
<ul>
<li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.1.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的高速缓存中， 减少对主存中 run 的访问，提高效率</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.2.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是<strong>旧值</strong></li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.3.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>解决方法</strong></p>
<ul>
<li>使用<strong>volatile</strong>易变关键字</li>
<li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Volatile01</span> </span>&#123;<br>    <span class="hljs-comment">//使用易变关键字</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (run) &#123;<br>                <span class="hljs-comment">//如果run为真，则一直执行</span><br>            &#125;<br>        &#125;).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);<br>        run = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能保证原子性</strong>，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p>
<ul>
<li><p>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。（当代码块内变量完全被synchronized 接管时，也保证<strong>有序性</strong>）</p>
</li>
<li><p>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</p>
</li>
<li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p>
<ul>
<li><p>因为使用了<strong>synchronized</strong>关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String x)</span> </span>&#123;<br>    <span class="hljs-comment">//使用了synchronized关键字</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        print(x);<br>        newLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="两阶终止模式优化"><a href="#两阶终止模式优化" class="headerlink" title="两阶终止模式优化"></a>两阶终止模式优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTerminationPattern</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>        monitor.start();<br>        monitor.start();<br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        monitor.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;<br>    Thread monitor;<br>    <span class="hljs-comment">//设置标记，用于判断是否被终止了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>        monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//开始不停的监控</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(stop) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//线程休眠</span><br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 	用于停止监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//打断线程</span><br>        monitor.interrupt();<br>        <span class="hljs-comment">//修改标记</span><br>        stop = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="同步模式之犹豫模式"><a href="#同步模式之犹豫模式" class="headerlink" title="同步模式之犹豫模式"></a>同步模式之犹豫模式</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong></p>
<ul>
<li>用一个标记来判断该任务是否已经被执行过了</li>
<li>需要避免线程安全问题<ul>
<li>加锁的代码块要尽量的小，以保证性能</li>
</ul>
</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HesitationMode</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Monitor2 monitor2 = <span class="hljs-keyword">new</span> Monitor2();<br>        monitor2.start();<br>        monitor2.start();<br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        monitor2.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor2</span> </span>&#123;<br>    Thread monitor;<br>    <span class="hljs-comment">//设置标记，用于判断是否被终止了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//设置标记，用于判断是否已经启动过了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//启动监控器线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//上锁，避免多线程运行时出现线程安全问题</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-comment">//已被启动，直接返回</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//启动监视器，改变标记</span><br>            starting = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>        monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//开始不停的监控</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(stop) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//线程休眠</span><br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        monitor.start();<br>    &#125;<br>    <span class="hljs-comment">//	用于停止监控器线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//打断线程</span><br>        monitor.interrupt();<br>        stop = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-3、有序性"><a href="#4-3、有序性" class="headerlink" title="4.3、有序性"></a>4.3、有序性</h2><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul>
<li>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.4.png" srcset="/img/loading.gif" lazyload></p>
<p>这种特性称之为『<strong>指令重排</strong>』，<strong>多线程下『指令重排』会影响正确性</strong>。</p>
<h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><ul>
<li>事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.5.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。</p>
</blockquote>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.6.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong></li>
<li>指令重排的前提是，重排指令<strong>不能影响结果</strong>，例如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子 </span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>; <br>System.out.println( a + b );<br><br><span class="hljs-comment">// 不能重排的例子 </span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = a - <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p>
<ul>
<li>禁止的是加volatile关键字变量之前的代码被重排序</li>
</ul>
<h2 id="4-5、volatile-原理"><a href="#4-5、volatile-原理" class="headerlink" title="4.5、volatile 原理"></a>4.5、volatile 原理</h2><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令后会加入写屏障</li>
<li>对 volatile 变量的读指令前会加入读屏障</li>
</ul>
<h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul>
<li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>	num = <span class="hljs-number">2</span>;<br>	ready = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// ready 是 volatile 赋值带写屏障</span><br>	<span class="hljs-comment">// 写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>	<span class="hljs-comment">// 读屏障</span><br>	<span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br>	<span class="hljs-keyword">if</span>(ready) &#123;<br>		r.r1 = num + num;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		r.r1 = <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.7.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul>
<li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p>
</li>
<li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p>
</li>
</ul>
<h3 id="不能保证原子性"><a href="#不能保证原子性" class="headerlink" title="不能保证原子性"></a>不能保证原子性</h3><ul>
<li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去</li>
<li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/4.8.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="double-checked-locking-问题"><a href="#double-checked-locking-问题" class="headerlink" title="double-checked locking 问题"></a>double-checked locking 问题</h3><p>以著名的 double-checked locking 单例模式为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t2</span><br>			<span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><br>			<span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>				<span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span><br>					INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> INSTANCE;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上的实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li>
<li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li>
</ul>
<p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">0:</span> <span class="hljs-string">getstatic</span>	 	 <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attr">3:</span> <span class="hljs-string">ifnonnull</span> 		 <span class="hljs-number">37</span><br><span class="hljs-attr">6:</span> <span class="hljs-string">ldc</span>     			 <span class="hljs-comment">#3 // class cn/itcast/n5/Singleton</span><br><span class="hljs-attr">8:</span> <span class="hljs-string">dup</span><br><span class="hljs-attr">9:</span> <span class="hljs-string">astore_0</span><br><span class="hljs-attr">10:</span> <span class="hljs-string">monitorenter</span><br><span class="hljs-attr">11:</span> <span class="hljs-string">getstatic</span> 		 <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attr">14:</span> <span class="hljs-string">ifnonnull</span>	     <span class="hljs-number">27</span><br><span class="hljs-attr">17:</span> <span class="hljs-string">new</span>				 <span class="hljs-comment">#3 // class cn/itcast/n5/Singleton</span><br><span class="hljs-attr">20:</span> <span class="hljs-string">dup</span><br><span class="hljs-attr">21:</span> <span class="hljs-string">invokespecial</span>    <span class="hljs-comment">#4 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-attr">24:</span> <span class="hljs-string">putstatic</span>	 	 <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attr">27:</span> <span class="hljs-string">aload_0</span><br><span class="hljs-attr">28:</span> <span class="hljs-string">monitorexit</span><br><span class="hljs-attr">29:</span> <span class="hljs-string">goto</span> <span class="hljs-number">37</span><br><span class="hljs-attr">32:</span> <span class="hljs-string">astore_1</span><br><span class="hljs-attr">33:</span> <span class="hljs-string">aload_0</span><br><span class="hljs-attr">34:</span> <span class="hljs-string">monitorexit</span><br><span class="hljs-attr">35:</span> <span class="hljs-string">aload_1</span><br><span class="hljs-attr">36:</span> <span class="hljs-string">athrow</span><br><span class="hljs-attr">37:</span> <span class="hljs-string">getstatic</span> 		 <span class="hljs-comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attr">40:</span> <span class="hljs-string">areturn</span><br></code></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>17 表示创建对象，将对象引用入栈 // new Singleton</li>
<li>20 表示复制一份对象引用 // 引用地址</li>
<li>21 表示利用一个对象引用，调用构造方法</li>
<li>24 表示利用一个对象引用，赋值给 static INSTANCE<br><strong>也许 jvm 会优化为：先执行 24，再执行 21</strong>。如果两个线程 t1，t2 按如下时间序列执行：</li>
</ul>
<p>关键在于 <strong>0: getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取INSTANCE 变量的值</strong></p>
<p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例<br>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p><strong>happens-before 规定了对共享变量的写操作对其它线程的读操作可见</strong>，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p>
<ul>
<li><p>线程解锁m之前对变量的写，对于接下来对m加锁的其它线程对该变量的读可见</p>
<ul>
<li><code>synchronized(m)</code></li>
</ul>
</li>
<li><p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p>
<ul>
<li><code>volatile static int x</code></li>
</ul>
</li>
<li><p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p>
</li>
<li><p>线程结束前对变量的写，对其它线程得知它结束后的读可见</p>
<ul>
<li>比如其它线程调用 <code>t1.isAlive()</code> 或 <code>t1.join()</code>等待它结束</li>
</ul>
</li>
<li><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见</p>
<ul>
<li>通过<code>t2.interrupted</code> 或 <code>t2.isInterrupted</code></li>
</ul>
</li>
<li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p>
</li>
<li><p>使用<code>volatile</code>指令</p>
</li>
<li><p>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</p>
</li>
</ul>
<h2 id="4-6、线程安全单例习题"><a href="#4-6、线程安全单例习题" class="headerlink" title="4.6、线程安全单例习题"></a>4.6、线程安全单例习题</h2><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题</p>
<blockquote>
<p>饿汉式：类加载就会导致该单实例对象被创建<br>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p>
</blockquote>
<p>实现1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：为什么加 final,答：防止子类继承后覆盖父类方法，破坏单例模式</span><br><span class="hljs-comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例，答：增加readResolve方法，反序列化过程中，发现readResolve有对象，就直接用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>	<span class="hljs-comment">// 问题3：为什么设置为私有? 是否能防止反射创建新的实例?，答：防止其他类用构造方法创建这个类的对象，不能防止暴力反射</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>	<span class="hljs-comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?，答：可以，静态成员变量在类加载阶段完成，由JVM保证</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>	<span class="hljs-comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由，答：提供更好的封装性，提供懒汉模式，提供泛型支持</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> INSTANCE;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> INSTANCE;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：枚举单例是如何限制实例个数的，答：反编译后得知，其是本质上枚举类的静态成员变量</span><br><span class="hljs-comment">// 问题2：枚举单例在创建时是否有并发问题，答：没有，静态成员变量在类加载阶段完成，由JVM保证</span><br><span class="hljs-comment">// 问题3：枚举单例能否被反射破坏单例，答：不能</span><br><span class="hljs-comment">// 问题4：枚举单例能否被反序列化破坏单例，答：不会，枚举类默认实现序列化接口，保证了不会被破坏</span><br><span class="hljs-comment">// 问题5：枚举单例属于懒汉式还是饿汉式，答：饿汉式</span><br><span class="hljs-comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做，答：增加构造方法</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>	INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//懒汉式单例</span><br>	<span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点，答：将锁加到了静态方法上，即类上。可以保证线程安全</span><br>    <span class="hljs-comment">// 缺点，锁的范围比较大，性能较低</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-keyword">null</span> )&#123;<br>			<span class="hljs-keyword">return</span> INSTANCE;<br>		&#125;<br>		INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>		<span class="hljs-keyword">return</span> INSTANCE;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现4：DCL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>	<span class="hljs-comment">// 问题1：解释为什么要加 volatile ，答：防止指令重排序，发生（先赋值操作，再构造方法，导致其他线程可能拿到一个null）</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>	<span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义，答：减小锁的范围，提高性能</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> INSTANCE;<br>		&#125;<br>		<span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>			<span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗，答：防止同时多个线程都在首次创建对象</span><br>			<span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123; <br>				<span class="hljs-keyword">return</span> INSTANCE;<br>			&#125;<br>			INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>			<span class="hljs-keyword">return</span> INSTANCE;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现5（推荐）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>	<span class="hljs-comment">// 问题1：属于懒汉式还是饿汉式，答：懒汉式，因为类加载是懒汉式。只加载外部类时候，不会加载内部类</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;<br>		<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>	&#125;	<br>	<span class="hljs-comment">// 问题2：在创建时是否有并发问题，答：不会，静态成员变量在类加载阶段完成，由JVM保证</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><h2 id="5-1、无锁解决线程安全问题"><a href="#5-1、无锁解决线程安全问题" class="headerlink" title="5.1、无锁解决线程安全问题"></a>5.1、无锁解决线程安全问题</h2><p>使用<strong>原子整数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicInteger balance = <span class="hljs-keyword">new</span> AtomicInteger();<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-comment">//获取余额</span><br>	<span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//取款</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;<br><br>	<span class="hljs-comment">//方法内会启动 1000 个线程，每个线程做 -10的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br>	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>		List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>		<span class="hljs-keyword">long</span> start = System.nanoTime();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>			ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>				account.withdraw(<span class="hljs-number">10</span>);<br>			&#125;));<br>		&#125;<br>		ts.forEach(Thread::start);<br>		ts.forEach(t -&gt; &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				t.join();<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>		&#125;);<br>		<span class="hljs-keyword">long</span> end = System.nanoTime();<br>		System.out.println(account.getBalance() + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程安全的做法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br>	<span class="hljs-comment">//使用原子整数</span><br>	<span class="hljs-keyword">private</span> AtomicInteger balance;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//得到原子整数的值</span><br>		<span class="hljs-keyword">return</span> balance.get();<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>			<span class="hljs-comment">//获得修改前的值</span><br>			<span class="hljs-keyword">int</span> prev = balance.get();<br>			<span class="hljs-comment">//获得修改后的值</span><br>			<span class="hljs-keyword">int</span> next = prev-amount;<br>			<span class="hljs-comment">//比较并设值</span><br>			<span class="hljs-keyword">if</span>(balance.compareAndSet(prev, next)) &#123;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>        <span class="hljs-comment">// 可以简化为下面的方法</span><br>	    <span class="hljs-comment">// balance.addAndGet(-1 * amount);</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	Account.demo(<span class="hljs-keyword">new</span> AccountCas(<span class="hljs-number">10000</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-2、CAS与volatile"><a href="#5-2、CAS与volatile" class="headerlink" title="5.2、CAS与volatile"></a>5.2、CAS与volatile</h2><p><code>AtomicInteger</code>的解决方法，内部并没有用锁来保护共享变量的线程安全。</p>
<p>他实现的<strong>关键是 compareAndSet</strong>（比较并设置值），它的<strong>简称就是 CAS</strong> （也有 Compare And Swap 的说法），它必须是<strong>原子操作</strong>。</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/5.1.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<ul>
<li>其实 CAS 的底层是 <strong>lock cmpxchg</strong> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的<strong>原子性</strong>。</li>
<li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li>
</ul>
</blockquote>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul>
<li>当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。<ul>
<li>如果<strong>两者相等</strong>，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li>
<li>如果<strong>两者不相等</strong>，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。</li>
</ul>
</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到<strong>主存中获取</strong> 它的值，线程操作 volatile 变量都是直接操作主存。即<strong>一个线程对 volatile 变量的修改，对另一个线程可见</strong>。</p>
<blockquote>
<p><strong>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）</strong></p>
</blockquote>
<p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的新值来实现【比较并交换】的效果</p>
<h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>一般情况下，使用无锁比使用加锁的<strong>效率更高。</strong></p>
<h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p>
<ul>
<li><p>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，再进行重试。</p>
</li>
<li><p>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，上锁之后其他线程都无法操作，我改完了解开锁，你们才有机会。</p>
</li>
<li><p>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</p>
<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
</ul>
</li>
<li><p>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</p>
</li>
</ul>
<h2 id="5-3、原子整数"><a href="#5-3、原子整数" class="headerlink" title="5.3、原子整数"></a>5.3、原子整数</h2><p>J.U.C 并发包（java.util .concurrent）提供了</p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<p><strong>以 AtomicInteger 为例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ </span><br>System.out.println(i.getAndIncrement());<br><span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>System.out.println(i.incrementAndGet());<br><span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>System.out.println(i.decrementAndGet());<br><span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>System.out.println(i.getAndDecrement());<br> <br><span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0） </span><br>System.out.println(i.getAndAdd(<span class="hljs-number">5</span>)); <br><span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0） </span><br>System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） </span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span><br>System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br> <br><span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span><br>System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br> <br><span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） </span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 </span><br><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 </span><br><span class="hljs-keyword">final</span> System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br> <br><span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） </span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br></code></pre></td></tr></table></figure>

<h2 id="5-4、原子引用"><a href="#5-4、原子引用" class="headerlink" title="5.4、原子引用"></a>5.4、原子引用</h2><ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference</li>
</ul>
<h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br>	<span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作    </span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccountImpl account)</span> </span>&#123;<br>		List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>		<span class="hljs-keyword">long</span> start = System.nanoTime();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>			ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>				account.withdraw(BigDecimal.TEN);<br>			&#125;));<br>		&#125;<br>		ts.forEach(Thread::start);<br>		ts.forEach(t -&gt; &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				t.join();<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>		&#125;);<br>		<span class="hljs-keyword">long</span> end = System.nanoTime();<br>		System.out.println(account.getBalance() + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br>	<span class="hljs-comment">//原子引用，泛型类型为小数类型</span><br>	AtomicReference&lt;BigDecimal&gt; balance;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountImpl</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;BigDecimal&gt;(balance);<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> balance.get();<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<br>		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>			BigDecimal pre = balance.get();<br>			BigDecimal next = pre.subtract(amount);<br>			<span class="hljs-keyword">if</span>(balance.compareAndSet(pre, next)) &#123;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		DecimalAccount.demo(<span class="hljs-keyword">new</span> DecimalAccountImpl(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;10000&quot;</span>)));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>	<span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>			String pre = str.get();<br>			System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br>			<span class="hljs-keyword">try</span> &#123;<br>				other();<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>			<span class="hljs-keyword">try</span> &#123;<br>				Thread.sleep(<span class="hljs-number">1000</span>);<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>			<span class="hljs-comment">//把str中的A改为C</span><br>			System.out.println(<span class="hljs-string">&quot;change A-&gt;C &quot;</span> + str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>));<br>		&#125;).start();<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>		<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>			System.out.println(<span class="hljs-string">&quot;change A-&gt;B &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>));<br>		&#125;).start();<br>		Thread.sleep(<span class="hljs-number">500</span>);<br>		<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>			System.out.println(<span class="hljs-string">&quot;change B-&gt;A &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>));<br>		&#125;).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>主线程仅能判断出共享变量的值与初值 A <strong>是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况</p>
<p>如果主线程希望：只要有其它线程【<strong>动过了</strong>】共享变量，那么自己的 <strong>cas 就算失败</strong>，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong></p>
</blockquote>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicStampedReference01</span> </span>&#123;<br>    <span class="hljs-comment">//指定版本号</span><br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            String pre = str.getReference();<br>            <span class="hljs-comment">//获得版本号</span><br>            <span class="hljs-keyword">int</span> stamp = str.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                other();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C stamp &quot;</span> + stamp + str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = str.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;B stamp &quot;</span> + stamp + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));<br>        &#125;).start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = str.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;change B-&gt;A stamp &quot;</span> + stamp +  str.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了 <strong>AtomicMarkableReference</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicMarkableReference01</span> </span>&#123;<br>    <span class="hljs-comment">//指定版本号</span><br>    <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            String pre = str.getReference();<br>            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                other();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C mark &quot;</span> +  str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;A mark &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul>
<li><strong>AtomicStampedReference</strong> 需要传入<strong>整型变量</strong>作为版本号，来判定是否被更改过</li>
<li><strong>AtomicMarkableReference</strong>需要传入<strong>布尔变量</strong>作为标记，来判断是否被更改过</li>
</ul>
<h2 id="5-5、原子数组"><a href="#5-5、原子数组" class="headerlink" title="5.5、原子数组"></a>5.5、原子数组</h2><ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArra</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerArray01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        demo(<br>                ()-&gt; <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>),<br>                (array) -&gt; array.length(),<br>                (array, index) -&gt; array.getAndIncrement(index),<br>                array -&gt; System.out.println(array)<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment">     参数2，获取数组长度的方法</span><br><span class="hljs-comment">     参数3，自增方法，回传 array, index</span><br><span class="hljs-comment">     参数4，打印数组的方法</span><br><span class="hljs-comment">     */</span><br><span class="hljs-comment">// supplier 提供者 无中生有 ()-&gt;结果</span><br><span class="hljs-comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span><br><span class="hljs-comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            Supplier&lt;T&gt; arraySupplier,</span></span><br><span class="hljs-params"><span class="hljs-function">            Function&lt;T, Integer&gt; lengthFun,</span></span><br><span class="hljs-params"><span class="hljs-function">            BiConsumer&lt;T, Integer&gt; putConsumer,</span></span><br><span class="hljs-params"><span class="hljs-function">            Consumer&lt;T&gt; printConsumer )</span>  </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        T array = arraySupplier.get();<br>        <span class="hljs-keyword">int</span> length = lengthFun.apply(array);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">// 每个线程对数组作 10000 次操作</span><br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    putConsumer.accept(array, j%length);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;); <span class="hljs-comment">// 等所有线程结束</span><br>        printConsumer.accept(array);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 线程安全，输出结果</span><br><span class="hljs-comment">//[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span><br></code></pre></td></tr></table></figure>



<h2 id="5-6、原子字段更新器"><a href="#5-6、原子字段更新器" class="headerlink" title="5.6、原子字段更新器"></a>5.6、原子字段更新器</h2><ul>
<li>AtomicReferenceFieldUpdater // 域 字段</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdate</li>
</ul>
<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能<strong>配合 volatile 修饰的字段使用</strong>，否则会出现异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Student student = <span class="hljs-keyword">new</span> Student();<br>       <br>      <span class="hljs-comment">// 获得原子更新器</span><br>      <span class="hljs-comment">// 泛型</span><br>      <span class="hljs-comment">// 参数1 持有属性的类 参数2 被更新的属性的类</span><br>      <span class="hljs-comment">// newUpdater中的参数：第三个为属性的名称</span><br>      AtomicReferenceFieldUpdater&lt;Student, String&gt; updater = AtomicReferenceFieldUpdater.newUpdater(<br>          													Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>); <br>      <span class="hljs-comment">// 修改</span><br>      updater.compareAndSet(student, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Nyima&quot;</span>);<br>      System.out.println(student);<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>   <span class="hljs-keyword">volatile</span> String name;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-7、原子累加器"><a href="#5-7、原子累加器" class="headerlink" title="5.7、原子累加器"></a>5.7、原子累加器</h2><p>LongAdder的性能高于AtomicLong。主要是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p>
<h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p>Cell源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 防止缓存行伪共享</span><br><span class="hljs-meta">@sun</span>.misc.Contended<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cell</span> </span>&#123;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value;<br>	Cell(<span class="hljs-keyword">long</span> x) &#123; value = x; &#125;<br>	<span class="hljs-comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span><br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> prev, <span class="hljs-keyword">long</span> next)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-keyword">this</span>, valueOffset, prev, next);<br>	&#125;<br>	<span class="hljs-comment">// 省略不重要代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Cell 即为累加单元</p>
</blockquote>
<p>缓存行伪共享得从缓存说起<br>缓存与内存的速度比较</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/5.2.png" srcset="/img/loading.gif" lazyload></p>
<p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至<strong>缓存</strong>来提升效率。<br>而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的<strong>一致性</strong>，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/5.3.png" srcset="/img/loading.gif" lazyload></p>
<p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p>
<ul>
<li>Core-0 要修改 Cell[0]</li>
<li>Core-1 要修改 Cell[1]</li>
</ul>
<p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p>
<p>比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</p>
<p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</p>
<p><strong>累加主要调用以下方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">// as 为累加单元数组,b 为基础值,x 为累加值</span><br>    Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;<br>    <span class="hljs-comment">// 进入 if 的两个条件</span><br>    <span class="hljs-comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span><br>    <span class="hljs-comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span><br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;<br>        <span class="hljs-comment">// uncontended 表示 cell 没有竞争</span><br>        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (<br>            <span class="hljs-comment">// as 还没有创建</span><br>            as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            <span class="hljs-comment">// 当前线程对应的 cell 还没有</span><br>            (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||<br>            <span class="hljs-comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span><br>            !(uncontended = a.cas(v = a.value, v + x)))&#123;<br>              <span class="hljs-comment">// 进入 cell 数组创建、cell 创建的流程</span><br>              longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/5.4.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="5-8、Unsafe"><a href="#5-8、Unsafe" class="headerlink" title="5.8、Unsafe"></a>5.8、Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetUnsafe</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;<br>		<span class="hljs-comment">// 通过反射获得Unsafe对象</span><br>		Class unsafeClass = Unsafe.class;<br>		<span class="hljs-comment">// 获得构造函数，Unsafe的构造函数为私有的</span><br>		Constructor constructor = unsafeClass.getDeclaredConstructor();<br>		<span class="hljs-comment">// 设置为允许访问私有内容</span><br>		constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>		<span class="hljs-comment">// 创建Unsafe对象</span><br>		Unsafe unsafe = (Unsafe) constructor.newInstance();<br>		<br>		<span class="hljs-comment">// 创建Person对象</span><br>		Person person = <span class="hljs-keyword">new</span> Person();<br>		<span class="hljs-comment">// 获得其属性 name 的偏移量</span><br>		Field field = Person.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>		<span class="hljs-keyword">long</span> offset = unsafe.objectFieldOffset(field);<br><br>		<span class="hljs-comment">// 通过unsafe的CAS操作改变值</span><br>		unsafe.compareAndSwapObject(person, offset, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Gotcha&quot;</span>);<br>		System.out.println(person);<br>	&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">// 配合CAS操作，必须用volatile修饰</span><br> 	<span class="hljs-keyword">volatile</span> String name;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>				<span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>				<span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h1><h2 id="6-1、定义"><a href="#6-1、定义" class="headerlink" title="6.1、定义"></a>6.1、定义</h2><p>如果一个对象在<strong>不能够修</strong>改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。</p>
<blockquote>
<p>线程不安全：SimpleDateFormat（日期格式化类）</p>
<p>线程安全：DateTimeFormatter（新的日期格式化类）</p>
</blockquote>
<ul>
<li>不可变对象，实际是另一种避免竞争的方式。</li>
</ul>
<h2 id="6-2、不可变设计"><a href="#6-2、不可变设计" class="headerlink" title="6.2、不可变设计"></a>6.2、不可变设计</h2><h3 id="String类中不可变的体现"><a href="#String类中不可变的体现" class="headerlink" title="String类中不可变的体现"></a>String类中不可变的体现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br><br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <br>   <span class="hljs-comment">//....</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ﬁnal-的使用"><a href="#ﬁnal-的使用" class="headerlink" title="ﬁnal 的使用"></a>ﬁnal 的使用</h3><p>发现该类、类中所有属性都是 final 的<br><strong>属性</strong>用 final 修饰<strong>保证了该属性是只读的，不能修改</strong><br><strong>类</strong>用 final 修饰<strong>保证了该类中的方法不能被覆盖</strong>，防止子类无意间破坏不可变性</p>
<h3 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h3><p>以 substring 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">int</span> subLen = value.length - beginIndex;<br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);<br>    &#125;<br>    <span class="hljs-comment">//返回的是一个新的对象</span><br>    <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br>            <span class="hljs-keyword">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br>    <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);<br>    &#125;<br>    <span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为<strong>保护性拷贝</strong>（defensive copy）</p>
<hr>
<h2 id="6-3、final的原理"><a href="#6-3、final的原理" class="headerlink" title="6.3、final的原理"></a>6.3、final的原理</h2><h3 id="设置final变量时的原理"><a href="#设置final变量时的原理" class="headerlink" title="设置final变量时的原理"></a>设置final变量时的原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinal</span> </span>&#123;<br>	<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应字节码如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">0:</span> <span class="hljs-string">aload_0</span><br><span class="hljs-attr">1:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-attr">4:</span> <span class="hljs-string">aload_0</span><br><span class="hljs-attr">5:</span> <span class="hljs-string">bipush</span> <span class="hljs-number">20</span><br><span class="hljs-attr">7:</span> <span class="hljs-string">putfield</span> <span class="hljs-comment">#2 // Field a:I</span><br><span class="hljs-string">&lt;--</span> <span class="hljs-string">写屏障</span><br><span class="hljs-attr">10:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入<strong>写屏障</strong>，保证在其它线程读到它的值时不会出现为 0 的情况</p>
</blockquote>
<h3 id="获取final变量时的原理"><a href="#获取final变量时的原理" class="headerlink" title="获取final变量时的原理"></a>获取final变量时的原理</h3><p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/6.2.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/6.3.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h2 id="6-4、享元模式"><a href="#6-4、享元模式" class="headerlink" title="6.4、享元模式"></a>6.4、享元模式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>当需要重用数量有限的同一类对象时，通过共享尽来最小化内存使用</p>
<blockquote>
<p>归类 Structual patterns</p>
</blockquote>
<h3 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h3><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的valueOf 会缓存 -128~127 之间的 Long 对象，<strong>在这个范围之间会重用对象</strong>，大于这个范围，才会新建 Long 对象：</p>
<ul>
<li>Byte, Short, Long 缓存的范围都是 -128~127</li>
<li>Character 缓存的范围是 0~127</li>
<li>Integer的默认范围是 -128~127。最小值不能变，但最大值可以通过调整虚拟机参数 <code> -Djava.lang.Integer.IntegerCache.high</code> 来改变</li>
<li>Boolean 缓存了 TRUE 和 FALSE</li>
</ul>
<h4 id="String-串池"><a href="#String-串池" class="headerlink" title="String 串池"></a>String 串池</h4><p>详见JVM笔记</p>
<h4 id="BigDecimal-BigInteger"><a href="#BigDecimal-BigInteger" class="headerlink" title="BigDecimal BigInteger"></a>BigDecimal BigInteger</h4><p>有一部分数字进行了缓存</p>
<blockquote>
<p>为什么BigDecimal是不可变类，线程安全。但还要用AtomicReference保护BigDecima</p>
<p>答：BigDecimal只能保证单个操作是原子的，多个操作组合起来不是原子操作</p>
</blockquote>
<h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><p>下面自定义一个连接池进行模拟</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyWeight01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pool pool = <span class="hljs-keyword">new</span> Pool(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                Connection connection = pool.borrow();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                pool.free(connection);<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;享元模式之自定义连接池&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span></span>&#123;<br>    <span class="hljs-comment">//1.连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> poolSize;<br>    <span class="hljs-comment">//2.连接对象数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br>    <span class="hljs-comment">//3.连接状态数组,0 表示空闲,1表示繁忙</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br><br>    <span class="hljs-comment">//4.构造方法初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.poolSize = poolSize;<br>        <span class="hljs-keyword">this</span>.connections = <span class="hljs-keyword">new</span> Connection[poolSize];<br>        <span class="hljs-keyword">this</span>.states = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[poolSize]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> MockConnection(<span class="hljs-string">&quot;第&quot;</span>+i+<span class="hljs-string">&quot;个连接&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//5.借连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">borrow</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-keyword">if</span> (states.get(i)==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//存在空闲连接，则CAS获取</span><br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        log.debug(<span class="hljs-string">&quot;借出 &#123;&#125;&quot;</span>,connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//没有空闲连接，则线程进入等待</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;当前无可用连接&quot;</span>);<br>                    <span class="hljs-keyword">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//6.还连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(Connection connection)</span></span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i]==connection)&#123;<br>                log.debug(<span class="hljs-string">&quot;归还 &#123;&#125;&quot;</span>,connection);<br>                states.set(i,<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>)&#123;<br>                    <span class="hljs-keyword">this</span>.notifyAll();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Connection</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MockConnection</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MockConnection&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <br>	<span class="hljs-comment">// 省略其他Connection接口需要实现的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Statement <span class="hljs-title">createStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/6.1.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="6-5、无状态"><a href="#6-5、无状态" class="headerlink" title="6.5、无状态"></a>6.5、无状态</h2><p>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的<br>因为成员变量保存的数据也可以称为状态信息，因此<strong>没有成员变量就称之为无状态</strong></p>
<ul>
<li>即没有成员变量</li>
</ul>
<hr>
<h1 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h1><h2 id="7-1、自定义线程池"><a href="#7-1、自定义线程池" class="headerlink" title="7.1、自定义线程池"></a>7.1、自定义线程池</h2><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.1.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>阻塞队列中维护了由主线程（或者其他线程）所产生的的任务</li>
<li>主线程类似于<strong>生产者</strong>，产生任务并放入阻塞队列中</li>
<li>线程池类似于<strong>消费者</strong>，得到阻塞队列中已有的任务并执行</li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;自定义线程池&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool01</span> </span>&#123;<br>    <span class="hljs-comment">//任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br><br>    <span class="hljs-comment">//线程集合</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet();<br><br>    <span class="hljs-comment">//核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> coreSize;<br><br>    <span class="hljs-comment">//获取任务的超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timeout;<br><br>    <span class="hljs-comment">//时间单位</span><br>    <span class="hljs-keyword">private</span> TimeUnit unit;<br><br>    <span class="hljs-comment">//拒绝策略</span><br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br><br>    <span class="hljs-comment">//执行任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span></span>&#123;<br>        <span class="hljs-comment">//当任务数没有超过coreSize时，直接交给worker对象执行</span><br>        <span class="hljs-comment">//当任务数超过coreSize时，进入阻塞队列</span><br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize)&#123;<br>                Worker worker = <span class="hljs-keyword">new</span> Worker(task);<br>                log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;,处理 任务&#123;&#125;&quot;</span>,worker,task);<br>                worker.start();<br>                workers.add(worker);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//taskQueue.put(task);</span><br>                <span class="hljs-comment">//1.死等</span><br>                <span class="hljs-comment">//2.带超时的等待</span><br>                <span class="hljs-comment">//3.让调用者放弃任务执行</span><br>                <span class="hljs-comment">//4.让调用者抛出异常</span><br>                <span class="hljs-comment">//5.让调用者自己执行任务</span><br>                taskQueue.tryPut(rejectPolicy,task);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPool01</span><span class="hljs-params">(<span class="hljs-keyword">int</span> coreSize, <span class="hljs-keyword">long</span> timeout, TimeUnit unit,<span class="hljs-keyword">int</span> queueCapcity,RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.coreSize = coreSize;<br>        <span class="hljs-keyword">this</span>.timeout = timeout;<br>        <span class="hljs-keyword">this</span>.unit = unit;<br>        <span class="hljs-keyword">this</span>.taskQueue = <span class="hljs-keyword">new</span> BlockingQueue&lt;&gt;(queueCapcity);<br>        <span class="hljs-keyword">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//执行任务</span><br>                <span class="hljs-comment">//1.当task不为空直接执行</span><br>                <span class="hljs-comment">//2.当task执行完毕，从任务队列中获取任务继续执行</span><br>                <span class="hljs-comment">//while (task != null || (task = taskQueue.take()) != null )&#123;</span><br>                <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = taskQueue.take(timeout,unit)) != <span class="hljs-keyword">null</span> )&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        log.debug(<span class="hljs-string">&quot;正在执行&#123;&#125;任务&quot;</span>,task);<br>                        task.run();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        task = <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (workers)&#123;<br>                    log.debug(<span class="hljs-string">&quot;worker&#123;&#125; 被移除&quot;</span>,<span class="hljs-keyword">this</span>);<br>                    workers.remove(<span class="hljs-keyword">this</span>);<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="任务阻塞队列"><a href="#任务阻塞队列" class="headerlink" title="任务阻塞队列"></a>任务阻塞队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;任务阻塞队列&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-comment">//1.任务队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br><br>    <span class="hljs-comment">//2.锁</span><br>    <span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-comment">//3.生产者条件变量</span><br>    <span class="hljs-keyword">private</span> Condition fullWaitSet = lock.newCondition();<br><br>    <span class="hljs-comment">//4.消费者条件变量</span><br>    <span class="hljs-keyword">private</span> Condition emptyWaitSet = lock.newCondition();<br><br>    <span class="hljs-comment">//5.容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capcity;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capcity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capcity = capcity;<br>    &#125;<br><br>    <span class="hljs-comment">//阻塞获取</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">take</span><span class="hljs-params">()</span></span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty())&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            T t = queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;  <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//带超时的阻塞获取</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">take</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//将时间统一转换为纳秒</span><br>            <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty())&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (nanos&lt;=<span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                    <span class="hljs-comment">//等待的时间 = 等待时间 - 已等待时间 = 剩余等待时间</span><br>                    nanos = emptyWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            T t = queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;  <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//阻塞添加</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T element)</span></span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务阻塞队列&#123;&#125;&quot;</span>,element);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;将任务加入任务阻塞队列&#123;&#125;&quot;</span>,element);<br>            queue.addLast(element);<br>            emptyWaitSet.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//带超时时间的阻塞添加</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">put</span><span class="hljs-params">(T element,<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//将时间统一转换为纳秒</span><br>            <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务阻塞队列&#123;&#125;&quot;</span>,element);<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)&#123;<br>                        log.debug(<span class="hljs-string">&quot;任务&#123;&#125;不再等待，直接移除&quot;</span>,element);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;将任务加入任务阻塞队列&#123;&#125;&quot;</span>,element);<br>            queue.addLast(element);<br>            emptyWaitSet.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取阻塞队列容量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (queue.size()==capcity)&#123;<br>                rejectPolicy.reject(<span class="hljs-keyword">this</span>,task);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;将任务加入任务阻塞队列&#123;&#125;&quot;</span>,task);<br>                queue.addLast(task);<br>                emptyWaitSet.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">//拒绝策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RejectPolicy</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; queue,T task)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool01Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ThreadPool01 threadPool = <span class="hljs-keyword">new</span> ThreadPool01(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS,<br>                <span class="hljs-number">1</span>,(queue,task)-&gt;&#123;<br>            <span class="hljs-comment">//1.死等</span><br>            <span class="hljs-comment">//queue.put(task);</span><br>            <span class="hljs-comment">//2.带超时的等待</span><br>            <span class="hljs-comment">//queue.put(task,500,TimeUnit.MILLISECONDS);</span><br>            <span class="hljs-comment">//3.让调用者放弃任务执行</span><br>            <span class="hljs-comment">//System.out.println(&quot;放弃执行&quot; + task);;</span><br>            <span class="hljs-comment">//4.让调用者抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;任务执行失败&quot;</span> + task);<br>            <span class="hljs-comment">//5.让调用者自己执行任务</span><br>            <span class="hljs-comment">//task.run();</span><br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> j = i;<br>            threadPool.execute(()-&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(j);&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.2.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h2 id="7-2、ThreadPoolExecutor"><a href="#7-2、ThreadPoolExecutor" class="headerlink" title="7.2、ThreadPoolExecutor"></a>7.2、ThreadPoolExecutor</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.3.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程池状态</span><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-comment">// RUNNING 高3位为111</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// SHUTDOWN 高3位为000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 001</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 010</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 011</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>状态名称</th>
<th>高3位的值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>接收新任务，同时处理任务队列中的任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>不接受新任务，但是处理任务队列中的任务</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>任务执行完毕，活动线程为0时，即将进入终结阶段</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>终结状态</td>
</tr>
</tbody></table>
<p>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示</strong></p>
<ul>
<li>使用一个数来表示两个值的主要原因是：<strong>可以通过一次CAS同时更改两个属性的值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">// 并不是所有平台的int都是32位。</span><br><span class="hljs-comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span><br><span class="hljs-comment">// 高3位为0，剩余位数全为1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数</span><br><span class="hljs-comment">// CAPACITY 的高3位为 0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>获取线程池状态、线程数量以及合并两个值的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Packing and unpacking ctl</span><br><span class="hljs-comment">// 获取运行状态</span><br><span class="hljs-comment">// 该操作会让除高3位以外的数全部变为0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><br><span class="hljs-comment">// 获取运行线程数</span><br><span class="hljs-comment">// 该操作会让高3位为0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><br><span class="hljs-comment">// 计算ctl新值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure>

<h3 id="线程池属性"><a href="#线程池属性" class="headerlink" title="线程池属性"></a>线程池属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 工作线程，内部封装了Thread</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><br><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br><br><span class="hljs-comment">// 锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br><span class="hljs-comment">//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;Worker&gt;();<br></code></pre></td></tr></table></figure>

<h3 id="构造方法及其参数"><a href="#构造方法及其参数" class="headerlink" title="构造方法及其参数"></a>构造方法及其参数</h3><p><strong>ThreadPoolExecutor最全面的构造方法</strong></p>
<p>也是构造自定义线程池的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler handler)</span></span><br></code></pre></td></tr></table></figure>

<h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a><strong>参数解释</strong></h4><ul>
<li>corePoolSize：核心线程数</li>
<li>maximumPoolSize：最大线程数<ul>
<li>maximumPoolSize - corePoolSize = 救急线程数</li>
</ul>
</li>
<li>keepAliveTime：救急线程空闲时的最大生存时间</li>
<li>unit：时间单位</li>
<li>workQueue：阻塞队列（存放任务）<ul>
<li>有界阻塞队列 ArrayBlockingQueue</li>
<li>无界阻塞队列 LinkedBlockingQueue</li>
<li>最多只有一个同步元素的 SynchronousQueue</li>
<li>优先队列 PriorityBlockingQueue</li>
</ul>
</li>
<li>threadFactory：线程工厂（给线程取名字）</li>
<li>handler：拒绝策略</li>
</ul>
<h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul>
<li>当一个任务传给线程池以后，可能有以下几种可能<ul>
<li>将任务分配给一个核心线程来执行</li>
<li>核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行</li>
<li>阻塞队列满了，使用救急线程来执行任务<ul>
<li>救急线程用完以后，超过生存时间（keepAliveTime）后会被释放</li>
</ul>
</li>
<li>任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略</li>
</ul>
</li>
</ul>
<h4 id="拒绝策略-1"><a href="#拒绝策略-1" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行<strong>拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.4.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>这是默认策略</strong></li>
<li>CallerRunsPolicy：让调用者运行任务</li>
<li>DiscardPolicy：放弃本次任务</li>
<li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li>
</ul>
<h3 id="Executors创建线程池类"><a href="#Executors创建线程池类" class="headerlink" title="Executors创建线程池类"></a>Executors创建线程池类</h3><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>内部调用的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>共有两个参数：</p>
<ul>
<li><strong>核心线程数：nThreads =  最大线程数（没有救急线程）</strong>，因此也不需要超时时间</li>
<li><strong>线程工厂：threadFactory</strong></li>
</ul>
</li>
<li><p><strong>阻塞队列无界</strong>，可以放任意数量的任务</p>
</li>
</ul>
<blockquote>
<p>适用于任务量已知，相对耗时的任务</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;FixedThreadPoolTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedThreadPoolTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 自定义线程工厂</span><br>        ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>            AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;gotchaThread_&quot;</span> + atomicInteger.getAndIncrement());<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 创建核心线程数量为2的线程池</span><br>        <span class="hljs-comment">// 通过 ThreadFactory可以给线程添加名字</span><br>        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">2</span>,factory);<br><br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;1&quot;</span>));<br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;2&quot;</span>));<br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;3&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.5.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><p>内部调用的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>共有一个参数：<ul>
<li><strong>线程工厂：threadFactory</strong></li>
</ul>
</li>
<li>没有核心线程，最大线程数为Integer.MAX_VALUE，<strong>所有创建的线程都是救急线程</strong>，空闲时生存时间为60秒</li>
<li>阻塞队列使用的是<code>SynchronousQueue</code><ul>
<li>SynchronousQueue是一种特殊的队列<ul>
<li><strong>没有容量</strong>，没有线程来取是放不进去的</li>
<li>只有当线程取任务时，才会将任务放入该阻塞队列中</li>
</ul>
</li>
</ul>
</li>
<li>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲1分钟后释放线程</li>
</ul>
<blockquote>
<p>适用于任务数量密集，但每个任务执行时间较短的情况</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;CachedThreadPool&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachedThreadPoolTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 自定义线程工厂</span><br>        ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>            AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;gotchaThread_&quot;</span> + atomicInteger.getAndIncrement());<br>            &#125;<br>        &#125;;<br><br><br>        ExecutorService pool = Executors.newCachedThreadPool(factory);<br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;1&quot;</span>));<br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;2&quot;</span>));<br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;3&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.6.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><p>内部调用的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                threadFactory));<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>共有一个参数：<ul>
<li><strong>线程工厂：threadFactory</strong></li>
</ul>
</li>
<li><code>FinalizableDelegatedExecutorService</code>应用的是<strong>装饰器模式</strong>，只对外暴露了ExecutorService接口，因此不能调用<code>ThreadPoolExecutor</code>中特有的方法</li>
</ul>
<blockquote>
<p>适用于希望多个任务排队执行。线程数固定为1，任务数多于1时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p>
</blockquote>
<p><strong>注意</strong></p>
<ul>
<li><p>SingleThread和自己创建一个线程来运行多个任务的区别</p>
<ul>
<li>当线程正在执行的任务发生错误时，如果是自己创建的线程，该任务和剩余的任务就无法再继续运行下去。而SingleThread会创建一个新线程，继续执行任务队列中剩余的任务。</li>
</ul>
</li>
<li><p>SingleThread和newFixedThreadPool(1)的区别</p>
<ul>
<li>newFixedThreadPool(1)传值为1，可以将FixedThreadPool强转为ThreadPoolExecutor，然后通过setCorePoolSize改变核心线程数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 强转为ThreadPoolExecutor</span><br>ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 改变核心线程数</span><br>threadPool.setCorePoolSize(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>而SingleThread无法修改核心线程数</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;SingleThread&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleThreadTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 自定义线程工厂</span><br>        ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>            AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;gotchaThread_&quot;</span> + atomicInteger.getAndIncrement());<br>            &#125;<br>        &#125;;<br><br>        ExecutorService pool = Executors.newSingleThreadExecutor(factory);<br>        pool.execute(()-&gt;log.debug(<span class="hljs-string">&quot;1&quot;</span>));<br>        pool.execute(()-&gt;&#123;<br>            <span class="hljs-comment">//当此任务出现异常时，之后的任务也会正常执行</span><br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>/<span class="hljs-number">0</span>;<br>            log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>        &#125;);<br>        pool.execute(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;3&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.7.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><p>内部调用的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>共有两个参数：<ul>
<li><strong>核心线程数：corePoolSize</strong></li>
<li><strong>线程工厂：threadFactory</strong></li>
</ul>
</li>
<li>延时执行<ul>
<li>schedule()</li>
</ul>
</li>
<li>定时执行<ul>
<li>scheduleAtFixedRate()：时间间隔取，线程运行时间与等待时间较大的</li>
<li>scheduleWithFixedDelay()：时间间隔取，线程运行时间与等待时间之和</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<p><strong>延时执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;ScheduledThreadPoolExecutorTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledThreadPoolExecutorTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 自定义线程工厂</span><br>        ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>            AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;gotchaThread_&quot;</span> + atomicInteger.getAndIncrement());<br>            &#125;<br>        &#125;;<br><br>        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">2</span>,factory);<br>        pool.schedule(()-&gt;<br>            &#123;<br>                log.debug(<span class="hljs-string">&quot;Task1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;,<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        pool.schedule(()-&gt; log.debug(<span class="hljs-string">&quot;Task2&quot;</span>),<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.8.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>定时执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;ScheduledThreadPoolExecutorTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledThreadPoolExecutorTest02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br>        pool.scheduleAtFixedRate(()-&gt; log.debug(<span class="hljs-string">&quot;Task&quot;</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.9.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h4 id="提交任务方法"><a href="#提交任务方法" class="headerlink" title="提交任务方法"></a>提交任务方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行任务</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;<br><br><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span><br>&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)<span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，带超时时间</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-keyword">long</span> timeout, TimeUnit unit) <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span><br>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br></code></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubmitTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>      <span class="hljs-comment">//  submitTest(pool);</span><br>      <span class="hljs-comment">//  invokeAllTest(pool);</span><br>        invokeAnyTest(pool);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submitTest</span><span class="hljs-params">(ExecutorService pool)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        Future&lt;String&gt; future = pool.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;开始运行&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>        &#125;);<br>        System.out.println(future.get());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAllTest</span><span class="hljs-params">(ExecutorService pool)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        List&lt;Future&lt;String&gt;&gt; futures = pool.invokeAll(Arrays.asList(<br>                () -&gt; &#123;<br>                        System.out.println(<span class="hljs-string">&quot;任务1开始运行&quot;</span>);<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务1OK&quot;</span>;<br>                    &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;任务2开始运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务2OK&quot;</span>;<br>                    &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;任务3开始运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务3OK&quot;</span>;<br>                &#125;<br>            )<br>        );<br>        futures.forEach((future)-&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(future.get());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAnyTest</span><span class="hljs-params">(ExecutorService pool)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException</span>&#123;<br>        String result = pool.invokeAny(Arrays.asList(<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;任务1开始运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务1OK&quot;</span>;<br>                &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;任务2开始运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务2OK&quot;</span>;<br>                &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;任务3开始运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务3OK&quot;</span>;<br>                &#125;<br>        ));<br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 SHUTDOWN</span><br><span class="hljs-comment">- 不会接收新任务</span><br><span class="hljs-comment">- 但已提交任务会执行完</span><br><span class="hljs-comment">- 此方法不会阻塞调用线程的执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<p>具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>    	checkShutdownAccess();<br>   		 <span class="hljs-comment">// 修改线程池状态</span><br>    	advanceRunState(SHUTDOWN);<br>   		 <span class="hljs-comment">// 仅会打断空闲线程</span><br>    	interruptIdleWorkers();<br>    	onShutdown(); <span class="hljs-comment">// 扩展点 ScheduledThreadPoolExecutor</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>    	mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span><br>    tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 STOP</span><br><span class="hljs-comment">- 不会接收新任务</span><br><span class="hljs-comment">- 会将队列中的任务返回</span><br><span class="hljs-comment">- 并用 interrupt 的方式中断正在执行的任务</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<p>具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Runnable&gt; tasks;<br>	<span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>	mainLock.lock();<br>	<span class="hljs-keyword">try</span> &#123;<br>		checkShutdownAccess();<br>		<span class="hljs-comment">// 修改线程池状态</span><br>		advanceRunState(STOP);<br>		<span class="hljs-comment">// 打断所有线程</span><br>		interruptWorkers();<br>		<span class="hljs-comment">// 获取队列中剩余任务</span><br>		tasks = drainQueue();<br>	&#125; <span class="hljs-keyword">finally</span> &#123;<br>		mainLock.unlock();<br>	&#125;<br>	<span class="hljs-comment">// 尝试终结</span><br>	tryTerminate();<br>	<span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="isShutdown"><a href="#isShutdown" class="headerlink" title="isShutdown()"></a>isShutdown()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<p>isTerminated()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<h5 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination()"></a>awaitTermination()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事</span><br>情，可以利用此方法等待<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="处理执行任务异常"><a href="#处理执行任务异常" class="headerlink" title="处理执行任务异常"></a>处理执行任务异常</h3><h4 id="主动捕获"><a href="#主动捕获" class="headerlink" title="主动捕获"></a>主动捕获</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>pool.submit(() -&gt; &#123;<br>	<span class="hljs-keyword">try</span> &#123;<br>		log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br>		<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>	&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>		log.error(<span class="hljs-string">&quot;error:&quot;</span>, e);<br>	&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h4 id="使用-Future"><a href="#使用-Future" class="headerlink" title="使用 Future"></a>使用 Future</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;<br>	log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br>	<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;);<br>log.debug(<span class="hljs-string">&quot;result:&#123;&#125;&quot;</span>, f.get());<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Gotcha</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@describe</span> 定时任务，设置，每周周一08:00执行</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduleTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//获取当前时间</span><br>        LocalDateTime now = LocalDateTime.now();<br>        <span class="hljs-comment">//获取到周四的时间</span><br>        LocalDateTime time = now.withHour(<span class="hljs-number">8</span>).withMinute(<span class="hljs-number">0</span>).withSecond(<span class="hljs-number">0</span>).withNano(<span class="hljs-number">0</span>).with(DayOfWeek.MONDAY);<br>        <span class="hljs-comment">//如果当前时间&gt;周一08:00，应当使用下周的周一</span><br>        <span class="hljs-keyword">if</span> (now.compareTo(time)&gt;<span class="hljs-number">0</span>)&#123;<br>            time = time.plusWeeks(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//求出下次执行到现在的时间差</span><br>        <span class="hljs-keyword">long</span> initailDelay = Duration.between(now, time).toMillis();<br>        <span class="hljs-keyword">long</span> period = <span class="hljs-number">1000</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">7</span>;<br>        <span class="hljs-comment">//执行任务</span><br>        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>        pool.scheduleAtFixedRate(()-&gt; System.out.println(<span class="hljs-string">&quot;hello&quot;</span>),initailDelay,period, TimeUnit.MILLISECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="7-3、异步模式之工作线程"><a href="#7-3、异步模式之工作线程" class="headerlink" title="7.3、异步模式之工作线程"></a>7.3、异步模式之工作线程</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。</p>
<p>例如，饭店的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）注意，<strong>不同任务类型应该使用不同的线程池，这样能够避免饥饿</strong>，并能提升效率</p>
<hr>
<h2 id="7-4、Tomcat线程池"><a href="#7-4、Tomcat线程池" class="headerlink" title="7.4、Tomcat线程池"></a>7.4、Tomcat线程池</h2><p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.10.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore</li>
<li>Acceptor 只负责【接收新的 socket 连接】</li>
<li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li>
<li>Executor 线程池中的工作线程最终负责【处理请求】</li>
</ul>
<p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p>
<ul>
<li>如果总线程数达到 maximumPoolSize，这时不会立刻抛 RejectedExecutionException 异常而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li>
</ul>
<h3 id="线程池相关配置"><a href="#线程池相关配置" class="headerlink" title="线程池相关配置"></a>线程池相关配置</h3><p>在server.xml中配置</p>
<h4 id="Connector配置"><a href="#Connector配置" class="headerlink" title="Connector配置"></a>Connector配置</h4><table>
<thead>
<tr>
<th>配置项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>acceptorThreadCount</td>
<td>1</td>
<td>acceptor 线程数量</td>
</tr>
<tr>
<td>pollerThreadCount</td>
<td>1</td>
<td>poller 线程数量</td>
</tr>
<tr>
<td>minSpareThreads</td>
<td>10</td>
<td>核心线程数，即 corePoolSize</td>
</tr>
<tr>
<td>maxThreads</td>
<td>200</td>
<td>最大线程数，即 maximumPoolSize</td>
</tr>
<tr>
<td>executor</td>
<td></td>
<td>Executor 名称，用来引用下面的 Executor</td>
</tr>
</tbody></table>
<h4 id="Executor线程配置"><a href="#Executor线程配置" class="headerlink" title="Executor线程配置"></a>Executor线程配置</h4><table>
<thead>
<tr>
<th>配置项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>threadPriority</td>
<td>5</td>
<td>线程优先级</td>
</tr>
<tr>
<td>daemon</td>
<td>true</td>
<td>是否守护线程</td>
</tr>
<tr>
<td>minSpareThreads</td>
<td>25</td>
<td>核心线程数，即 corePoolSize</td>
</tr>
<tr>
<td>maxThreads</td>
<td>200</td>
<td>最大线程数，即 maximumPoolSize</td>
</tr>
<tr>
<td>maxIdleTime</td>
<td>60000</td>
<td>线程生存时间，单位是毫秒，默认值即 1 分钟</td>
</tr>
<tr>
<td>maxQueueSize</td>
<td>Integer.MAX_VALUE</td>
<td>队列长度</td>
</tr>
<tr>
<td>prestartminSpareThreads</td>
<td>false</td>
<td>核心线程是否在服务器启动时启动</td>
</tr>
</tbody></table>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.11.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h2 id="7-5、Fork-Join线程池"><a href="#7-5、Fork-Join线程池" class="headerlink" title="7.5、Fork/Join线程池"></a>7.5、Fork/Join线程池</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种<strong>分治</strong>思想，适用于能够进行任务拆分的 cpu 密集型运算。<br>任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解。<br>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率。<br>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池。</p>
<blockquote>
<p>提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值）</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;ForkAndJoinTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkAndJoinTest01</span>  </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">4</span>);<br>        System.out.println(pool.invoke(<span class="hljs-keyword">new</span> MyTask(<span class="hljs-number">5</span>)));<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.n = n;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了</span><br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>                log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, n);<br>                <span class="hljs-keyword">return</span> n;<br>            &#125;<br>            <span class="hljs-comment">// 将任务进行拆分(fork)</span><br>            MyTask t1 = <span class="hljs-keyword">new</span> MyTask(n - <span class="hljs-number">1</span>);<br>            t1.fork();<br>            log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);<br>            <span class="hljs-comment">// 合并(join)结果</span><br>            <span class="hljs-keyword">int</span> result = n + t1.join();<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.12.png" srcset="/img/loading.gif" lazyload></p>
<p>图解</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.13.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;ForkAndJoinTest02&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkAndJoinTest02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">4</span>);<br>        System.out.println(pool.invoke(<span class="hljs-keyword">new</span> MyTask(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">int</span> begin;<br>        <span class="hljs-keyword">int</span> end;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.begin = begin;<br>            <span class="hljs-keyword">this</span>.end = end;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + begin + <span class="hljs-string">&quot;,&quot;</span> + end + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 5, 5</span><br>            <span class="hljs-keyword">if</span> (begin == end) &#123;<br>                log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, begin);<br>                <span class="hljs-keyword">return</span> begin;<br>            &#125;<br>            <span class="hljs-comment">// 4, 5</span><br>            <span class="hljs-keyword">if</span> (end - begin == <span class="hljs-number">1</span>) &#123;<br>                log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, begin, end, end + begin);<br>                <span class="hljs-keyword">return</span> end + begin;<br>            &#125;<br>            <span class="hljs-comment">// 1 5</span><br>            <span class="hljs-keyword">int</span> mid = (end + begin) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 3</span><br>            MyTask t1 = <span class="hljs-keyword">new</span> MyTask(begin, mid); <span class="hljs-comment">// 1,3</span><br>            t1.fork();<br>            MyTask t2 = <span class="hljs-keyword">new</span> MyTask(mid + <span class="hljs-number">1</span>, end); <span class="hljs-comment">// 4,5</span><br>            t2.fork();<br>            log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125; = ?&quot;</span>, t1, t2);<br>            <span class="hljs-keyword">int</span> result = t1.join() + t2.join();<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, t1, t2, result);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.14.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/7.15.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h1 id="八、JUC"><a href="#八、JUC" class="headerlink" title="八、JUC"></a>八、JUC</h1><h2 id="8-1、概述"><a href="#8-1、概述" class="headerlink" title="8.1、概述"></a>8.1、概述</h2><p>JUC就是<code>java.util .concurrent</code>工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.1.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h2 id="8-2、AQS"><a href="#8-2、AQS" class="headerlink" title="8.2、AQS"></a>8.2、AQS</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>AQS全称是AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>AQS 要实现的功能目标</p>
<ul>
<li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire</li>
<li>获取锁超时机制</li>
<li>通过打断取消机制</li>
<li>独占机制及共享机制</li>
<li>条件不满足时的等待机制</li>
</ul>
<h3 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h3><ul>
<li>获取锁的逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(state 状态不允许获取) &#123;<br>	<span class="hljs-keyword">if</span>(队列中还没有此线程) &#123;<br>		入队并阻塞<br>	&#125;<br>&#125;<br>获取到锁，当前线程出队<br></code></pre></td></tr></table></figure>

<ul>
<li>释放锁的逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(state 状态允许了) &#123;<br>	恢复阻塞的线程(s)<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态</li>
<li>compareAndSetState - cas 机制设置 state 状态</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<blockquote>
<p>子类主要实现这如下方法</p>
<ul>
<li>tryAcquire，尝试获取锁</li>
<li>tryRelease，尝试释放锁</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively，判断是否持有独占锁</li>
</ul>
</blockquote>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>实现自定义不可重入锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;AQSTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AQSTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Lock lock = <span class="hljs-keyword">new</span> MyLock();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;t1线程开始&quot;</span>);<br>                sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;t2线程开始&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;);<br>        t1.run();<br>        t2.run();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//自定义不可重入锁</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> MySync sync = <span class="hljs-keyword">new</span> MySync();<br><br><br>    <span class="hljs-comment">//独占锁,同步器类</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span>&#123;<br>        <span class="hljs-comment">//尝试获取锁</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span>(compareAndSetState(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-comment">//加上了锁,设置owner为当前线程</span><br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//是否持有独占锁</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> getState()==<span class="hljs-number">1</span> ;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();<br>        &#125;<br>    &#125;<br><br><br><br>    <span class="hljs-comment">//加锁(不成功会进入等待队列)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//加锁，可打断锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//尝试加锁，一次</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//尝试加锁，带超时</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>,unit.toNanos(time));<br>    &#125;<br><br>    <span class="hljs-comment">//解锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//创建条件变量</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.3.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h2 id="8-3、ReentrantLock-原理"><a href="#8-3、ReentrantLock-原理" class="headerlink" title="8.3、ReentrantLock 原理"></a>8.3、ReentrantLock 原理</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>有两个构造方法，默认为非公平锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;<br>    sync = <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>FairSync、NonfairSync都继承自 AQS</p>
</blockquote>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.4.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h3><h4 id="加锁解锁流程"><a href="#加锁解锁流程" class="headerlink" title="加锁解锁流程"></a>加锁解锁流程</h4><ul>
<li>没有竞争时</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.5.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>第一个竞争线程出现</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.6.png" srcset="/img/loading.gif" lazyload></p>
<p>Thread-1 执行了</p>
<ol>
<li>CAS 尝试将 state 由 0 改为 1，结果失败</li>
<li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li>
<li>接下来进入 addWaiter 逻辑，构造 Node 队列<br>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态，-1表示该节点有后继节点，该节点执行后要唤醒后继节点。<br>Node 的创建是懒惰的，其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li>
</ol>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.7.png" srcset="/img/loading.gif" lazyload></p>
<p>当前线程进入 acquireQueued 逻辑</p>
<ol>
<li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li>
<li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li>
<li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</li>
</ol>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.8.png" srcset="/img/loading.gif" lazyload></p>
<ol start="4">
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时state 仍为 1，失败</li>
<li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回true</li>
<li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li>
</ol>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.9.png" srcset="/img/loading.gif" lazyload></p>
<p>再次有多个线程经历上述过程竞争失败，变成这个样子</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.10.png" srcset="/img/loading.gif" lazyload></p>
<p>Thread-0 释放锁，进入 tryRelease 流程，如果成功，设置 exclusiveOwnerThread 为 null，state = 0</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.11.png" srcset="/img/loading.gif" lazyload></p>
<p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程<br>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1。回到 Thread-1 的 acquireQueued 流程</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.12.png" srcset="/img/loading.gif" lazyload></p>
<p>如果加锁成功（没有竞争），会设置</p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state = 1</li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li>
<li>原本的 head 因为从链表断开，而可被垃圾回收</li>
</ul>
<p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了，不巧又被 Thread-4 占了先<br>Thread-4 被设置为 exclusiveOwnerThread，state = 1，Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.13.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="加锁源码"><a href="#加锁源码" class="headerlink" title="加锁源码"></a>加锁源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7316153563782823691L</span>;<br>	<span class="hljs-comment">// 加锁实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span><br>		<span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>			setExclusiveOwnerThread(Thread.currentThread());<br>		<span class="hljs-keyword">else</span><br>		<span class="hljs-comment">// 如果尝试失败，进入 ㈠</span><br>			acquire(<span class="hljs-number">1</span>);<br>	&#125;<br>    <br>	<span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>		<span class="hljs-comment">// ㈡ tryAcquire</span><br>		<span class="hljs-keyword">if</span> (<br>			!tryAcquire(arg) &amp;&amp;<br>			<span class="hljs-comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span><br>			acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>		) &#123;<br>			selfInterrupt();<br>		&#125;<br>	&#125;<br>    <br>    <span class="hljs-comment">// ㈡ 进入 ㈢</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>	&#125;<br>    <br>	<span class="hljs-comment">// ㈢ Sync 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>		<span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>		<span class="hljs-keyword">int</span> c = getState();<br>		<span class="hljs-comment">// 如果还没有获得锁</span><br>		<span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span><br>			<span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>				setExclusiveOwnerThread(current);<br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span><br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>			<span class="hljs-comment">// state++</span><br>			<span class="hljs-keyword">int</span> nextc = c + acquires;<br>			<span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>			setState(nextc);<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br>		<span class="hljs-comment">// 获取失败, 回到调用处</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>    <br>	<span class="hljs-comment">// ㈣ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    	<span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span><br>		Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>		<span class="hljs-comment">// 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部</span><br>		Node pred = tail;<br>		<span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br>			node.prev = pred;<br>			<span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>				<span class="hljs-comment">// 双向链表</span><br>				pred.next = node;<br>				<span class="hljs-keyword">return</span> node;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">// 尝试将 Node 加入 AQS, 进入 ㈥</span><br>		enq(node);<br>		<span class="hljs-keyword">return</span> node;<br>	&#125;<br>    <br>	<span class="hljs-comment">// ㈥ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (;;) &#123;<br>			Node t = tail;<br>			<span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span><br>				<span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node())) &#123;<br>					tail = head;<br>				&#125;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span><br>				node.prev = t;<br>				<span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>					t.next = node;<br>					<span class="hljs-keyword">return</span> t;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>    <br>    <span class="hljs-comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>		<span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>			<span class="hljs-keyword">for</span> (;;) &#123;<br>				<span class="hljs-keyword">final</span> Node p = node.predecessor();<br>				<span class="hljs-comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span><br>				<span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>					<span class="hljs-comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span><br>					setHead(node);<br>					<span class="hljs-comment">// 上一个节点 help GC</span><br>					p.next = <span class="hljs-keyword">null</span>;<br>					failed = <span class="hljs-keyword">false</span>;<br>					<span class="hljs-comment">// 返回中断标记 false</span><br>					<span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>    			<span class="hljs-keyword">if</span> (<br>					<span class="hljs-comment">// 判断是否应当 park, 进入 ㈦</span><br>					shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>					<span class="hljs-comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span><br>					parkAndCheckInterrupt()<br>				) &#123;<br>					interrupted = <span class="hljs-keyword">true</span>;<br>				&#125;<br>			&#125;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (failed)<br>			cancelAcquire(node);<br>			&#125;<br>		&#125;<br>    <br>    <span class="hljs-comment">// ㈦ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>		<span class="hljs-comment">// 获取上一个节点的状态</span><br>		<span class="hljs-keyword">int</span> ws = pred.waitStatus;<br>		<span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>			<span class="hljs-comment">// 上一个节点都在阻塞, 那么自己也阻塞好了</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br>		<span class="hljs-comment">// &gt; 0 表示取消状态</span><br>		<span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span><br>			<span class="hljs-keyword">do</span> &#123;<br>				node.prev = pred = pred.prev;<br>			&#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>			pred.next = node;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// 这次还没有阻塞</span><br>			<span class="hljs-comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span><br>			compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>    <br>	<span class="hljs-comment">// ㈧ 阻塞当前线程</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>		LockSupport.park(<span class="hljs-keyword">this</span>);<br>		<span class="hljs-keyword">return</span> Thread.interrupted();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意<br>是否需要 unpark 是由当前节点的<code>前驱节点的 waitStatus == Node.SIGNAL </code>来决定，而不是本节点的waitStatus 决定</p>
</blockquote>
<h4 id="解锁源码"><a href="#解锁源码" class="headerlink" title="解锁源码"></a>解锁源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>	<span class="hljs-comment">// 解锁实现</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>		sync.release(<span class="hljs-number">1</span>);<br>	&#125;<br>    <br>	<span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>		<span class="hljs-comment">// 尝试释放锁, 进入 ㈠</span><br>		<span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>			<span class="hljs-comment">// 队列头节点 unpark</span><br>			Node h = head;<br>			<span class="hljs-keyword">if</span> (<br>				<span class="hljs-comment">// 队列不为 null</span><br>				h != <span class="hljs-keyword">null</span> &amp;&amp;<br>				<span class="hljs-comment">// waitStatus == Node.SIGNAL 才需要 unpark</span><br>				h.waitStatus != <span class="hljs-number">0</span><br>			) &#123;<br>				<span class="hljs-comment">// unpark AQS 中等待的线程, 进入 ㈡</span><br>				unparkSuccessor(h);<br>			&#125;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>    <br>    <span class="hljs-comment">// ㈠ Sync 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>		<span class="hljs-comment">// state--</span><br>		<span class="hljs-keyword">int</span> c = getState() - releases;<br>		<span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>		<span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>		<span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span><br>		<span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>			free = <span class="hljs-keyword">true</span>;<br>			setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>		&#125;<br>		setState(c);<br>		<span class="hljs-keyword">return</span> free;<br>	&#125;<br>    <br>	<span class="hljs-comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>		<span class="hljs-comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0</span><br>		<span class="hljs-comment">// 不成功也可以</span><br>		<span class="hljs-keyword">int</span> ws = node.waitStatus;<br>		<span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>) &#123;<br>			compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>		&#125;<br>		<span class="hljs-comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span><br>    	Node s = node.next;<br>		<span class="hljs-comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span><br>		<span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>			s = <span class="hljs-keyword">null</span>;<br>			<span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<br>				<span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>			s = t;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>			LockSupport.unpark(s.thread);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>	<span class="hljs-comment">// ...</span><br>	<span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>		<span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>		<span class="hljs-keyword">int</span> c = getState();<br>		<span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>				setExclusiveOwnerThread(current);<br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span><br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>			<span class="hljs-comment">// state++</span><br>			<span class="hljs-keyword">int</span> nextc = c + acquires;<br>			<span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>			setState(nextc);<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>    <br>	<span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>		<span class="hljs-comment">// state--</span><br>		<span class="hljs-keyword">int</span> c = getState() - releases;<br>		<span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>		<span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>		<span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span><br>		<span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>			free = <span class="hljs-keyword">true</span>;<br>			setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>		&#125;<br>   		setState(c);<br>		<span class="hljs-keyword">return</span> free;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><h4 id="不可打断模式"><a href="#不可打断模式" class="headerlink" title="不可打断模式"></a>不可打断模式</h4><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>	<span class="hljs-comment">// ...</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 如果打断标记已经是 true, 则 park 会失效</span><br>		LockSupport.park(<span class="hljs-keyword">this</span>);<br>		<span class="hljs-comment">// interrupted 会清除打断标记</span><br>		<span class="hljs-keyword">return</span> Thread.interrupted();<br>	&#125;<br>    <br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>		<span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>			<span class="hljs-keyword">for</span> (;;) &#123;<br>				<span class="hljs-keyword">final</span> Node p = node.predecessor();<br>				<span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>					setHead(node);<br>					p.next = <span class="hljs-keyword">null</span>;<br>					failed = <span class="hljs-keyword">false</span>;<br>					<span class="hljs-comment">// 还是需要获得锁后, 才能返回打断状态</span><br>					<span class="hljs-keyword">return</span> interrupted;<br>				&#125;<br>				<span class="hljs-keyword">if</span> (<br>					shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>					parkAndCheckInterrupt()<br>				) &#123;<br>					<span class="hljs-comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span><br>					interrupted = <span class="hljs-keyword">true</span>;<br>				&#125;<br>			&#125;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (failed)<br>				cancelAcquire(node);<br>		&#125;<br>	&#125;<br>    <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<br>			!tryAcquire(arg) &amp;&amp;<br>			acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>		) &#123;<br>			<span class="hljs-comment">// 如果打断状态为 true</span><br>			selfInterrupt();<br>		&#125;<br>	&#125;<br>    <br>	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selfInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 重新产生一次中断</span><br>		Thread.currentThread().interrupt();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="可打断模式"><a href="#可打断模式" class="headerlink" title="可打断模式"></a>可打断模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>		<span class="hljs-keyword">if</span> (Thread.interrupted())<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>		<span class="hljs-comment">// 如果没有获得到锁, 进入 ㈠</span><br>		<span class="hljs-keyword">if</span> (!tryAcquire(arg))<br>			doAcquireInterruptibly(arg);<br>	&#125;<br>    <br>	<span class="hljs-comment">// ㈠ 可打断的获取锁流程</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>		<span class="hljs-keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<br>		<span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-keyword">for</span> (;;) &#123;<br>				<span class="hljs-keyword">final</span> Node p = node.predecessor();<br>				<span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>					setHead(node);<br>					p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>					failed = <span class="hljs-keyword">false</span>;<br>					<span class="hljs-keyword">return</span>;<br>				&#125;<br>				<span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>				parkAndCheckInterrupt()) &#123;<br>					<span class="hljs-comment">// 在 park 过程中如果被 interrupt 会进入此</span><br>					<span class="hljs-comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span><br>					<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>				&#125;<br>			&#125;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (failed)<br>				cancelAcquire(node);<br>			&#125;<br>		&#125;<br>	&#125;	<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>		acquire(<span class="hljs-number">1</span>);<br>	&#125;<br>    <br>	<span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (<br>			!tryAcquire(arg) &amp;&amp;<br>			acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>		) &#123;<br>			selfInterrupt();<br>		&#125;<br>	&#125;<br>    <br>	<span class="hljs-comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>		<span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>		<span class="hljs-keyword">int</span> c = getState();<br>		<span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span><br>			<span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>			compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>				setExclusiveOwnerThread(current);<br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>			<span class="hljs-keyword">int</span> nextc = c + acquires;<br>			<span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>			setState(nextc);<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>    <br>	<span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;<br>		Node t = tail;<br>		Node h = head;<br>		Node s;<br>		<span class="hljs-comment">// h != t 时表示队列中有 Node</span><br>		<span class="hljs-keyword">return</span> h != t &amp;&amp;<br>		(<br>		<span class="hljs-comment">// (s = h.next) == null 表示队列中还有没有老二</span><br>		(s = h.next) == <span class="hljs-keyword">null</span> ||<br>   		<span class="hljs-comment">// 或者队列中老二线程不是此线程</span><br>		s.thread != Thread.currentThread()<br>		);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>每个条件变量其实就对应着一个<strong>等待队列</strong>，其实现类是 ConditionObject</p>
<h4 id="await-流程"><a href="#await-流程" class="headerlink" title="await 流程"></a>await 流程</h4><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程。创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.14.png" srcset="/img/loading.gif" lazyload></p>
<p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.15.png" srcset="/img/loading.gif" lazyload></p>
<p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.16.png" srcset="/img/loading.gif" lazyload></p>
<p>park 阻塞 Thread-0</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.17.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="signal-流程"><a href="#signal-流程" class="headerlink" title="signal 流程"></a>signal 流程</h4><p>假设 Thread-1 要来唤醒 Thread-0</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.18.png" srcset="/img/loading.gif" lazyload></p>
<p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.19.png" srcset="/img/loading.gif" lazyload></p>
<p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</p>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.20.png" srcset="/img/loading.gif" lazyload></p>
<p>Thread-1 释放锁，进入 unlock 流程</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1173984872572414699L</span>;<br>	<span class="hljs-comment">// 第一个等待节点</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br>	<span class="hljs-comment">// 最后一个等待节点</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConditionObject</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <br>	<span class="hljs-comment">// ㈠ 添加一个 Node 至等待队列</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addConditionWaiter</span><span class="hljs-params">()</span> </span>&#123;<br>		Node t = lastWaiter;<br>		<span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span><br>    	<span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>			unlinkCancelledWaiters();<br>			t = lastWaiter;<br>		&#125;<br>		<span class="hljs-comment">// 创建一个关联当前线程的新 Node, 添加至队列尾部</span><br>		Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);<br>		<span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>)<br>			firstWaiter = node;<br>		<span class="hljs-keyword">else</span><br>			t.nextWaiter = node;<br>		lastWaiter = node;<br>		<span class="hljs-keyword">return</span> node;<br>	&#125;<br>    <br>	<span class="hljs-comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;<br>		<span class="hljs-keyword">do</span> &#123;<br>			<span class="hljs-comment">// 已经是尾节点了</span><br>			<span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>) &#123;<br>				lastWaiter = <span class="hljs-keyword">null</span>;<br>			&#125;<br>			first.nextWaiter = <span class="hljs-keyword">null</span>;<br>		&#125; <span class="hljs-keyword">while</span> (<br>			<span class="hljs-comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span><br>			!transferForSignal(first) &amp;&amp;<br>			<span class="hljs-comment">// 队列还有节点</span><br>			(first = firstWaiter) != <span class="hljs-keyword">null</span><br>		);<br>	&#125;<br>    <br>	<span class="hljs-comment">// 外部类方法, 方便阅读, 放在此处</span><br>	<span class="hljs-comment">// ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span><br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferForSignal</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>		<span class="hljs-comment">// 如果状态已经不是 Node.CONDITION, 说明被取消了</span><br>		<span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>		<span class="hljs-comment">// 加入 AQS 队列尾部</span><br>		Node p = enq(node);<br>		<span class="hljs-keyword">int</span> ws = p.waitStatus;<br>		<span class="hljs-keyword">if</span> (<br>			<span class="hljs-comment">// 上一个节点被取消</span><br>			ws &gt; <span class="hljs-number">0</span> ||<br>			<span class="hljs-comment">// 上一个节点不能设置状态为 Node.SIGNAL</span><br>			!compareAndSetWaitStatus(p, ws, Node.SIGNAL)<br>		) &#123;<br>			<span class="hljs-comment">// unpark 取消阻塞, 让线程重新同步状态</span><br>			LockSupport.unpark(node.thread);<br>		&#125;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>	&#125;<br>    <br>	<span class="hljs-comment">// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignalAll</span><span class="hljs-params">(Node first)</span> </span>&#123;<br>		lastWaiter = firstWaiter = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">do</span> &#123;<br>			Node next = first.nextWaiter;<br>			first.nextWaiter = <span class="hljs-keyword">null</span>;<br>			transferForSignal(first);<br>			first = next;<br>		&#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-keyword">null</span>);<br>	&#125;<br>    <br>	<span class="hljs-comment">// ㈡</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlinkCancelledWaiters</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// ...</span><br>	&#125;<br>    <br>	<span class="hljs-comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (!isHeldExclusively())<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>		Node first = firstWaiter;<br>		<span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>			doSignal(first);<br>	&#125;<br>    <br>	<span class="hljs-comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (!isHeldExclusively())<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>		Node first = firstWaiter;<br>		<span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>			doSignalAll(first);<br>	&#125;<br>    <br>	<span class="hljs-comment">// 不可打断等待 - 直到被唤醒</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>		Node node = addConditionWaiter();<br>		<span class="hljs-comment">// 释放节点持有的锁, 见 ㈣</span><br>		<span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>		<span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>		<span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br>		<span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>			<span class="hljs-comment">// park 阻塞</span><br>			LockSupport.park(<span class="hljs-keyword">this</span>);<br>			<span class="hljs-comment">// 如果被打断, 仅设置打断状态</span><br>			<span class="hljs-keyword">if</span> (Thread.interrupted())<br>				interrupted = <span class="hljs-keyword">true</span>;<br>		&#125;<br>		<span class="hljs-comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span><br>		<span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted)<br>			selfInterrupt();<br>	&#125;<br>    <br>    <span class="hljs-comment">// 外部类方法, 方便阅读, 放在此处</span><br>	<span class="hljs-comment">// ㈣ 因为某线程可能重入，需要将 state 全部释放</span><br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fullyRelease</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>		<span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-keyword">int</span> savedState = getState();<br>			<span class="hljs-keyword">if</span> (release(savedState)) &#123;<br>				failed = <span class="hljs-keyword">false</span>;<br>				<span class="hljs-keyword">return</span> savedState;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>			&#125;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (failed)<br>				node.waitStatus = Node.CANCELLED;<br>		&#125;<br>	&#125;<br>    <br>	<span class="hljs-comment">// 打断模式 - 在退出等待时重新设置打断状态</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REINTERRUPT = <span class="hljs-number">1</span>;<br>	<span class="hljs-comment">// 打断模式 - 在退出等待时抛出异常</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THROW_IE = -<span class="hljs-number">1</span>;<br>	<span class="hljs-comment">// 判断打断模式</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> Thread.interrupted() ?(transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :<span class="hljs-number">0</span>;<br>	&#125;<br>    <br>	<span class="hljs-comment">// ㈤ 应用打断模式</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> interruptMode)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>		<span class="hljs-keyword">if</span> (interruptMode == THROW_IE)<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)<br>			selfInterrupt();<br>	&#125;<br>    <br>	<span class="hljs-comment">// 等待 - 直到被唤醒或打断</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>		<span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>		&#125;<br>		<span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>		Node node = addConditionWaiter();<br>		<span class="hljs-comment">// 释放节点持有的锁</span><br>		<span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>		<span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br>		<span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br>		<span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>			<span class="hljs-comment">// park 阻塞</span><br>			LockSupport.park(<span class="hljs-keyword">this</span>);<br>  		 	<span class="hljs-comment">// 如果被打断, 退出等待队列</span><br>			<span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>				<span class="hljs-keyword">break</span>;<br>		&#125;<br>		<span class="hljs-comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span><br>		<span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>			interruptMode = REINTERRUPT;<br>		<span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span><br>		<span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)<br>			unlinkCancelledWaiters();<br>		<span class="hljs-comment">// 应用打断模式, 见 ㈤</span><br>		<span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>			reportInterruptAfterWait(interruptMode);<br>	&#125;<br>    <br>	<span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">awaitNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>		<span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>		&#125;<br>		<span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>		Node node = addConditionWaiter();<br>		<span class="hljs-comment">// 释放节点持有的锁</span><br>		<span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>		<span class="hljs-comment">// 获得最后期限</span><br>		<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = System.nanoTime() + nanosTimeout;<br>		<span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br>		<span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br>		<span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>			<span class="hljs-comment">// 已超时, 退出等待队列</span><br>			<span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;<br>				transferAfterCancelledWait(node);<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			<span class="hljs-comment">// park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns</span><br>			<span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)<br>				LockSupport.parkNanos(<span class="hljs-keyword">this</span>, nanosTimeout);<br>			<span class="hljs-comment">// 如果被打断, 退出等待队列</span><br>			<span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>				<span class="hljs-keyword">break</span>;<br>			nanosTimeout = deadline - System.nanoTime();<br>		&#125;<br>		<span class="hljs-comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span><br>		<span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>			interruptMode = REINTERRUPT;<br>		<span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span><br>		<span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)<br>			unlinkCancelledWaiters();<br>		<span class="hljs-comment">// 应用打断模式, 见 ㈤</span><br>		<span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>			reportInterruptAfterWait(interruptMode);<br>		<span class="hljs-keyword">return</span> deadline - System.nanoTime();<br>	&#125;<br>    <br>    <span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>		<span class="hljs-comment">// ...</span><br>	&#125;<br>	<span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>		<span class="hljs-comment">// ...</span><br>	&#125;<br>	<span class="hljs-comment">// 工具方法 省略 ...</span><br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h2 id="8-4、读写锁"><a href="#8-4、读写锁" class="headerlink" title="8.4、读写锁"></a>8.4、读写锁</h2><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>当读操作远远高于写操作时，这时候使用<strong>读写锁</strong>，让读-读可以并发，提高性能。类似于数据库中的 <code>select ...from ... lock in share mode</code></p>
<p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantReadWriteLockTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        DataContainer dataContainer = <span class="hljs-keyword">new</span> DataContainer();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            dataContainer.read();<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            dataContainer.read();<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;DataContainer&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainer</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Object data;<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock rw = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.ReadLock r = rw.readLock();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.WriteLock w = rw.writeLock();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;获取读锁...&quot;</span>);<br>        r.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;读取&quot;</span>);<br>            sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;释放读锁...&quot;</span>);r.unlock();<br>        &#125;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;获取写锁...&quot;</span>);<br>        w.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;写入&quot;</span>);<br>            sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;释放写锁...&quot;</span>);<br>            w.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.21.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><strong>读锁不支持条件变量</strong></li>
<li><strong>重入时锁升级不支持</strong>：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li>
<li><strong>重入时降级支持</strong>：即持有写锁的情况下去获取读锁</li>
</ul>
<h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个</p>
<h5 id="t1-w-lock，t2-r-lock"><a href="#t1-w-lock，t2-r-lock" class="headerlink" title="t1 w.lock，t2 r.lock"></a>t1 w.lock，t2 r.lock</h5><ul>
<li>t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.22.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么 tryAcquireShared 返回 -1 表示失败</li>
</ul>
<blockquote>
<p>tryAcquireShared 返回值</p>
<p>-1 表示失败</p>
<p>0 表示成功，但后继节点不会继续唤醒</p>
<p>正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1</p>
</blockquote>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.23.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.24.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁</li>
<li>如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.25.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="t3-r-lock，t4-w-lock"><a href="#t3-r-lock，t4-w-lock" class="headerlink" title="t3 r.lock，t4 w.lock"></a>t3 r.lock，t4 w.lock</h5><ul>
<li>这种状态下，假设又有 t3 加读锁（shared）和 t4 加写锁（Ex），这期间 t1 仍然持有锁，就变成了下面的样子</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.26.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="t1-w-unlock"><a href="#t1-w-unlock" class="headerlink" title="t1 w.unlock"></a>t1 w.unlock</h5><ul>
<li>这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.27.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行<br>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.28.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.29.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.30.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.31.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.32.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</li>
</ul>
<h5 id="t2-r-unlock，t3-r-unlock"><a href="#t2-r-unlock，t3-r-unlock" class="headerlink" title="t2 r.unlock，t3 r.unlock"></a>t2 r.unlock，t3 r.unlock</h5><ul>
<li>t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.33.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.34.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他竞争，tryAcquire(1) 成功，修改头结点，流程结束</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.35.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><h5 id="写锁上锁流程"><a href="#写锁上锁流程" class="headerlink" title="写锁上锁流程"></a>写锁上锁流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>	<span class="hljs-comment">// ... 省略无关代码</span><br>	<span class="hljs-comment">// 外部类 WriteLock 方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>		sync.acquire(<span class="hljs-number">1</span>);<br>	&#125;<br>    <br>	<span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (<br>				<span class="hljs-comment">// 尝试获得写锁失败</span><br>				!tryAcquire(arg) &amp;&amp;<br>				<span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span><br>				<span class="hljs-comment">// 进入 AQS 队列阻塞</span><br>				acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>			) &#123;<br>				selfInterrupt();<br>			&#125;<br>		&#125;<br>    <br>	<span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>		<span class="hljs-comment">// 获得低 16 位, 代表写锁的 state 计数</span><br>		Thread current = Thread.currentThread();<br>		<span class="hljs-keyword">int</span> c = getState();<br>    	<span class="hljs-keyword">int</span> w = exclusiveCount(c);<br>		<span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-keyword">if</span> (<br>				<span class="hljs-comment">// c != 0 and w == 0 表示有读锁, 或者</span><br>				w == <span class="hljs-number">0</span> ||<br>				<span class="hljs-comment">// 如果 exclusiveOwnerThread 不是自己</span><br>				current != getExclusiveOwnerThread()<br>			) &#123;<br>				<span class="hljs-comment">// 获得锁失败</span><br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>			&#125;<br>			<span class="hljs-comment">// 写锁计数超过低 16 位, 报异常</span><br>			<span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>			<span class="hljs-comment">// 写锁重入, 获得锁成功</span><br>			setState(c + acquires);<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (<br>			<span class="hljs-comment">// 判断写锁是否该阻塞, 或者</span><br>			writerShouldBlock() ||<br>			<span class="hljs-comment">// 尝试更改计数失败</span><br>			!compareAndSetState(c, c + acquires)<br>		) &#123;<br>		<span class="hljs-comment">// 获得锁失败</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>		&#125;<br>		<span class="hljs-comment">// 获得锁成功</span><br>		setExclusiveOwnerThread(current);<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>	&#125;<br>    <br>	<span class="hljs-comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span><br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">writerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="写锁释放流程"><a href="#写锁释放流程" class="headerlink" title="写锁释放流程"></a>写锁释放流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>	<span class="hljs-comment">// ... 省略无关代码</span><br>	<span class="hljs-comment">// WriteLock 方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>		sync.release(<span class="hljs-number">1</span>);<br>	&#125;<br>    <br>	<span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>		<span class="hljs-comment">// 尝试释放写锁成功</span><br>   		<span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>			<span class="hljs-comment">// unpark AQS 中等待的线程</span><br>			Node h = head;<br>			<span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>				unparkSuccessor(h);<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>    <br>	<span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (!isHeldExclusively())<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>		<span class="hljs-keyword">int</span> nextc = getState() - releases;<br>		<span class="hljs-comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span><br>		<span class="hljs-keyword">boolean</span> free = exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span> (free) &#123;<br>			setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>		&#125;<br>		setState(nextc);<br>		<span class="hljs-keyword">return</span> free;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="读锁上锁流程"><a href="#读锁上锁流程" class="headerlink" title="读锁上锁流程"></a>读锁上锁流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>	<span class="hljs-comment">// ReadLock 方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>		sync.acquireShared(<span class="hljs-number">1</span>);<br>	&#125;<br>    <br>	<span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>		<span class="hljs-comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span><br>		<span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>) &#123;<br>			doAcquireShared(arg);<br>		&#125;<br>	&#125;<br>    <br>	<span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>		Thread current = Thread.currentThread();<br>		<span class="hljs-keyword">int</span> c = getState();<br>		<span class="hljs-comment">// 如果是其它线程持有写锁, 获取读锁失败</span><br>		<span class="hljs-keyword">if</span> (<br>			exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp; getExclusiveOwnerThread() != current<br>		) &#123;<br>			<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    	&#125;<br>		<span class="hljs-keyword">int</span> r = sharedCount(c);<br>		<span class="hljs-keyword">if</span> (<br>			<span class="hljs-comment">// 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且</span><br>			!readerShouldBlock() &amp;&amp;<br>			<span class="hljs-comment">// 小于读锁计数, 并且</span><br>			r &lt; MAX_COUNT &amp;&amp;<br>			<span class="hljs-comment">// 尝试增加计数成功</span><br>			compareAndSetState(c, c + SHARED_UNIT)<br>		) &#123;<br>			<span class="hljs-comment">// ... 省略不重要的代码</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>	&#125;<br>    <br>	<span class="hljs-comment">// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span><br>	<span class="hljs-comment">// true 则该阻塞, false 则不阻塞</span><br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">readerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();<br>	&#125;<br>    <br>	<span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-comment">// 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span><br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fullTryAcquireShared</span><span class="hljs-params">(Thread current)</span> </span>&#123;<br>		HoldCounter rh = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">for</span> (;;) &#123;<br>			<span class="hljs-keyword">int</span> c = getState();<br>			<span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != current)<br>					<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readerShouldBlock()) &#123;<br>					<span class="hljs-comment">// ... 省略不重要的代码</span><br>				&#125;<br>			<span class="hljs-keyword">if</span> (sharedCount(c) == MAX_COUNT)<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>			<span class="hljs-keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>				<span class="hljs-comment">// ... 省略不重要的代码</span><br>				<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>    <br>	<span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>		<span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span><br>		<span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>		<span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>			<span class="hljs-keyword">for</span> (;;) &#123;<br>				<span class="hljs-keyword">final</span> Node p = node.predecessor();<br>				<span class="hljs-keyword">if</span> (p == head) &#123;<br>    				<span class="hljs-comment">// 再一次尝试获取读锁</span><br>					<span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>					<span class="hljs-comment">// 成功</span><br>					<span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>						<span class="hljs-comment">// ㈠</span><br>						<span class="hljs-comment">// r 表示可用资源数, 在这里总是 1 允许传播</span><br>						<span class="hljs-comment">//（唤醒 AQS 中下一个 Share 节点）</span><br>						setHeadAndPropagate(node, r);<br>						p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>						<span class="hljs-keyword">if</span> (interrupted)<br>							selfInterrupt();<br>						failed = <span class="hljs-keyword">false</span>;<br>						<span class="hljs-keyword">return</span>;<br>					&#125;<br>				&#125;<br>				<span class="hljs-keyword">if</span> (<br>					<span class="hljs-comment">// 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）</span><br>					shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>					<span class="hljs-comment">// park 当前线程</span><br>					parkAndCheckInterrupt()<br>				) &#123;<br>					interrupted = <span class="hljs-keyword">true</span>;<br>				&#125;<br>			&#125;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (failed)<br>				cancelAcquire(node);<br>		&#125;<br>	&#125;<br>    <br>	<span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;<br>		Node h = head; <span class="hljs-comment">// Record old head for check below</span><br>		<span class="hljs-comment">// 设置自己为 head</span><br>		setHead(node);<br>		<span class="hljs-comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span><br>		<span class="hljs-comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span><br>		<span class="hljs-comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span><br>		<span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||(h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>			Node s = node.next;<br>			<span class="hljs-comment">// 如果是最后一个节点或者是等待共享读锁的节点</span><br>			<span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared()) &#123;<br>				<span class="hljs-comment">// 进入 ㈡</span><br>				doReleaseShared();<br>			&#125;<br>		&#125;<br>	&#125;<br>    <br>	<span class="hljs-comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span><br>    	<span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析</span><br>		<span class="hljs-keyword">for</span> (;;) &#123;<br>			Node h = head;<br>			<span class="hljs-comment">// 队列还有节点</span><br>			<span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<br>				<span class="hljs-keyword">int</span> ws = h.waitStatus;<br>				<span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>					<span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>						<span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop to recheck cases</span><br>					<span class="hljs-comment">// 下一个节点 unpark 如果成功获取读锁</span><br>					<span class="hljs-comment">// 并且下下个节点还是 shared, 继续 doReleaseShared</span><br>					unparkSuccessor(h);<br>				&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>				<span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop on failed CAS</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// loop if head changed</span><br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="读锁释放流程"><a href="#读锁释放流程" class="headerlink" title="读锁释放流程"></a>读锁释放流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>	<span class="hljs-comment">// ReadLock 方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>		sync.releaseShared(<span class="hljs-number">1</span>);<br>	&#125;<br>    <br>	<span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>			doReleaseShared();<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>    <br>	<span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>		<span class="hljs-comment">// ... 省略不重要的代码</span><br>		<span class="hljs-keyword">for</span> (;;) &#123;<br>			<span class="hljs-keyword">int</span> c = getState();<br>			<span class="hljs-keyword">int</span> nextc = c - SHARED_UNIT;<br>			<span class="hljs-keyword">if</span> (compareAndSetState(c, nextc)) &#123;<br>				<span class="hljs-comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span><br>				<span class="hljs-comment">// 计数为 0 才是真正释放</span><br>				<span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>			&#125;<br>    	&#125;<br>	&#125;<br>    <br>	<span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span><br>		<span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span><br>		<span class="hljs-keyword">for</span> (;;) &#123;<br>			Node h = head;<br>			<span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<br>				<span class="hljs-keyword">int</span> ws = h.waitStatus;<br>				<span class="hljs-comment">// 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span><br>				<span class="hljs-comment">// 防止 unparkSuccessor 被多次执行</span><br>				<span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>					<span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>						<span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop to recheck cases</span><br>					unparkSuccessor(h);<br>				&#125;<br>				<span class="hljs-comment">// 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析</span><br>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>					<span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop on failed CAS</span><br>			&#125;<br>			<span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// loop if head changed</span><br>				<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p>
<h4 id="加解读锁"><a href="#加解读锁" class="headerlink" title="加解读锁"></a>加解读锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.readLock();<br>lock.unlockRead(stamp);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead();<br><span class="hljs-comment">// 验戳</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br><span class="hljs-comment">// 锁升级</span><br>&#125;<br></code></pre></td></tr></table></figure>


</blockquote>
<h4 id="加解写锁"><a href="#加解写锁" class="headerlink" title="加解写锁"></a>加解写锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure>

<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StampedLockTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        DataContainerStamped container = <span class="hljs-keyword">new</span> DataContainerStamped(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;container.read(<span class="hljs-number">2000</span>)).start();<br>        <span class="hljs-comment">//new Thread(()-&gt;container.read(2000)).start();</span><br>        sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;container.write(<span class="hljs-number">2</span>)).start();<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;DataContainerStamped&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainerStamped</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StampedLock lock = <span class="hljs-keyword">new</span> StampedLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataContainerStamped</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> readTime)</span></span>&#123;<br>        <span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead();<br>        log.debug(<span class="hljs-string">&quot;加锁,乐观读锁，&#123;&#125;&quot;</span>,stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(readTime);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lock.validate(stamp))&#123;<br>            log.debug(<span class="hljs-string">&quot;解锁,乐观读锁，&#123;&#125;&quot;</span>,stamp);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br><br>        <span class="hljs-comment">//锁升级-乐观锁升级为读锁</span><br>        log.debug(<span class="hljs-string">&quot;更新,读锁，&#123;&#125;&quot;</span>,stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            stamp = lock.tryReadLock();<br>            log.debug(<span class="hljs-string">&quot;加锁,正常读锁，&#123;&#125;&quot;</span>,stamp);<br>            sleep(readTime);<br>            log.debug(<span class="hljs-string">&quot;读取结束，&#123;&#125;&quot;</span>,stamp);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;解锁,正常读锁，&#123;&#125;&quot;</span>,stamp);<br>            lock.unlockRead(stamp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newData)</span></span>&#123;<br>        <span class="hljs-keyword">long</span> stamp = lock.writeLock();<br>        log.debug(<span class="hljs-string">&quot;加锁,写锁，&#123;&#125;&quot;</span>,stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">this</span>.data = newData;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;解锁,写锁，&#123;&#125;&quot;</span>,stamp);<br>            lock.unlockWrite(stamp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.36.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>注意</p>
<ul>
<li>StampedLock 不支持条件变量</li>
<li>StampedLock 不支持可重入</li>
</ul>
</blockquote>
<h2 id="8-5、Semaphore"><a href="#8-5、Semaphore" class="headerlink" title="8.5、Semaphore"></a>8.5、Semaphore</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>信号量，用来限制能同时访问共享资源的线程上限。</p>
<h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;SemaphoreTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//1.创建信号量</span><br>        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//2.十个线程执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                    log.debug(<span class="hljs-string">&quot;线程开始运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;线程结束运行&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.37.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现）</li>
<li>用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好，（需要线程数和数据库连接数是相等的）</li>
</ul>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><h4 id="加锁解锁流程-1"><a href="#加锁解锁流程-1" class="headerlink" title="加锁解锁流程"></a>加锁解锁流程</h4><p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减一</p>
<ul>
<li>刚开始，permits（state）为 3，这时 5 个线程来获取资源</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.38.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.39.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>这时 Thread-4 释放了 permits，状态如下</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.40.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</li>
</ul>
<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.41.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">2694183684443567898L</span>;<br>	NonfairSync(<span class="hljs-keyword">int</span> permits) &#123;<br>		<span class="hljs-comment">// permits 即 state</span><br>		<span class="hljs-keyword">super</span>(permits);<br>	&#125;<br>	<span class="hljs-comment">// Semaphore 方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>		sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>		<span class="hljs-keyword">if</span> (Thread.interrupted())<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>		<span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>			doAcquireSharedInterruptibly(arg);<br>	&#125;<br>	<span class="hljs-comment">// 尝试获得共享锁</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>	&#125;<br>	<span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (;;) &#123;<br>			<span class="hljs-keyword">int</span> available = getState();<br>			<span class="hljs-keyword">int</span> remaining = available - acquires;<br>			<span class="hljs-keyword">if</span> (<br>				<span class="hljs-comment">// 如果许可已经用完, 返回负数, 表示获取失败, 进入 doAcquireSharedInterruptibly</span><br>				remaining &lt; <span class="hljs-number">0</span> ||<br>				<span class="hljs-comment">// 如果 cas 重试成功, 返回正数, 表示获取成功</span><br>				compareAndSetState(available, remaining)<br>    		) &#123;<br>				<span class="hljs-keyword">return</span> remaining;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>		<span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>		<span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-keyword">for</span> (;;) &#123;<br>				<span class="hljs-keyword">final</span> Node p = node.predecessor();<br>				<span class="hljs-keyword">if</span> (p == head) &#123;<br>					<span class="hljs-comment">// 再次尝试获取许可</span><br>					<span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>					<span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>						<span class="hljs-comment">// 成功后本线程出队（AQS）, 所在 Node设置为 head</span><br>						<span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span><br>						<span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span><br>						<span class="hljs-comment">// r 表示可用资源数, 为 0 则不会继续传播</span><br>						setHeadAndPropagate(node, r);<br>						p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>						failed = <span class="hljs-keyword">false</span>;<br>						<span class="hljs-keyword">return</span>;<br>					&#125;<br>				&#125;<br>				<span class="hljs-comment">// 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞</span><br>				<span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>					<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>			&#125;<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (failed)<br>				cancelAcquire(node);<br>		&#125;<br>	&#125;<br>    <br>	<span class="hljs-comment">// Semaphore 方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>		sync.releaseShared(<span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>			doReleaseShared();<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>	<span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (;;) &#123;<br>			<span class="hljs-keyword">int</span> current = getState();<br>			<span class="hljs-keyword">int</span> next = current + releases;<br>			<span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>			<span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="8-6、CountdownLatch-用于线程同步"><a href="#8-6、CountdownLatch-用于线程同步" class="headerlink" title="8.6、CountdownLatch-用于线程同步"></a>8.6、CountdownLatch-用于线程同步</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><code>CountdownLatch</code>用来进行<strong>线程同步</strong>协作，等待所有线程完成倒计时。</p>
<p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p>
<h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;CountdownLatchTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountdownLatchTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">3</span>);<br>        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>        pool.execute(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;线程任务开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            latch.countDown();<br>            log.debug(<span class="hljs-string">&quot;线程任务结束，&#123;&#125;&quot;</span>,latch.getCount());<br>        &#125;);<br>        pool.execute(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;线程任务开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            latch.countDown();<br>            log.debug(<span class="hljs-string">&quot;线程任务结束，&#123;&#125;&quot;</span>,latch.getCount());<br>        &#125;);<br>        pool.execute(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;线程任务开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            latch.countDown();<br>            log.debug(<span class="hljs-string">&quot;线程任务结束，&#123;&#125;&quot;</span>,latch.getCount());<br>        &#125;);<br>        latch.await();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.42.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//等待多个线程准备完毕</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountdownLatchTest02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">10</span>);<br>        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        Random r = <span class="hljs-keyword">new</span> Random();<br>        String[] all = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>        System.out.println(<span class="hljs-string">&quot;等待所有玩家加载&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt; <span class="hljs-number">10</span>;j++) &#123;<br>            <span class="hljs-keyword">int</span> k = j;<br>            pool.execute(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(r.nextInt(<span class="hljs-number">100</span>));<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    all[k] = i + <span class="hljs-string">&quot;%&quot;</span>;<br>                    System.out.print(<span class="hljs-string">&quot;\r&quot;</span>+Arrays.toString(all));<br>                &#125;<br>                latch.countDown();<br>            &#125;);<br>        &#125;<br>        latch.await();<br>        System.out.println(<span class="hljs-string">&quot;\n游戏开始&quot;</span>);<br>        pool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.43.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>注意：</p>
<p>CountDownLatch对象不能重用，如果需要重用可以使用CyclicBarrier</p>
</blockquote>
<hr>
<h2 id="8-7、CyclicBarrier-用于线程同步"><a href="#8-7、CyclicBarrier-用于线程同步" class="headerlink" title="8.7、CyclicBarrier-用于线程同步"></a>8.7、CyclicBarrier-用于线程同步</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>CyclicBarrier，循环栅栏，用来进行线程协作，等待线程满足某个计数。</p>
<p>构造时设置<strong>计数个数</strong>，每个线程执行到某个需要“同步”的时刻调用 <code>await()</code> 方法进行等待，当等待的线程数满足计数个数时，继续执行</p>
<h3 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;CyclicBarrierTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>        CyclicBarrier barrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++) &#123;<br>            pool.execute(()-&gt;&#123;<br>                log.debug(<span class="hljs-string">&quot;任务1开始&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sleep(<span class="hljs-number">1000</span>);<br>                    barrier.await();<span class="hljs-comment">//2-1=1</span><br>                    log.debug(<span class="hljs-string">&quot;任务1结束&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            pool.execute(()-&gt;&#123;<br>                log.debug(<span class="hljs-string">&quot;任务2开始&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sleep(<span class="hljs-number">2000</span>);<br>                    barrier.await();<span class="hljs-comment">//1-1=0</span><br>                    log.debug(<span class="hljs-string">&quot;任务2结束&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        pool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.44.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>注意：</p>
<p>线程数需要和CyclicBarrier对象中计数是一样的</p>
</blockquote>
<hr>
<h2 id="8-8、线程安全集合类概述"><a href="#8-8、线程安全集合类概述" class="headerlink" title="8.8、线程安全集合类概述"></a>8.8、线程安全集合类概述</h2><p><img src="/2020/10/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91/8.45.png" srcset="/img/loading.gif" lazyload></p>
<p>线程安全集合类可以分为三大类：</p>
<ul>
<li>遗留的线程安全集合如 <code>Hashtable </code>， <code>Vector</code>，此类型集合线程安全是由方法上加了<code>synchronized</code>关键字实现的。性能较低</li>
<li>使用Collections装饰的线程安全集合，如下：此类型集合线程安全是将原本的不是线程安全集合传入，多加了<code>fina Object mutex</code>属性，并<code>synchronized(mutex)</code>加锁，是装饰器模式的一种体现。性能较低<ul>
<li><code>Collections.synchronizedCollection</code></li>
<li><code>Collections.synchronizedList</code></li>
<li><code>Collections.synchronizedMap</code></li>
<li><code>Collections.synchronizedSet</code></li>
<li><code>Collections.synchronizedNavigableMap</code></li>
<li><code>Collections.synchronizedNavigableSet</code></li>
<li><code>Collections.synchronizedSortedMap</code></li>
<li><code>Collections.synchronizedSortedSet</code></li>
</ul>
</li>
<li><code>java.util.concurrent.*</code>，主要分为三类，Blocking、CopyOnWrite、Concurrent<ul>
<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法</li>
<li>CopyOnWrite 之类容器修改开销相对较重</li>
<li>Concurrent 类型的容器<ul>
<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</li>
<li>弱一致性<ul>
<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li>
<li>求大小弱一致性，size 操作未必是 100% 准确</li>
<li>读取弱一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历</p>
</blockquote>
<h3 id="8-9、ConcurrentHashMap"><a href="#8-9、ConcurrentHashMap" class="headerlink" title="8.9、ConcurrentHashMap"></a>8.9、ConcurrentHashMap</h3><p>详见容器源码</p>
<h3 id="8-10、BlockingQueue"><a href="#8-10、BlockingQueue" class="headerlink" title="8.10、BlockingQueue"></a>8.10、BlockingQueue</h3><p>详见容器源码</p>
<h3 id="8-11、ConcurrentLinkedQueue"><a href="#8-11、ConcurrentLinkedQueue" class="headerlink" title="8.11、ConcurrentLinkedQueue"></a>8.11、ConcurrentLinkedQueue</h3><p>详见容器源码</p>
<h3 id="8-12、CopyOnWriteArrayList"><a href="#8-12、CopyOnWriteArrayList" class="headerlink" title="8.12、CopyOnWriteArrayList"></a>8.12、CopyOnWriteArrayList</h3><p>详见容器源码</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Java/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/11/10/Mysql/Mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL进阶</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/20/JVM/JVM%E5%AD%A6%E4%B9%A0/">
                        <span class="hidden-mobile">JVM学习</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?cd190160b5401a029cee361d013e32a1";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
